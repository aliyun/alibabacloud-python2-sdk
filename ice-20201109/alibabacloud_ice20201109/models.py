# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class AddCategoryRequest(TeaModel):
    def __init__(self, cate_name=None, parent_id=None, type=None):
        self.cate_name = cate_name  # type: str
        self.parent_id = parent_id  # type: long
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCategoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddCategoryResponseBodyCategory(TeaModel):
    def __init__(self, cate_id=None, cate_name=None, level=None, parent_id=None, type=None):
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str
        self.level = level  # type: long
        self.parent_id = parent_id  # type: long
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddCategoryResponseBodyCategory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddCategoryResponseBody(TeaModel):
    def __init__(self, category=None, request_id=None):
        self.category = category  # type: AddCategoryResponseBodyCategory
        self.request_id = request_id  # type: str

    def validate(self):
        if self.category:
            self.category.validate()

    def to_map(self):
        _map = super(AddCategoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = AddCategoryResponseBodyCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddCategoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddCategoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddCategoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddEditingProjectMaterialsRequest(TeaModel):
    def __init__(self, material_maps=None, project_id=None):
        # 素材ID
        self.material_maps = material_maps  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddEditingProjectMaterialsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_maps is not None:
            result['MaterialMaps'] = self.material_maps
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaterialMaps') is not None:
            self.material_maps = m.get('MaterialMaps')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class AddEditingProjectMaterialsResponseBodyLiveMaterials(TeaModel):
    def __init__(self, app_name=None, domain_name=None, live_url=None, stream_name=None):
        self.app_name = app_name  # type: str
        self.domain_name = domain_name  # type: str
        self.live_url = live_url  # type: str
        self.stream_name = stream_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBodyLiveMaterials, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_url is not None:
            result['LiveUrl'] = self.live_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveUrl') is not None:
            self.live_url = m.get('LiveUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, region=None, width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, input_url=None, media_id=None, media_tags=None, media_type=None, modified_time=None,
                 snapshots=None, source=None, sprite_images=None, status=None, title=None, transcode_status=None,
                 user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class AddEditingProjectMaterialsResponseBodyMediaInfos(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBodyMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = AddEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class AddEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(self, live_materials=None, media_infos=None, project_id=None, project_materials=None,
                 request_id=None):
        self.live_materials = live_materials  # type: list[AddEditingProjectMaterialsResponseBodyLiveMaterials]
        # 符合要求的媒资集合
        self.media_infos = media_infos  # type: list[AddEditingProjectMaterialsResponseBodyMediaInfos]
        self.project_id = project_id  # type: str
        self.project_materials = project_materials  # type: list[str]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.live_materials:
            for k in self.live_materials:
                if k:
                    k.validate()
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveMaterials'] = []
        if self.live_materials is not None:
            for k in self.live_materials:
                result['LiveMaterials'].append(k.to_map() if k else None)
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_materials is not None:
            result['ProjectMaterials'] = self.project_materials
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.live_materials = []
        if m.get('LiveMaterials') is not None:
            for k in m.get('LiveMaterials'):
                temp_model = AddEditingProjectMaterialsResponseBodyLiveMaterials()
                self.live_materials.append(temp_model.from_map(k))
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = AddEditingProjectMaterialsResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMaterials') is not None:
            self.project_materials = m.get('ProjectMaterials')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddEditingProjectMaterialsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddEditingProjectMaterialsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddEditingProjectMaterialsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddFavoritePublicMediaRequest(TeaModel):
    def __init__(self, media_ids=None):
        self.media_ids = media_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddFavoritePublicMediaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class AddFavoritePublicMediaResponseBody(TeaModel):
    def __init__(self, ignored_list=None, request_id=None):
        self.ignored_list = ignored_list  # type: list[str]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddFavoritePublicMediaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddFavoritePublicMediaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddFavoritePublicMediaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddFavoritePublicMediaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddFavoritePublicMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTemplateRequest(TeaModel):
    def __init__(self, config=None, cover_url=None, name=None, preview_media=None, source=None, status=None,
                 type=None):
        # 参见Timeline模板Config文档
        self.config = config  # type: str
        # 模板封面
        self.cover_url = cover_url  # type: str
        # 模板名称
        self.name = name  # type: str
        # 预览视频媒资id
        self.preview_media = preview_media  # type: str
        # 模板创建来源，默认OpenAPI
        self.source = source  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板类型，取值范围：Timeline
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddTemplateResponseBodyTemplate(TeaModel):
    def __init__(self, config=None, cover_url=None, create_source=None, modified_source=None, name=None,
                 preview_media=None, status=None, template_id=None, type=None):
        # 参见Timeline模板Config文档
        self.config = config  # type: str
        # 模板封面
        self.cover_url = cover_url  # type: str
        # 模板创建来源
        self.create_source = create_source  # type: str
        # 模板修改来源
        self.modified_source = modified_source  # type: str
        # 模板名称
        self.name = name  # type: str
        # 预览视频媒资id
        self.preview_media = preview_media  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板类型
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTemplateResponseBodyTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, template=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 模板信息
        self.template = template  # type: AddTemplateResponseBodyTemplate

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super(AddTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = AddTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class AddTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchGetMediaInfosRequest(TeaModel):
    def __init__(self, addition_type=None, media_ids=None):
        self.addition_type = addition_type  # type: str
        self.media_ids = media_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchGetMediaInfosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.addition_type is not None:
            result['AdditionType'] = self.addition_type
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdditionType') is not None:
            self.addition_type = m.get('AdditionType')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, region=None, width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class BatchGetMediaInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(BatchGetMediaInfosResponseBodyMediaInfosFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = BatchGetMediaInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, input_url=None, media_id=None, media_tags=None, media_type=None, modified_time=None,
                 snapshots=None, source=None, sprite_images=None, status=None, title=None, transcode_status=None,
                 user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class BatchGetMediaInfosResponseBodyMediaInfos(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[BatchGetMediaInfosResponseBodyMediaInfosFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(BatchGetMediaInfosResponseBodyMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = BatchGetMediaInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = BatchGetMediaInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class BatchGetMediaInfosResponseBody(TeaModel):
    def __init__(self, media_infos=None, request_id=None):
        # 符合要求的媒资集合
        self.media_infos = media_infos  # type: list[BatchGetMediaInfosResponseBodyMediaInfos]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(BatchGetMediaInfosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = BatchGetMediaInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class BatchGetMediaInfosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BatchGetMediaInfosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BatchGetMediaInfosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchGetMediaInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelFavoritePublicMediaRequest(TeaModel):
    def __init__(self, media_ids=None):
        self.media_ids = media_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelFavoritePublicMediaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class CancelFavoritePublicMediaResponseBody(TeaModel):
    def __init__(self, ignored_list=None, request_id=None):
        self.ignored_list = ignored_list  # type: list[str]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelFavoritePublicMediaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelFavoritePublicMediaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelFavoritePublicMediaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelFavoritePublicMediaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelFavoritePublicMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelUrlUploadJobsRequest(TeaModel):
    def __init__(self, job_ids=None, upload_urls=None):
        self.job_ids = job_ids  # type: str
        self.upload_urls = upload_urls  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelUrlUploadJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.upload_urls is not None:
            result['UploadUrls'] = self.upload_urls
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('UploadUrls') is not None:
            self.upload_urls = m.get('UploadUrls')
        return self


class CancelUrlUploadJobsResponseBody(TeaModel):
    def __init__(self, canceled_jobs=None, non_exists=None, request_id=None):
        self.canceled_jobs = canceled_jobs  # type: list[str]
        self.non_exists = non_exists  # type: list[str]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelUrlUploadJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.canceled_jobs is not None:
            result['CanceledJobs'] = self.canceled_jobs
        if self.non_exists is not None:
            result['NonExists'] = self.non_exists
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CanceledJobs') is not None:
            self.canceled_jobs = m.get('CanceledJobs')
        if m.get('NonExists') is not None:
            self.non_exists = m.get('NonExists')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelUrlUploadJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelUrlUploadJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelUrlUploadJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelUrlUploadJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAuditRequest(TeaModel):
    def __init__(self, app_id=None, audit_content=None):
        self.app_id = app_id  # type: str
        self.audit_content = audit_content  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAuditRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.audit_content is not None:
            result['AuditContent'] = self.audit_content
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('AuditContent') is not None:
            self.audit_content = m.get('AuditContent')
        return self


class CreateAuditResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAuditResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAuditResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAuditResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAuditResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAuditResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCustomTemplateRequest(TeaModel):
    def __init__(self, name=None, subtype=None, template_config=None, type=None):
        # 模板名称
        self.name = name  # type: str
        # 模板子类型。
        self.subtype = subtype  # type: int
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板类型。
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCustomTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreateCustomTemplateResponseBodyCustomTemplate(TeaModel):
    def __init__(self, create_time=None, is_default=None, modified_time=None, status=None, subtype=None,
                 template_config=None, template_id=None, template_name=None, type=None, type_name=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 是否默认模板
        self.is_default = is_default  # type: bool
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板子类型名称
        self.subtype = subtype  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板名称
        self.template_name = template_name  # type: str
        # 模板类型ID
        self.type = type  # type: int
        # 模板类型名称
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCustomTemplateResponseBodyCustomTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class CreateCustomTemplateResponseBody(TeaModel):
    def __init__(self, custom_template=None, request_id=None):
        # 模板信息
        self.custom_template = custom_template  # type: CreateCustomTemplateResponseBodyCustomTemplate
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.custom_template:
            self.custom_template.validate()

    def to_map(self):
        _map = super(CreateCustomTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            temp_model = CreateCustomTemplateResponseBodyCustomTemplate()
            self.custom_template = temp_model.from_map(m['CustomTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCustomTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCustomTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCustomTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateEditingProjectRequest(TeaModel):
    def __init__(self, business_config=None, clips_param=None, cover_url=None, description=None, material_maps=None,
                 project_type=None, template_id=None, timeline=None, title=None):
        # 工程业务配置。如果是直播剪辑工程必填OutputMediaConfig.StorageLocation,   Path 不填默认合成的直播片段存储在根路径下 OutputMediaTarget 不填默认oss-object，可以填vod-media 表示存储到vod  OutputMediaTarget 为vod-media 时，Path不生效。
        self.business_config = business_config  # type: str
        # 模板素材参数
        self.clips_param = clips_param  # type: str
        # 云剪辑工程封面
        self.cover_url = cover_url  # type: str
        # 云剪辑工程描述
        self.description = description  # type: str
        # 工程关联素材，多个素材以逗号（,）分隔；每种类型最多支持10个素材ID
        self.material_maps = material_maps  # type: str
        # 剪辑工程类型，EditingProject: 普通剪辑工程；LiveEditingProject: 直播剪辑工程
        self.project_type = project_type  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 云剪辑工程时间线，Json格式
        self.timeline = timeline  # type: str
        # 云剪辑工程标题
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateEditingProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.material_maps is not None:
            result['MaterialMaps'] = self.material_maps
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MaterialMaps') is not None:
            self.material_maps = m.get('MaterialMaps')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateEditingProjectResponseBodyProject(TeaModel):
    def __init__(self, business_config=None, business_status=None, clips_param=None, cover_url=None,
                 create_source=None, create_time=None, description=None, duration=None, modified_source=None, modified_time=None,
                 project_id=None, project_type=None, status=None, status_name=None, template_id=None, template_type=None,
                 timeline=None, title=None):
        # 工程业务配置
        self.business_config = business_config  # type: str
        # 业务状态，业务状态 /** 预约中 **/ RESERVING(0, "Reserving"), /** 预约取消 **/ RESERVATION_CANCELED(1, "ReservationCanceled"), /** 直播中 **/ BROADCASTING(3, "BroadCasting"), /** 加载失败 **/ LOADING_FAILED(4, "LoadingFailed"), /** 直播结束 **/ LIVE_FINISHED(5, "LiveFinished");
        self.business_status = business_status  # type: str
        # 模板素材参数
        self.clips_param = clips_param  # type: str
        # 云剪辑工程封面。
        self.cover_url = cover_url  # type: str
        # 云剪辑工程创建方式  -OpenAPI  -AliyunConsole  -WebSDK -LiveEditingOpenAPI -LiveEditingConsole
        self.create_source = create_source  # type: str
        # 云剪辑工程创建时间
        self.create_time = create_time  # type: str
        # 云剪辑工程描述
        self.description = description  # type: str
        # 云剪辑工程时长
        self.duration = duration  # type: float
        # 云剪辑工程创建方式  -OpenAPI  -AliyunConsole  -WebSDK -LiveEditingOpenAPI -LiveEditingConsole
        self.modified_source = modified_source  # type: str
        # 云剪辑工程编辑时间
        self.modified_time = modified_time  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str
        # 剪辑工程类型，EditingProject: 普通剪辑工程；LiveEditingProject: 直播剪辑工程
        self.project_type = project_type  # type: str
        # 云剪辑工程状态。  所有云剪辑工程状态列表：  -1:Draft  -2:Editing  -3:Producing  -4:Produced  -5:ProduceFailed  -7:Deleted
        self.status = status  # type: long
        # 云剪辑状态名称，对应状态列表中状态名称。
        self.status_name = status_name  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        self.template_type = template_type  # type: str
        # 云剪辑工程时间线，Json格式
        self.timeline = timeline  # type: str
        # 云剪辑工程标题
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateEditingProjectResponseBodyProject, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.status_name is not None:
            result['StatusName'] = self.status_name
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusName') is not None:
            self.status_name = m.get('StatusName')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class CreateEditingProjectResponseBody(TeaModel):
    def __init__(self, project=None, request_id=None):
        self.project = project  # type: CreateEditingProjectResponseBodyProject
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super(CreateEditingProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = CreateEditingProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateEditingProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateEditingProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateEditingProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLiveRecordTemplateRequestRecordFormat(TeaModel):
    def __init__(self, cycle_duration=None, format=None, oss_object_prefix=None, slice_duration=None,
                 slice_oss_object_prefix=None):
        self.cycle_duration = cycle_duration  # type: int
        # 格式
        self.format = format  # type: bytes
        # Oss对象名
        self.oss_object_prefix = oss_object_prefix  # type: bytes
        # 切片时长
        self.slice_duration = slice_duration  # type: int
        # 切片Oss对象名
        self.slice_oss_object_prefix = slice_oss_object_prefix  # type: bytes

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLiveRecordTemplateRequestRecordFormat, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class CreateLiveRecordTemplateRequest(TeaModel):
    def __init__(self, name=None, record_format=None):
        # 资源名称
        self.name = name  # type: bytes
        # 录制格式
        self.record_format = record_format  # type: list[CreateLiveRecordTemplateRequestRecordFormat]

    def validate(self):
        if self.record_format:
            for k in self.record_format:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateLiveRecordTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormat'] = []
        if self.record_format is not None:
            for k in self.record_format:
                result['RecordFormat'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format = []
        if m.get('RecordFormat') is not None:
            for k in m.get('RecordFormat'):
                temp_model = CreateLiveRecordTemplateRequestRecordFormat()
                self.record_format.append(temp_model.from_map(k))
        return self


class CreateLiveRecordTemplateShrinkRequest(TeaModel):
    def __init__(self, name=None, record_format_shrink=None):
        # 资源名称
        self.name = name  # type: bytes
        # 录制格式
        self.record_format_shrink = record_format_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLiveRecordTemplateShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.record_format_shrink is not None:
            result['RecordFormat'] = self.record_format_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RecordFormat') is not None:
            self.record_format_shrink = m.get('RecordFormat')
        return self


class CreateLiveRecordTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, template_id=None):
        self.request_id = request_id  # type: str
        # 资源一级ID
        self.template_id = template_id  # type: bytes

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLiveRecordTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class CreateLiveRecordTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLiveRecordTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLiveRecordTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLiveRecordTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePipelineRequest(TeaModel):
    def __init__(self, name=None, priority=None, speed=None):
        # 管道名称
        self.name = name  # type: str
        # 优先级，1-10，默认6。数值越大，优先级越高
        self.priority = priority  # type: int
        # 管道类型。
        self.speed = speed  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        return self


class CreatePipelineResponseBodyPipeline(TeaModel):
    def __init__(self, create_time=None, modified_time=None, name=None, pipeline_id=None, priority=None, speed=None,
                 status=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 管道名称
        self.name = name  # type: str
        # 管道Id
        self.pipeline_id = pipeline_id  # type: str
        # 管道优先级
        self.priority = priority  # type: int
        # 管道类型
        self.speed = speed  # type: str
        # 管道状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePipelineResponseBodyPipeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreatePipelineResponseBody(TeaModel):
    def __init__(self, pipeline=None, request_id=None):
        # 管道信息
        self.pipeline = pipeline  # type: CreatePipelineResponseBodyPipeline
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super(CreatePipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = CreatePipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreatePipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreatePipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadMediaRequest(TeaModel):
    def __init__(self, app_id=None, entity_id=None, file_info=None, media_meta_data=None, post_process_config=None,
                 upload_target_config=None, user_data=None):
        self.app_id = app_id  # type: str
        self.entity_id = entity_id  # type: str
        self.file_info = file_info  # type: str
        self.media_meta_data = media_meta_data  # type: str
        self.post_process_config = post_process_config  # type: str
        self.upload_target_config = upload_target_config  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadMediaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.file_info is not None:
            result['FileInfo'] = self.file_info
        if self.media_meta_data is not None:
            result['MediaMetaData'] = self.media_meta_data
        if self.post_process_config is not None:
            result['PostProcessConfig'] = self.post_process_config
        if self.upload_target_config is not None:
            result['UploadTargetConfig'] = self.upload_target_config
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('FileInfo') is not None:
            self.file_info = m.get('FileInfo')
        if m.get('MediaMetaData') is not None:
            self.media_meta_data = m.get('MediaMetaData')
        if m.get('PostProcessConfig') is not None:
            self.post_process_config = m.get('PostProcessConfig')
        if m.get('UploadTargetConfig') is not None:
            self.upload_target_config = m.get('UploadTargetConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class CreateUploadMediaResponseBody(TeaModel):
    def __init__(self, file_url=None, media_id=None, media_url=None, request_id=None, upload_address=None,
                 upload_auth=None):
        self.file_url = file_url  # type: str
        self.media_id = media_id  # type: str
        self.media_url = media_url  # type: str
        # RequestId
        self.request_id = request_id  # type: str
        self.upload_address = upload_address  # type: str
        self.upload_auth = upload_auth  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadMediaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class CreateUploadMediaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUploadMediaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUploadMediaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateUploadStreamRequest(TeaModel):
    def __init__(self, definition=None, file_extension=None, hdrtype=None, media_id=None, user_data=None):
        self.definition = definition  # type: str
        self.file_extension = file_extension  # type: str
        self.hdrtype = hdrtype  # type: str
        self.media_id = media_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadStreamRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.file_extension is not None:
            result['FileExtension'] = self.file_extension
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('FileExtension') is not None:
            self.file_extension = m.get('FileExtension')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class CreateUploadStreamResponseBody(TeaModel):
    def __init__(self, file_url=None, media_id=None, request_id=None, upload_address=None, upload_auth=None):
        self.file_url = file_url  # type: str
        self.media_id = media_id  # type: str
        self.request_id = request_id  # type: str
        self.upload_address = upload_address  # type: str
        self.upload_auth = upload_auth  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateUploadStreamResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class CreateUploadStreamResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateUploadStreamResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateUploadStreamResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateUploadStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCategoryRequest(TeaModel):
    def __init__(self, cate_id=None):
        self.cate_id = cate_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCategoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        return self


class DeleteCategoryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCategoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCategoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCategoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCategoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomTemplateRequest(TeaModel):
    def __init__(self, template_id=None):
        # 模板ID
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteCustomTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCustomTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCustomTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCustomTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEditingProjectMaterialsRequest(TeaModel):
    def __init__(self, material_ids=None, material_type=None, project_id=None):
        # 素材ID
        self.material_ids = material_ids  # type: str
        # 素材类型
        self.material_type = material_type  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEditingProjectMaterialsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_ids is not None:
            result['MaterialIds'] = self.material_ids
        if self.material_type is not None:
            result['MaterialType'] = self.material_type
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaterialIds') is not None:
            self.material_ids = m.get('MaterialIds')
        if m.get('MaterialType') is not None:
            self.material_type = m.get('MaterialType')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class DeleteEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEditingProjectMaterialsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEditingProjectMaterialsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteEditingProjectMaterialsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteEditingProjectMaterialsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEditingProjectsRequest(TeaModel):
    def __init__(self, project_ids=None):
        # 云剪辑工程ID。支持多个云剪辑工程，以逗号分隔。
        self.project_ids = project_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEditingProjectsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_ids is not None:
            result['ProjectIds'] = self.project_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProjectIds') is not None:
            self.project_ids = m.get('ProjectIds')
        return self


class DeleteEditingProjectsResponseBody(TeaModel):
    def __init__(self, ignored_list=None, request_id=None):
        self.ignored_list = ignored_list  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEditingProjectsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteEditingProjectsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteEditingProjectsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteEditingProjectsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEditingProjectsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveTranscodeJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 模板Id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLiveTranscodeJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteLiveTranscodeJobResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLiveTranscodeJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveTranscodeJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLiveTranscodeJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLiveTranscodeJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLiveTranscodeTemplateRequest(TeaModel):
    def __init__(self, template_id=None):
        # 模板Id
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLiveTranscodeTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLiveTranscodeTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLiveTranscodeTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLiveTranscodeTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLiveTranscodeTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaInfosRequest(TeaModel):
    def __init__(self, input_urls=None, media_ids=None):
        # 待注册的媒资在相应系统中的地址
        self.input_urls = input_urls  # type: str
        # ICE 媒资ID
        self.media_ids = media_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMediaInfosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_urls is not None:
            result['InputURLs'] = self.input_urls
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputURLs') is not None:
            self.input_urls = m.get('InputURLs')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        return self


class DeleteMediaInfosResponseBody(TeaModel):
    def __init__(self, ignored_list=None, request_id=None):
        # 出现获取错误的ID或inputUr
        self.ignored_list = ignored_list  # type: list[str]
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMediaInfosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignored_list is not None:
            result['IgnoredList'] = self.ignored_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoredList') is not None:
            self.ignored_list = m.get('IgnoredList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaInfosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMediaInfosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMediaInfosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMediaProducingJobsRequest(TeaModel):
    def __init__(self, job_ids=None):
        self.job_ids = job_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMediaProducingJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        return self


class DeleteMediaProducingJobsResponseBody(TeaModel):
    def __init__(self, ignore_list=None, request_id=None):
        self.ignore_list = ignore_list  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMediaProducingJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ignore_list is not None:
            result['IgnoreList'] = self.ignore_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IgnoreList') is not None:
            self.ignore_list = m.get('IgnoreList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteMediaProducingJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMediaProducingJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMediaProducingJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMediaProducingJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePipelineRequest(TeaModel):
    def __init__(self, pipeline_id=None):
        # 管道ID
        self.pipeline_id = pipeline_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class DeletePipelineResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeletePipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeletePipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeletePipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePlayInfoRequest(TeaModel):
    def __init__(self, file_urls=None, media_id=None):
        self.file_urls = file_urls  # type: str
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePlayInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_urls is not None:
            result['FileURLs'] = self.file_urls
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileURLs') is not None:
            self.file_urls = m.get('FileURLs')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class DeletePlayInfoResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePlayInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePlayInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeletePlayInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeletePlayInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePlayInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSmartJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 任务id，多个任务id用英文逗号分割
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSmartJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class DeleteSmartJobResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSmartJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSmartJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSmartJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSmartJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSmartJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteTemplateRequest(TeaModel):
    def __init__(self, template_ids=None):
        # 模板id，多个id用英文逗号隔开
        self.template_ids = template_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        return self


class DeleteTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBizUserTypeRequest(TeaModel):
    def __init__(self, region=None):
        self.region = region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBizUserTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class DescribeBizUserTypeResponseBodyData(TeaModel):
    def __init__(self, profile=None):
        self.profile = profile  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBizUserTypeResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.profile is not None:
            result['Profile'] = self.profile
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        return self


class DescribeBizUserTypeResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeBizUserTypeResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBizUserTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeBizUserTypeResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBizUserTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBizUserTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBizUserTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBizUserTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFilterConfigsRequest(TeaModel):
    def __init__(self, type=None):
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFilterConfigsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeFilterConfigsResponseBodyFilterConfigs(TeaModel):
    def __init__(self, filter_name=None, item_configs=None, type=None):
        self.filter_name = filter_name  # type: str
        self.item_configs = item_configs  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFilterConfigsResponseBodyFilterConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter_name is not None:
            result['FilterName'] = self.filter_name
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FilterName') is not None:
            self.filter_name = m.get('FilterName')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeFilterConfigsResponseBody(TeaModel):
    def __init__(self, filter_configs=None, request_id=None):
        self.filter_configs = filter_configs  # type: list[DescribeFilterConfigsResponseBodyFilterConfigs]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.filter_configs:
            for k in self.filter_configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFilterConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FilterConfigs'] = []
        if self.filter_configs is not None:
            for k in self.filter_configs:
                result['FilterConfigs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter_configs = []
        if m.get('FilterConfigs') is not None:
            for k in m.get('FilterConfigs'):
                temp_model = DescribeFilterConfigsResponseBodyFilterConfigs()
                self.filter_configs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFilterConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFilterConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFilterConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFilterConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePubExperienceMetricDataRequest(TeaModel):
    def __init__(self, begin_ts=None, domain=None, end_ts=None, metric_type=None, os=None, pub_protocol=None,
                 terminal_type=None):
        self.begin_ts = begin_ts  # type: str
        self.domain = domain  # type: str
        self.end_ts = end_ts  # type: str
        self.metric_type = metric_type  # type: str
        self.os = os  # type: str
        self.pub_protocol = pub_protocol  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubExperienceMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.os is not None:
            result['Os'] = self.os
        if self.pub_protocol is not None:
            result['PubProtocol'] = self.pub_protocol
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PubProtocol') is not None:
            self.pub_protocol = m.get('PubProtocol')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLivePubExperienceMetricDataResponseBodyMetricList(TeaModel):
    def __init__(self, avg_score=None, max_score=None, min_score=None):
        self.avg_score = avg_score  # type: float
        self.max_score = max_score  # type: float
        self.min_score = min_score  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubExperienceMetricDataResponseBodyMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_score is not None:
            result['AvgScore'] = self.avg_score
        if self.max_score is not None:
            result['MaxScore'] = self.max_score
        if self.min_score is not None:
            result['MinScore'] = self.min_score
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgScore') is not None:
            self.avg_score = m.get('AvgScore')
        if m.get('MaxScore') is not None:
            self.max_score = m.get('MaxScore')
        if m.get('MinScore') is not None:
            self.min_score = m.get('MinScore')
        return self


class DescribeLivePubExperienceMetricDataResponseBody(TeaModel):
    def __init__(self, metric_list=None, request_id=None):
        self.metric_list = metric_list  # type: list[DescribeLivePubExperienceMetricDataResponseBodyMetricList]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLivePubExperienceMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['MetricList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_list = []
        if m.get('MetricList') is not None:
            for k in m.get('MetricList'):
                temp_model = DescribeLivePubExperienceMetricDataResponseBodyMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePubExperienceMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLivePubExperienceMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLivePubExperienceMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePubExperienceMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePubListRequest(TeaModel):
    def __init__(self, begin_ts=None, domain=None, end_ts=None, metric_type=None, os=None, page_num=None,
                 page_size=None, pub_protocol=None, terminal_type=None):
        self.begin_ts = begin_ts  # type: str
        self.domain = domain  # type: str
        self.end_ts = end_ts  # type: str
        self.metric_type = metric_type  # type: str
        self.os = os  # type: str
        self.page_num = page_num  # type: int
        self.page_size = page_size  # type: int
        self.pub_protocol = pub_protocol  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.os is not None:
            result['Os'] = self.os
        if self.page_num is not None:
            result['PageNum'] = self.page_num
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.pub_protocol is not None:
            result['PubProtocol'] = self.pub_protocol
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageNum') is not None:
            self.page_num = m.get('PageNum')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PubProtocol') is not None:
            self.pub_protocol = m.get('PubProtocol')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLivePubListResponseBodyPubInfoList(TeaModel):
    def __init__(self, area=None, cpu_usage_rate=None, domain=None, end_ts=None, fps=None, kbps=None,
                 pub_heap_up_duration=None, pub_machine_type=None, second_play_rate=None, start_ts=None, stream_name=None):
        self.area = area  # type: str
        self.cpu_usage_rate = cpu_usage_rate  # type: str
        self.domain = domain  # type: str
        self.end_ts = end_ts  # type: str
        self.fps = fps  # type: str
        self.kbps = kbps  # type: str
        self.pub_heap_up_duration = pub_heap_up_duration  # type: str
        self.pub_machine_type = pub_machine_type  # type: str
        self.second_play_rate = second_play_rate  # type: str
        self.start_ts = start_ts  # type: str
        self.stream_name = stream_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubListResponseBodyPubInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area is not None:
            result['Area'] = self.area
        if self.cpu_usage_rate is not None:
            result['CpuUsageRate'] = self.cpu_usage_rate
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.kbps is not None:
            result['Kbps'] = self.kbps
        if self.pub_heap_up_duration is not None:
            result['PubHeapUpDuration'] = self.pub_heap_up_duration
        if self.pub_machine_type is not None:
            result['PubMachineType'] = self.pub_machine_type
        if self.second_play_rate is not None:
            result['SecondPlayRate'] = self.second_play_rate
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Area') is not None:
            self.area = m.get('Area')
        if m.get('CpuUsageRate') is not None:
            self.cpu_usage_rate = m.get('CpuUsageRate')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Kbps') is not None:
            self.kbps = m.get('Kbps')
        if m.get('PubHeapUpDuration') is not None:
            self.pub_heap_up_duration = m.get('PubHeapUpDuration')
        if m.get('PubMachineType') is not None:
            self.pub_machine_type = m.get('PubMachineType')
        if m.get('SecondPlayRate') is not None:
            self.second_play_rate = m.get('SecondPlayRate')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class DescribeLivePubListResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, pub_info_list=None, request_id=None, total_count=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.pub_info_list = pub_info_list  # type: list[DescribeLivePubListResponseBodyPubInfoList]
        # Id
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        if self.pub_info_list:
            for k in self.pub_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLivePubListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PubInfoList'] = []
        if self.pub_info_list is not None:
            for k in self.pub_info_list:
                result['PubInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.pub_info_list = []
        if m.get('PubInfoList') is not None:
            for k in m.get('PubInfoList'):
                temp_model = DescribeLivePubListResponseBodyPubInfoList()
                self.pub_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLivePubListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLivePubListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLivePubListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePubListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLivePubMetricDataRequest(TeaModel):
    def __init__(self, begin_ts=None, domain=None, end_ts=None, experience_level=None, metric_type=None, os=None,
                 pub_protocol=None, sdk_version=None, stream_name=None, terminal_type=None):
        self.begin_ts = begin_ts  # type: long
        self.domain = domain  # type: str
        self.end_ts = end_ts  # type: long
        self.experience_level = experience_level  # type: str
        self.metric_type = metric_type  # type: str
        self.os = os  # type: str
        self.pub_protocol = pub_protocol  # type: str
        self.sdk_version = sdk_version  # type: str
        self.stream_name = stream_name  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.os is not None:
            result['Os'] = self.os
        if self.pub_protocol is not None:
            result['PubProtocol'] = self.pub_protocol
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PubProtocol') is not None:
            self.pub_protocol = m.get('PubProtocol')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLivePubMetricDataResponseBodyNodes(TeaModel):
    def __init__(self, duration=None, time=None):
        self.duration = duration  # type: long
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLivePubMetricDataResponseBodyNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeLivePubMetricDataResponseBody(TeaModel):
    def __init__(self, nodes=None, request_id=None):
        self.nodes = nodes  # type: list[DescribeLivePubMetricDataResponseBodyNodes]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLivePubMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeLivePubMetricDataResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLivePubMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLivePubMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLivePubMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLivePubMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSubExperienceMetricDataRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, end_ts=None, experience_level=None, metric_type=None, os=None,
                 sub_protocol=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: str
        self.end_ts = end_ts  # type: str
        self.experience_level = experience_level  # type: str
        self.metric_type = metric_type  # type: str
        self.os = os  # type: str
        self.sub_protocol = sub_protocol  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubExperienceMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.os is not None:
            result['Os'] = self.os
        if self.sub_protocol is not None:
            result['SubProtocol'] = self.sub_protocol
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('SubProtocol') is not None:
            self.sub_protocol = m.get('SubProtocol')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLiveSubExperienceMetricDataResponseBodyMetricList(TeaModel):
    def __init__(self, avg_score=None, max_score=None, min_score=None):
        self.avg_score = avg_score  # type: float
        self.max_score = max_score  # type: float
        self.min_score = min_score  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubExperienceMetricDataResponseBodyMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_score is not None:
            result['AvgScore'] = self.avg_score
        if self.max_score is not None:
            result['MaxScore'] = self.max_score
        if self.min_score is not None:
            result['MinScore'] = self.min_score
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgScore') is not None:
            self.avg_score = m.get('AvgScore')
        if m.get('MaxScore') is not None:
            self.max_score = m.get('MaxScore')
        if m.get('MinScore') is not None:
            self.min_score = m.get('MinScore')
        return self


class DescribeLiveSubExperienceMetricDataResponseBody(TeaModel):
    def __init__(self, metric_list=None, request_id=None):
        self.metric_list = metric_list  # type: list[DescribeLiveSubExperienceMetricDataResponseBodyMetricList]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLiveSubExperienceMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['MetricList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_list = []
        if m.get('MetricList') is not None:
            for k in m.get('MetricList'):
                temp_model = DescribeLiveSubExperienceMetricDataResponseBodyMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveSubExperienceMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLiveSubExperienceMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLiveSubExperienceMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSubExperienceMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSubListRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, definition=None, end_ts=None, experience_level=None,
                 item_configs=None, metric_type=None, network=None, os=None, page_no=None, page_size=None, stream_name=None,
                 sub_protocol=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: str
        self.definition = definition  # type: str
        self.end_ts = end_ts  # type: str
        self.experience_level = experience_level  # type: str
        self.item_configs = item_configs  # type: str
        self.metric_type = metric_type  # type: str
        self.network = network  # type: str
        self.os = os  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.stream_name = stream_name  # type: str
        self.sub_protocol = sub_protocol  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.network is not None:
            result['Network'] = self.network
        if self.os is not None:
            result['Os'] = self.os
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.sub_protocol is not None:
            result['SubProtocol'] = self.sub_protocol
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('SubProtocol') is not None:
            self.sub_protocol = m.get('SubProtocol')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLiveSubListResponseBodySubInfoList(TeaModel):
    def __init__(self, cache_duration=None, cpu_usage_rate=None, first_frame_duration=None, play_fps=None,
                 second_play_rate=None, sub_net_bitrate=None, sub_rate=None, trace_id=None, video_stuck=None):
        self.cache_duration = cache_duration  # type: str
        self.cpu_usage_rate = cpu_usage_rate  # type: str
        self.first_frame_duration = first_frame_duration  # type: str
        self.play_fps = play_fps  # type: str
        self.second_play_rate = second_play_rate  # type: str
        self.sub_net_bitrate = sub_net_bitrate  # type: str
        self.sub_rate = sub_rate  # type: str
        self.trace_id = trace_id  # type: str
        self.video_stuck = video_stuck  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubListResponseBodySubInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cache_duration is not None:
            result['CacheDuration'] = self.cache_duration
        if self.cpu_usage_rate is not None:
            result['CpuUsageRate'] = self.cpu_usage_rate
        if self.first_frame_duration is not None:
            result['FirstFrameDuration'] = self.first_frame_duration
        if self.play_fps is not None:
            result['PlayFps'] = self.play_fps
        if self.second_play_rate is not None:
            result['SecondPlayRate'] = self.second_play_rate
        if self.sub_net_bitrate is not None:
            result['SubNetBitrate'] = self.sub_net_bitrate
        if self.sub_rate is not None:
            result['SubRate'] = self.sub_rate
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        if self.video_stuck is not None:
            result['VideoStuck'] = self.video_stuck
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CacheDuration') is not None:
            self.cache_duration = m.get('CacheDuration')
        if m.get('CpuUsageRate') is not None:
            self.cpu_usage_rate = m.get('CpuUsageRate')
        if m.get('FirstFrameDuration') is not None:
            self.first_frame_duration = m.get('FirstFrameDuration')
        if m.get('PlayFps') is not None:
            self.play_fps = m.get('PlayFps')
        if m.get('SecondPlayRate') is not None:
            self.second_play_rate = m.get('SecondPlayRate')
        if m.get('SubNetBitrate') is not None:
            self.sub_net_bitrate = m.get('SubNetBitrate')
        if m.get('SubRate') is not None:
            self.sub_rate = m.get('SubRate')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        if m.get('VideoStuck') is not None:
            self.video_stuck = m.get('VideoStuck')
        return self


class DescribeLiveSubListResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, request_id=None, sub_info_list=None, total_count=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        # Id
        self.request_id = request_id  # type: str
        self.sub_info_list = sub_info_list  # type: list[DescribeLiveSubListResponseBodySubInfoList]
        self.total_count = total_count  # type: long

    def validate(self):
        if self.sub_info_list:
            for k in self.sub_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLiveSubListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SubInfoList'] = []
        if self.sub_info_list is not None:
            for k in self.sub_info_list:
                result['SubInfoList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.sub_info_list = []
        if m.get('SubInfoList') is not None:
            for k in m.get('SubInfoList'):
                temp_model = DescribeLiveSubListResponseBodySubInfoList()
                self.sub_info_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLiveSubListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLiveSubListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLiveSubListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSubListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLiveSubMetricDataRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, definition=None, end_ts=None, experience_level=None,
                 item_configs=None, metric_type=None, network=None, os=None, sdk_version=None, stream_name=None,
                 sub_protocol=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: long
        self.definition = definition  # type: str
        self.end_ts = end_ts  # type: long
        self.experience_level = experience_level  # type: str
        self.item_configs = item_configs  # type: str
        self.metric_type = metric_type  # type: str
        self.network = network  # type: str
        self.os = os  # type: str
        self.sdk_version = sdk_version  # type: str
        self.stream_name = stream_name  # type: str
        self.sub_protocol = sub_protocol  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.network is not None:
            result['Network'] = self.network
        if self.os is not None:
            result['Os'] = self.os
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        if self.sub_protocol is not None:
            result['SubProtocol'] = self.sub_protocol
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        if m.get('SubProtocol') is not None:
            self.sub_protocol = m.get('SubProtocol')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribeLiveSubMetricDataResponseBodyNodes(TeaModel):
    def __init__(self, duration=None, time=None):
        self.duration = duration  # type: long
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLiveSubMetricDataResponseBodyNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeLiveSubMetricDataResponseBody(TeaModel):
    def __init__(self, nodes=None, request_id=None):
        self.nodes = nodes  # type: list[DescribeLiveSubMetricDataResponseBodyNodes]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLiveSubMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribeLiveSubMetricDataResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeLiveSubMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLiveSubMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLiveSubMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLiveSubMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceEditUsageRequest(TeaModel):
    def __init__(self, end_ts=None, interval=None, region=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.interval = interval  # type: long
        self.region = region  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceEditUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceEditUsageResponseBodyData(TeaModel):
    def __init__(self, duration=None, profile=None, time=None):
        self.duration = duration  # type: long
        self.profile = profile  # type: str
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceEditUsageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterIceEditUsageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceEditUsageResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceEditUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceEditUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceEditUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceEditUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceEditUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceEditUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceLiveMediaConvertUsageRequest(TeaModel):
    def __init__(self, end_ts=None, interval=None, region=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.interval = interval  # type: long
        self.region = region  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceLiveMediaConvertUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceLiveMediaConvertUsageResponseBodyData(TeaModel):
    def __init__(self, duration=None, specification=None, time=None):
        self.duration = duration  # type: long
        self.specification = specification  # type: str
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceLiveMediaConvertUsageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterIceLiveMediaConvertUsageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceLiveMediaConvertUsageResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceLiveMediaConvertUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceLiveMediaConvertUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceLiveMediaConvertUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceLiveMediaConvertUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceLiveMediaConvertUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceLiveMediaConvertUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceMediaConvertUHDUsageRequest(TeaModel):
    def __init__(self, end_ts=None, interval=None, region_id=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.interval = interval  # type: str
        self.region_id = region_id  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUHDUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceMediaConvertUHDUsageResponseBodyData(TeaModel):
    def __init__(self, duration=None, specification=None, time=None):
        self.duration = duration  # type: long
        self.specification = specification  # type: str
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUHDUsageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterIceMediaConvertUHDUsageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceMediaConvertUHDUsageResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUHDUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceMediaConvertUHDUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceMediaConvertUHDUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceMediaConvertUHDUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUHDUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceMediaConvertUHDUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceMediaConvertUsageRequest(TeaModel):
    def __init__(self, end_ts=None, interval=None, region=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.interval = interval  # type: long
        self.region = region  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceMediaConvertUsageResponseBodyData(TeaModel):
    def __init__(self, duration=None, specification=None, time=None):
        self.duration = duration  # type: long
        self.specification = specification  # type: str
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUsageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeMeterIceMediaConvertUsageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceMediaConvertUsageResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceMediaConvertUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceMediaConvertUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceMediaConvertUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMediaConvertUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceMediaConvertUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceMpsAiUsageRequest(TeaModel):
    def __init__(self, end_ts=None, interval=None, region=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.interval = interval  # type: long
        self.region = region  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMpsAiUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceMpsAiUsageResponseBodyData(TeaModel):
    def __init__(self, duration=None, time=None, type=None):
        self.duration = duration  # type: long
        self.time = time  # type: long
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceMpsAiUsageResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeMeterIceMpsAiUsageResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceMpsAiUsageResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMpsAiUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceMpsAiUsageResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceMpsAiUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceMpsAiUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceMpsAiUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceMpsAiUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMeterIceSummaryRequest(TeaModel):
    def __init__(self, end_ts=None, region=None, start_ts=None):
        self.end_ts = end_ts  # type: long
        self.region = region  # type: str
        self.start_ts = start_ts  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceSummaryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.region is not None:
            result['Region'] = self.region
        if self.start_ts is not None:
            result['StartTs'] = self.start_ts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('StartTs') is not None:
            self.start_ts = m.get('StartTs')
        return self


class DescribeMeterIceSummaryResponseBodyData(TeaModel):
    def __init__(self, editing_duration=None, live_transcode_duration=None, mps_ai_duration=None,
                 mps_transcode_duration=None, mps_transcode_uhdduration=None):
        self.editing_duration = editing_duration  # type: str
        self.live_transcode_duration = live_transcode_duration  # type: long
        self.mps_ai_duration = mps_ai_duration  # type: long
        self.mps_transcode_duration = mps_transcode_duration  # type: long
        self.mps_transcode_uhdduration = mps_transcode_uhdduration  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMeterIceSummaryResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.editing_duration is not None:
            result['EditingDuration'] = self.editing_duration
        if self.live_transcode_duration is not None:
            result['LiveTranscodeDuration'] = self.live_transcode_duration
        if self.mps_ai_duration is not None:
            result['MpsAiDuration'] = self.mps_ai_duration
        if self.mps_transcode_duration is not None:
            result['MpsTranscodeDuration'] = self.mps_transcode_duration
        if self.mps_transcode_uhdduration is not None:
            result['MpsTranscodeUHDDuration'] = self.mps_transcode_uhdduration
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EditingDuration') is not None:
            self.editing_duration = m.get('EditingDuration')
        if m.get('LiveTranscodeDuration') is not None:
            self.live_transcode_duration = m.get('LiveTranscodeDuration')
        if m.get('MpsAiDuration') is not None:
            self.mps_ai_duration = m.get('MpsAiDuration')
        if m.get('MpsTranscodeDuration') is not None:
            self.mps_transcode_duration = m.get('MpsTranscodeDuration')
        if m.get('MpsTranscodeUHDDuration') is not None:
            self.mps_transcode_uhdduration = m.get('MpsTranscodeUHDDuration')
        return self


class DescribeMeterIceSummaryResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribeMeterIceSummaryResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMeterIceSummaryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribeMeterIceSummaryResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMeterIceSummaryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMeterIceSummaryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMeterIceSummaryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMeterIceSummaryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePalyDetailRequest(TeaModel):
    def __init__(self, trace_id=None):
        self.trace_id = trace_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePalyDetailResponseBodyData(TeaModel):
    def __init__(self, app_name=None, bps=None, broadcast_pace=None, codec=None, decode_stuck_time=None,
                 definition=None, first_frame_duration=None, fps=None, is_hard_decode=None, mdat=None, moov=None,
                 net_work_duration=None, network=None, network_stuck_time=None, os=None, play_ts=None, player_load_duration=None,
                 player_pre_deal_duration=None, player_ready_duration=None, sdk_version=None, session_id=None, status=None,
                 terminal_type=None):
        self.app_name = app_name  # type: str
        self.bps = bps  # type: str
        self.broadcast_pace = broadcast_pace  # type: str
        self.codec = codec  # type: str
        self.decode_stuck_time = decode_stuck_time  # type: str
        self.definition = definition  # type: str
        self.first_frame_duration = first_frame_duration  # type: str
        self.fps = fps  # type: str
        self.is_hard_decode = is_hard_decode  # type: str
        self.mdat = mdat  # type: str
        self.moov = moov  # type: str
        self.net_work_duration = net_work_duration  # type: str
        self.network = network  # type: str
        self.network_stuck_time = network_stuck_time  # type: str
        self.os = os  # type: str
        self.play_ts = play_ts  # type: str
        self.player_load_duration = player_load_duration  # type: str
        self.player_pre_deal_duration = player_pre_deal_duration  # type: str
        self.player_ready_duration = player_ready_duration  # type: str
        self.sdk_version = sdk_version  # type: str
        self.session_id = session_id  # type: str
        self.status = status  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyDetailResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.bps is not None:
            result['Bps'] = self.bps
        if self.broadcast_pace is not None:
            result['BroadcastPace'] = self.broadcast_pace
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.decode_stuck_time is not None:
            result['DecodeStuckTime'] = self.decode_stuck_time
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.first_frame_duration is not None:
            result['FirstFrameDuration'] = self.first_frame_duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.is_hard_decode is not None:
            result['IsHardDecode'] = self.is_hard_decode
        if self.mdat is not None:
            result['Mdat'] = self.mdat
        if self.moov is not None:
            result['Moov'] = self.moov
        if self.net_work_duration is not None:
            result['NetWorkDuration'] = self.net_work_duration
        if self.network is not None:
            result['Network'] = self.network
        if self.network_stuck_time is not None:
            result['NetworkStuckTime'] = self.network_stuck_time
        if self.os is not None:
            result['Os'] = self.os
        if self.play_ts is not None:
            result['PlayTs'] = self.play_ts
        if self.player_load_duration is not None:
            result['PlayerLoadDuration'] = self.player_load_duration
        if self.player_pre_deal_duration is not None:
            result['PlayerPreDealDuration'] = self.player_pre_deal_duration
        if self.player_ready_duration is not None:
            result['PlayerReadyDuration'] = self.player_ready_duration
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status is not None:
            result['Status'] = self.status
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('Bps') is not None:
            self.bps = m.get('Bps')
        if m.get('BroadcastPace') is not None:
            self.broadcast_pace = m.get('BroadcastPace')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('DecodeStuckTime') is not None:
            self.decode_stuck_time = m.get('DecodeStuckTime')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('FirstFrameDuration') is not None:
            self.first_frame_duration = m.get('FirstFrameDuration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('IsHardDecode') is not None:
            self.is_hard_decode = m.get('IsHardDecode')
        if m.get('Mdat') is not None:
            self.mdat = m.get('Mdat')
        if m.get('Moov') is not None:
            self.moov = m.get('Moov')
        if m.get('NetWorkDuration') is not None:
            self.net_work_duration = m.get('NetWorkDuration')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('NetworkStuckTime') is not None:
            self.network_stuck_time = m.get('NetworkStuckTime')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PlayTs') is not None:
            self.play_ts = m.get('PlayTs')
        if m.get('PlayerLoadDuration') is not None:
            self.player_load_duration = m.get('PlayerLoadDuration')
        if m.get('PlayerPreDealDuration') is not None:
            self.player_pre_deal_duration = m.get('PlayerPreDealDuration')
        if m.get('PlayerReadyDuration') is not None:
            self.player_ready_duration = m.get('PlayerReadyDuration')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribePalyDetailResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribePalyDetailResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePalyDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePalyDetailResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePalyDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePalyDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePalyDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePalyDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePalyEventListRequest(TeaModel):
    def __init__(self, page_no=None, page_size=None, trace_id=None):
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.trace_id = trace_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyEventListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePalyEventListResponseBodyEventList(TeaModel):
    def __init__(self, description=None, duration=None, event_name=None, time=None, topic=None):
        self.description = description  # type: str
        self.duration = duration  # type: float
        self.event_name = event_name  # type: str
        self.time = time  # type: long
        self.topic = topic  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyEventListResponseBodyEventList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.time is not None:
            result['Time'] = self.time
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class DescribePalyEventListResponseBody(TeaModel):
    def __init__(self, event_list=None, page_no=None, page_size=None, request_id=None, total_cnt=None):
        self.event_list = event_list  # type: list[DescribePalyEventListResponseBodyEventList]
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        # Id
        self.request_id = request_id  # type: str
        self.total_cnt = total_cnt  # type: long

    def validate(self):
        if self.event_list:
            for k in self.event_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePalyEventListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventList'] = []
        if self.event_list is not None:
            for k in self.event_list:
                result['EventList'].append(k.to_map() if k else None)
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_list = []
        if m.get('EventList') is not None:
            for k in m.get('EventList'):
                temp_model = DescribePalyEventListResponseBodyEventList()
                self.event_list.append(temp_model.from_map(k))
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribePalyEventListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePalyEventListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePalyEventListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePalyEventListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePalyListRequest(TeaModel):
    def __init__(self, begin_ts=None, end_ts=None, order_name=None, order_type=None, page_no=None, page_size=None,
                 play_type=None, status=None, trace_id=None):
        self.begin_ts = begin_ts  # type: str
        self.end_ts = end_ts  # type: str
        self.order_name = order_name  # type: str
        self.order_type = order_type  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.play_type = play_type  # type: str
        self.status = status  # type: str
        self.trace_id = trace_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.order_name is not None:
            result['OrderName'] = self.order_name
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.play_type is not None:
            result['PlayType'] = self.play_type
        if self.status is not None:
            result['Status'] = self.status
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('OrderName') is not None:
            self.order_name = m.get('OrderName')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PlayType') is not None:
            self.play_type = m.get('PlayType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePalyListResponseBodyPlayList(TeaModel):
    def __init__(self, first_frame_duration=None, play_duration=None, play_type=None, session_id=None, status=None,
                 stuck_duration=None, trace_id=None, video_duration=None, video_id=None):
        self.first_frame_duration = first_frame_duration  # type: str
        self.play_duration = play_duration  # type: str
        self.play_type = play_type  # type: str
        self.session_id = session_id  # type: str
        self.status = status  # type: str
        self.stuck_duration = stuck_duration  # type: str
        self.trace_id = trace_id  # type: str
        self.video_duration = video_duration  # type: str
        self.video_id = video_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePalyListResponseBodyPlayList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_frame_duration is not None:
            result['FirstFrameDuration'] = self.first_frame_duration
        if self.play_duration is not None:
            result['PlayDuration'] = self.play_duration
        if self.play_type is not None:
            result['PlayType'] = self.play_type
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.status is not None:
            result['Status'] = self.status
        if self.stuck_duration is not None:
            result['StuckDuration'] = self.stuck_duration
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        if self.video_duration is not None:
            result['VideoDuration'] = self.video_duration
        if self.video_id is not None:
            result['VideoId'] = self.video_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FirstFrameDuration') is not None:
            self.first_frame_duration = m.get('FirstFrameDuration')
        if m.get('PlayDuration') is not None:
            self.play_duration = m.get('PlayDuration')
        if m.get('PlayType') is not None:
            self.play_type = m.get('PlayType')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StuckDuration') is not None:
            self.stuck_duration = m.get('StuckDuration')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        if m.get('VideoDuration') is not None:
            self.video_duration = m.get('VideoDuration')
        if m.get('VideoId') is not None:
            self.video_id = m.get('VideoId')
        return self


class DescribePalyListResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, play_list=None, request_id=None, total_cnt=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.play_list = play_list  # type: list[DescribePalyListResponseBodyPlayList]
        # Id
        self.request_id = request_id  # type: str
        self.total_cnt = total_cnt  # type: long

    def validate(self):
        if self.play_list:
            for k in self.play_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePalyListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['PlayList'] = []
        if self.play_list is not None:
            for k in self.play_list:
                result['PlayList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_cnt is not None:
            result['TotalCnt'] = self.total_cnt
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.play_list = []
        if m.get('PlayList') is not None:
            for k in m.get('PlayList'):
                temp_model = DescribePalyListResponseBodyPlayList()
                self.play_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCnt') is not None:
            self.total_cnt = m.get('TotalCnt')
        return self


class DescribePalyListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePalyListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePalyListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePalyListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayExperienceMetricDataRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, end_ts=None, experience_level=None, os=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: str
        self.end_ts = end_ts  # type: str
        self.experience_level = experience_level  # type: str
        self.os = os  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayExperienceMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.os is not None:
            result['Os'] = self.os
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribePlayExperienceMetricDataResponseBodyData(TeaModel):
    def __init__(self, avg_score=None, max_score=None, min_score=None):
        self.avg_score = avg_score  # type: float
        self.max_score = max_score  # type: float
        self.min_score = min_score  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayExperienceMetricDataResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_score is not None:
            result['AvgScore'] = self.avg_score
        if self.max_score is not None:
            result['MaxScore'] = self.max_score
        if self.min_score is not None:
            result['MinScore'] = self.min_score
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgScore') is not None:
            self.avg_score = m.get('AvgScore')
        if m.get('MaxScore') is not None:
            self.max_score = m.get('MaxScore')
        if m.get('MinScore') is not None:
            self.min_score = m.get('MinScore')
        return self


class DescribePlayExperienceMetricDataResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        self.data = data  # type: list[DescribePlayExperienceMetricDataResponseBodyData]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePlayExperienceMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = DescribePlayExperienceMetricDataResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePlayExperienceMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePlayExperienceMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePlayExperienceMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayExperienceMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayFirstFrameDurationMetricDataRequest(TeaModel):
    def __init__(self, begin_ts=None, end_ts=None, trace_id=None):
        self.begin_ts = begin_ts  # type: str
        self.end_ts = end_ts  # type: str
        self.trace_id = trace_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayFirstFrameDurationMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        return self


class DescribePlayFirstFrameDurationMetricDataResponseBodyNodes(TeaModel):
    def __init__(self, duration=None, time=None):
        self.duration = duration  # type: long
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayFirstFrameDurationMetricDataResponseBodyNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribePlayFirstFrameDurationMetricDataResponseBody(TeaModel):
    def __init__(self, nodes=None, request_id=None):
        self.nodes = nodes  # type: list[DescribePlayFirstFrameDurationMetricDataResponseBodyNodes]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePlayFirstFrameDurationMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribePlayFirstFrameDurationMetricDataResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePlayFirstFrameDurationMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePlayFirstFrameDurationMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePlayFirstFrameDurationMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayFirstFrameDurationMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayMetricDataRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, definition=None, end_ts=None, experience_level=None,
                 item_configs=None, metric_type=None, network=None, os=None, sdk_version=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: long
        self.definition = definition  # type: str
        self.end_ts = end_ts  # type: long
        self.experience_level = experience_level  # type: str
        self.item_configs = item_configs  # type: str
        self.metric_type = metric_type  # type: str
        self.network = network  # type: str
        self.os = os  # type: str
        self.sdk_version = sdk_version  # type: str
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.experience_level is not None:
            result['ExperienceLevel'] = self.experience_level
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.network is not None:
            result['Network'] = self.network
        if self.os is not None:
            result['Os'] = self.os
        if self.sdk_version is not None:
            result['SdkVersion'] = self.sdk_version
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ExperienceLevel') is not None:
            self.experience_level = m.get('ExperienceLevel')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('SdkVersion') is not None:
            self.sdk_version = m.get('SdkVersion')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribePlayMetricDataResponseBodyNodes(TeaModel):
    def __init__(self, x=None, y=None):
        self.x = x  # type: long
        self.y = y  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayMetricDataResponseBodyNodes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.x is not None:
            result['X'] = self.x
        if self.y is not None:
            result['Y'] = self.y
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('X') is not None:
            self.x = m.get('X')
        if m.get('Y') is not None:
            self.y = m.get('Y')
        return self


class DescribePlayMetricDataResponseBody(TeaModel):
    def __init__(self, nodes=None, request_id=None):
        self.nodes = nodes  # type: list[DescribePlayMetricDataResponseBodyNodes]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.nodes:
            for k in self.nodes:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePlayMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Nodes'] = []
        if self.nodes is not None:
            for k in self.nodes:
                result['Nodes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nodes = []
        if m.get('Nodes') is not None:
            for k in m.get('Nodes'):
                temp_model = DescribePlayMetricDataResponseBodyNodes()
                self.nodes.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePlayMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePlayMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePlayMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayQoeListRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, definition=None, end_ts=None, item_configs=None,
                 metric_type=None, network=None, os=None, page_no=None, page_size=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: long
        self.definition = definition  # type: str
        self.end_ts = end_ts  # type: long
        self.item_configs = item_configs  # type: str
        self.metric_type = metric_type  # type: str
        self.network = network  # type: str
        self.os = os  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayQoeListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.network is not None:
            result['Network'] = self.network
        if self.os is not None:
            result['Os'] = self.os
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribePlayQoeListResponseBodyQoeInfoList(TeaModel):
    def __init__(self, qoe_finished_vv=None, qoe_finished_vvrate=None, qoe_ufinished_vvtime=None, qoe_uv=None,
                 qoe_uvvduration=None, qoe_uvvtime=None, qoe_vduration=None, qoe_vvduration=None, vpsid=None):
        self.qoe_finished_vv = qoe_finished_vv  # type: float
        self.qoe_finished_vvrate = qoe_finished_vvrate  # type: float
        self.qoe_ufinished_vvtime = qoe_ufinished_vvtime  # type: float
        self.qoe_uv = qoe_uv  # type: float
        self.qoe_uvvduration = qoe_uvvduration  # type: float
        self.qoe_uvvtime = qoe_uvvtime  # type: float
        self.qoe_vduration = qoe_vduration  # type: float
        self.qoe_vvduration = qoe_vvduration  # type: float
        self.vpsid = vpsid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayQoeListResponseBodyQoeInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.qoe_finished_vv is not None:
            result['QoeFinishedVV'] = self.qoe_finished_vv
        if self.qoe_finished_vvrate is not None:
            result['QoeFinishedVVRate'] = self.qoe_finished_vvrate
        if self.qoe_ufinished_vvtime is not None:
            result['QoeUFinishedVVTime'] = self.qoe_ufinished_vvtime
        if self.qoe_uv is not None:
            result['QoeUV'] = self.qoe_uv
        if self.qoe_uvvduration is not None:
            result['QoeUVVDuration'] = self.qoe_uvvduration
        if self.qoe_uvvtime is not None:
            result['QoeUVVTime'] = self.qoe_uvvtime
        if self.qoe_vduration is not None:
            result['QoeVDuration'] = self.qoe_vduration
        if self.qoe_vvduration is not None:
            result['QoeVVDuration'] = self.qoe_vvduration
        if self.vpsid is not None:
            result['Vpsid'] = self.vpsid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QoeFinishedVV') is not None:
            self.qoe_finished_vv = m.get('QoeFinishedVV')
        if m.get('QoeFinishedVVRate') is not None:
            self.qoe_finished_vvrate = m.get('QoeFinishedVVRate')
        if m.get('QoeUFinishedVVTime') is not None:
            self.qoe_ufinished_vvtime = m.get('QoeUFinishedVVTime')
        if m.get('QoeUV') is not None:
            self.qoe_uv = m.get('QoeUV')
        if m.get('QoeUVVDuration') is not None:
            self.qoe_uvvduration = m.get('QoeUVVDuration')
        if m.get('QoeUVVTime') is not None:
            self.qoe_uvvtime = m.get('QoeUVVTime')
        if m.get('QoeVDuration') is not None:
            self.qoe_vduration = m.get('QoeVDuration')
        if m.get('QoeVVDuration') is not None:
            self.qoe_vvduration = m.get('QoeVVDuration')
        if m.get('Vpsid') is not None:
            self.vpsid = m.get('Vpsid')
        return self


class DescribePlayQoeListResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, qoe_info_list=None, request_id=None, total_count=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.qoe_info_list = qoe_info_list  # type: list[DescribePlayQoeListResponseBodyQoeInfoList]
        # Id
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        if self.qoe_info_list:
            for k in self.qoe_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePlayQoeListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['QoeInfoList'] = []
        if self.qoe_info_list is not None:
            for k in self.qoe_info_list:
                result['QoeInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.qoe_info_list = []
        if m.get('QoeInfoList') is not None:
            for k in m.get('QoeInfoList'):
                temp_model = DescribePlayQoeListResponseBodyQoeInfoList()
                self.qoe_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePlayQoeListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePlayQoeListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePlayQoeListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayQoeListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePlayQosListRequest(TeaModel):
    def __init__(self, app_name=None, begin_ts=None, definition=None, end_ts=None, item_configs=None,
                 metric_type=None, network=None, os=None, page_no=None, page_size=None, terminal_type=None):
        self.app_name = app_name  # type: str
        self.begin_ts = begin_ts  # type: str
        self.definition = definition  # type: str
        self.end_ts = end_ts  # type: str
        self.item_configs = item_configs  # type: str
        self.metric_type = metric_type  # type: str
        self.network = network  # type: str
        self.os = os  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.terminal_type = terminal_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayQosListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.begin_ts is not None:
            result['BeginTs'] = self.begin_ts
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.end_ts is not None:
            result['EndTs'] = self.end_ts
        if self.item_configs is not None:
            result['ItemConfigs'] = self.item_configs
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.network is not None:
            result['Network'] = self.network
        if self.os is not None:
            result['Os'] = self.os
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.terminal_type is not None:
            result['TerminalType'] = self.terminal_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('BeginTs') is not None:
            self.begin_ts = m.get('BeginTs')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('EndTs') is not None:
            self.end_ts = m.get('EndTs')
        if m.get('ItemConfigs') is not None:
            self.item_configs = m.get('ItemConfigs')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Network') is not None:
            self.network = m.get('Network')
        if m.get('Os') is not None:
            self.os = m.get('Os')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TerminalType') is not None:
            self.terminal_type = m.get('TerminalType')
        return self


class DescribePlayQosListResponseBodyQosInfoList(TeaModel):
    def __init__(self, qos_first_frame=None, qos_kbps=None, qos_play=None, qos_play_fail=None, qos_real_play=None,
                 qos_seed_fail_rate=None, qos_stuck_rate=None, vpsid=None):
        self.qos_first_frame = qos_first_frame  # type: str
        self.qos_kbps = qos_kbps  # type: str
        self.qos_play = qos_play  # type: str
        self.qos_play_fail = qos_play_fail  # type: str
        self.qos_real_play = qos_real_play  # type: str
        self.qos_seed_fail_rate = qos_seed_fail_rate  # type: str
        self.qos_stuck_rate = qos_stuck_rate  # type: str
        self.vpsid = vpsid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePlayQosListResponseBodyQosInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.qos_first_frame is not None:
            result['QosFirstFrame'] = self.qos_first_frame
        if self.qos_kbps is not None:
            result['QosKbps'] = self.qos_kbps
        if self.qos_play is not None:
            result['QosPlay'] = self.qos_play
        if self.qos_play_fail is not None:
            result['QosPlayFail'] = self.qos_play_fail
        if self.qos_real_play is not None:
            result['QosRealPlay'] = self.qos_real_play
        if self.qos_seed_fail_rate is not None:
            result['QosSeedFailRate'] = self.qos_seed_fail_rate
        if self.qos_stuck_rate is not None:
            result['QosStuckRate'] = self.qos_stuck_rate
        if self.vpsid is not None:
            result['Vpsid'] = self.vpsid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QosFirstFrame') is not None:
            self.qos_first_frame = m.get('QosFirstFrame')
        if m.get('QosKbps') is not None:
            self.qos_kbps = m.get('QosKbps')
        if m.get('QosPlay') is not None:
            self.qos_play = m.get('QosPlay')
        if m.get('QosPlayFail') is not None:
            self.qos_play_fail = m.get('QosPlayFail')
        if m.get('QosRealPlay') is not None:
            self.qos_real_play = m.get('QosRealPlay')
        if m.get('QosSeedFailRate') is not None:
            self.qos_seed_fail_rate = m.get('QosSeedFailRate')
        if m.get('QosStuckRate') is not None:
            self.qos_stuck_rate = m.get('QosStuckRate')
        if m.get('Vpsid') is not None:
            self.vpsid = m.get('Vpsid')
        return self


class DescribePlayQosListResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, qos_info_list=None, request_id=None, total_count=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.qos_info_list = qos_info_list  # type: list[DescribePlayQosListResponseBodyQosInfoList]
        # Id
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        if self.qos_info_list:
            for k in self.qos_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePlayQosListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['QosInfoList'] = []
        if self.qos_info_list is not None:
            for k in self.qos_info_list:
                result['QosInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.qos_info_list = []
        if m.get('QosInfoList') is not None:
            for k in m.get('QosInfoList'):
                temp_model = DescribePlayQosListResponseBodyQosInfoList()
                self.qos_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePlayQosListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePlayQosListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePlayQosListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePlayQosListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeQueryConfigsRequest(TeaModel):
    def __init__(self, type=None):
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeQueryConfigsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeQueryConfigsResponseBodyConfigs(TeaModel):
    def __init__(self, value=None):
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeQueryConfigsResponseBodyConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeQueryConfigsResponseBody(TeaModel):
    def __init__(self, configs=None, request_id=None):
        self.configs = configs  # type: list[DescribeQueryConfigsResponseBodyConfigs]
        # Id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.configs:
            for k in self.configs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeQueryConfigsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Configs'] = []
        if self.configs is not None:
            for k in self.configs:
                result['Configs'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.configs = []
        if m.get('Configs') is not None:
            for k in m.get('Configs'):
                temp_model = DescribeQueryConfigsResponseBodyConfigs()
                self.configs.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeQueryConfigsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeQueryConfigsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeQueryConfigsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeQueryConfigsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DownloadResourceByResourceIdsRequest(TeaModel):
    def __init__(self, resource_ids=None):
        # 资源id号
        self.resource_ids = resource_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DownloadResourceByResourceIdsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        return self


class DownloadResourceByResourceIdsResponseBody(TeaModel):
    def __init__(self, expire_time=None, request_id=None, resource_package_url=None):
        # 过期时间
        self.expire_time = expire_time  # type: long
        # 请求Id
        self.request_id = request_id  # type: str
        # 资源地址
        self.resource_package_url = resource_package_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DownloadResourceByResourceIdsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_package_url is not None:
            result['ResourcePackageUrl'] = self.resource_package_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourcePackageUrl') is not None:
            self.resource_package_url = m.get('ResourcePackageUrl')
        return self


class DownloadResourceByResourceIdsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DownloadResourceByResourceIdsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DownloadResourceByResourceIdsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DownloadResourceByResourceIdsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetAuditConfigRequest(TeaModel):
    def __init__(self, app_id=None):
        self.app_id = app_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuditConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        return self


class GetAuditConfigResponseBodyAudit(TeaModel):
    def __init__(self, channel=None, create_time=None, legal_switch=None, update_time=None, user_id=None):
        self.channel = channel  # type: str
        self.create_time = create_time  # type: str
        self.legal_switch = legal_switch  # type: str
        self.update_time = update_time  # type: str
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetAuditConfigResponseBodyAudit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.legal_switch is not None:
            result['LegalSwitch'] = self.legal_switch
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channel') is not None:
            self.channel = m.get('Channel')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LegalSwitch') is not None:
            self.legal_switch = m.get('LegalSwitch')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetAuditConfigResponseBody(TeaModel):
    def __init__(self, audit=None, request_id=None):
        self.audit = audit  # type: GetAuditConfigResponseBodyAudit
        self.request_id = request_id  # type: str

    def validate(self):
        if self.audit:
            self.audit.validate()

    def to_map(self):
        _map = super(GetAuditConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audit is not None:
            result['Audit'] = self.audit.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audit') is not None:
            temp_model = GetAuditConfigResponseBodyAudit()
            self.audit = temp_model.from_map(m['Audit'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetAuditConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetAuditConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetAuditConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCategoriesRequest(TeaModel):
    def __init__(self, cate_id=None, page_no=None, page_size=None, sort_by=None, type=None):
        self.cate_id = cate_id  # type: long
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.sort_by = sort_by  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCategoriesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodyCategory(TeaModel):
    def __init__(self, cate_id=None, cate_name=None, level=None, parent_id=None, type=None):
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str
        self.level = level  # type: long
        self.parent_id = parent_id  # type: long
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCategoriesResponseBodyCategory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodySubCategoriesCategory(TeaModel):
    def __init__(self, cate_id=None, cate_name=None, level=None, parent_id=None, sub_total=None, type=None):
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str
        self.level = level  # type: long
        self.parent_id = parent_id  # type: long
        self.sub_total = sub_total  # type: long
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCategoriesResponseBodySubCategoriesCategory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.level is not None:
            result['Level'] = self.level
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.sub_total is not None:
            result['SubTotal'] = self.sub_total
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('SubTotal') is not None:
            self.sub_total = m.get('SubTotal')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCategoriesResponseBodySubCategories(TeaModel):
    def __init__(self, category=None):
        self.category = category  # type: list[GetCategoriesResponseBodySubCategoriesCategory]

    def validate(self):
        if self.category:
            for k in self.category:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetCategoriesResponseBodySubCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Category'] = []
        if self.category is not None:
            for k in self.category:
                result['Category'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.category = []
        if m.get('Category') is not None:
            for k in m.get('Category'):
                temp_model = GetCategoriesResponseBodySubCategoriesCategory()
                self.category.append(temp_model.from_map(k))
        return self


class GetCategoriesResponseBody(TeaModel):
    def __init__(self, category=None, request_id=None, sub_categories=None, sub_total=None):
        self.category = category  # type: GetCategoriesResponseBodyCategory
        self.request_id = request_id  # type: str
        self.sub_categories = sub_categories  # type: GetCategoriesResponseBodySubCategories
        self.sub_total = sub_total  # type: long

    def validate(self):
        if self.category:
            self.category.validate()
        if self.sub_categories:
            self.sub_categories.validate()

    def to_map(self):
        _map = super(GetCategoriesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sub_categories is not None:
            result['SubCategories'] = self.sub_categories.to_map()
        if self.sub_total is not None:
            result['SubTotal'] = self.sub_total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            temp_model = GetCategoriesResponseBodyCategory()
            self.category = temp_model.from_map(m['Category'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SubCategories') is not None:
            temp_model = GetCategoriesResponseBodySubCategories()
            self.sub_categories = temp_model.from_map(m['SubCategories'])
        if m.get('SubTotal') is not None:
            self.sub_total = m.get('SubTotal')
        return self


class GetCategoriesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCategoriesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCategoriesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCategoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetClientConfigRequest(TeaModel):
    def __init__(self, bundle_id=None, pkg_name=None, pkg_signature=None):
        # 云端配置所对应的IOS BundleId
        self.bundle_id = bundle_id  # type: str
        # 云端配置所对应的包名。
        self.pkg_name = pkg_name  # type: str
        # 云端配置所对应的包签名
        self.pkg_signature = pkg_signature  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClientConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.pkg_name is not None:
            result['PkgName'] = self.pkg_name
        if self.pkg_signature is not None:
            result['PkgSignature'] = self.pkg_signature
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('PkgName') is not None:
            self.pkg_name = m.get('PkgName')
        if m.get('PkgSignature') is not None:
            self.pkg_signature = m.get('PkgSignature')
        return self


class GetClientConfigResponseBody(TeaModel):
    def __init__(self, client_upload_bucket=None, client_upload_path=None, client_upload_storage_status=None,
                 client_upload_storage_type=None, request_id=None):
        # oss bucket 名称
        self.client_upload_bucket = client_upload_bucket  # type: str
        # 路径
        self.client_upload_path = client_upload_path  # type: str
        # 状态
        self.client_upload_storage_status = client_upload_storage_status  # type: str
        # 存储类型
        self.client_upload_storage_type = client_upload_storage_type  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetClientConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_upload_bucket is not None:
            result['ClientUploadBucket'] = self.client_upload_bucket
        if self.client_upload_path is not None:
            result['ClientUploadPath'] = self.client_upload_path
        if self.client_upload_storage_status is not None:
            result['ClientUploadStorageStatus'] = self.client_upload_storage_status
        if self.client_upload_storage_type is not None:
            result['ClientUploadStorageType'] = self.client_upload_storage_type
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientUploadBucket') is not None:
            self.client_upload_bucket = m.get('ClientUploadBucket')
        if m.get('ClientUploadPath') is not None:
            self.client_upload_path = m.get('ClientUploadPath')
        if m.get('ClientUploadStorageStatus') is not None:
            self.client_upload_storage_status = m.get('ClientUploadStorageStatus')
        if m.get('ClientUploadStorageType') is not None:
            self.client_upload_storage_type = m.get('ClientUploadStorageType')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetClientConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetClientConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetClientConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetClientConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetCustomTemplateRequest(TeaModel):
    def __init__(self, subtype=None, template_id=None, type=None):
        self.subtype = subtype  # type: int
        # 模板ID
        self.template_id = template_id  # type: str
        self.type = type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCustomTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetCustomTemplateResponseBodyCustomTemplate(TeaModel):
    def __init__(self, create_time=None, is_default=None, modified_time=None, status=None, subtype=None,
                 subtype_name=None, template_config=None, template_id=None, template_name=None, type=None, type_name=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 是否默认模板
        self.is_default = is_default  # type: bool
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板子类型ID
        self.subtype = subtype  # type: int
        # 模板子类型名称
        self.subtype_name = subtype_name  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板名称
        self.template_name = template_name  # type: str
        # 模板类型ID
        self.type = type  # type: int
        # 模板类型名称
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetCustomTemplateResponseBodyCustomTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetCustomTemplateResponseBody(TeaModel):
    def __init__(self, custom_template=None, request_id=None):
        # 模板信息
        self.custom_template = custom_template  # type: GetCustomTemplateResponseBodyCustomTemplate
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.custom_template:
            self.custom_template.validate()

    def to_map(self):
        _map = super(GetCustomTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_template is not None:
            result['CustomTemplate'] = self.custom_template.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomTemplate') is not None:
            temp_model = GetCustomTemplateResponseBodyCustomTemplate()
            self.custom_template = temp_model.from_map(m['CustomTemplate'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetCustomTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetCustomTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetCustomTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDefaultStorageLocationResponseBody(TeaModel):
    def __init__(self, bucket=None, path=None, request_id=None, status=None, storage_type=None):
        # oss bucket 名称
        self.bucket = bucket  # type: str
        # 路径
        self.path = path  # type: str
        # Id of the request
        self.request_id = request_id  # type: str
        # 状态
        self.status = status  # type: str
        # 存储类型
        self.storage_type = storage_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDefaultStorageLocationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.path is not None:
            result['Path'] = self.path
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class GetDefaultStorageLocationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDefaultStorageLocationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDefaultStorageLocationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDefaultStorageLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDynamicImageJobRequest(TeaModel):
    def __init__(self, job_id=None):
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDynamicImageJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobInput(TeaModel):
    def __init__(self, media=None, oss_file=None, type=None):
        self.media = media  # type: str
        # 输入类型为媒资ID时的OSS地址
        self.oss_file = oss_file  # type: GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile
        self.type = type  # type: str

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBodyDynamicImageJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobInputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJobOutput(TeaModel):
    def __init__(self, media=None, oss_file=None, type=None):
        self.media = media  # type: str
        # 输出类型为媒资ID时的OSS地址
        self.oss_file = oss_file  # type: GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile
        self.type = type  # type: str

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBodyDynamicImageJobOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobOutputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDynamicImageJobResponseBodyDynamicImageJob(TeaModel):
    def __init__(self, code=None, create_time=None, finish_time=None, input=None, job_id=None, message=None,
                 modified_time=None, name=None, output=None, output_url=None, pipeline_id=None, status=None, submit_time=None,
                 template_config=None, template_id=None, trigger_source=None, user_data=None):
        self.code = code  # type: str
        self.create_time = create_time  # type: str
        self.finish_time = finish_time  # type: str
        self.input = input  # type: GetDynamicImageJobResponseBodyDynamicImageJobInput
        self.job_id = job_id  # type: str
        self.message = message  # type: str
        self.modified_time = modified_time  # type: str
        self.name = name  # type: str
        self.output = output  # type: GetDynamicImageJobResponseBodyDynamicImageJobOutput
        self.output_url = output_url  # type: str
        self.pipeline_id = pipeline_id  # type: str
        self.status = status  # type: str
        self.submit_time = submit_time  # type: str
        self.template_config = template_config  # type: str
        self.template_id = template_id  # type: str
        self.trigger_source = trigger_source  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBodyDynamicImageJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetDynamicImageJobResponseBody(TeaModel):
    def __init__(self, dynamic_image_job=None, request_id=None):
        # 截图任务信息
        self.dynamic_image_job = dynamic_image_job  # type: GetDynamicImageJobResponseBodyDynamicImageJob
        self.request_id = request_id  # type: str

    def validate(self):
        if self.dynamic_image_job:
            self.dynamic_image_job.validate()

    def to_map(self):
        _map = super(GetDynamicImageJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_image_job is not None:
            result['DynamicImageJob'] = self.dynamic_image_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicImageJob') is not None:
            temp_model = GetDynamicImageJobResponseBodyDynamicImageJob()
            self.dynamic_image_job = temp_model.from_map(m['DynamicImageJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDynamicImageJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDynamicImageJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDynamicImageJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDynamicImageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEditingProjectRequest(TeaModel):
    def __init__(self, project_id=None):
        # 云剪辑工程ID
        self.project_id = project_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetEditingProjectResponseBodyProject(TeaModel):
    def __init__(self, business_config=None, business_status=None, clips_param=None, cover_url=None,
                 create_source=None, create_time=None, description=None, duration=None, modified_source=None, modified_time=None,
                 project_id=None, project_type=None, status=None, template_id=None, template_type=None, timeline=None,
                 title=None):
        self.business_config = business_config  # type: str
        self.business_status = business_status  # type: str
        # 模板素材参数
        self.clips_param = clips_param  # type: str
        # 云剪辑工程封面
        self.cover_url = cover_url  # type: str
        # 云剪辑工程创建来源
        self.create_source = create_source  # type: str
        # 云剪辑工程创建时间
        self.create_time = create_time  # type: str
        # 云剪辑工程描述
        self.description = description  # type: str
        # 云剪辑工程总时长
        self.duration = duration  # type: long
        # 云剪辑工程修改来源
        self.modified_source = modified_source  # type: str
        # 云剪辑工程最新修改时间
        self.modified_time = modified_time  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str
        self.project_type = project_type  # type: str
        # 云剪辑工程状态
        self.status = status  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 云剪辑工程模板类型
        self.template_type = template_type  # type: str
        # 云剪辑工程时间线
        self.timeline = timeline  # type: str
        # 云剪辑工程标题
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectResponseBodyProject, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetEditingProjectResponseBody(TeaModel):
    def __init__(self, project=None, request_id=None):
        self.project = project  # type: GetEditingProjectResponseBodyProject
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.project:
            self.project.validate()

    def to_map(self):
        _map = super(GetEditingProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project is not None:
            result['Project'] = self.project.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Project') is not None:
            temp_model = GetEditingProjectResponseBodyProject()
            self.project = temp_model.from_map(m['Project'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEditingProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetEditingProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetEditingProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEditingProjectMaterialsRequest(TeaModel):
    def __init__(self, project_id=None):
        # 云剪辑工程ID
        self.project_id = project_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectMaterialsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        return self


class GetEditingProjectMaterialsResponseBodyLiveMaterials(TeaModel):
    def __init__(self, app_name=None, domain_name=None, live_url=None, stream_name=None):
        self.app_name = app_name  # type: str
        self.domain_name = domain_name  # type: str
        self.live_url = live_url  # type: str
        self.stream_name = stream_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBodyLiveMaterials, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.live_url is not None:
            result['LiveUrl'] = self.live_url
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('LiveUrl') is not None:
            self.live_url = m.get('LiveUrl')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, region=None, width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, input_url=None, media_id=None, media_tags=None, media_type=None, modified_time=None,
                 snapshots=None, source=None, sprite_images=None, status=None, title=None, transcode_status=None,
                 user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetEditingProjectMaterialsResponseBodyMediaInfos(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBodyMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetEditingProjectMaterialsResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetEditingProjectMaterialsResponseBody(TeaModel):
    def __init__(self, live_materials=None, media_infos=None, project_id=None, project_materials=None,
                 request_id=None):
        self.live_materials = live_materials  # type: list[GetEditingProjectMaterialsResponseBodyLiveMaterials]
        # 符合要求的媒资集合
        self.media_infos = media_infos  # type: list[GetEditingProjectMaterialsResponseBodyMediaInfos]
        self.project_id = project_id  # type: str
        self.project_materials = project_materials  # type: list[str]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.live_materials:
            for k in self.live_materials:
                if k:
                    k.validate()
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LiveMaterials'] = []
        if self.live_materials is not None:
            for k in self.live_materials:
                result['LiveMaterials'].append(k.to_map() if k else None)
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_materials is not None:
            result['ProjectMaterials'] = self.project_materials
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.live_materials = []
        if m.get('LiveMaterials') is not None:
            for k in m.get('LiveMaterials'):
                temp_model = GetEditingProjectMaterialsResponseBodyLiveMaterials()
                self.live_materials.append(temp_model.from_map(k))
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = GetEditingProjectMaterialsResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMaterials') is not None:
            self.project_materials = m.get('ProjectMaterials')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEditingProjectMaterialsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetEditingProjectMaterialsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetEditingProjectMaterialsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEditingProjectMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetEventCallbackResponseBody(TeaModel):
    def __init__(self, auth_key=None, auth_switch=None, callback_queue_name=None, callback_type=None,
                 callback_url=None, event_type_list=None, request_id=None):
        self.auth_key = auth_key  # type: str
        self.auth_switch = auth_switch  # type: str
        self.callback_queue_name = callback_queue_name  # type: str
        self.callback_type = callback_type  # type: str
        self.callback_url = callback_url  # type: str
        self.event_type_list = event_type_list  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetEventCallbackResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.auth_switch is not None:
            result['AuthSwitch'] = self.auth_switch
        if self.callback_queue_name is not None:
            result['CallbackQueueName'] = self.callback_queue_name
        if self.callback_type is not None:
            result['CallbackType'] = self.callback_type
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('AuthSwitch') is not None:
            self.auth_switch = m.get('AuthSwitch')
        if m.get('CallbackQueueName') is not None:
            self.callback_queue_name = m.get('CallbackQueueName')
        if m.get('CallbackType') is not None:
            self.callback_type = m.get('CallbackType')
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetEventCallbackResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetEventCallbackResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetEventCallbackResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetEventCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveEditingIndexFileRequest(TeaModel):
    def __init__(self, app_name=None, domain_name=None, project_id=None, stream_name=None):
        self.app_name = app_name  # type: str
        self.domain_name = domain_name  # type: str
        self.project_id = project_id  # type: str
        self.stream_name = stream_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingIndexFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetLiveEditingIndexFileResponseBody(TeaModel):
    def __init__(self, index_file=None, request_id=None):
        self.index_file = index_file  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingIndexFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index_file is not None:
            result['IndexFile'] = self.index_file
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IndexFile') is not None:
            self.index_file = m.get('IndexFile')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveEditingIndexFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLiveEditingIndexFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLiveEditingIndexFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveEditingIndexFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveEditingJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 直播剪辑JobId
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig(TeaModel):
    def __init__(self, app_name=None, domain_name=None, stream_name=None):
        # 播流所属应用名称
        self.app_name = app_name  # type: str
        # 播流所属域名
        self.domain_name = domain_name  # type: str
        # 播流所属流名
        self.stream_name = stream_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_name is not None:
            result['AppName'] = self.app_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.stream_name is not None:
            result['StreamName'] = self.stream_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppName') is not None:
            self.app_name = m.get('AppName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('StreamName') is not None:
            self.stream_name = m.get('StreamName')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig(TeaModel):
    def __init__(self, mode=None):
        # 剪辑模式，默认Accurate
        self.mode = mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mode is not None:
            result['Mode'] = self.mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Mode') is not None:
            self.mode = m.get('Mode')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig(TeaModel):
    def __init__(self, bitrate=None, file_name=None, height=None, media_url=None, storage_location=None,
                 vod_template_group_id=None, width=None):
        # 输出成品的码率，单位为Kbps。可以不填，默认值是多个素材的最高码率
        self.bitrate = bitrate  # type: long
        # 当 OutputMediaTarget 的目标为 vod-media 时，指定 fileName(包含文件后缀，不含路径）作为输出文件名
        self.file_name = file_name  # type: str
        # 输出成品的高。可以不填，默认值是多个素材的最大高
        self.height = height  # type: int
        # 输出成片的文件地址
        self.media_url = media_url  # type: str
        # 当 OutputMediaTarget 的目标为 vod-media 时， 指定 storage location 来存储媒资到 VOD; storage location 是 VOD 中的文件存储位置， 不包含 http:// 的前缀， 如:  outin-xxxxxx.oss-cn-shanghai.aliyuncs.com
        self.storage_location = storage_location  # type: str
        # 合成成片输出到vod，指定vod转码模板组。如不需要VOD转码，请填写 "VOD_NO_TRANSCODE".
        self.vod_template_group_id = vod_template_group_id  # type: str
        # 输出成品的宽。可以不填，默认值是多个素材的最大宽
        self.width = width  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.storage_location is not None:
            result['StorageLocation'] = self.storage_location
        if self.vod_template_group_id is not None:
            result['VodTemplateGroupId'] = self.vod_template_group_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('StorageLocation') is not None:
            self.storage_location = m.get('StorageLocation')
        if m.get('VodTemplateGroupId') is not None:
            self.vod_template_group_id = m.get('VodTemplateGroupId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetLiveEditingJobResponseBodyLiveEditingJob(TeaModel):
    def __init__(self, clips=None, code=None, complete_time=None, creation_time=None, job_id=None,
                 live_stream_config=None, media_id=None, media_produce_config=None, media_url=None, message=None, modified_time=None,
                 output_media_config=None, project_id=None, status=None, user_data=None):
        # 剪辑片段列表
        self.clips = clips  # type: str
        # 剪辑合成作业错误码  注：作业失败时关注该字段
        self.code = code  # type: str
        # 直播剪辑作业完成时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。
        self.complete_time = complete_time  # type: str
        # 直播剪辑作业创建时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。
        self.creation_time = creation_time  # type: str
        # 直播剪辑任务ID
        self.job_id = job_id  # type: str
        # 直播剪辑配置
        self.live_stream_config = live_stream_config  # type: GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig
        # 输出成品的资源Id
        self.media_id = media_id  # type: str
        # 直播剪辑合成配置
        self.media_produce_config = media_produce_config  # type: GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig
        # 输出成品的资源文件URL
        self.media_url = media_url  # type: str
        # 剪辑合成作业错误信息  注：作业失败时关注该字段
        self.message = message  # type: str
        # 直播剪辑作业修改时间，格式为utc时间。  格式为："2021-06-21T08:01:00Z"。
        self.modified_time = modified_time  # type: str
        # 输出成片的存储配置
        self.output_media_config = output_media_config  # type: GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig
        # 直播剪辑工程ID
        self.project_id = project_id  # type: str
        # 直播剪辑作业状态，取值可能为如下值：  -Init （初始状态）  -Queuing（排队中）  -Processing（处理中）  -Success（成功）  -Failed（失败）
        self.status = status  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.live_stream_config:
            self.live_stream_config.validate()
        if self.media_produce_config:
            self.media_produce_config.validate()
        if self.output_media_config:
            self.output_media_config.validate()

    def to_map(self):
        _map = super(GetLiveEditingJobResponseBodyLiveEditingJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips
        if self.code is not None:
            result['Code'] = self.code
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.live_stream_config is not None:
            result['LiveStreamConfig'] = self.live_stream_config.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_produce_config is not None:
            result['MediaProduceConfig'] = self.media_produce_config.to_map()
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config.to_map()
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Clips') is not None:
            self.clips = m.get('Clips')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('LiveStreamConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobLiveStreamConfig()
            self.live_stream_config = temp_model.from_map(m['LiveStreamConfig'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaProduceConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobMediaProduceConfig()
            self.media_produce_config = temp_model.from_map(m['MediaProduceConfig'])
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputMediaConfig') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJobOutputMediaConfig()
            self.output_media_config = temp_model.from_map(m['OutputMediaConfig'])
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetLiveEditingJobResponseBody(TeaModel):
    def __init__(self, live_editing_job=None, request_id=None):
        # 直播剪辑任务
        self.live_editing_job = live_editing_job  # type: GetLiveEditingJobResponseBodyLiveEditingJob
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.live_editing_job:
            self.live_editing_job.validate()

    def to_map(self):
        _map = super(GetLiveEditingJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.live_editing_job is not None:
            result['LiveEditingJob'] = self.live_editing_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LiveEditingJob') is not None:
            temp_model = GetLiveEditingJobResponseBodyLiveEditingJob()
            self.live_editing_job = temp_model.from_map(m['LiveEditingJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveEditingJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLiveEditingJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLiveEditingJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveEditingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveTranscodeJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 模板Id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos(TeaModel):
    def __init__(self, output_url=None, type=None):
        self.output_url = output_url  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeJobResponseBodyJobOutputStream(TeaModel):
    def __init__(self, stream_infos=None):
        self.stream_infos = stream_infos  # type: list[GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos]

    def validate(self):
        if self.stream_infos:
            for k in self.stream_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponseBodyJobOutputStream, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfos'] = []
        if self.stream_infos is not None:
            for k in self.stream_infos:
                result['StreamInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.stream_infos = []
        if m.get('StreamInfos') is not None:
            for k in m.get('StreamInfos'):
                temp_model = GetLiveTranscodeJobResponseBodyJobOutputStreamStreamInfos()
                self.stream_infos.append(temp_model.from_map(k))
        return self


class GetLiveTranscodeJobResponseBodyJobStreamInput(TeaModel):
    def __init__(self, input_url=None, type=None):
        self.input_url = input_url  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponseBodyJobStreamInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeJobResponseBodyJob(TeaModel):
    def __init__(self, create_time=None, job_id=None, name=None, output_stream=None, start_mode=None, status=None,
                 stream_input=None, template_id=None, template_name=None, template_type=None):
        self.create_time = create_time  # type: str
        self.job_id = job_id  # type: str
        self.name = name  # type: str
        self.output_stream = output_stream  # type: GetLiveTranscodeJobResponseBodyJobOutputStream
        self.start_mode = start_mode  # type: int
        self.status = status  # type: int
        self.stream_input = stream_input  # type: GetLiveTranscodeJobResponseBodyJobStreamInput
        self.template_id = template_id  # type: str
        self.template_name = template_name  # type: str
        self.template_type = template_type  # type: str

    def validate(self):
        if self.output_stream:
            self.output_stream.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponseBodyJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output_stream is not None:
            result['OutputStream'] = self.output_stream.to_map()
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputStream') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJobOutputStream()
            self.output_stream = temp_model.from_map(m['OutputStream'])
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJobStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class GetLiveTranscodeJobResponseBody(TeaModel):
    def __init__(self, job=None, request_id=None):
        self.job = job  # type: GetLiveTranscodeJobResponseBodyJob
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.job:
            self.job.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job is not None:
            result['Job'] = self.job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Job') is not None:
            temp_model = GetLiveTranscodeJobResponseBodyJob()
            self.job = temp_model.from_map(m['Job'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetLiveTranscodeJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLiveTranscodeJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetLiveTranscodeTemplateRequest(TeaModel):
    def __init__(self, template_id=None):
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, samplerate=None):
        self.bitrate = bitrate  # type: str
        self.channels = channels  # type: str
        self.codec = codec  # type: str
        self.profile = profile  # type: str
        self.samplerate = samplerate  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams(TeaModel):
    def __init__(self, bitrate=None, codec=None, fps=None, gop=None, height=None, profile=None, width=None):
        self.bitrate = bitrate  # type: str
        self.codec = codec  # type: str
        self.fps = fps  # type: str
        self.gop = gop  # type: str
        self.height = height  # type: str
        self.profile = profile  # type: str
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig(TeaModel):
    def __init__(self, audio_params=None, video_params=None):
        self.audio_params = audio_params  # type: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams
        self.video_params = video_params  # type: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class GetLiveTranscodeTemplateResponseBodyTemplateContent(TeaModel):
    def __init__(self, category=None, create_time=None, name=None, template_config=None, template_id=None, type=None):
        self.category = category  # type: str
        self.create_time = create_time  # type: str
        self.name = name  # type: str
        self.template_config = template_config  # type: GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig
        self.template_id = template_id  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponseBodyTemplateContent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContentTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, template_content=None):
        # 请求ID
        self.request_id = request_id  # type: str
        self.template_content = template_content  # type: GetLiveTranscodeTemplateResponseBodyTemplateContent

    def validate(self):
        if self.template_content:
            self.template_content.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template_content is not None:
            result['TemplateContent'] = self.template_content.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TemplateContent') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBodyTemplateContent()
            self.template_content = temp_model.from_map(m['TemplateContent'])
        return self


class GetLiveTranscodeTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetLiveTranscodeTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetLiveTranscodeTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaAuditResultRequest(TeaModel):
    def __init__(self, app_id=None, media_id=None):
        self.app_id = app_id  # type: str
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetMediaAuditResultResponseBodyAudioResult(TeaModel):
    def __init__(self, label=None, scene=None, score=None, suggestion=None):
        self.label = label  # type: str
        self.scene = scene  # type: str
        self.score = score  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyAudioResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBodyCoverResult(TeaModel):
    def __init__(self, label=None, scene=None, score=None, suggestion=None):
        self.label = label  # type: str
        self.scene = scene  # type: str
        self.score = score  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyCoverResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBodyDescResult(TeaModel):
    def __init__(self, label=None, scene=None, score=None, suggestion=None):
        self.label = label  # type: str
        self.scene = scene  # type: str
        self.score = score  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyDescResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBodyMediaAuditResult(TeaModel):
    def __init__(self, abnormal_modules=None, label=None, suggestion=None):
        self.abnormal_modules = abnormal_modules  # type: str
        self.label = label  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyMediaAuditResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abnormal_modules is not None:
            result['AbnormalModules'] = self.abnormal_modules
        if self.label is not None:
            result['Label'] = self.label
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbnormalModules') is not None:
            self.abnormal_modules = m.get('AbnormalModules')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBodyTitleResult(TeaModel):
    def __init__(self, label=None, scene=None, score=None, suggestion=None):
        self.label = label  # type: str
        self.scene = scene  # type: str
        self.score = score  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyTitleResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBodyVideoResult(TeaModel):
    def __init__(self, label=None, scene=None, score=None, suggestion=None):
        self.label = label  # type: str
        self.scene = scene  # type: str
        self.score = score  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBodyVideoResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.score is not None:
            result['Score'] = self.score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class GetMediaAuditResultResponseBody(TeaModel):
    def __init__(self, audio_result=None, cover_result=None, desc_result=None, media_audit_result=None,
                 request_id=None, title_result=None, video_result=None):
        self.audio_result = audio_result  # type: GetMediaAuditResultResponseBodyAudioResult
        self.cover_result = cover_result  # type: GetMediaAuditResultResponseBodyCoverResult
        self.desc_result = desc_result  # type: GetMediaAuditResultResponseBodyDescResult
        self.media_audit_result = media_audit_result  # type: GetMediaAuditResultResponseBodyMediaAuditResult
        # RequestId
        self.request_id = request_id  # type: str
        self.title_result = title_result  # type: GetMediaAuditResultResponseBodyTitleResult
        self.video_result = video_result  # type: GetMediaAuditResultResponseBodyVideoResult

    def validate(self):
        if self.audio_result:
            self.audio_result.validate()
        if self.cover_result:
            self.cover_result.validate()
        if self.desc_result:
            self.desc_result.validate()
        if self.media_audit_result:
            self.media_audit_result.validate()
        if self.title_result:
            self.title_result.validate()
        if self.video_result:
            self.video_result.validate()

    def to_map(self):
        _map = super(GetMediaAuditResultResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_result is not None:
            result['AudioResult'] = self.audio_result.to_map()
        if self.cover_result is not None:
            result['CoverResult'] = self.cover_result.to_map()
        if self.desc_result is not None:
            result['DescResult'] = self.desc_result.to_map()
        if self.media_audit_result is not None:
            result['MediaAuditResult'] = self.media_audit_result.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.title_result is not None:
            result['TitleResult'] = self.title_result.to_map()
        if self.video_result is not None:
            result['VideoResult'] = self.video_result.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AudioResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyAudioResult()
            self.audio_result = temp_model.from_map(m['AudioResult'])
        if m.get('CoverResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyCoverResult()
            self.cover_result = temp_model.from_map(m['CoverResult'])
        if m.get('DescResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyDescResult()
            self.desc_result = temp_model.from_map(m['DescResult'])
        if m.get('MediaAuditResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyMediaAuditResult()
            self.media_audit_result = temp_model.from_map(m['MediaAuditResult'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TitleResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyTitleResult()
            self.title_result = temp_model.from_map(m['TitleResult'])
        if m.get('VideoResult') is not None:
            temp_model = GetMediaAuditResultResponseBodyVideoResult()
            self.video_result = temp_model.from_map(m['VideoResult'])
        return self


class GetMediaAuditResultResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMediaAuditResultResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMediaAuditResultResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaAuditResultResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaAuditResultDetailRequest(TeaModel):
    def __init__(self, app_id=None, media_id=None):
        self.app_id = app_id  # type: str
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetMediaAuditResultDetailResponseBodyAuditResultDetails(TeaModel):
    def __init__(self, ad_label=None, ad_score=None, live_label=None, live_score=None, logo_label=None,
                 logo_score=None, porn_label=None, porn_score=None, terrorism_label=None, terrorism_score=None, timestamp=None,
                 url=None):
        self.ad_label = ad_label  # type: str
        self.ad_score = ad_score  # type: str
        self.live_label = live_label  # type: str
        self.live_score = live_score  # type: str
        self.logo_label = logo_label  # type: str
        self.logo_score = logo_score  # type: str
        self.porn_label = porn_label  # type: str
        self.porn_score = porn_score  # type: str
        self.terrorism_label = terrorism_label  # type: str
        self.terrorism_score = terrorism_score  # type: str
        self.timestamp = timestamp  # type: str
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaAuditResultDetailResponseBodyAuditResultDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_label is not None:
            result['AdLabel'] = self.ad_label
        if self.ad_score is not None:
            result['AdScore'] = self.ad_score
        if self.live_label is not None:
            result['LiveLabel'] = self.live_label
        if self.live_score is not None:
            result['LiveScore'] = self.live_score
        if self.logo_label is not None:
            result['LogoLabel'] = self.logo_label
        if self.logo_score is not None:
            result['LogoScore'] = self.logo_score
        if self.porn_label is not None:
            result['PornLabel'] = self.porn_label
        if self.porn_score is not None:
            result['PornScore'] = self.porn_score
        if self.terrorism_label is not None:
            result['TerrorismLabel'] = self.terrorism_label
        if self.terrorism_score is not None:
            result['TerrorismScore'] = self.terrorism_score
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdLabel') is not None:
            self.ad_label = m.get('AdLabel')
        if m.get('AdScore') is not None:
            self.ad_score = m.get('AdScore')
        if m.get('LiveLabel') is not None:
            self.live_label = m.get('LiveLabel')
        if m.get('LiveScore') is not None:
            self.live_score = m.get('LiveScore')
        if m.get('LogoLabel') is not None:
            self.logo_label = m.get('LogoLabel')
        if m.get('LogoScore') is not None:
            self.logo_score = m.get('LogoScore')
        if m.get('PornLabel') is not None:
            self.porn_label = m.get('PornLabel')
        if m.get('PornScore') is not None:
            self.porn_score = m.get('PornScore')
        if m.get('TerrorismLabel') is not None:
            self.terrorism_label = m.get('TerrorismLabel')
        if m.get('TerrorismScore') is not None:
            self.terrorism_score = m.get('TerrorismScore')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class GetMediaAuditResultDetailResponseBody(TeaModel):
    def __init__(self, audit_result_details=None, request_id=None, total=None):
        self.audit_result_details = audit_result_details  # type: list[GetMediaAuditResultDetailResponseBodyAuditResultDetails]
        # RequestId
        self.request_id = request_id  # type: str
        self.total = total  # type: str

    def validate(self):
        if self.audit_result_details:
            for k in self.audit_result_details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetMediaAuditResultDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AuditResultDetails'] = []
        if self.audit_result_details is not None:
            for k in self.audit_result_details:
                result['AuditResultDetails'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audit_result_details = []
        if m.get('AuditResultDetails') is not None:
            for k in m.get('AuditResultDetails'):
                temp_model = GetMediaAuditResultDetailResponseBodyAuditResultDetails()
                self.audit_result_details.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class GetMediaAuditResultDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMediaAuditResultDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMediaAuditResultDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaAuditResultDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaInfoRequest(TeaModel):
    def __init__(self, input_url=None, media_id=None, output_type=None):
        self.input_url = input_url  # type: str
        self.media_id = media_id  # type: str
        self.output_type = output_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.output_type is not None:
            result['OutputType'] = self.output_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('OutputType') is not None:
            self.output_type = m.get('OutputType')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, fps=None, index=None, lang=None,
                 num_frames=None, profile=None, sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道输出样式
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 音频帧率
        self.fps = fps  # type: str
        # 音频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 编码预置
        self.profile = profile  # type: str
        # 采样格式
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, create_time=None, duration=None, file_name=None, file_size=None,
                 file_status=None, file_type=None, file_url=None, format_name=None, height=None, modified_time=None, region=None,
                 width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        self.create_time = create_time  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        self.modified_time = modified_time  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(TeaModel):
    def __init__(self, codec_long_name=None, codec_name=None, codec_tag=None, codec_tag_string=None,
                 codec_time_base=None, duration=None, index=None, lang=None, start_time=None, timebase=None):
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 音频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bitrate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, nb_frames=None, num_frames=None, pix_fmt=None, profile=None,
                 rotate=None, sar=None, start_time=None, timebase=None, width=None):
        # 平均帧率
        self.avg_fps = avg_fps  # type: str
        # 码率
        self.bitrate = bitrate  # type: str
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 编码显示分辨率比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 视频帧率
        self.fps = fps  # type: str
        # 是否有B帧
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 视频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.nb_frames = nb_frames  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 像素格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码预置
        self.profile = profile  # type: str
        # 旋转
        self.rotate = rotate  # type: str
        # 编码信号分辨率比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.nb_frames is not None:
            result['Nb_frames'] = self.nb_frames
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Nb_frames') is not None:
            self.nb_frames = m.get('Nb_frames')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoResponseBodyMediaInfoFileInfoList(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, subtitle_stream_info_list=None,
                 video_stream_info_list=None):
        # 音频流信息，一个媒资可能有多条音频流
        self.audio_stream_info_list = audio_stream_info_list  # type: list[GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList]
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo
        # 字幕流信息，一个媒资可能有多条字幕流
        self.subtitle_stream_info_list = subtitle_stream_info_list  # type: list[GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList]
        # 视频流信息，一个媒资可能有多条视频流
        self.video_stream_info_list = video_stream_info_list  # type: list[GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.subtitle_stream_info_list:
            for k in self.subtitle_stream_info_list:
                if k:
                    k.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['SubtitleStreamInfoList'] = []
        if self.subtitle_stream_info_list is not None:
            for k in self.subtitle_stream_info_list:
                result['SubtitleStreamInfoList'].append(k.to_map() if k else None)
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.subtitle_stream_info_list = []
        if m.get('SubtitleStreamInfoList') is not None:
            for k in m.get('SubtitleStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList()
                self.subtitle_stream_info_list.append(temp_model.from_map(k))
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetMediaInfoResponseBodyMediaInfoMediaBasicInfo(TeaModel):
    def __init__(self, biz=None, business_type=None, cate_id=None, cate_name=None, category=None, cover_url=None,
                 create_time=None, deleted_time=None, description=None, input_url=None, media_id=None, media_tags=None,
                 media_type=None, modified_time=None, source=None, sprite_images=None, status=None, title=None,
                 upload_source=None, user_data=None):
        self.biz = biz  # type: str
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        self.upload_source = upload_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfoMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetMediaInfoResponseBodyMediaInfo(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[GetMediaInfoResponseBodyMediaInfoFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: GetMediaInfoResponseBodyMediaInfoMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(GetMediaInfoResponseBodyMediaInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetMediaInfoResponseBodyMediaInfoFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetMediaInfoResponseBody(TeaModel):
    def __init__(self, media_info=None, request_id=None):
        self.media_info = media_info  # type: GetMediaInfoResponseBodyMediaInfo
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super(GetMediaInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaInfo') is not None:
            temp_model = GetMediaInfoResponseBodyMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMediaInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMediaInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaInfoJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 任务 id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(self, async=None, finish_time=None, input=None, job_id=None, media_info_property=None, name=None,
                 request_id=None, schedule_config=None, status=None, submit_result_json=None, submit_time=None,
                 trigger_source=None, user_data=None):
        # 是否异步处理
        self.async = async  # type: bool
        # 任务完成时间
        self.finish_time = finish_time  # type: str
        # 任务输入
        self.input = input  # type: GetMediaInfoJobResponseBodyMediaInfoJobInput
        # 任务 id
        self.job_id = job_id  # type: str
        # 媒体信息详情
        self.media_info_property = media_info_property  # type: GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty
        # 任务名字
        self.name = name  # type: str
        # 请求 id
        self.request_id = request_id  # type: str
        # 调度信息
        self.schedule_config = schedule_config  # type: GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig
        # 任务状态 - Init: 已提交, Success: 成功, Fail: 失败
        self.status = status  # type: str
        # 任务提交信息
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBodyMediaInfoJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetMediaInfoJobResponseBody(TeaModel):
    def __init__(self, media_info_job=None, request_id=None):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job  # type: GetMediaInfoJobResponseBodyMediaInfoJob
        # 请求 id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super(GetMediaInfoJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = GetMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaInfoJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMediaInfoJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMediaInfoJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetMediaProducingJobRequest(TeaModel):
    def __init__(self, job_id=None):
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaProducingJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetMediaProducingJobResponseBodyMediaProducingJob(TeaModel):
    def __init__(self, clips_param=None, code=None, complete_time=None, create_time=None, duration=None, job_id=None,
                 media_id=None, media_url=None, message=None, modified_time=None, project_id=None, status=None,
                 template_id=None, timeline=None, vod_media_id=None):
        self.clips_param = clips_param  # type: str
        self.code = code  # type: str
        self.complete_time = complete_time  # type: str
        self.create_time = create_time  # type: str
        self.duration = duration  # type: float
        self.job_id = job_id  # type: str
        self.media_id = media_id  # type: str
        self.media_url = media_url  # type: str
        self.message = message  # type: str
        self.modified_time = modified_time  # type: str
        self.project_id = project_id  # type: str
        self.status = status  # type: str
        self.template_id = template_id  # type: str
        self.timeline = timeline  # type: str
        self.vod_media_id = vod_media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetMediaProducingJobResponseBodyMediaProducingJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.code is not None:
            result['Code'] = self.code
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.vod_media_id is not None:
            result['VodMediaId'] = self.vod_media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('VodMediaId') is not None:
            self.vod_media_id = m.get('VodMediaId')
        return self


class GetMediaProducingJobResponseBody(TeaModel):
    def __init__(self, media_producing_job=None, request_id=None):
        self.media_producing_job = media_producing_job  # type: GetMediaProducingJobResponseBodyMediaProducingJob
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_producing_job:
            self.media_producing_job.validate()

    def to_map(self):
        _map = super(GetMediaProducingJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_producing_job is not None:
            result['MediaProducingJob'] = self.media_producing_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaProducingJob') is not None:
            temp_model = GetMediaProducingJobResponseBodyMediaProducingJob()
            self.media_producing_job = temp_model.from_map(m['MediaProducingJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetMediaProducingJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetMediaProducingJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetMediaProducingJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPipelineRequest(TeaModel):
    def __init__(self, pipeline_id=None):
        # 管道ID
        self.pipeline_id = pipeline_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class GetPipelineResponseBodyPipeline(TeaModel):
    def __init__(self, create_time=None, modified_time=None, name=None, pipeline_id=None, priority=None, speed=None,
                 status=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 管道名称
        self.name = name  # type: str
        # 管道Id
        self.pipeline_id = pipeline_id  # type: str
        # 管道优先级
        self.priority = priority  # type: int
        # 管道类型
        self.speed = speed  # type: str
        # 管道状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPipelineResponseBodyPipeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class GetPipelineResponseBody(TeaModel):
    def __init__(self, pipeline=None, request_id=None):
        # 管道信息
        self.pipeline = pipeline  # type: GetPipelineResponseBodyPipeline
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.pipeline:
            self.pipeline.validate()

    def to_map(self):
        _map = super(GetPipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline is not None:
            result['Pipeline'] = self.pipeline.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Pipeline') is not None:
            temp_model = GetPipelineResponseBodyPipeline()
            self.pipeline = temp_model.from_map(m['Pipeline'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPlayInfoRequest(TeaModel):
    def __init__(self, media_id=None):
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPlayInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPlayInfoResponseBodyMediaBase(TeaModel):
    def __init__(self, cover_url=None, creation_time=None, media_id=None, media_type=None, status=None, title=None):
        self.cover_url = cover_url  # type: str
        self.creation_time = creation_time  # type: str
        self.media_id = media_id  # type: str
        self.media_type = media_type  # type: str
        self.status = status  # type: str
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPlayInfoResponseBodyMediaBase, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class GetPlayInfoResponseBodyPlayInfoList(TeaModel):
    def __init__(self, bit_depth=None, bitrate=None, creation_time=None, definition=None, duration=None,
                 encrypt=None, encrypt_type=None, file_url=None, format=None, fps=None, hdrtype=None, height=None,
                 modification_time=None, narrow_band_type=None, play_url=None, size=None, status=None, stream_type=None,
                 trans_template_type=None, watermark_id=None, width=None):
        # 颜色位深
        self.bit_depth = bit_depth  # type: int
        self.bitrate = bitrate  # type: str
        self.creation_time = creation_time  # type: str
        self.definition = definition  # type: str
        self.duration = duration  # type: str
        self.encrypt = encrypt  # type: long
        self.encrypt_type = encrypt_type  # type: str
        self.file_url = file_url  # type: str
        self.format = format  # type: str
        self.fps = fps  # type: str
        # 视频流HDR类型
        self.hdrtype = hdrtype  # type: str
        self.height = height  # type: long
        self.modification_time = modification_time  # type: str
        self.narrow_band_type = narrow_band_type  # type: str
        self.play_url = play_url  # type: str
        self.size = size  # type: long
        self.status = status  # type: str
        self.stream_type = stream_type  # type: str
        self.trans_template_type = trans_template_type  # type: str
        self.watermark_id = watermark_id  # type: str
        self.width = width  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPlayInfoResponseBodyPlayInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bit_depth is not None:
            result['BitDepth'] = self.bit_depth
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.encrypt is not None:
            result['Encrypt'] = self.encrypt
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.height is not None:
            result['Height'] = self.height
        if self.modification_time is not None:
            result['ModificationTime'] = self.modification_time
        if self.narrow_band_type is not None:
            result['NarrowBandType'] = self.narrow_band_type
        if self.play_url is not None:
            result['PlayURL'] = self.play_url
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_type is not None:
            result['StreamType'] = self.stream_type
        if self.trans_template_type is not None:
            result['TransTemplateType'] = self.trans_template_type
        if self.watermark_id is not None:
            result['WatermarkId'] = self.watermark_id
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BitDepth') is not None:
            self.bit_depth = m.get('BitDepth')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Encrypt') is not None:
            self.encrypt = m.get('Encrypt')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModificationTime') is not None:
            self.modification_time = m.get('ModificationTime')
        if m.get('NarrowBandType') is not None:
            self.narrow_band_type = m.get('NarrowBandType')
        if m.get('PlayURL') is not None:
            self.play_url = m.get('PlayURL')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamType') is not None:
            self.stream_type = m.get('StreamType')
        if m.get('TransTemplateType') is not None:
            self.trans_template_type = m.get('TransTemplateType')
        if m.get('WatermarkId') is not None:
            self.watermark_id = m.get('WatermarkId')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPlayInfoResponseBody(TeaModel):
    def __init__(self, media_base=None, play_info_list=None, request_id=None):
        self.media_base = media_base  # type: GetPlayInfoResponseBodyMediaBase
        self.play_info_list = play_info_list  # type: list[GetPlayInfoResponseBodyPlayInfoList]
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_base:
            self.media_base.validate()
        if self.play_info_list:
            for k in self.play_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetPlayInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_base is not None:
            result['MediaBase'] = self.media_base.to_map()
        result['PlayInfoList'] = []
        if self.play_info_list is not None:
            for k in self.play_info_list:
                result['PlayInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaBase') is not None:
            temp_model = GetPlayInfoResponseBodyMediaBase()
            self.media_base = temp_model.from_map(m['MediaBase'])
        self.play_info_list = []
        if m.get('PlayInfoList') is not None:
            for k in m.get('PlayInfoList'):
                temp_model = GetPlayInfoResponseBodyPlayInfoList()
                self.play_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPlayInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPlayInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPlayInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPlayInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetPublicMediaInfoRequest(TeaModel):
    def __init__(self, media_id=None):
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData(TeaModel):
    def __init__(self, data=None, type=None):
        # 元数据json
        self.data = data  # type: str
        # 类型
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, fps=None, index=None, lang=None,
                 num_frames=None, profile=None, sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道输出样式
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 音频帧率
        self.fps = fps  # type: str
        # 音频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 编码预置
        self.profile = profile  # type: str
        # 采样格式
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, region=None, width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList(TeaModel):
    def __init__(self, codec_long_name=None, codec_name=None, codec_tag=None, codec_tag_string=None,
                 codec_time_base=None, duration=None, index=None, lang=None, start_time=None, timebase=None):
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 音频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bitrate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, nb_frames=None, num_frames=None, pix_fmt=None, profile=None,
                 rotate=None, sar=None, start_time=None, timebase=None, width=None):
        # 平均帧率
        self.avg_fps = avg_fps  # type: str
        # 码率
        self.bitrate = bitrate  # type: str
        # 编码格式长述名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式简述名
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码时基
        self.codec_time_base = codec_time_base  # type: str
        # 编码显示分辨率比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 视频帧率
        self.fps = fps  # type: str
        # 是否有B帧
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 视频流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.nb_frames = nb_frames  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 像素格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码预置
        self.profile = profile  # type: str
        # 旋转
        self.rotate = rotate  # type: str
        # 编码信号分辨率比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        # 时基
        self.timebase = timebase  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['AvgFPS'] = self.avg_fps
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['HasBFrames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.nb_frames is not None:
            result['Nb_frames'] = self.nb_frames
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvgFPS') is not None:
            self.avg_fps = m.get('AvgFPS')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('HasBFrames') is not None:
            self.has_bframes = m.get('HasBFrames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Nb_frames') is not None:
            self.nb_frames = m.get('Nb_frames')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetPublicMediaInfoResponseBodyMediaInfoFileInfoList(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, subtitle_stream_info_list=None,
                 video_stream_info_list=None):
        # 音频流信息，一个媒资可能有多条音频流
        self.audio_stream_info_list = audio_stream_info_list  # type: list[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList]
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo
        # 字幕流信息，一个媒资可能有多条字幕流
        self.subtitle_stream_info_list = subtitle_stream_info_list  # type: list[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList]
        # 视频流信息，一个媒资可能有多条视频流
        self.video_stream_info_list = video_stream_info_list  # type: list[GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.subtitle_stream_info_list:
            for k in self.subtitle_stream_info_list:
                if k:
                    k.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['SubtitleStreamInfoList'] = []
        if self.subtitle_stream_info_list is not None:
            for k in self.subtitle_stream_info_list:
                result['SubtitleStreamInfoList'].append(k.to_map() if k else None)
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.subtitle_stream_info_list = []
        if m.get('SubtitleStreamInfoList') is not None:
            for k in m.get('SubtitleStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListSubtitleStreamInfoList()
                self.subtitle_stream_info_list.append(temp_model.from_map(k))
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoListVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, media_id=None, media_tags=None, media_type=None, modified_time=None, source=None,
                 sprite_images=None, status=None, title=None, user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetPublicMediaInfoResponseBodyMediaInfo(TeaModel):
    def __init__(self, dynamic_meta_data=None, file_info_list=None, media_basic_info=None, media_id=None):
        # 公共媒资动态元数据
        self.dynamic_meta_data = dynamic_meta_data  # type: GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData
        # FileInfos
        self.file_info_list = file_info_list  # type: list[GetPublicMediaInfoResponseBodyMediaInfoFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.dynamic_meta_data:
            self.dynamic_meta_data.validate()
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBodyMediaInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_meta_data is not None:
            result['DynamicMetaData'] = self.dynamic_meta_data.to_map()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicMetaData') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoDynamicMetaData()
            self.dynamic_meta_data = temp_model.from_map(m['DynamicMetaData'])
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = GetPublicMediaInfoResponseBodyMediaInfoFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class GetPublicMediaInfoResponseBody(TeaModel):
    def __init__(self, media_info=None, request_id=None):
        self.media_info = media_info  # type: GetPublicMediaInfoResponseBodyMediaInfo
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super(GetPublicMediaInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaInfo') is not None:
            temp_model = GetPublicMediaInfoResponseBodyMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetPublicMediaInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetPublicMediaInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetPublicMediaInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetPublicMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSmartHandleJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 任务Id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSmartHandleJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetSmartHandleJobResponseBodySmartJobInfoInputConfig(TeaModel):
    def __init__(self, input_file=None):
        # OSS地址 或 内容库素材ID
        self.input_file = input_file  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSmartHandleJobResponseBodySmartJobInfoInputConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        return self


class GetSmartHandleJobResponseBodySmartJobInfoOutputConfig(TeaModel):
    def __init__(self, bucket=None, object=None):
        # OSS Bucket
        self.bucket = bucket  # type: str
        # OSS Object
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSmartHandleJobResponseBodySmartJobInfoOutputConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSmartHandleJobResponseBodySmartJobInfo(TeaModel):
    def __init__(self, create_time=None, description=None, input_config=None, job_type=None, modified_time=None,
                 output_config=None, title=None, user_id=None):
        # 创建时间
        self.create_time = create_time  # type: str
        # 任务描述
        self.description = description  # type: str
        # 输入参数
        self.input_config = input_config  # type: GetSmartHandleJobResponseBodySmartJobInfoInputConfig
        # 任务类型
        self.job_type = job_type  # type: str
        # 修改时间
        self.modified_time = modified_time  # type: str
        # 输出配置
        self.output_config = output_config  # type: GetSmartHandleJobResponseBodySmartJobInfoOutputConfig
        # 任务标题
        self.title = title  # type: str
        # userid
        self.user_id = user_id  # type: str

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.output_config:
            self.output_config.validate()

    def to_map(self):
        _map = super(GetSmartHandleJobResponseBodySmartJobInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputConfig') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfoInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfoOutputConfig()
            self.output_config = temp_model.from_map(m['OutputConfig'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class GetSmartHandleJobResponseBody(TeaModel):
    def __init__(self, job_id=None, output=None, request_id=None, smart_job_info=None, state=None, user_data=None):
        # 任务Id
        self.job_id = job_id  # type: str
        # 任务结果
        self.output = output  # type: str
        # 请求Id
        self.request_id = request_id  # type: str
        # 智能任务信息
        self.smart_job_info = smart_job_info  # type: GetSmartHandleJobResponseBodySmartJobInfo
        # 任务状态
        self.state = state  # type: str
        # 用户自定义信息
        self.user_data = user_data  # type: str

    def validate(self):
        if self.smart_job_info:
            self.smart_job_info.validate()

    def to_map(self):
        _map = super(GetSmartHandleJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.output is not None:
            result['Output'] = self.output
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.smart_job_info is not None:
            result['SmartJobInfo'] = self.smart_job_info.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SmartJobInfo') is not None:
            temp_model = GetSmartHandleJobResponseBodySmartJobInfo()
            self.smart_job_info = temp_model.from_map(m['SmartJobInfo'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetSmartHandleJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSmartHandleJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSmartHandleJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSmartHandleJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSnapshotJobRequest(TeaModel):
    def __init__(self, job_id=None):
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSnapshotJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetSnapshotJobResponseBodySnapshotJobInputOssFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSnapshotJobResponseBodySnapshotJobInputOssFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSnapshotJobResponseBodySnapshotJobInput(TeaModel):
    def __init__(self, media=None, oss_file=None, type=None):
        self.media = media  # type: str
        # 输入类型为媒资ID时的OSS地址
        self.oss_file = oss_file  # type: GetSnapshotJobResponseBodySnapshotJobInputOssFile
        self.type = type  # type: str

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super(GetSnapshotJobResponseBodySnapshotJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobInputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSnapshotJobResponseBodySnapshotJobOutputOssFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSnapshotJobResponseBodySnapshotJobOutputOssFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class GetSnapshotJobResponseBodySnapshotJobOutput(TeaModel):
    def __init__(self, media=None, oss_file=None, type=None):
        self.media = media  # type: str
        # 输出类型为媒资ID时的OSS地址
        self.oss_file = oss_file  # type: GetSnapshotJobResponseBodySnapshotJobOutputOssFile
        self.type = type  # type: str

    def validate(self):
        if self.oss_file:
            self.oss_file.validate()

    def to_map(self):
        _map = super(GetSnapshotJobResponseBodySnapshotJobOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.oss_file is not None:
            result['OssFile'] = self.oss_file.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('OssFile') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobOutputOssFile()
            self.oss_file = temp_model.from_map(m['OssFile'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetSnapshotJobResponseBodySnapshotJob(TeaModel):
    def __init__(self, async=None, code=None, count=None, create_time=None, finish_time=None, input=None, job_id=None,
                 message=None, modified_time=None, name=None, output=None, pipeline_id=None, status=None, submit_time=None,
                 template_config=None, template_id=None, trigger_source=None, type=None, user_data=None):
        self.async = async  # type: bool
        self.code = code  # type: str
        self.count = count  # type: int
        self.create_time = create_time  # type: str
        self.finish_time = finish_time  # type: str
        self.input = input  # type: GetSnapshotJobResponseBodySnapshotJobInput
        self.job_id = job_id  # type: str
        self.message = message  # type: str
        self.modified_time = modified_time  # type: str
        self.name = name  # type: str
        self.output = output  # type: GetSnapshotJobResponseBodySnapshotJobOutput
        self.pipeline_id = pipeline_id  # type: str
        self.status = status  # type: str
        self.submit_time = submit_time  # type: str
        self.template_config = template_config  # type: str
        self.template_id = template_id  # type: str
        self.trigger_source = trigger_source  # type: str
        self.type = type  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super(GetSnapshotJobResponseBodySnapshotJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.type is not None:
            result['Type'] = self.type
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJobOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetSnapshotJobResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_job=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 截图任务信息
        self.snapshot_job = snapshot_job  # type: GetSnapshotJobResponseBodySnapshotJob

    def validate(self):
        if self.snapshot_job:
            self.snapshot_job.validate()

    def to_map(self):
        _map = super(GetSnapshotJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_job is not None:
            result['SnapshotJob'] = self.snapshot_job.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotJob') is not None:
            temp_model = GetSnapshotJobResponseBodySnapshotJob()
            self.snapshot_job = temp_model.from_map(m['SnapshotJob'])
        return self


class GetSnapshotJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSnapshotJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSnapshotJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSnapshotUrlsRequest(TeaModel):
    def __init__(self, job_id=None, order_by=None, page_number=None, page_size=None, timeout=None):
        self.job_id = job_id  # type: str
        # 排列顺序。取值：Asc，Desc
        self.order_by = order_by  # type: str
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        # 鉴权超时时间
        self.timeout = timeout  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSnapshotUrlsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class GetSnapshotUrlsResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_urls=None, total=None, web_vtturl=None):
        self.request_id = request_id  # type: str
        # 截图URL
        self.snapshot_urls = snapshot_urls  # type: list[str]
        # 截图总数量
        self.total = total  # type: int
        # WebVTT文件URL
        self.web_vtturl = web_vtturl  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSnapshotUrlsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_urls is not None:
            result['SnapshotUrls'] = self.snapshot_urls
        if self.total is not None:
            result['Total'] = self.total
        if self.web_vtturl is not None:
            result['WebVTTUrl'] = self.web_vtturl
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotUrls') is not None:
            self.snapshot_urls = m.get('SnapshotUrls')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        if m.get('WebVTTUrl') is not None:
            self.web_vtturl = m.get('WebVTTUrl')
        return self


class GetSnapshotUrlsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSnapshotUrlsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSnapshotUrlsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSnapshotUrlsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSystemTemplateRequest(TeaModel):
    def __init__(self, template_id=None):
        # 模板ID
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSystemTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetSystemTemplateResponseBodySystemTemplate(TeaModel):
    def __init__(self, status=None, subtype=None, subtype_name=None, template_config=None, template_id=None,
                 template_name=None, type=None, type_name=None):
        # 模板状态
        self.status = status  # type: str
        # 模板子类型ID
        self.subtype = subtype  # type: int
        # 模板子类型名称
        self.subtype_name = subtype_name  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板名称
        self.template_name = template_name  # type: str
        # 模板类型ID
        self.type = type  # type: int
        # 模板类型名称
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSystemTemplateResponseBodySystemTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class GetSystemTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, system_template=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 模板信息
        self.system_template = system_template  # type: GetSystemTemplateResponseBodySystemTemplate

    def validate(self):
        if self.system_template:
            self.system_template.validate()

    def to_map(self):
        _map = super(GetSystemTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.system_template is not None:
            result['SystemTemplate'] = self.system_template.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SystemTemplate') is not None:
            temp_model = GetSystemTemplateResponseBodySystemTemplate()
            self.system_template = temp_model.from_map(m['SystemTemplate'])
        return self


class GetSystemTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSystemTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSystemTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSystemTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateRequest(TeaModel):
    def __init__(self, related_mediaid_flag=None, template_id=None):
        # 是否返回模板关联素材，1返回，默认0，不返回
        self.related_mediaid_flag = related_mediaid_flag  # type: str
        # 模板Id
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.related_mediaid_flag is not None:
            result['RelatedMediaidFlag'] = self.related_mediaid_flag
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RelatedMediaidFlag') is not None:
            self.related_mediaid_flag = m.get('RelatedMediaidFlag')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateResponseBodyTemplate(TeaModel):
    def __init__(self, clips_param=None, config=None, cover_url=None, create_source=None, creation_time=None,
                 modified_source=None, modified_time=None, name=None, preview_media=None, preview_media_status=None,
                 related_mediaids=None, status=None, template_id=None, type=None):
        # 提交合成任务的ClipsParam参数
        self.clips_param = clips_param  # type: str
        # 模板配置
        self.config = config  # type: str
        # 封面URL
        self.cover_url = cover_url  # type: str
        # 创建来源
        self.create_source = create_source  # type: str
        # 创建时间
        self.creation_time = creation_time  # type: str
        # 修改来源
        self.modified_source = modified_source  # type: str
        # 修改时间
        self.modified_time = modified_time  # type: str
        # 模板名称
        self.name = name  # type: str
        # 预览素材
        self.preview_media = preview_media  # type: str
        # 预览素材状态
        self.preview_media_status = preview_media_status  # type: str
        # 模板关联素材
        self.related_mediaids = related_mediaids  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板ID
        self.template_id = template_id  # type: str
        # 模板类型
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTemplateResponseBodyTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.preview_media_status is not None:
            result['PreviewMediaStatus'] = self.preview_media_status
        if self.related_mediaids is not None:
            result['RelatedMediaids'] = self.related_mediaids
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('PreviewMediaStatus') is not None:
            self.preview_media_status = m.get('PreviewMediaStatus')
        if m.get('RelatedMediaids') is not None:
            self.related_mediaids = m.get('RelatedMediaids')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, template=None):
        # Id of the request
        self.request_id = request_id  # type: str
        self.template = template  # type: GetTemplateResponseBodyTemplate

    def validate(self):
        if self.template:
            self.template.validate()

    def to_map(self):
        _map = super(GetTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.template is not None:
            result['Template'] = self.template.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Template') is not None:
            temp_model = GetTemplateResponseBodyTemplate()
            self.template = temp_model.from_map(m['Template'])
        return self


class GetTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTemplateMaterialsRequest(TeaModel):
    def __init__(self, file_list=None, template_id=None):
        # 所需文件列表
        self.file_list = file_list  # type: str
        # 模板Id
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTemplateMaterialsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_list is not None:
            result['FileList'] = self.file_list
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileList') is not None:
            self.file_list = m.get('FileList')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTemplateMaterialsResponseBody(TeaModel):
    def __init__(self, material_urls=None, request_id=None):
        # 关联素材地址
        self.material_urls = material_urls  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTemplateMaterialsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.material_urls is not None:
            result['MaterialUrls'] = self.material_urls
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaterialUrls') is not None:
            self.material_urls = m.get('MaterialUrls')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetTemplateMaterialsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTemplateMaterialsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTemplateMaterialsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTemplateMaterialsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetTranscodeJobRequest(TeaModel):
    def __init__(self, job_id=None):
        # 任务 id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup(TeaModel):
    def __init__(self, output=None, process_config=None):
        # 输出媒体配置
        self.output = output  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput
        # 任务处理配置
        self.process_config = process_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input_group=None, job_id=None, job_index=None, name=None,
                 out_file_meta=None, output=None, parent_job_id=None, process_config=None, request_id=None, schedule_config=None,
                 status=None, submit_result_json=None, submit_time=None, user_data=None):
        # 任务创建时间
        self.create_time = create_time  # type: str
        # 任务结束时间
        self.finish_time = finish_time  # type: str
        # 任务输入组 (目前只支持单个输入)
        self.input_group = input_group  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup]
        # 子任务 id
        self.job_id = job_id  # type: str
        # 子任务在整个任务中的索引号
        self.job_index = job_index  # type: int
        # 任务名
        self.name = name  # type: str
        # 任务生成视频 media 信息
        self.out_file_meta = out_file_meta  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta
        # 输出媒体配置
        self.output = output  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput
        # 主任务 id
        self.parent_job_id = parent_job_id  # type: str
        # 转码处理配置
        self.process_config = process_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig
        # 请求 id
        self.request_id = request_id  # type: str
        # 任务调度信息
        self.schedule_config = schedule_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig
        # 转码任务任务状态 - Init: 已提交, Processing: 转码中, Success: 转码成功, Fail: 转码失败, Deleted: 已删除
        self.status = status  # type: str
        # 任务提交结果
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.out_file_meta:
            self.out_file_meta.validate()
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_index is not None:
            result['JobIndex'] = self.job_index
        if self.name is not None:
            result['Name'] = self.name
        if self.out_file_meta is not None:
            result['OutFileMeta'] = self.out_file_meta.to_map()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobIndex') is not None:
            self.job_index = m.get('JobIndex')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutFileMeta') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta()
            self.out_file_meta = temp_model.from_map(m['OutFileMeta'])
        if m.get('Output') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('ProcessConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetTranscodeJobResponseBodyTranscodeParentJob(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input_group=None, job_count=None, name=None,
                 output_group=None, parent_job_id=None, percent=None, request_id=None, schedule_config=None, status=None,
                 submit_time=None, transcode_job_list=None, trigger_source=None, user_data=None):
        # 任务创建时间
        self.create_time = create_time  # type: str
        # 任务结束时间
        self.finish_time = finish_time  # type: str
        # 任务输入组 (目前只支持单个输入)
        self.input_group = input_group  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobInputGroup]
        # 子任务数量
        self.job_count = job_count  # type: int
        # 任务名
        self.name = name  # type: str
        # 任务输出组
        self.output_group = output_group  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup]
        # 主任务 id
        self.parent_job_id = parent_job_id  # type: str
        # 任务完成百分比
        self.percent = percent  # type: int
        # 提交任务时请求 id
        self.request_id = request_id  # type: str
        # 任务调度配置
        self.schedule_config = schedule_config  # type: GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig
        # 任务状态 Success: 有子任务成功, Fail: 所有子任务失败
        self.status = status  # type: str
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 子任务列表
        self.transcode_job_list = transcode_job_list  # type: list[GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList]
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.transcode_job_list:
            for k in self.transcode_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBodyTranscodeParentJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        result['TranscodeJobList'] = []
        if self.transcode_job_list is not None:
            for k in self.transcode_job_list:
                result['TranscodeJobList'].append(k.to_map() if k else None)
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        self.transcode_job_list = []
        if m.get('TranscodeJobList') is not None:
            for k in m.get('TranscodeJobList'):
                temp_model = GetTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList()
                self.transcode_job_list.append(temp_model.from_map(k))
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetTranscodeJobResponseBody(TeaModel):
    def __init__(self, request_id=None, transcode_parent_job=None):
        # 请求 id
        self.request_id = request_id  # type: str
        # TranscodeParentJobWithSubJobDTO
        self.transcode_parent_job = transcode_parent_job  # type: GetTranscodeJobResponseBodyTranscodeParentJob

    def validate(self):
        if self.transcode_parent_job:
            self.transcode_parent_job.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.transcode_parent_job is not None:
            result['TranscodeParentJob'] = self.transcode_parent_job.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TranscodeParentJob') is not None:
            temp_model = GetTranscodeJobResponseBodyTranscodeParentJob()
            self.transcode_parent_job = temp_model.from_map(m['TranscodeParentJob'])
        return self


class GetTranscodeJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetTranscodeJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetTranscodeJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetUrlUploadInfosRequest(TeaModel):
    def __init__(self, job_ids=None, upload_urls=None):
        self.job_ids = job_ids  # type: str
        self.upload_urls = upload_urls  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUrlUploadInfosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.upload_urls is not None:
            result['UploadURLs'] = self.upload_urls
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('UploadURLs') is not None:
            self.upload_urls = m.get('UploadURLs')
        return self


class GetUrlUploadInfosResponseBodyURLUploadInfoList(TeaModel):
    def __init__(self, complete_time=None, creation_time=None, error_code=None, error_message=None, file_size=None,
                 job_id=None, media_id=None, status=None, upload_url=None, user_data=None):
        self.complete_time = complete_time  # type: str
        self.creation_time = creation_time  # type: str
        self.error_code = error_code  # type: str
        self.error_message = error_message  # type: str
        self.file_size = file_size  # type: str
        self.job_id = job_id  # type: str
        self.media_id = media_id  # type: str
        self.status = status  # type: str
        self.upload_url = upload_url  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetUrlUploadInfosResponseBodyURLUploadInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.complete_time is not None:
            result['CompleteTime'] = self.complete_time
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.status is not None:
            result['Status'] = self.status
        if self.upload_url is not None:
            result['UploadURL'] = self.upload_url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CompleteTime') is not None:
            self.complete_time = m.get('CompleteTime')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UploadURL') is not None:
            self.upload_url = m.get('UploadURL')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class GetUrlUploadInfosResponseBody(TeaModel):
    def __init__(self, non_exists=None, request_id=None, urlupload_info_list=None):
        self.non_exists = non_exists  # type: list[str]
        self.request_id = request_id  # type: str
        self.urlupload_info_list = urlupload_info_list  # type: list[GetUrlUploadInfosResponseBodyURLUploadInfoList]

    def validate(self):
        if self.urlupload_info_list:
            for k in self.urlupload_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetUrlUploadInfosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.non_exists is not None:
            result['NonExists'] = self.non_exists
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['URLUploadInfoList'] = []
        if self.urlupload_info_list is not None:
            for k in self.urlupload_info_list:
                result['URLUploadInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NonExists') is not None:
            self.non_exists = m.get('NonExists')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.urlupload_info_list = []
        if m.get('URLUploadInfoList') is not None:
            for k in m.get('URLUploadInfoList'):
                temp_model = GetUrlUploadInfosResponseBodyURLUploadInfoList()
                self.urlupload_info_list.append(temp_model.from_map(k))
        return self


class GetUrlUploadInfosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetUrlUploadInfosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetUrlUploadInfosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetUrlUploadInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListAllPublicMediaTagsRequest(TeaModel):
    def __init__(self, business_type=None, entity_id=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.entity_id = entity_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAllPublicMediaTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        return self


class ListAllPublicMediaTagsResponseBodyMediaTagListOptions(TeaModel):
    def __init__(self, option_chinese_name=None, option_english_name=None, option_id=None):
        self.option_chinese_name = option_chinese_name  # type: str
        self.option_english_name = option_english_name  # type: str
        self.option_id = option_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListAllPublicMediaTagsResponseBodyMediaTagListOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.option_chinese_name is not None:
            result['OptionChineseName'] = self.option_chinese_name
        if self.option_english_name is not None:
            result['OptionEnglishName'] = self.option_english_name
        if self.option_id is not None:
            result['OptionId'] = self.option_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OptionChineseName') is not None:
            self.option_chinese_name = m.get('OptionChineseName')
        if m.get('OptionEnglishName') is not None:
            self.option_english_name = m.get('OptionEnglishName')
        if m.get('OptionId') is not None:
            self.option_id = m.get('OptionId')
        return self


class ListAllPublicMediaTagsResponseBodyMediaTagList(TeaModel):
    def __init__(self, media_tag_id=None, media_tag_name_chinese=None, media_tag_name_english=None, options=None):
        # 素材标签id
        self.media_tag_id = media_tag_id  # type: str
        # 素材标签中文名
        self.media_tag_name_chinese = media_tag_name_chinese  # type: str
        # 素材标签英文名
        self.media_tag_name_english = media_tag_name_english  # type: str
        self.options = options  # type: list[ListAllPublicMediaTagsResponseBodyMediaTagListOptions]

    def validate(self):
        if self.options:
            for k in self.options:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListAllPublicMediaTagsResponseBodyMediaTagList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_tag_id is not None:
            result['MediaTagId'] = self.media_tag_id
        if self.media_tag_name_chinese is not None:
            result['MediaTagNameChinese'] = self.media_tag_name_chinese
        if self.media_tag_name_english is not None:
            result['MediaTagNameEnglish'] = self.media_tag_name_english
        result['Options'] = []
        if self.options is not None:
            for k in self.options:
                result['Options'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaTagId') is not None:
            self.media_tag_id = m.get('MediaTagId')
        if m.get('MediaTagNameChinese') is not None:
            self.media_tag_name_chinese = m.get('MediaTagNameChinese')
        if m.get('MediaTagNameEnglish') is not None:
            self.media_tag_name_english = m.get('MediaTagNameEnglish')
        self.options = []
        if m.get('Options') is not None:
            for k in m.get('Options'):
                temp_model = ListAllPublicMediaTagsResponseBodyMediaTagListOptions()
                self.options.append(temp_model.from_map(k))
        return self


class ListAllPublicMediaTagsResponseBody(TeaModel):
    def __init__(self, media_tag_list=None, request_id=None):
        # 公共素材库标签列表
        self.media_tag_list = media_tag_list  # type: list[ListAllPublicMediaTagsResponseBodyMediaTagList]
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_tag_list:
            for k in self.media_tag_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListAllPublicMediaTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MediaTagList'] = []
        if self.media_tag_list is not None:
            for k in self.media_tag_list:
                result['MediaTagList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.media_tag_list = []
        if m.get('MediaTagList') is not None:
            for k in m.get('MediaTagList'):
                temp_model = ListAllPublicMediaTagsResponseBodyMediaTagList()
                self.media_tag_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListAllPublicMediaTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListAllPublicMediaTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListAllPublicMediaTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListAllPublicMediaTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCustomTemplatesRequest(TeaModel):
    def __init__(self, name=None, order_by=None, page_number=None, page_size=None, subtype=None, template_id=None,
                 type=None):
        # 模板名称
        self.name = name  # type: str
        # 排序顺序：CreateTimeDesc 和 CreateTimeAsc
        self.order_by = order_by  # type: str
        # 分页数目
        self.page_number = page_number  # type: int
        # 分页大小
        self.page_size = page_size  # type: int
        # 模板子类型ID
        self.subtype = subtype  # type: str
        # 模板ID
        self.template_id = template_id  # type: str
        # 模板类型。逗号分隔
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCustomTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListCustomTemplatesResponseBodyCustomTemplateList(TeaModel):
    def __init__(self, create_time=None, is_default=None, modified_time=None, status=None, subtype=None,
                 subtype_name=None, template_config=None, template_id=None, template_name=None, type=None, type_name=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 是否默认模板
        self.is_default = is_default  # type: bool
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板子类型ID
        self.subtype = subtype  # type: int
        # 模板子类型名称
        self.subtype_name = subtype_name  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板名称
        self.template_name = template_name  # type: str
        # 模板类型ID
        self.type = type  # type: int
        # 模板类型名称
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCustomTemplatesResponseBodyCustomTemplateList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class ListCustomTemplatesResponseBody(TeaModel):
    def __init__(self, custom_template_list=None, request_id=None, total=None):
        # 模板信息列表
        self.custom_template_list = custom_template_list  # type: list[ListCustomTemplatesResponseBodyCustomTemplateList]
        # 请求ID
        self.request_id = request_id  # type: str
        # 模板总数
        self.total = total  # type: int

    def validate(self):
        if self.custom_template_list:
            for k in self.custom_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCustomTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomTemplateList'] = []
        if self.custom_template_list is not None:
            for k in self.custom_template_list:
                result['CustomTemplateList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.custom_template_list = []
        if m.get('CustomTemplateList') is not None:
            for k in m.get('CustomTemplateList'):
                temp_model = ListCustomTemplatesResponseBodyCustomTemplateList()
                self.custom_template_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListCustomTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCustomTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCustomTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCustomTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDynamicImageJobsRequest(TeaModel):
    def __init__(self, end_of_create_time=None, job_id=None, next_page_token=None, order_by=None, page_size=None,
                 start_of_create_time=None, status=None):
        self.end_of_create_time = end_of_create_time  # type: str
        # 任务ID
        self.job_id = job_id  # type: str
        # 连续分页查询时下一页的标记
        self.next_page_token = next_page_token  # type: str
        # 排序顺序：CreateTimeDesc 和 CreateTimeAsc
        self.order_by = order_by  # type: str
        self.page_size = page_size  # type: int
        self.start_of_create_time = start_of_create_time  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDynamicImageJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListDynamicImageJobsResponseBodyJobsInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDynamicImageJobsResponseBodyJobsInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDynamicImageJobsResponseBodyJobsOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDynamicImageJobsResponseBodyJobsOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListDynamicImageJobsResponseBodyJobs(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input=None, job_id=None, modified_time=None, name=None,
                 output=None, pipeline_id=None, status=None, submit_time=None, template_id=None, trigger_source=None):
        self.create_time = create_time  # type: str
        self.finish_time = finish_time  # type: str
        self.input = input  # type: ListDynamicImageJobsResponseBodyJobsInput
        self.job_id = job_id  # type: str
        self.modified_time = modified_time  # type: str
        self.name = name  # type: str
        self.output = output  # type: ListDynamicImageJobsResponseBodyJobsOutput
        self.pipeline_id = pipeline_id  # type: str
        self.status = status  # type: str
        self.submit_time = submit_time  # type: str
        self.template_id = template_id  # type: str
        self.trigger_source = trigger_source  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super(ListDynamicImageJobsResponseBodyJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListDynamicImageJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = ListDynamicImageJobsResponseBodyJobsOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        return self


class ListDynamicImageJobsResponseBody(TeaModel):
    def __init__(self, jobs=None, next_page_token=None, request_id=None):
        self.jobs = jobs  # type: list[ListDynamicImageJobsResponseBodyJobs]
        self.next_page_token = next_page_token  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDynamicImageJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListDynamicImageJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListDynamicImageJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDynamicImageJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDynamicImageJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDynamicImageJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveRecordTemplatesRequest(TeaModel):
    def __init__(self, keyword=None, page_no=None, page_size=None, sort_by=None, template_ids=None, type=None):
        self.keyword = keyword  # type: str
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        self.sort_by = sort_by  # type: str
        self.template_ids = template_ids  # type: list[str]
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveRecordTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList(TeaModel):
    def __init__(self, cycle_duration=None, format=None, oss_object_prefix=None, slice_duration=None,
                 slice_oss_object_prefix=None):
        # 录制周期时长
        self.cycle_duration = cycle_duration  # type: bytes
        # 格式
        self.format = format  # type: bytes
        # Oss对象名
        self.oss_object_prefix = oss_object_prefix  # type: bytes
        # 切片时长
        self.slice_duration = slice_duration  # type: int
        # 切片Oss对象名
        self.slice_oss_object_prefix = slice_oss_object_prefix  # type: bytes

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cycle_duration is not None:
            result['CycleDuration'] = self.cycle_duration
        if self.format is not None:
            result['Format'] = self.format
        if self.oss_object_prefix is not None:
            result['OssObjectPrefix'] = self.oss_object_prefix
        if self.slice_duration is not None:
            result['SliceDuration'] = self.slice_duration
        if self.slice_oss_object_prefix is not None:
            result['SliceOssObjectPrefix'] = self.slice_oss_object_prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CycleDuration') is not None:
            self.cycle_duration = m.get('CycleDuration')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OssObjectPrefix') is not None:
            self.oss_object_prefix = m.get('OssObjectPrefix')
        if m.get('SliceDuration') is not None:
            self.slice_duration = m.get('SliceDuration')
        if m.get('SliceOssObjectPrefix') is not None:
            self.slice_oss_object_prefix = m.get('SliceOssObjectPrefix')
        return self


class ListLiveRecordTemplatesResponseBodyRecordTemplateList(TeaModel):
    def __init__(self, create_time=None, last_modified=None, name=None, record_format_list=None, template_id=None,
                 type=None):
        # 创建时间
        self.create_time = create_time  # type: str
        # 最后修改时间
        self.last_modified = last_modified  # type: str
        # 资源名称
        self.name = name  # type: bytes
        # 录制格式
        self.record_format_list = record_format_list  # type: list[ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList]
        # 资源一级ID
        self.template_id = template_id  # type: bytes
        # 资源名称
        self.type = type  # type: bytes

    def validate(self):
        if self.record_format_list:
            for k in self.record_format_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLiveRecordTemplatesResponseBodyRecordTemplateList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.last_modified is not None:
            result['LastModified'] = self.last_modified
        if self.name is not None:
            result['Name'] = self.name
        result['RecordFormatList'] = []
        if self.record_format_list is not None:
            for k in self.record_format_list:
                result['RecordFormatList'].append(k.to_map() if k else None)
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('LastModified') is not None:
            self.last_modified = m.get('LastModified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.record_format_list = []
        if m.get('RecordFormatList') is not None:
            for k in m.get('RecordFormatList'):
                temp_model = ListLiveRecordTemplatesResponseBodyRecordTemplateListRecordFormatList()
                self.record_format_list.append(temp_model.from_map(k))
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveRecordTemplatesResponseBody(TeaModel):
    def __init__(self, page_no=None, page_size=None, record_template_list=None, request_id=None, sort_by=None,
                 total_count=None):
        self.page_no = page_no  # type: long
        self.page_size = page_size  # type: long
        # 数组，返回示例目录。
        self.record_template_list = record_template_list  # type: list[ListLiveRecordTemplatesResponseBodyRecordTemplateList]
        # Id of the request
        self.request_id = request_id  # type: str
        self.sort_by = sort_by  # type: str
        # 总记录数。
        self.total_count = total_count  # type: long

    def validate(self):
        if self.record_template_list:
            for k in self.record_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLiveRecordTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['RecordTemplateList'] = []
        if self.record_template_list is not None:
            for k in self.record_template_list:
                result['RecordTemplateList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.record_template_list = []
        if m.get('RecordTemplateList') is not None:
            for k in m.get('RecordTemplateList'):
                temp_model = ListLiveRecordTemplatesResponseBodyRecordTemplateList()
                self.record_template_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveRecordTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLiveRecordTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLiveRecordTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveRecordTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveTranscodeJobsRequest(TeaModel):
    def __init__(self, key_word=None, page_no=None, page_size=None, sort_by=None, start_mode=None, status=None,
                 type=None):
        self.key_word = key_word  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.sort_by = sort_by  # type: str
        self.start_mode = start_mode  # type: int
        self.status = status  # type: int
        # 模板Id
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos(TeaModel):
    def __init__(self, output_url=None, type=None):
        self.output_url = output_url  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output_url is not None:
            result['OutputUrl'] = self.output_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OutputUrl') is not None:
            self.output_url = m.get('OutputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobListOutputStream(TeaModel):
    def __init__(self, stream_infos=None):
        self.stream_infos = stream_infos  # type: list[ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos]

    def validate(self):
        if self.stream_infos:
            for k in self.stream_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponseBodyJobListOutputStream, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StreamInfos'] = []
        if self.stream_infos is not None:
            for k in self.stream_infos:
                result['StreamInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.stream_infos = []
        if m.get('StreamInfos') is not None:
            for k in m.get('StreamInfos'):
                temp_model = ListLiveTranscodeJobsResponseBodyJobListOutputStreamStreamInfos()
                self.stream_infos.append(temp_model.from_map(k))
        return self


class ListLiveTranscodeJobsResponseBodyJobListStreamInput(TeaModel):
    def __init__(self, input_url=None, type=None):
        self.input_url = input_url  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponseBodyJobListStreamInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeJobsResponseBodyJobList(TeaModel):
    def __init__(self, create_time=None, job_id=None, name=None, output_stream=None, start_mode=None, status=None,
                 stream_input=None, template_id=None, template_name=None, template_type=None):
        self.create_time = create_time  # type: str
        self.job_id = job_id  # type: str
        self.name = name  # type: str
        self.output_stream = output_stream  # type: ListLiveTranscodeJobsResponseBodyJobListOutputStream
        self.start_mode = start_mode  # type: int
        self.status = status  # type: int
        self.stream_input = stream_input  # type: ListLiveTranscodeJobsResponseBodyJobListStreamInput
        self.template_id = template_id  # type: str
        self.template_name = template_name  # type: str
        self.template_type = template_type  # type: str

    def validate(self):
        if self.output_stream:
            self.output_stream.validate()
        if self.stream_input:
            self.stream_input.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponseBodyJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.output_stream is not None:
            result['OutputStream'] = self.output_stream.to_map()
        if self.start_mode is not None:
            result['StartMode'] = self.start_mode
        if self.status is not None:
            result['Status'] = self.status
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputStream') is not None:
            temp_model = ListLiveTranscodeJobsResponseBodyJobListOutputStream()
            self.output_stream = temp_model.from_map(m['OutputStream'])
        if m.get('StartMode') is not None:
            self.start_mode = m.get('StartMode')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StreamInput') is not None:
            temp_model = ListLiveTranscodeJobsResponseBodyJobListStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class ListLiveTranscodeJobsResponseBody(TeaModel):
    def __init__(self, job_list=None, request_id=None, total_count=None):
        self.job_list = job_list  # type: list[ListLiveTranscodeJobsResponseBodyJobList]
        # 请求ID
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.job_list:
            for k in self.job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['JobList'] = []
        if self.job_list is not None:
            for k in self.job_list:
                result['JobList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.job_list = []
        if m.get('JobList') is not None:
            for k in m.get('JobList'):
                temp_model = ListLiveTranscodeJobsResponseBodyJobList()
                self.job_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveTranscodeJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLiveTranscodeJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveTranscodeJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListLiveTranscodeTemplatesRequest(TeaModel):
    def __init__(self, category=None, key_word=None, page_no=None, page_size=None, sort_by=None, type=None,
                 video_codec=None):
        self.category = category  # type: str
        self.key_word = key_word  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.sort_by = sort_by  # type: str
        # 模板Id
        self.type = type  # type: str
        self.video_codec = video_codec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.type is not None:
            result['Type'] = self.type
        if self.video_codec is not None:
            result['VideoCodec'] = self.video_codec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VideoCodec') is not None:
            self.video_codec = m.get('VideoCodec')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, samplerate=None):
        self.bitrate = bitrate  # type: str
        self.channels = channels  # type: str
        self.codec = codec  # type: str
        self.profile = profile  # type: str
        self.samplerate = samplerate  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams(TeaModel):
    def __init__(self, bitrate=None, codec=None, fps=None, gop=None, height=None, profile=None, width=None):
        self.bitrate = bitrate  # type: str
        self.codec = codec  # type: str
        self.fps = fps  # type: str
        self.gop = gop  # type: str
        self.height = height  # type: str
        self.profile = profile  # type: str
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig(TeaModel):
    def __init__(self, audio_params=None, video_params=None):
        self.audio_params = audio_params  # type: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams
        self.video_params = video_params  # type: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class ListLiveTranscodeTemplatesResponseBodyTemplateContentList(TeaModel):
    def __init__(self, category=None, create_time=None, name=None, template_config=None, template_id=None, type=None):
        self.category = category  # type: str
        self.create_time = create_time  # type: str
        self.name = name  # type: str
        self.template_config = template_config  # type: ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig
        self.template_id = template_id  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponseBodyTemplateContentList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentListTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListLiveTranscodeTemplatesResponseBody(TeaModel):
    def __init__(self, request_id=None, template_content_list=None, total_count=None):
        # 请求ID
        self.request_id = request_id  # type: str
        self.template_content_list = template_content_list  # type: list[ListLiveTranscodeTemplatesResponseBodyTemplateContentList]
        self.total_count = total_count  # type: int

    def validate(self):
        if self.template_content_list:
            for k in self.template_content_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TemplateContentList'] = []
        if self.template_content_list is not None:
            for k in self.template_content_list:
                result['TemplateContentList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.template_content_list = []
        if m.get('TemplateContentList') is not None:
            for k in m.get('TemplateContentList'):
                temp_model = ListLiveTranscodeTemplatesResponseBodyTemplateContentList()
                self.template_content_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListLiveTranscodeTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListLiveTranscodeTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListLiveTranscodeTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListLiveTranscodeTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaBasicInfosRequest(TeaModel):
    def __init__(self, business_type=None, end_time=None, include_file_basic_info=None, max_results=None,
                 media_id=None, media_type=None, next_token=None, sort_by=None, source=None, start_time=None, status=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 结束时间
        self.end_time = end_time  # type: str
        # 返回值中是否包含文件基础信息
        self.include_file_basic_info = include_file_basic_info  # type: bool
        # 分页大小
        self.max_results = max_results  # type: int
        # 媒资ID，单个媒资ID支持前缀匹配
        self.media_id = media_id  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 页号
        self.next_token = next_token  # type: str
        # 排序
        self.sort_by = sort_by  # type: str
        # 来源
        self.source = source  # type: str
        # 创建时间
        self.start_time = start_time  # type: str
        # 资源状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaBasicInfosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.include_file_basic_info is not None:
            result['IncludeFileBasicInfo'] = self.include_file_basic_info
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.source is not None:
            result['Source'] = self.source
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('IncludeFileBasicInfo') is not None:
            self.include_file_basic_info = m.get('IncludeFileBasicInfo')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, create_time=None, duration=None, file_name=None, file_size=None,
                 file_status=None, file_type=None, file_url=None, format_name=None, height=None, modified_time=None, region=None,
                 width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        self.create_time = create_time  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        self.modified_time = modified_time  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaBasicInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(ListMediaBasicInfosResponseBodyMediaInfosFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = ListMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(self, biz=None, business_type=None, cate_id=None, category=None, cover_url=None, create_time=None,
                 deleted_time=None, description=None, input_url=None, media_id=None, media_tags=None, media_type=None,
                 modified_time=None, snapshots=None, source=None, sprite_images=None, status=None, title=None,
                 transcode_status=None, upload_source=None, user_data=None):
        self.biz = biz  # type: str
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.cate_id = cate_id  # type: long
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        self.upload_source = upload_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaBasicInfosResponseBodyMediaInfos(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[ListMediaBasicInfosResponseBodyMediaInfosFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(ListMediaBasicInfosResponseBodyMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = ListMediaBasicInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = ListMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class ListMediaBasicInfosResponseBody(TeaModel):
    def __init__(self, max_results=None, media_infos=None, next_token=None, request_id=None, total_count=None):
        self.max_results = max_results  # type: int
        # 符合要求的媒资集合
        self.media_infos = media_infos  # type: list[ListMediaBasicInfosResponseBodyMediaInfos]
        self.next_token = next_token  # type: str
        # Id of the request
        self.request_id = request_id  # type: str
        # 符合要求的媒资总数
        self.total_count = total_count  # type: long

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListMediaBasicInfosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = ListMediaBasicInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListMediaBasicInfosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListMediaBasicInfosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListMediaBasicInfosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaBasicInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListMediaInfoJobsRequest(TeaModel):
    def __init__(self, end_of_create_time=None, job_id=None, next_page_token=None, order_by=None, page_size=None,
                 start_of_create_time=None, status=None):
        # 任务创建时间筛选条件的结束时间
        self.end_of_create_time = end_of_create_time  # type: str
        # 按 jobId 筛选
        self.job_id = job_id  # type: str
        # 连续分页查询时下一页的标记 (第一页没有)
        self.next_page_token = next_page_token  # type: str
        # 排序顺序，目前只支持两种：CreateTimeDesc 和 CreateTimeAsc
        self.order_by = order_by  # type: str
        self.page_size = page_size  # type: int
        # 任务创建时间筛选条件的起始时间
        self.start_of_create_time = start_of_create_time  # type: str
        # 任务状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListMediaInfoJobsResponseBodyJobsInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListMediaInfoJobsResponseBodyJobsMediaInfoProperty(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsMediaInfoProperty, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class ListMediaInfoJobsResponseBodyJobsScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobsScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class ListMediaInfoJobsResponseBodyJobs(TeaModel):
    def __init__(self, async=None, finish_time=None, input=None, job_id=None, media_info_property=None, name=None,
                 request_id=None, schedule_config=None, status=None, submit_result_json=None, submit_time=None,
                 trigger_source=None, user_data=None):
        # 是否异步处理
        self.async = async  # type: bool
        # 任务完成时间
        self.finish_time = finish_time  # type: str
        # 任务输入
        self.input = input  # type: ListMediaInfoJobsResponseBodyJobsInput
        # 任务 id
        self.job_id = job_id  # type: str
        # 媒体信息详情
        self.media_info_property = media_info_property  # type: ListMediaInfoJobsResponseBodyJobsMediaInfoProperty
        # 任务名字
        self.name = name  # type: str
        # 请求 id
        self.request_id = request_id  # type: str
        # 调度信息
        self.schedule_config = schedule_config  # type: ListMediaInfoJobsResponseBodyJobsScheduleConfig
        # 任务状态 - Init: 已提交, Success: 成功, Fail: 失败
        self.status = status  # type: str
        # 任务提交信息
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBodyJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = ListMediaInfoJobsResponseBodyJobsScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListMediaInfoJobsResponseBody(TeaModel):
    def __init__(self, jobs=None, next_page_token=None, request_id=None):
        self.jobs = jobs  # type: list[ListMediaInfoJobsResponseBodyJobs]
        self.next_page_token = next_page_token  # type: str
        # 请求 id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListMediaInfoJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListMediaInfoJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListMediaInfoJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListMediaInfoJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListMediaInfoJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListMediaInfoJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPipelinesRequest(TeaModel):
    def __init__(self, speed=None):
        # 管道类型。
        self.speed = speed  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPipelinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.speed is not None:
            result['Speed'] = self.speed
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        return self


class ListPipelinesResponseBodyPipelineList(TeaModel):
    def __init__(self, create_time=None, modified_time=None, name=None, pipeline_id=None, priority=None, speed=None,
                 status=None):
        # 模板创建时间
        self.create_time = create_time  # type: str
        # 模板修改时间
        self.modified_time = modified_time  # type: str
        # 管道名称
        self.name = name  # type: str
        # 管道Id
        self.pipeline_id = pipeline_id  # type: str
        # 管道优先级
        self.priority = priority  # type: int
        # 管道类型
        self.speed = speed  # type: str
        # 管道状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPipelinesResponseBodyPipelineList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.speed is not None:
            result['Speed'] = self.speed
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Speed') is not None:
            self.speed = m.get('Speed')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListPipelinesResponseBody(TeaModel):
    def __init__(self, pipeline_list=None, request_id=None):
        self.pipeline_list = pipeline_list  # type: list[ListPipelinesResponseBodyPipelineList]
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.pipeline_list:
            for k in self.pipeline_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPipelinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PipelineList'] = []
        if self.pipeline_list is not None:
            for k in self.pipeline_list:
                result['PipelineList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.pipeline_list = []
        if m.get('PipelineList') is not None:
            for k in m.get('PipelineList'):
                temp_model = ListPipelinesResponseBodyPipelineList()
                self.pipeline_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListPipelinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPipelinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPipelinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPipelinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPublicMediaBasicInfosRequest(TeaModel):
    def __init__(self, include_file_basic_info=None, max_results=None, media_tag_id=None, next_token=None):
        # 返回值中是否包含文件基础信息
        self.include_file_basic_info = include_file_basic_info  # type: bool
        # 分页大小
        self.max_results = max_results  # type: int
        # 标签
        self.media_tag_id = media_tag_id  # type: str
        # 下一次读取的位置
        self.next_token = next_token  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_file_basic_info is not None:
            result['IncludeFileBasicInfo'] = self.include_file_basic_info
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.media_tag_id is not None:
            result['MediaTagId'] = self.media_tag_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IncludeFileBasicInfo') is not None:
            self.include_file_basic_info = m.get('IncludeFileBasicInfo')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MediaTagId') is not None:
            self.media_tag_id = m.get('MediaTagId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, region=None, width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, input_url=None, media_id=None, media_tags=None, media_type=None, modified_time=None,
                 snapshots=None, source=None, status=None, title=None, transcode_status=None, user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListPublicMediaBasicInfosResponseBodyMediaInfos(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponseBodyMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfosMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class ListPublicMediaBasicInfosResponseBody(TeaModel):
    def __init__(self, max_results=None, media_infos=None, next_token=None, request_id=None, total_count=None):
        self.max_results = max_results  # type: int
        # 符合要求的媒资集合
        self.media_infos = media_infos  # type: list[ListPublicMediaBasicInfosResponseBodyMediaInfos]
        self.next_token = next_token  # type: str
        # Id of the request
        self.request_id = request_id  # type: str
        # 符合要求的媒资总数
        self.total_count = total_count  # type: long

    def validate(self):
        if self.media_infos:
            for k in self.media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        result['MediaInfos'] = []
        if self.media_infos is not None:
            for k in self.media_infos:
                result['MediaInfos'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        self.media_infos = []
        if m.get('MediaInfos') is not None:
            for k in m.get('MediaInfos'):
                temp_model = ListPublicMediaBasicInfosResponseBodyMediaInfos()
                self.media_infos.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPublicMediaBasicInfosResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPublicMediaBasicInfosResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPublicMediaBasicInfosResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPublicMediaBasicInfosResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSmartJobsRequest(TeaModel):
    def __init__(self, job_state=None, job_type=None, max_results=None, next_token=None, page_no=None,
                 page_size=None, sort_by=None):
        # 任务状态
        self.job_state = job_state  # type: str
        # 任务类型
        self.job_type = job_type  # type: str
        # 分页大小。最大不超过100。  默认值：10
        self.max_results = max_results  # type: long
        # 当前开始读取的位置
        self.next_token = next_token  # type: str
        # 当前页码。默认值为1。
        self.page_no = page_no  # type: long
        # 分页大小，每页显示条数。默认值为10，最大值为100。
        self.page_size = page_size  # type: long
        # 排序参数，默认根据创建时间倒序
        self.sort_by = sort_by  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSmartJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_state is not None:
            result['JobState'] = self.job_state
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobState') is not None:
            self.job_state = m.get('JobState')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class ListSmartJobsResponseBodySmartJobListInputConfig(TeaModel):
    def __init__(self, input_file=None, keyword=None):
        # 文件信息
        self.input_file = input_file  # type: str
        # 关键词信息
        self.keyword = keyword  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSmartJobsResponseBodySmartJobListInputConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        return self


class ListSmartJobsResponseBodySmartJobListOutputConfig(TeaModel):
    def __init__(self, bucket=None, object=None):
        # OSS Bucket
        self.bucket = bucket  # type: str
        # OSS Object
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSmartJobsResponseBodySmartJobListOutputConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class ListSmartJobsResponseBodySmartJobList(TeaModel):
    def __init__(self, create_time=None, description=None, editing_config=None, input_config=None, job_id=None,
                 job_state=None, job_type=None, modified_time=None, output_config=None, title=None, user_data=None,
                 user_id=None):
        # 创建时间
        self.create_time = create_time  # type: str
        # 任务描述
        self.description = description  # type: str
        # 输入配置
        self.editing_config = editing_config  # type: str
        # 任务输入配置
        self.input_config = input_config  # type: ListSmartJobsResponseBodySmartJobListInputConfig
        # 任务Id
        self.job_id = job_id  # type: str
        # 任务状态
        self.job_state = job_state  # type: str
        # 任务类型
        self.job_type = job_type  # type: str
        # 最后修改时间
        self.modified_time = modified_time  # type: str
        # 任务输出配置
        self.output_config = output_config  # type: ListSmartJobsResponseBodySmartJobListOutputConfig
        # 任务标题
        self.title = title  # type: str
        # 用户自定义字段
        self.user_data = user_data  # type: str
        # 用户Id
        self.user_id = user_id  # type: long

    def validate(self):
        if self.input_config:
            self.input_config.validate()
        if self.output_config:
            self.output_config.validate()

    def to_map(self):
        _map = super(ListSmartJobsResponseBodySmartJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_state is not None:
            result['JobState'] = self.job_state
        if self.job_type is not None:
            result['JobType'] = self.job_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config.to_map()
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            temp_model = ListSmartJobsResponseBodySmartJobListInputConfig()
            self.input_config = temp_model.from_map(m['InputConfig'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobState') is not None:
            self.job_state = m.get('JobState')
        if m.get('JobType') is not None:
            self.job_type = m.get('JobType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('OutputConfig') is not None:
            temp_model = ListSmartJobsResponseBodySmartJobListOutputConfig()
            self.output_config = temp_model.from_map(m['OutputConfig'])
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class ListSmartJobsResponseBody(TeaModel):
    def __init__(self, max_results=None, next_token=None, request_id=None, smart_job_list=None, total_count=None):
        # 本次请求所返回的最大记录条数，最后一页前每页记录条数为MaxResults取值。  例如：  正例：10,10,5，反例：10,5,10
        self.max_results = max_results  # type: str
        # 用来表示当前调用返回读取到的位置，空代表数据已经读取完毕。
        self.next_token = next_token  # type: str
        # 请求ID。
        self.request_id = request_id  # type: str
        self.smart_job_list = smart_job_list  # type: list[ListSmartJobsResponseBodySmartJobList]
        # 本次请求条件下的数据总量，此参数为可选参数，默认可不返回。
        self.total_count = total_count  # type: str

    def validate(self):
        if self.smart_job_list:
            for k in self.smart_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSmartJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SmartJobList'] = []
        if self.smart_job_list is not None:
            for k in self.smart_job_list:
                result['SmartJobList'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.smart_job_list = []
        if m.get('SmartJobList') is not None:
            for k in m.get('SmartJobList'):
                temp_model = ListSmartJobsResponseBodySmartJobList()
                self.smart_job_list.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListSmartJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSmartJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSmartJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSmartJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSnapshotJobsRequest(TeaModel):
    def __init__(self, end_of_create_time=None, job_id=None, next_page_token=None, order_by=None, page_size=None,
                 start_of_create_time=None, status=None):
        self.end_of_create_time = end_of_create_time  # type: str
        self.job_id = job_id  # type: str
        # 连续分页查询时下一页的标记
        self.next_page_token = next_page_token  # type: str
        # 排序顺序：CreateTimeDesc 和 CreateTimeAsc
        self.order_by = order_by  # type: str
        self.page_size = page_size  # type: int
        self.start_of_create_time = start_of_create_time  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSnapshotJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListSnapshotJobsResponseBodyJobsInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSnapshotJobsResponseBodyJobsInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBodyJobsOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSnapshotJobsResponseBodyJobsOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBodyJobs(TeaModel):
    def __init__(self, async=None, count=None, create_time=None, finish_time=None, input=None, job_id=None,
                 modified_time=None, name=None, output=None, pipeline_id=None, status=None, submit_time=None, template_id=None,
                 trigger_source=None, type=None):
        self.async = async  # type: bool
        self.count = count  # type: int
        self.create_time = create_time  # type: str
        self.finish_time = finish_time  # type: str
        self.input = input  # type: ListSnapshotJobsResponseBodyJobsInput
        self.job_id = job_id  # type: str
        self.modified_time = modified_time  # type: str
        self.name = name  # type: str
        self.output = output  # type: ListSnapshotJobsResponseBodyJobsOutput
        self.pipeline_id = pipeline_id  # type: str
        self.status = status  # type: str
        self.submit_time = submit_time  # type: str
        self.template_id = template_id  # type: str
        self.trigger_source = trigger_source  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()

    def to_map(self):
        _map = super(ListSnapshotJobsResponseBodyJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.count is not None:
            result['Count'] = self.count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = ListSnapshotJobsResponseBodyJobsInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = ListSnapshotJobsResponseBodyJobsOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSnapshotJobsResponseBody(TeaModel):
    def __init__(self, jobs=None, next_page_token=None, request_id=None):
        self.jobs = jobs  # type: list[ListSnapshotJobsResponseBodyJobs]
        self.next_page_token = next_page_token  # type: str
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSnapshotJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListSnapshotJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListSnapshotJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSnapshotJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSnapshotJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSnapshotJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListSystemTemplatesRequest(TeaModel):
    def __init__(self, name=None, page_number=None, page_size=None, status=None, subtype=None, template_id=None,
                 type=None):
        # 模板名称
        self.name = name  # type: str
        # 分页数目
        self.page_number = page_number  # type: int
        # 分页大小
        self.page_size = page_size  # type: int
        # 模板状态：Normal正常，Invisible不可见，ALL全部
        self.status = status  # type: str
        # 模板子类型ID
        self.subtype = subtype  # type: str
        # 模板ID
        self.template_id = template_id  # type: str
        # 模板类型。逗号分隔
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListSystemTemplatesResponseBodySystemTemplateList(TeaModel):
    def __init__(self, status=None, subtype=None, subtype_name=None, template_config=None, template_id=None,
                 template_name=None, type=None, type_name=None):
        # 模板状态
        self.status = status  # type: str
        # 模板子类型ID
        self.subtype = subtype  # type: int
        # 模板子类型名称
        self.subtype_name = subtype_name  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 模板名称
        self.template_name = template_name  # type: str
        # 模板类型ID
        self.type = type  # type: int
        # 模板类型名称
        self.type_name = type_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListSystemTemplatesResponseBodySystemTemplateList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status is not None:
            result['Status'] = self.status
        if self.subtype is not None:
            result['Subtype'] = self.subtype
        if self.subtype_name is not None:
            result['SubtypeName'] = self.subtype_name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.template_name is not None:
            result['TemplateName'] = self.template_name
        if self.type is not None:
            result['Type'] = self.type
        if self.type_name is not None:
            result['TypeName'] = self.type_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Subtype') is not None:
            self.subtype = m.get('Subtype')
        if m.get('SubtypeName') is not None:
            self.subtype_name = m.get('SubtypeName')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('TemplateName') is not None:
            self.template_name = m.get('TemplateName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('TypeName') is not None:
            self.type_name = m.get('TypeName')
        return self


class ListSystemTemplatesResponseBody(TeaModel):
    def __init__(self, request_id=None, system_template_list=None, total=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 模板信息列表
        self.system_template_list = system_template_list  # type: list[ListSystemTemplatesResponseBodySystemTemplateList]
        # 模板总数
        self.total = total  # type: int

    def validate(self):
        if self.system_template_list:
            for k in self.system_template_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListSystemTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SystemTemplateList'] = []
        if self.system_template_list is not None:
            for k in self.system_template_list:
                result['SystemTemplateList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.system_template_list = []
        if m.get('SystemTemplateList') is not None:
            for k in m.get('SystemTemplateList'):
                temp_model = ListSystemTemplatesResponseBodySystemTemplateList()
                self.system_template_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class ListSystemTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListSystemTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListSystemTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListSystemTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTemplatesRequest(TeaModel):
    def __init__(self, create_source=None, keyword=None, page_no=None, page_size=None, sort_type=None, status=None,
                 type=None):
        # 创建来源
        self.create_source = create_source  # type: str
        # 搜索关键词，可以根据模板id和title搜索
        self.keyword = keyword  # type: str
        # 当前页码。默认值为1。
        self.page_no = page_no  # type: long
        # 分页大小，每页显示条数。默认值为10，最大值为100。
        self.page_size = page_size  # type: long
        # 排序参数，默认根据创建时间倒序
        self.sort_type = sort_type  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板类型
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_type is not None:
            result['SortType'] = self.sort_type
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortType') is not None:
            self.sort_type = m.get('SortType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTemplatesResponseBodyTemplates(TeaModel):
    def __init__(self, clips_param=None, config=None, cover_url=None, create_source=None, creation_time=None,
                 modified_source=None, modified_time=None, name=None, preview_media=None, preview_media_status=None, status=None,
                 template_id=None, type=None):
        # ClipsParam
        self.clips_param = clips_param  # type: str
        # 模板配置
        self.config = config  # type: str
        # 封面URL
        self.cover_url = cover_url  # type: str
        # 创建来源
        self.create_source = create_source  # type: str
        # 创建时间
        self.creation_time = creation_time  # type: str
        # 修改来源
        self.modified_source = modified_source  # type: str
        # 修改时间
        self.modified_time = modified_time  # type: str
        # 模板名称
        self.name = name  # type: str
        # 预览素材
        self.preview_media = preview_media  # type: str
        # 预览素材状态
        self.preview_media_status = preview_media_status  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板ID
        self.template_id = template_id  # type: str
        # 模板类型
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTemplatesResponseBodyTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.preview_media_status is not None:
            result['PreviewMediaStatus'] = self.preview_media_status
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('PreviewMediaStatus') is not None:
            self.preview_media_status = m.get('PreviewMediaStatus')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTemplatesResponseBody(TeaModel):
    def __init__(self, request_id=None, templates=None, total_count=None):
        # 请求ID
        self.request_id = request_id  # type: str
        self.templates = templates  # type: list[ListTemplatesResponseBodyTemplates]
        # 本次请求条件下的数据总量。
        self.total_count = total_count  # type: int

    def validate(self):
        if self.templates:
            for k in self.templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Templates'] = []
        if self.templates is not None:
            for k in self.templates:
                result['Templates'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.templates = []
        if m.get('Templates') is not None:
            for k in m.get('Templates'):
                temp_model = ListTemplatesResponseBodyTemplates()
                self.templates.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTranscodeJobsRequest(TeaModel):
    def __init__(self, end_of_create_time=None, job_id=None, next_page_token=None, order_by=None, page_size=None,
                 start_of_create_time=None, status=None):
        # 任务创建时间筛选条件的结束时间
        self.end_of_create_time = end_of_create_time  # type: str
        # 按 jobId 筛选
        self.job_id = job_id  # type: str
        # 连续分页查询时下一页的标记 (第一页没有)
        self.next_page_token = next_page_token  # type: str
        # 排序顺序，目前只支持两种：CreateTimeDesc 和 CreateTimeAsc
        self.order_by = order_by  # type: str
        self.page_size = page_size  # type: int
        # 任务创建时间筛选条件的起始时间
        self.start_of_create_time = start_of_create_time  # type: str
        # 任务状态
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_of_create_time is not None:
            result['EndOfCreateTime'] = self.end_of_create_time
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.start_of_create_time is not None:
            result['StartOfCreateTime'] = self.start_of_create_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndOfCreateTime') is not None:
            self.end_of_create_time = m.get('EndOfCreateTime')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('StartOfCreateTime') is not None:
            self.start_of_create_time = m.get('StartOfCreateTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListTranscodeJobsResponseBodyJobsInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class ListTranscodeJobsResponseBodyJobsOutputGroup(TeaModel):
    def __init__(self, output=None, process_config=None):
        # 输出媒体配置
        self.output = output  # type: ListTranscodeJobsResponseBodyJobsOutputGroupOutput
        # 任务处理配置
        self.process_config = process_config  # type: ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsOutputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class ListTranscodeJobsResponseBodyJobsScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobsScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class ListTranscodeJobsResponseBodyJobs(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input_group=None, job_count=None, name=None,
                 output_group=None, parent_job_id=None, percent=None, request_id=None, schedule_config=None, status=None,
                 submit_time=None, trigger_source=None, user_data=None):
        # 任务创建时间
        self.create_time = create_time  # type: str
        # 任务结束时间
        self.finish_time = finish_time  # type: str
        # 任务输入组 (目前只支持单个输入)
        self.input_group = input_group  # type: list[ListTranscodeJobsResponseBodyJobsInputGroup]
        # 子任务数量
        self.job_count = job_count  # type: int
        # 任务名
        self.name = name  # type: str
        # 任务输出组
        self.output_group = output_group  # type: list[ListTranscodeJobsResponseBodyJobsOutputGroup]
        # 主任务 id
        self.parent_job_id = parent_job_id  # type: str
        # 任务完成百分比
        self.percent = percent  # type: int
        # 提交任务时请求 id
        self.request_id = request_id  # type: str
        # 任务调度配置
        self.schedule_config = schedule_config  # type: ListTranscodeJobsResponseBodyJobsScheduleConfig
        # 任务状态 Success: 有子任务成功, Fail: 所有子任务失败
        self.status = status  # type: str
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBodyJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = ListTranscodeJobsResponseBodyJobsInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = ListTranscodeJobsResponseBodyJobsOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = ListTranscodeJobsResponseBodyJobsScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ListTranscodeJobsResponseBody(TeaModel):
    def __init__(self, jobs=None, next_page_token=None, request_id=None):
        self.jobs = jobs  # type: list[ListTranscodeJobsResponseBodyJobs]
        self.next_page_token = next_page_token  # type: str
        # 请求 id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.jobs:
            for k in self.jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Jobs'] = []
        if self.jobs is not None:
            for k in self.jobs:
                result['Jobs'].append(k.to_map() if k else None)
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.jobs = []
        if m.get('Jobs') is not None:
            for k in m.get('Jobs'):
                temp_model = ListTranscodeJobsResponseBodyJobs()
                self.jobs.append(temp_model.from_map(k))
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListTranscodeJobsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTranscodeJobsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTranscodeJobsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTranscodeJobsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class NotifyPreOssUploadCompleteRequest(TeaModel):
    def __init__(self, file_name=None):
        self.file_name = file_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotifyPreOssUploadCompleteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_name is not None:
            result['FileName'] = self.file_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        return self


class NotifyPreOssUploadCompleteResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotifyPreOssUploadCompleteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class NotifyPreOssUploadCompleteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: NotifyPreOssUploadCompleteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(NotifyPreOssUploadCompleteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = NotifyPreOssUploadCompleteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryCensorJobListRequest(TeaModel):
    def __init__(self, job_ids=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.job_ids = job_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_ids is not None:
            result['JobIds'] = self.job_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobIds') is not None:
            self.job_ids = m.get('JobIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorConfig(TeaModel):
    def __init__(self, biz_type=None, interval=None, output_file=None, save_type=None, scenes=None):
        self.biz_type = biz_type  # type: str
        self.interval = interval  # type: str
        self.output_file = output_file  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile
        self.save_type = save_type  # type: str
        self.scenes = scenes  # type: str

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.save_type is not None:
            result['SaveType'] = self.save_type
        if self.scenes is not None:
            result['Scenes'] = self.scenes
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OutputFile') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('SaveType') is not None:
            self.save_type = m.get('SaveType')
        if m.get('Scenes') is not None:
            self.scenes = m.get('Scenes')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter(TeaModel):
    def __init__(self, count=None, label=None):
        self.count = count  # type: int
        self.label = label  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.label is not None:
            result['Label'] = self.label
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList(TeaModel):
    def __init__(self, counter=None):
        self.counter = counter  # type: list[QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter]

    def validate(self):
        if self.counter:
            for k in self.counter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Counter'] = []
        if self.counter is not None:
            for k in self.counter:
                result['Counter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.counter = []
        if m.get('Counter') is not None:
            for k in m.get('Counter'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterListCounter()
                self.counter.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop(TeaModel):
    def __init__(self, index=None, label=None, object=None, score=None, timestamp=None):
        self.index = index  # type: str
        self.label = label  # type: str
        self.object = object  # type: str
        self.score = score  # type: str
        self.timestamp = timestamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.label is not None:
            result['Label'] = self.label
        if self.object is not None:
            result['Object'] = self.object
        if self.score is not None:
            result['Score'] = self.score
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList(TeaModel):
    def __init__(self, top=None):
        self.top = top  # type: list[QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop]

    def validate(self):
        if self.top:
            for k in self.top:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Top'] = []
        if self.top is not None:
            for k in self.top:
                result['Top'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.top = []
        if m.get('Top') is not None:
            for k in m.get('Top'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopListTop()
                self.top.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult(TeaModel):
    def __init__(self, average_score=None, label=None, max_score=None, porn_counter_list=None, porn_top_list=None,
                 suggestion=None):
        self.average_score = average_score  # type: str
        self.label = label  # type: str
        self.max_score = max_score  # type: str
        self.porn_counter_list = porn_counter_list  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList
        self.porn_top_list = porn_top_list  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList
        self.suggestion = suggestion  # type: str

    def validate(self):
        if self.porn_counter_list:
            self.porn_counter_list.validate()
        if self.porn_top_list:
            self.porn_top_list.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_score is not None:
            result['AverageScore'] = self.average_score
        if self.label is not None:
            result['Label'] = self.label
        if self.max_score is not None:
            result['MaxScore'] = self.max_score
        if self.porn_counter_list is not None:
            result['PornCounterList'] = self.porn_counter_list.to_map()
        if self.porn_top_list is not None:
            result['PornTopList'] = self.porn_top_list.to_map()
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AverageScore') is not None:
            self.average_score = m.get('AverageScore')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('MaxScore') is not None:
            self.max_score = m.get('MaxScore')
        if m.get('PornCounterList') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornCounterList()
            self.porn_counter_list = temp_model.from_map(m['PornCounterList'])
        if m.get('PornTopList') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorPornResultPornTopList()
            self.porn_top_list = temp_model.from_map(m['PornTopList'])
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter(TeaModel):
    def __init__(self, count=None, label=None):
        self.count = count  # type: int
        self.label = label  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.label is not None:
            result['Label'] = self.label
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList(TeaModel):
    def __init__(self, counter=None):
        self.counter = counter  # type: list[QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter]

    def validate(self):
        if self.counter:
            for k in self.counter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Counter'] = []
        if self.counter is not None:
            for k in self.counter:
                result['Counter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.counter = []
        if m.get('Counter') is not None:
            for k in m.get('Counter'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterListCounter()
                self.counter.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop(TeaModel):
    def __init__(self, index=None, label=None, object=None, score=None, timestamp=None):
        self.index = index  # type: str
        self.label = label  # type: str
        self.object = object  # type: str
        self.score = score  # type: str
        self.timestamp = timestamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.index is not None:
            result['Index'] = self.index
        if self.label is not None:
            result['Label'] = self.label
        if self.object is not None:
            result['Object'] = self.object
        if self.score is not None:
            result['Score'] = self.score
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Score') is not None:
            self.score = m.get('Score')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList(TeaModel):
    def __init__(self, top=None):
        self.top = top  # type: list[QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop]

    def validate(self):
        if self.top:
            for k in self.top:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Top'] = []
        if self.top is not None:
            for k in self.top:
                result['Top'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.top = []
        if m.get('Top') is not None:
            for k in m.get('Top'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopListTop()
                self.top.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult(TeaModel):
    def __init__(self, average_score=None, label=None, max_score=None, suggestion=None, terrorism_counter_list=None,
                 terrorism_top_list=None):
        self.average_score = average_score  # type: str
        self.label = label  # type: str
        self.max_score = max_score  # type: str
        self.suggestion = suggestion  # type: str
        self.terrorism_counter_list = terrorism_counter_list  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList
        self.terrorism_top_list = terrorism_top_list  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList

    def validate(self):
        if self.terrorism_counter_list:
            self.terrorism_counter_list.validate()
        if self.terrorism_top_list:
            self.terrorism_top_list.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_score is not None:
            result['AverageScore'] = self.average_score
        if self.label is not None:
            result['Label'] = self.label
        if self.max_score is not None:
            result['MaxScore'] = self.max_score
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.terrorism_counter_list is not None:
            result['TerrorismCounterList'] = self.terrorism_counter_list.to_map()
        if self.terrorism_top_list is not None:
            result['TerrorismTopList'] = self.terrorism_top_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AverageScore') is not None:
            self.average_score = m.get('AverageScore')
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('MaxScore') is not None:
            self.max_score = m.get('MaxScore')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TerrorismCounterList') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismCounterList()
            self.terrorism_counter_list = temp_model.from_map(m['TerrorismCounterList'])
        if m.get('TerrorismTopList') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResultTerrorismTopList()
            self.terrorism_top_list = temp_model.from_map(m['TerrorismTopList'])
        return self


class QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult(TeaModel):
    def __init__(self, image_bucket=None, image_location=None, image_object=None, result=None):
        self.image_bucket = image_bucket  # type: str
        self.image_location = image_location  # type: str
        self.image_object = image_object  # type: str
        self.result = result  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_bucket is not None:
            result['ImageBucket'] = self.image_bucket
        if self.image_location is not None:
            result['ImageLocation'] = self.image_location
        if self.image_object is not None:
            result['ImageObject'] = self.image_object
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageBucket') is not None:
            self.image_bucket = m.get('ImageBucket')
        if m.get('ImageLocation') is not None:
            self.image_location = m.get('ImageLocation')
        if m.get('ImageObject') is not None:
            self.image_object = m.get('ImageObject')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults(TeaModel):
    def __init__(self, image_censor_result=None):
        self.image_censor_result = image_censor_result  # type: list[QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult]

    def validate(self):
        if self.image_censor_result:
            for k in self.image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageCensorResult'] = []
        if self.image_censor_result is not None:
            for k in self.image_censor_result:
                result['ImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_censor_result = []
        if m.get('ImageCensorResult') is not None:
            for k in m.get('ImageCensorResult'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJobImageCensorResultsImageCensorResult()
                self.image_censor_result.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyJobsCensorJobInput(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryCensorJobListResponseBodyJobsCensorJob(TeaModel):
    def __init__(self, barrage_censor_result=None, censor_config=None, censor_porn_result=None,
                 censor_terrorism_result=None, code=None, creation_time=None, desc_censor_result=None, id=None, image_censor_results=None,
                 input=None, message=None, pipeline_id=None, result_save_object=None, state=None,
                 title_censor_result=None, user_data=None):
        self.barrage_censor_result = barrage_censor_result  # type: str
        self.censor_config = censor_config  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorConfig
        self.censor_porn_result = censor_porn_result  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult
        self.censor_terrorism_result = censor_terrorism_result  # type: QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult
        self.code = code  # type: str
        self.creation_time = creation_time  # type: str
        self.desc_censor_result = desc_censor_result  # type: str
        self.id = id  # type: str
        self.image_censor_results = image_censor_results  # type: QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults
        self.input = input  # type: QueryCensorJobListResponseBodyJobsCensorJobInput
        self.message = message  # type: str
        self.pipeline_id = pipeline_id  # type: str
        self.result_save_object = result_save_object  # type: str
        self.state = state  # type: str
        self.title_censor_result = title_censor_result  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.censor_config:
            self.censor_config.validate()
        if self.censor_porn_result:
            self.censor_porn_result.validate()
        if self.censor_terrorism_result:
            self.censor_terrorism_result.validate()
        if self.image_censor_results:
            self.image_censor_results.validate()
        if self.input:
            self.input.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobsCensorJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result
        if self.censor_config is not None:
            result['CensorConfig'] = self.censor_config.to_map()
        if self.censor_porn_result is not None:
            result['CensorPornResult'] = self.censor_porn_result.to_map()
        if self.censor_terrorism_result is not None:
            result['CensorTerrorismResult'] = self.censor_terrorism_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result
        if self.id is not None:
            result['Id'] = self.id
        if self.image_censor_results is not None:
            result['ImageCensorResults'] = self.image_censor_results.to_map()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.result_save_object is not None:
            result['ResultSaveObject'] = self.result_save_object
        if self.state is not None:
            result['State'] = self.state
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BarrageCensorResult') is not None:
            self.barrage_censor_result = m.get('BarrageCensorResult')
        if m.get('CensorConfig') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorConfig()
            self.censor_config = temp_model.from_map(m['CensorConfig'])
        if m.get('CensorPornResult') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorPornResult()
            self.censor_porn_result = temp_model.from_map(m['CensorPornResult'])
        if m.get('CensorTerrorismResult') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobCensorTerrorismResult()
            self.censor_terrorism_result = temp_model.from_map(m['CensorTerrorismResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            self.desc_censor_result = m.get('DescCensorResult')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('ImageCensorResults') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobImageCensorResults()
            self.image_censor_results = temp_model.from_map(m['ImageCensorResults'])
        if m.get('Input') is not None:
            temp_model = QueryCensorJobListResponseBodyJobsCensorJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('ResultSaveObject') is not None:
            self.result_save_object = m.get('ResultSaveObject')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('TitleCensorResult') is not None:
            self.title_censor_result = m.get('TitleCensorResult')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryCensorJobListResponseBodyJobs(TeaModel):
    def __init__(self, censor_job=None):
        self.censor_job = censor_job  # type: list[QueryCensorJobListResponseBodyJobsCensorJob]

    def validate(self):
        if self.censor_job:
            for k in self.censor_job:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorJob'] = []
        if self.censor_job is not None:
            for k in self.censor_job:
                result['CensorJob'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.censor_job = []
        if m.get('CensorJob') is not None:
            for k in m.get('CensorJob'):
                temp_model = QueryCensorJobListResponseBodyJobsCensorJob()
                self.censor_job.append(temp_model.from_map(k))
        return self


class QueryCensorJobListResponseBodyNonExistIds(TeaModel):
    def __init__(self, string=None):
        self.string = string  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryCensorJobListResponseBodyNonExistIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class QueryCensorJobListResponseBody(TeaModel):
    def __init__(self, jobs=None, non_exist_ids=None, request_id=None):
        self.jobs = jobs  # type: QueryCensorJobListResponseBodyJobs
        self.non_exist_ids = non_exist_ids  # type: QueryCensorJobListResponseBodyNonExistIds
        self.request_id = request_id  # type: str

    def validate(self):
        if self.jobs:
            self.jobs.validate()
        if self.non_exist_ids:
            self.non_exist_ids.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.jobs is not None:
            result['Jobs'] = self.jobs.to_map()
        if self.non_exist_ids is not None:
            result['NonExistIds'] = self.non_exist_ids.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Jobs') is not None:
            temp_model = QueryCensorJobListResponseBodyJobs()
            self.jobs = temp_model.from_map(m['Jobs'])
        if m.get('NonExistIds') is not None:
            temp_model = QueryCensorJobListResponseBodyNonExistIds()
            self.non_exist_ids = temp_model.from_map(m['NonExistIds'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryCensorJobListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryCensorJobListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryCensorJobListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryCensorJobListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryIProductionJobRequest(TeaModel):
    def __init__(self, client_token=None, job_id=None):
        # 幂等参数
        self.client_token = client_token  # type: str
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryIProductionJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class QueryIProductionJobResponseBodyInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryIProductionJobResponseBodyInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryIProductionJobResponseBodyOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryIProductionJobResponseBodyOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class QueryIProductionJobResponseBodyScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        self.pipeline_id = pipeline_id  # type: str
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryIProductionJobResponseBodyScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class QueryIProductionJobResponseBody(TeaModel):
    def __init__(self, create_time=None, finish_time=None, function_name=None, input=None, job_id=None,
                 job_params=None, name=None, output=None, output_files=None, output_urls=None, request_id=None, result=None,
                 schedule_config=None, status=None, template_id=None, user_data=None):
        self.create_time = create_time  # type: str
        self.finish_time = finish_time  # type: str
        self.function_name = function_name  # type: str
        self.input = input  # type: QueryIProductionJobResponseBodyInput
        self.job_id = job_id  # type: str
        self.job_params = job_params  # type: str
        self.name = name  # type: str
        self.output = output  # type: QueryIProductionJobResponseBodyOutput
        self.output_files = output_files  # type: list[str]
        self.output_urls = output_urls  # type: list[str]
        # Id of the request
        self.request_id = request_id  # type: str
        self.result = result  # type: str
        self.schedule_config = schedule_config  # type: QueryIProductionJobResponseBodyScheduleConfig
        self.status = status  # type: str
        self.template_id = template_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(QueryIProductionJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.output_files is not None:
            result['OutputFiles'] = self.output_files
        if self.output_urls is not None:
            result['OutputUrls'] = self.output_urls
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            temp_model = QueryIProductionJobResponseBodyInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = QueryIProductionJobResponseBodyOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('OutputFiles') is not None:
            self.output_files = m.get('OutputFiles')
        if m.get('OutputUrls') is not None:
            self.output_urls = m.get('OutputUrls')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('ScheduleConfig') is not None:
            temp_model = QueryIProductionJobResponseBodyScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class QueryIProductionJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryIProductionJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryIProductionJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class QueryMediaCensorJobDetailRequest(TeaModel):
    def __init__(self, job_id=None, maximum_page_size=None, next_page_token=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.job_id = job_id  # type: str
        self.maximum_page_size = maximum_page_size  # type: long
        self.next_page_token = next_page_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.maximum_page_size is not None:
            result['MaximumPageSize'] = self.maximum_page_size
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MaximumPageSize') is not None:
            self.maximum_page_size = m.get('MaximumPageSize')
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults(TeaModel):
    def __init__(self, result=None):
        self.result = result  # type: list[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult]

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult(TeaModel):
    def __init__(self, bucket=None, location=None, object=None, results=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str
        self.results = results  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        if self.results is not None:
            result['Results'] = self.results.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Results') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResultResults()
            self.results = temp_model.from_map(m['Results'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults(TeaModel):
    def __init__(self, cover_image_censor_result=None):
        self.cover_image_censor_result = cover_image_censor_result  # type: list[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult]

    def validate(self):
        if self.cover_image_censor_result:
            for k in self.cover_image_censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoverImageCensorResult'] = []
        if self.cover_image_censor_result is not None:
            for k in self.cover_image_censor_result:
                result['CoverImageCensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cover_image_censor_result = []
        if m.get('CoverImageCensorResult') is not None:
            for k in m.get('CoverImageCensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResultsCoverImageCensorResult()
                self.cover_image_censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults(TeaModel):
    def __init__(self, censor_result=None):
        self.censor_result = censor_result  # type: list[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult]

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult(TeaModel):
    def __init__(self, label=None, rate=None, scene=None, suggestion=None):
        self.label = label  # type: str
        self.rate = rate  # type: str
        self.scene = scene  # type: str
        self.suggestion = suggestion  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.rate is not None:
            result['Rate'] = self.rate
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Rate') is not None:
            self.rate = m.get('Rate')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults(TeaModel):
    def __init__(self, censor_result=None):
        self.censor_result = censor_result  # type: list[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult]

    def validate(self):
        if self.censor_result:
            for k in self.censor_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CensorResult'] = []
        if self.censor_result is not None:
            for k in self.censor_result:
                result['CensorResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.censor_result = []
        if m.get('CensorResult') is not None:
            for k in m.get('CensorResult'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResultsCensorResult()
                self.censor_result.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline(TeaModel):
    def __init__(self, censor_results=None, object=None, timestamp=None):
        self.censor_results = censor_results  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults
        self.object = object  # type: str
        self.timestamp = timestamp  # type: str

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.object is not None:
            result['Object'] = self.object
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimelineCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('Object') is not None:
            self.object = m.get('Object')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines(TeaModel):
    def __init__(self, video_timeline=None):
        self.video_timeline = video_timeline  # type: list[QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline]

    def validate(self):
        if self.video_timeline:
            for k in self.video_timeline:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VideoTimeline'] = []
        if self.video_timeline is not None:
            for k in self.video_timeline:
                result['VideoTimeline'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.video_timeline = []
        if m.get('VideoTimeline') is not None:
            for k in m.get('VideoTimeline'):
                temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelinesVideoTimeline()
                self.video_timeline.append(temp_model.from_map(k))
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult(TeaModel):
    def __init__(self, censor_results=None, next_page_token=None, video_timelines=None):
        self.censor_results = censor_results  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults
        self.next_page_token = next_page_token  # type: str
        self.video_timelines = video_timelines  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines

    def validate(self):
        if self.censor_results:
            self.censor_results.validate()
        if self.video_timelines:
            self.video_timelines.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.censor_results is not None:
            result['CensorResults'] = self.censor_results.to_map()
        if self.next_page_token is not None:
            result['NextPageToken'] = self.next_page_token
        if self.video_timelines is not None:
            result['VideoTimelines'] = self.video_timelines.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultCensorResults()
            self.censor_results = temp_model.from_map(m['CensorResults'])
        if m.get('NextPageToken') is not None:
            self.next_page_token = m.get('NextPageToken')
        if m.get('VideoTimelines') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResultVideoTimelines()
            self.video_timelines = temp_model.from_map(m['VideoTimelines'])
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile(TeaModel):
    def __init__(self, bucket=None, location=None, object=None):
        self.bucket = bucket  # type: str
        self.location = location  # type: str
        self.object = object  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.location is not None:
            result['Location'] = self.location
        if self.object is not None:
            result['Object'] = self.object
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Object') is not None:
            self.object = m.get('Object')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig(TeaModel):
    def __init__(self, biz_type=None, output_file=None, video_censor=None):
        self.biz_type = biz_type  # type: str
        self.output_file = output_file  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile
        self.video_censor = video_censor  # type: str

    def validate(self):
        if self.output_file:
            self.output_file.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz_type is not None:
            result['BizType'] = self.biz_type
        if self.output_file is not None:
            result['OutputFile'] = self.output_file.to_map()
        if self.video_censor is not None:
            result['VideoCensor'] = self.video_censor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BizType') is not None:
            self.biz_type = m.get('BizType')
        if m.get('OutputFile') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfigOutputFile()
            self.output_file = temp_model.from_map(m['OutputFile'])
        if m.get('VideoCensor') is not None:
            self.video_censor = m.get('VideoCensor')
        return self


class QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail(TeaModel):
    def __init__(self, barrage_censor_result=None, code=None, cover_image_censor_results=None, creation_time=None,
                 desc_censor_result=None, finish_time=None, input=None, job_id=None, message=None, pipeline_id=None, state=None,
                 suggestion=None, title_censor_result=None, user_data=None, vensor_censor_result=None,
                 video_censor_config=None):
        self.barrage_censor_result = barrage_censor_result  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult
        self.code = code  # type: str
        self.cover_image_censor_results = cover_image_censor_results  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults
        self.creation_time = creation_time  # type: str
        self.desc_censor_result = desc_censor_result  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult
        self.finish_time = finish_time  # type: str
        self.input = input  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput
        self.job_id = job_id  # type: str
        self.message = message  # type: str
        self.pipeline_id = pipeline_id  # type: str
        self.state = state  # type: str
        self.suggestion = suggestion  # type: str
        self.title_censor_result = title_censor_result  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult
        self.user_data = user_data  # type: str
        self.vensor_censor_result = vensor_censor_result  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult
        self.video_censor_config = video_censor_config  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig

    def validate(self):
        if self.barrage_censor_result:
            self.barrage_censor_result.validate()
        if self.cover_image_censor_results:
            self.cover_image_censor_results.validate()
        if self.desc_censor_result:
            self.desc_censor_result.validate()
        if self.input:
            self.input.validate()
        if self.title_censor_result:
            self.title_censor_result.validate()
        if self.vensor_censor_result:
            self.vensor_censor_result.validate()
        if self.video_censor_config:
            self.video_censor_config.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrage_censor_result is not None:
            result['BarrageCensorResult'] = self.barrage_censor_result.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.cover_image_censor_results is not None:
            result['CoverImageCensorResults'] = self.cover_image_censor_results.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desc_censor_result is not None:
            result['DescCensorResult'] = self.desc_censor_result.to_map()
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.message is not None:
            result['Message'] = self.message
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.state is not None:
            result['State'] = self.state
        if self.suggestion is not None:
            result['Suggestion'] = self.suggestion
        if self.title_censor_result is not None:
            result['TitleCensorResult'] = self.title_censor_result.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.vensor_censor_result is not None:
            result['VensorCensorResult'] = self.vensor_censor_result.to_map()
        if self.video_censor_config is not None:
            result['VideoCensorConfig'] = self.video_censor_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BarrageCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailBarrageCensorResult()
            self.barrage_censor_result = temp_model.from_map(m['BarrageCensorResult'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CoverImageCensorResults') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailCoverImageCensorResults()
            self.cover_image_censor_results = temp_model.from_map(m['CoverImageCensorResults'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DescCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailDescCensorResult()
            self.desc_censor_result = temp_model.from_map(m['DescCensorResult'])
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Suggestion') is not None:
            self.suggestion = m.get('Suggestion')
        if m.get('TitleCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailTitleCensorResult()
            self.title_censor_result = temp_model.from_map(m['TitleCensorResult'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VensorCensorResult') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVensorCensorResult()
            self.vensor_censor_result = temp_model.from_map(m['VensorCensorResult'])
        if m.get('VideoCensorConfig') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetailVideoCensorConfig()
            self.video_censor_config = temp_model.from_map(m['VideoCensorConfig'])
        return self


class QueryMediaCensorJobDetailResponseBody(TeaModel):
    def __init__(self, media_censor_job_detail=None, request_id=None):
        self.media_censor_job_detail = media_censor_job_detail  # type: QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_censor_job_detail:
            self.media_censor_job_detail.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_censor_job_detail is not None:
            result['MediaCensorJobDetail'] = self.media_censor_job_detail.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaCensorJobDetail') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBodyMediaCensorJobDetail()
            self.media_censor_job_detail = temp_model.from_map(m['MediaCensorJobDetail'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class QueryMediaCensorJobDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: QueryMediaCensorJobDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(QueryMediaCensorJobDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = QueryMediaCensorJobDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RefreshUploadMediaRequest(TeaModel):
    def __init__(self, media_id=None):
        self.media_id = media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshUploadMediaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class RefreshUploadMediaResponseBody(TeaModel):
    def __init__(self, media_id=None, request_id=None, upload_address=None, upload_auth=None):
        self.media_id = media_id  # type: str
        # RequestId
        self.request_id = request_id  # type: str
        self.upload_address = upload_address  # type: str
        self.upload_auth = upload_auth  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RefreshUploadMediaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.upload_address is not None:
            result['UploadAddress'] = self.upload_address
        if self.upload_auth is not None:
            result['UploadAuth'] = self.upload_auth
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UploadAddress') is not None:
            self.upload_address = m.get('UploadAddress')
        if m.get('UploadAuth') is not None:
            self.upload_auth = m.get('UploadAuth')
        return self


class RefreshUploadMediaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RefreshUploadMediaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RefreshUploadMediaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RefreshUploadMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterMediaInfoRequest(TeaModel):
    def __init__(self, business_type=None, cate_id=None, client_token=None, cover_url=None, description=None,
                 input_url=None, media_tags=None, media_type=None, overwrite=None, register_config=None, title=None,
                 user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.cate_id = cate_id  # type: long
        # 客户端token
        self.client_token = client_token  # type: str
        # 封面图，仅视频媒资有效
        self.cover_url = cover_url  # type: str
        # 描述
        self.description = description  # type: str
        # 媒资媒体url
        self.input_url = input_url  # type: str
        # 标签,如果有多个标签用逗号隔开
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 是否覆盖已有媒资
        self.overwrite = overwrite  # type: bool
        # 注册媒资的配置
        self.register_config = register_config  # type: str
        # 标题
        self.title = title  # type: str
        # 用户数据，最大1024字节
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterMediaInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.register_config is not None:
            result['RegisterConfig'] = self.register_config
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('RegisterConfig') is not None:
            self.register_config = m.get('RegisterConfig')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class RegisterMediaInfoResponseBody(TeaModel):
    def __init__(self, media_id=None, request_id=None):
        # ICE媒资ID
        self.media_id = media_id  # type: str
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterMediaInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterMediaInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RegisterMediaInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RegisterMediaInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RegisterMediaStreamRequest(TeaModel):
    def __init__(self, input_url=None, media_id=None, user_data=None):
        self.input_url = input_url  # type: str
        self.media_id = media_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterMediaStreamRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class RegisterMediaStreamResponseBody(TeaModel):
    def __init__(self, media_id=None, request_id=None):
        self.media_id = media_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RegisterMediaStreamResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RegisterMediaStreamResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RegisterMediaStreamResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RegisterMediaStreamResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RegisterMediaStreamResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchEditingProjectRequest(TeaModel):
    def __init__(self, create_source=None, end_time=None, max_results=None, next_token=None, project_type=None,
                 sort_by=None, start_time=None, status=None, template_type=None):
        # 创建来源
        self.create_source = create_source  # type: str
        # CreationTime（创建时间）的结束时间
        self.end_time = end_time  # type: str
        # 分页参数
        self.max_results = max_results  # type: long
        # 分页参数
        self.next_token = next_token  # type: str
        self.project_type = project_type  # type: str
        # 结果排序方式
        self.sort_by = sort_by  # type: str
        # CreateTime（创建时间）的开始时间
        self.start_time = start_time  # type: str
        # 云剪辑工程状态。多个用逗号分隔
        self.status = status  # type: str
        # 模板类型
        self.template_type = template_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchEditingProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        return self


class SearchEditingProjectResponseBodyProjectList(TeaModel):
    def __init__(self, business_config=None, business_status=None, cover_url=None, create_source=None,
                 create_time=None, description=None, duration=None, error_code=None, error_message=None, modified_source=None,
                 modified_time=None, project_id=None, project_type=None, status=None, template_type=None, timeline=None,
                 title=None):
        self.business_config = business_config  # type: str
        self.business_status = business_status  # type: str
        # 云剪辑工程封面
        self.cover_url = cover_url  # type: str
        # 创建来源
        self.create_source = create_source  # type: str
        # 云剪辑工程创建时间
        self.create_time = create_time  # type: str
        # 云剪辑工程描述
        self.description = description  # type: str
        # 云剪辑工程总时长
        self.duration = duration  # type: long
        # 云剪辑工程合成失败的错误码
        self.error_code = error_code  # type: str
        # 云剪辑工程合成失败的消息
        self.error_message = error_message  # type: str
        # 最后一次修改来源
        self.modified_source = modified_source  # type: str
        # 云剪辑工程最新修改时间
        self.modified_time = modified_time  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str
        self.project_type = project_type  # type: str
        # 云剪辑工程状态
        self.status = status  # type: str
        # 模板类型
        self.template_type = template_type  # type: str
        # 云剪辑工程时间线
        self.timeline = timeline  # type: str
        # 云剪辑工程标题
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchEditingProjectResponseBodyProjectList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_config is not None:
            result['BusinessConfig'] = self.business_config
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_source is not None:
            result['CreateSource'] = self.create_source
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.modified_source is not None:
            result['ModifiedSource'] = self.modified_source
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_type is not None:
            result['ProjectType'] = self.project_type
        if self.status is not None:
            result['Status'] = self.status
        if self.template_type is not None:
            result['TemplateType'] = self.template_type
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessConfig') is not None:
            self.business_config = m.get('BusinessConfig')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateSource') is not None:
            self.create_source = m.get('CreateSource')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('ModifiedSource') is not None:
            self.modified_source = m.get('ModifiedSource')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectType') is not None:
            self.project_type = m.get('ProjectType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateType') is not None:
            self.template_type = m.get('TemplateType')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class SearchEditingProjectResponseBody(TeaModel):
    def __init__(self, max_results=None, next_token=None, project_list=None, request_id=None, total_count=None):
        # 云剪辑工程总数
        self.max_results = max_results  # type: long
        self.next_token = next_token  # type: str
        # 云剪辑工程列表
        self.project_list = project_list  # type: list[SearchEditingProjectResponseBodyProjectList]
        # Id of the request
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        if self.project_list:
            for k in self.project_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchEditingProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['ProjectList'] = []
        if self.project_list is not None:
            for k in self.project_list:
                result['ProjectList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.project_list = []
        if m.get('ProjectList') is not None:
            for k in m.get('ProjectList'):
                temp_model = SearchEditingProjectResponseBodyProjectList()
                self.project_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchEditingProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchEditingProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchEditingProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchMediaRequest(TeaModel):
    def __init__(self, entity_id=None, match=None, page_no=None, page_size=None, sort_by=None):
        # 实体Id
        self.entity_id = entity_id  # type: str
        # 过滤条件
        self.match = match  # type: str
        # 当前页码。默认值为1
        self.page_no = page_no  # type: int
        # 每页返回的数据条数。默认值为10，最大值为100
        self.page_size = page_size  # type: int
        # 排序字段和排序顺序。多个使用英文逗号（,）分隔
        self.sort_by = sort_by  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchMediaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.match is not None:
            result['Match'] = self.match
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('Match') is not None:
            self.match = m.get('Match')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, create_time=None, duration=None, file_name=None, file_size=None,
                 file_status=None, file_type=None, file_url=None, format_name=None, height=None, modified_time=None, region=None,
                 width=None):
        # 码率
        self.bitrate = bitrate  # type: str
        self.create_time = create_time  # type: str
        # 时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小（字节）
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        self.file_type = file_type  # type: str
        # 文件oss地址
        self.file_url = file_url  # type: str
        # 封装格式
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        self.modified_time = modified_time  # type: str
        # 文件存储区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SearchMediaResponseBodyMediaInfoListFileInfoList(TeaModel):
    def __init__(self, file_basic_info=None):
        # 文件基础信息，包含时长，大小等
        self.file_basic_info = file_basic_info  # type: SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo

    def validate(self):
        if self.file_basic_info:
            self.file_basic_info.validate()

    def to_map(self):
        _map = super(SearchMediaResponseBodyMediaInfoListFileInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileBasicInfo') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListFileInfoListFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        return self


class SearchMediaResponseBodyMediaInfoListMediaBasicInfo(TeaModel):
    def __init__(self, biz=None, business_type=None, cate_id=None, cate_name=None, category=None, cover_url=None,
                 create_time=None, deleted_time=None, description=None, input_url=None, media_id=None, media_tags=None,
                 media_type=None, modified_time=None, snapshots=None, source=None, sprite_images=None, status=None, title=None,
                 transcode_status=None, upload_source=None, user_data=None):
        self.biz = biz  # type: str
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # 待注册的媒资在相应系统中的地址
        self.input_url = input_url  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 截图
        self.snapshots = snapshots  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 转码状态
        self.transcode_status = transcode_status  # type: str
        self.upload_source = upload_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchMediaResponseBodyMediaInfoListMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.biz is not None:
            result['Biz'] = self.biz
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.transcode_status is not None:
            result['TranscodeStatus'] = self.transcode_status
        if self.upload_source is not None:
            result['UploadSource'] = self.upload_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Biz') is not None:
            self.biz = m.get('Biz')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Snapshots') is not None:
            self.snapshots = m.get('Snapshots')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('TranscodeStatus') is not None:
            self.transcode_status = m.get('TranscodeStatus')
        if m.get('UploadSource') is not None:
            self.upload_source = m.get('UploadSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SearchMediaResponseBodyMediaInfoList(TeaModel):
    def __init__(self, file_info_list=None, media_basic_info=None, media_id=None):
        # FileInfos
        self.file_info_list = file_info_list  # type: list[SearchMediaResponseBodyMediaInfoListFileInfoList]
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: SearchMediaResponseBodyMediaInfoListMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.file_info_list:
            for k in self.file_info_list:
                if k:
                    k.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(SearchMediaResponseBodyMediaInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileInfoList'] = []
        if self.file_info_list is not None:
            for k in self.file_info_list:
                result['FileInfoList'].append(k.to_map() if k else None)
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_info_list = []
        if m.get('FileInfoList') is not None:
            for k in m.get('FileInfoList'):
                temp_model = SearchMediaResponseBodyMediaInfoListFileInfoList()
                self.file_info_list.append(temp_model.from_map(k))
        if m.get('MediaBasicInfo') is not None:
            temp_model = SearchMediaResponseBodyMediaInfoListMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchMediaResponseBody(TeaModel):
    def __init__(self, code=None, media_info_list=None, request_id=None, success=None, total=None):
        self.code = code  # type: str
        # 符合要求的媒资集合
        self.media_info_list = media_info_list  # type: list[SearchMediaResponseBodyMediaInfoList]
        self.request_id = request_id  # type: str
        self.success = success  # type: str
        self.total = total  # type: long

    def validate(self):
        if self.media_info_list:
            for k in self.media_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchMediaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['MediaInfoList'] = []
        if self.media_info_list is not None:
            for k in self.media_info_list:
                result['MediaInfoList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.media_info_list = []
        if m.get('MediaInfoList') is not None:
            for k in m.get('MediaInfoList'):
                temp_model = SearchMediaResponseBodyMediaInfoList()
                self.media_info_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class SearchMediaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchMediaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchMediaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchMediaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SearchPublicMediaInfoRequest(TeaModel):
    def __init__(self, authorized=None, dynamic_meta_data_match_fields=None, entity_id=None, favorite=None,
                 media_ids=None, page_no=None, page_size=None, sort_by=None):
        self.authorized = authorized  # type: bool
        self.dynamic_meta_data_match_fields = dynamic_meta_data_match_fields  # type: str
        self.entity_id = entity_id  # type: str
        self.favorite = favorite  # type: bool
        self.media_ids = media_ids  # type: str
        self.page_no = page_no  # type: int
        self.page_size = page_size  # type: int
        self.sort_by = sort_by  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchPublicMediaInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.dynamic_meta_data_match_fields is not None:
            result['DynamicMetaDataMatchFields'] = self.dynamic_meta_data_match_fields
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.favorite is not None:
            result['Favorite'] = self.favorite
        if self.media_ids is not None:
            result['MediaIds'] = self.media_ids
        if self.page_no is not None:
            result['PageNo'] = self.page_no
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.sort_by is not None:
            result['SortBy'] = self.sort_by
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('DynamicMetaDataMatchFields') is not None:
            self.dynamic_meta_data_match_fields = m.get('DynamicMetaDataMatchFields')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('Favorite') is not None:
            self.favorite = m.get('Favorite')
        if m.get('MediaIds') is not None:
            self.media_ids = m.get('MediaIds')
        if m.get('PageNo') is not None:
            self.page_no = m.get('PageNo')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('SortBy') is not None:
            self.sort_by = m.get('SortBy')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData(TeaModel):
    def __init__(self, data=None, type=None):
        self.data = data  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo(TeaModel):
    def __init__(self, business_type=None, category=None, cover_url=None, create_time=None, deleted_time=None,
                 description=None, media_id=None, media_tags=None, media_type=None, modified_time=None, source=None,
                 sprite_images=None, status=None, title=None, user_data=None):
        # 媒资业务类型
        self.business_type = business_type  # type: str
        # 分类
        self.category = category  # type: str
        # 封面地址
        self.cover_url = cover_url  # type: str
        # 媒资创建时间
        self.create_time = create_time  # type: str
        # 媒资删除时间
        self.deleted_time = deleted_time  # type: str
        # 内容描述
        self.description = description  # type: str
        # MediaId
        self.media_id = media_id  # type: str
        # 标签
        self.media_tags = media_tags  # type: str
        # 媒资媒体类型
        self.media_type = media_type  # type: str
        # 媒资修改时间
        self.modified_time = modified_time  # type: str
        # 来源
        self.source = source  # type: str
        # 雪碧图
        self.sprite_images = sprite_images  # type: str
        # 资源状态
        self.status = status  # type: str
        # 标题
        self.title = title  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.deleted_time is not None:
            result['DeletedTime'] = self.deleted_time
        if self.description is not None:
            result['Description'] = self.description
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.media_type is not None:
            result['MediaType'] = self.media_type
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.source is not None:
            result['Source'] = self.source
        if self.sprite_images is not None:
            result['SpriteImages'] = self.sprite_images
        if self.status is not None:
            result['Status'] = self.status
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DeletedTime') is not None:
            self.deleted_time = m.get('DeletedTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('MediaType') is not None:
            self.media_type = m.get('MediaType')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SpriteImages') is not None:
            self.sprite_images = m.get('SpriteImages')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo(TeaModel):
    def __init__(self, dynamic_meta_data=None, media_basic_info=None, media_id=None):
        self.dynamic_meta_data = dynamic_meta_data  # type: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData
        # BasicInfo
        self.media_basic_info = media_basic_info  # type: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo
        # 媒资ID
        self.media_id = media_id  # type: str

    def validate(self):
        if self.dynamic_meta_data:
            self.dynamic_meta_data.validate()
        if self.media_basic_info:
            self.media_basic_info.validate()

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_meta_data is not None:
            result['DynamicMetaData'] = self.dynamic_meta_data.to_map()
        if self.media_basic_info is not None:
            result['MediaBasicInfo'] = self.media_basic_info.to_map()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicMetaData') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoDynamicMetaData()
            self.dynamic_meta_data = temp_model.from_map(m['DynamicMetaData'])
        if m.get('MediaBasicInfo') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfoMediaBasicInfo()
            self.media_basic_info = temp_model.from_map(m['MediaBasicInfo'])
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        return self


class SearchPublicMediaInfoResponseBodyPublicMediaInfos(TeaModel):
    def __init__(self, authorized=None, favorite=None, media_info=None, remaining_auth_time=None):
        self.authorized = authorized  # type: bool
        self.favorite = favorite  # type: bool
        self.media_info = media_info  # type: SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo
        self.remaining_auth_time = remaining_auth_time  # type: str

    def validate(self):
        if self.media_info:
            self.media_info.validate()

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponseBodyPublicMediaInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorized is not None:
            result['Authorized'] = self.authorized
        if self.favorite is not None:
            result['Favorite'] = self.favorite
        if self.media_info is not None:
            result['MediaInfo'] = self.media_info.to_map()
        if self.remaining_auth_time is not None:
            result['RemainingAuthTime'] = self.remaining_auth_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Authorized') is not None:
            self.authorized = m.get('Authorized')
        if m.get('Favorite') is not None:
            self.favorite = m.get('Favorite')
        if m.get('MediaInfo') is not None:
            temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfosMediaInfo()
            self.media_info = temp_model.from_map(m['MediaInfo'])
        if m.get('RemainingAuthTime') is not None:
            self.remaining_auth_time = m.get('RemainingAuthTime')
        return self


class SearchPublicMediaInfoResponseBody(TeaModel):
    def __init__(self, public_media_infos=None, request_id=None, total_count=None):
        self.public_media_infos = public_media_infos  # type: list[SearchPublicMediaInfoResponseBodyPublicMediaInfos]
        # Id of the request
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: long

    def validate(self):
        if self.public_media_infos:
            for k in self.public_media_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PublicMediaInfos'] = []
        if self.public_media_infos is not None:
            for k in self.public_media_infos:
                result['PublicMediaInfos'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.public_media_infos = []
        if m.get('PublicMediaInfos') is not None:
            for k in m.get('PublicMediaInfos'):
                temp_model = SearchPublicMediaInfoResponseBodyPublicMediaInfos()
                self.public_media_infos.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class SearchPublicMediaInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SearchPublicMediaInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SearchPublicMediaInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SearchPublicMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendLiveTranscodeJobCommandRequest(TeaModel):
    def __init__(self, command=None, job_id=None):
        self.command = command  # type: str
        # 模板Id
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendLiveTranscodeJobCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class SendLiveTranscodeJobCommandResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendLiveTranscodeJobCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendLiveTranscodeJobCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SendLiveTranscodeJobCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SendLiveTranscodeJobCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendLiveTranscodeJobCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetAuditConfigRequest(TeaModel):
    def __init__(self, app_id=None, channel=None, legal_switch=None):
        self.app_id = app_id  # type: str
        self.channel = channel  # type: str
        self.legal_switch = legal_switch  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetAuditConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.channel is not None:
            result['Channel'] = self.channel
        if self.legal_switch is not None:
            result['LegalSwitch'] = self.legal_switch
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('Channel') is not None:
            self.channel = m.get('Channel')
        if m.get('LegalSwitch') is not None:
            self.legal_switch = m.get('LegalSwitch')
        return self


class SetAuditConfigResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # RequestId
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetAuditConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetAuditConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetAuditConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetAuditConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetAuditConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetClientConfigRequest(TeaModel):
    def __init__(self, bundle_id=None, client_upload_bucket=None, client_upload_path=None,
                 client_upload_storage_type=None, pkg_name=None, pkg_signature=None):
        # 云端配置所对应的IOS BundleId
        self.bundle_id = bundle_id  # type: str
        # 端侧上传存储Bucket信息
        self.client_upload_bucket = client_upload_bucket  # type: str
        # 端侧上传存储bucket下路径信息
        self.client_upload_path = client_upload_path  # type: str
        # 端侧上传存储类型，vod_oss_bucket: vod托管bucket，user_oss_bucket: 用户私有bucket
        self.client_upload_storage_type = client_upload_storage_type  # type: str
        # 云端配置所对应的安卓包名。
        self.pkg_name = pkg_name  # type: str
        # 云端配置所对应的安卓包签名，当包名不为空时，必填。
        self.pkg_signature = pkg_signature  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetClientConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.client_upload_bucket is not None:
            result['ClientUploadBucket'] = self.client_upload_bucket
        if self.client_upload_path is not None:
            result['ClientUploadPath'] = self.client_upload_path
        if self.client_upload_storage_type is not None:
            result['ClientUploadStorageType'] = self.client_upload_storage_type
        if self.pkg_name is not None:
            result['PkgName'] = self.pkg_name
        if self.pkg_signature is not None:
            result['PkgSignature'] = self.pkg_signature
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('ClientUploadBucket') is not None:
            self.client_upload_bucket = m.get('ClientUploadBucket')
        if m.get('ClientUploadPath') is not None:
            self.client_upload_path = m.get('ClientUploadPath')
        if m.get('ClientUploadStorageType') is not None:
            self.client_upload_storage_type = m.get('ClientUploadStorageType')
        if m.get('PkgName') is not None:
            self.pkg_name = m.get('PkgName')
        if m.get('PkgSignature') is not None:
            self.pkg_signature = m.get('PkgSignature')
        return self


class SetClientConfigResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # Id of the request
        self.request_id = request_id  # type: str
        # 配置是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetClientConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetClientConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetClientConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetClientConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetClientConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDefaultCustomTemplateRequest(TeaModel):
    def __init__(self, template_id=None):
        # 模板ID
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDefaultCustomTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SetDefaultCustomTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDefaultCustomTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDefaultCustomTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDefaultCustomTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDefaultCustomTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDefaultCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDefaultStorageLocationRequest(TeaModel):
    def __init__(self, bucket=None, path=None, storage_type=None):
        self.bucket = bucket  # type: str
        self.path = path  # type: str
        self.storage_type = storage_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDefaultStorageLocationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bucket is not None:
            result['Bucket'] = self.bucket
        if self.path is not None:
            result['Path'] = self.path
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bucket') is not None:
            self.bucket = m.get('Bucket')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class SetDefaultStorageLocationResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # Id of the request
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDefaultStorageLocationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetDefaultStorageLocationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDefaultStorageLocationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDefaultStorageLocationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDefaultStorageLocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetEventCallbackRequest(TeaModel):
    def __init__(self, auth_key=None, auth_switch=None, callback_queue_name=None, callback_type=None,
                 callback_url=None, event_type_list=None):
        self.auth_key = auth_key  # type: str
        self.auth_switch = auth_switch  # type: str
        self.callback_queue_name = callback_queue_name  # type: str
        self.callback_type = callback_type  # type: str
        self.callback_url = callback_url  # type: str
        self.event_type_list = event_type_list  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetEventCallbackRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auth_key is not None:
            result['AuthKey'] = self.auth_key
        if self.auth_switch is not None:
            result['AuthSwitch'] = self.auth_switch
        if self.callback_queue_name is not None:
            result['CallbackQueueName'] = self.callback_queue_name
        if self.callback_type is not None:
            result['CallbackType'] = self.callback_type
        if self.callback_url is not None:
            result['CallbackURL'] = self.callback_url
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthKey') is not None:
            self.auth_key = m.get('AuthKey')
        if m.get('AuthSwitch') is not None:
            self.auth_switch = m.get('AuthSwitch')
        if m.get('CallbackQueueName') is not None:
            self.callback_queue_name = m.get('CallbackQueueName')
        if m.get('CallbackType') is not None:
            self.callback_type = m.get('CallbackType')
        if m.get('CallbackURL') is not None:
            self.callback_url = m.get('CallbackURL')
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        return self


class SetEventCallbackResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # Id of the request
        self.request_id = request_id  # type: str
        # 是否设置成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetEventCallbackResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SetEventCallbackResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetEventCallbackResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetEventCallbackResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetEventCallbackResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitASRJobRequest(TeaModel):
    def __init__(self, description=None, duration=None, input_file=None, start_time=None, title=None, user_data=None):
        # 任务描述
        self.description = description  # type: str
        # 持续时间
        self.duration = duration  # type: str
        # 输入配置，支持OSS地址和内容库素材ID
        self.input_file = input_file  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 任务标题
        self.title = title  # type: str
        # 自定义设置，为JSON字符串
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitASRJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.input_file is not None:
            result['InputFile'] = self.input_file
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InputFile') is not None:
            self.input_file = m.get('InputFile')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitASRJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None, state=None):
        # 智能任务Id
        self.job_id = job_id  # type: str
        # 请求Id
        self.request_id = request_id  # type: str
        # 任务状态
        self.state = state  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitASRJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitASRJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitASRJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitASRJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitASRJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitAudioProduceJobRequest(TeaModel):
    def __init__(self, description=None, editing_config=None, input_config=None, output_config=None, overwrite=None,
                 title=None, user_data=None):
        # 任务描述
        self.description = description  # type: str
        # 音频生产配置
        self.editing_config = editing_config  # type: str
        # 文本内容。  最大支持300个汉字
        self.input_config = input_config  # type: str
        # 音频输出配置
        self.output_config = output_config  # type: str
        # 是否覆盖现有OSS文件
        self.overwrite = overwrite  # type: bool
        # 任务标题
        self.title = title  # type: str
        # 自定义数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitAudioProduceJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitAudioProduceJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None, state=None):
        # 任务ID
        self.job_id = job_id  # type: str
        # 请求Id
        self.request_id = request_id  # type: str
        # 任务状态
        self.state = state  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitAudioProduceJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class SubmitAudioProduceJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitAudioProduceJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitAudioProduceJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitAudioProduceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitBatchMediaProducingJobRequest(TeaModel):
    def __init__(self, client_token=None, clips_param=None, editing_produce_config=None, job_title=None,
                 output_media_config=None, output_media_target=None, output_num=None, project_metadata=None, source=None,
                 submit_by=None, template_id=None, user_data=None):
        # 调用方保证请求幂等性Client Token
        self.client_token = client_token  # type: str
        # 批量混剪ClipsParam
        self.clips_param = clips_param  # type: str
        # 剪辑合成配置
        self.editing_produce_config = editing_produce_config  # type: str
        # 任务名称
        self.job_title = job_title  # type: str
        # 用户合成输出配置
        self.output_media_config = output_media_config  # type: str
        # 用户合成输出目标
        self.output_media_target = output_media_target  # type: str
        # 批量混剪下合成成片的个数
        self.output_num = output_num  # type: int
        # 剪辑任务工程信息
        self.project_metadata = project_metadata  # type: str
        # 任务来源
        self.source = source  # type: str
        # 提交任务类型
        self.submit_by = submit_by  # type: str
        # 批量混剪模版id
        self.template_id = template_id  # type: str
        # 用户配置UserData
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitBatchMediaProducingJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.editing_produce_config is not None:
            result['EditingProduceConfig'] = self.editing_produce_config
        if self.job_title is not None:
            result['JobTitle'] = self.job_title
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.output_media_target is not None:
            result['OutputMediaTarget'] = self.output_media_target
        if self.output_num is not None:
            result['OutputNum'] = self.output_num
        if self.project_metadata is not None:
            result['ProjectMetadata'] = self.project_metadata
        if self.source is not None:
            result['Source'] = self.source
        if self.submit_by is not None:
            result['SubmitBy'] = self.submit_by
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('EditingProduceConfig') is not None:
            self.editing_produce_config = m.get('EditingProduceConfig')
        if m.get('JobTitle') is not None:
            self.job_title = m.get('JobTitle')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('OutputMediaTarget') is not None:
            self.output_media_target = m.get('OutputMediaTarget')
        if m.get('OutputNum') is not None:
            self.output_num = m.get('OutputNum')
        if m.get('ProjectMetadata') is not None:
            self.project_metadata = m.get('ProjectMetadata')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('SubmitBy') is not None:
            self.submit_by = m.get('SubmitBy')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitBatchMediaProducingJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        # 批量混剪任务jobId
        self.job_id = job_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitBatchMediaProducingJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitBatchMediaProducingJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitBatchMediaProducingJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitBatchMediaProducingJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitBatchMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDynamicChartJobRequest(TeaModel):
    def __init__(self, axis_params=None, background=None, chart_config=None, chart_title=None, chart_type=None,
                 data_source=None, description=None, input=None, output_config=None, subtitle=None, title=None, unit=None,
                 user_data=None):
        # 坐标样式。XAxisFontInterval不传或为0则算法自动计算间距
        self.axis_params = axis_params  # type: str
        # 图表背景
        self.background = background  # type: str
        # 图表配置
        self.chart_config = chart_config  # type: str
        # 主标题
        self.chart_title = chart_title  # type: str
        # 图表类型
        self.chart_type = chart_type  # type: str
        # 数据来源
        self.data_source = data_source  # type: str
        # 任务描述
        self.description = description  # type: str
        # 图表输入数据
        self.input = input  # type: str
        # 输出设置
        self.output_config = output_config  # type: str
        # 副标题
        self.subtitle = subtitle  # type: str
        # 任务标题
        self.title = title  # type: str
        # 单位
        self.unit = unit  # type: str
        # 自定义数据，JSON格式
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicChartJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.axis_params is not None:
            result['AxisParams'] = self.axis_params
        if self.background is not None:
            result['Background'] = self.background
        if self.chart_config is not None:
            result['ChartConfig'] = self.chart_config
        if self.chart_title is not None:
            result['ChartTitle'] = self.chart_title
        if self.chart_type is not None:
            result['ChartType'] = self.chart_type
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.subtitle is not None:
            result['Subtitle'] = self.subtitle
        if self.title is not None:
            result['Title'] = self.title
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AxisParams') is not None:
            self.axis_params = m.get('AxisParams')
        if m.get('Background') is not None:
            self.background = m.get('Background')
        if m.get('ChartConfig') is not None:
            self.chart_config = m.get('ChartConfig')
        if m.get('ChartTitle') is not None:
            self.chart_title = m.get('ChartTitle')
        if m.get('ChartType') is not None:
            self.chart_type = m.get('ChartType')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input = m.get('Input')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Subtitle') is not None:
            self.subtitle = m.get('Subtitle')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicChartJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        # 任务Id
        self.job_id = job_id  # type: str
        # 请求Id
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicChartJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitDynamicChartJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitDynamicChartJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitDynamicChartJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDynamicChartJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitDynamicImageJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitDynamicImageJobRequestOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitDynamicImageJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        self.pipeline_id = pipeline_id  # type: str
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan(TeaModel):
    def __init__(self, duration=None, end=None, seek=None):
        self.duration = duration  # type: str
        self.end = end  # type: str
        self.seek = seek  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.end is not None:
            result['End'] = self.end
        if self.seek is not None:
            result['Seek'] = self.seek
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Seek') is not None:
            self.seek = m.get('Seek')
        return self


class SubmitDynamicImageJobRequestTemplateConfigOverwriteParams(TeaModel):
    def __init__(self, format=None, fps=None, height=None, long_short_mode=None, scan_mode=None, time_span=None,
                 width=None):
        self.format = format  # type: str
        self.fps = fps  # type: int
        self.height = height  # type: int
        self.long_short_mode = long_short_mode  # type: bool
        self.scan_mode = scan_mode  # type: str
        # 时间线参数
        self.time_span = time_span  # type: SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan
        self.width = width  # type: int

    def validate(self):
        if self.time_span:
            self.time_span.validate()

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestTemplateConfigOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.time_span is not None:
            result['TimeSpan'] = self.time_span.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('TimeSpan') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfigOverwriteParamsTimeSpan()
            self.time_span = temp_model.from_map(m['TimeSpan'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitDynamicImageJobRequestTemplateConfig(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        self.overwrite_params = overwrite_params  # type: SubmitDynamicImageJobRequestTemplateConfigOverwriteParams
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequestTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfigOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitDynamicImageJobRequest(TeaModel):
    def __init__(self, input=None, name=None, output=None, schedule_config=None, template_config=None,
                 user_data=None):
        self.input = input  # type: SubmitDynamicImageJobRequestInput
        self.name = name  # type: str
        self.output = output  # type: SubmitDynamicImageJobRequestOutput
        self.schedule_config = schedule_config  # type: SubmitDynamicImageJobRequestScheduleConfig
        self.template_config = template_config  # type: SubmitDynamicImageJobRequestTemplateConfig
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super(SubmitDynamicImageJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitDynamicImageJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitDynamicImageJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitDynamicImageJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateConfig') is not None:
            temp_model = SubmitDynamicImageJobRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicImageJobShrinkRequest(TeaModel):
    def __init__(self, input_shrink=None, name=None, output_shrink=None, schedule_config_shrink=None,
                 template_config_shrink=None, user_data=None):
        self.input_shrink = input_shrink  # type: str
        self.name = name  # type: str
        self.output_shrink = output_shrink  # type: str
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        self.template_config_shrink = template_config_shrink  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitDynamicImageJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        self.job_id = job_id  # type: str
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitDynamicImageJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitDynamicImageJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitDynamicImageJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitDynamicImageJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitDynamicImageJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitIProductionJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitIProductionJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitIProductionJobRequestOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitIProductionJobRequestOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitIProductionJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        self.pipeline_id = pipeline_id  # type: str
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitIProductionJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitIProductionJobRequest(TeaModel):
    def __init__(self, function_name=None, input=None, job_params=None, name=None, output=None, schedule_config=None,
                 template_id=None, user_data=None):
        self.function_name = function_name  # type: str
        self.input = input  # type: SubmitIProductionJobRequestInput
        self.job_params = job_params  # type: str
        self.name = name  # type: str
        self.output = output  # type: SubmitIProductionJobRequestOutput
        self.schedule_config = schedule_config  # type: SubmitIProductionJobRequestScheduleConfig
        self.template_id = template_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitIProductionJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            temp_model = SubmitIProductionJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitIProductionJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitIProductionJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitIProductionJobShrinkRequest(TeaModel):
    def __init__(self, function_name=None, input_shrink=None, job_params=None, name=None, output_shrink=None,
                 schedule_config_shrink=None, template_id=None, user_data=None):
        self.function_name = function_name  # type: str
        self.input_shrink = input_shrink  # type: str
        self.job_params = job_params  # type: str
        self.name = name  # type: str
        self.output_shrink = output_shrink  # type: str
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        self.template_id = template_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitIProductionJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.job_params is not None:
            result['JobParams'] = self.job_params
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('JobParams') is not None:
            self.job_params = m.get('JobParams')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitIProductionJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        self.job_id = job_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitIProductionJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitIProductionJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitIProductionJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitIProductionJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitIProductionJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitLiveEditingJobRequest(TeaModel):
    def __init__(self, clips=None, live_stream_config=None, media_produce_config=None, output_media_config=None,
                 output_media_target=None, project_id=None, user_data=None):
        self.clips = clips  # type: str
        self.live_stream_config = live_stream_config  # type: str
        self.media_produce_config = media_produce_config  # type: str
        self.output_media_config = output_media_config  # type: str
        self.output_media_target = output_media_target  # type: str
        self.project_id = project_id  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitLiveEditingJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clips is not None:
            result['Clips'] = self.clips
        if self.live_stream_config is not None:
            result['LiveStreamConfig'] = self.live_stream_config
        if self.media_produce_config is not None:
            result['MediaProduceConfig'] = self.media_produce_config
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.output_media_target is not None:
            result['OutputMediaTarget'] = self.output_media_target
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Clips') is not None:
            self.clips = m.get('Clips')
        if m.get('LiveStreamConfig') is not None:
            self.live_stream_config = m.get('LiveStreamConfig')
        if m.get('MediaProduceConfig') is not None:
            self.media_produce_config = m.get('MediaProduceConfig')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('OutputMediaTarget') is not None:
            self.output_media_target = m.get('OutputMediaTarget')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitLiveEditingJobResponseBody(TeaModel):
    def __init__(self, job_id=None, media_id=None, media_url=None, project_id=None, request_id=None):
        self.job_id = job_id  # type: str
        self.media_id = media_id  # type: str
        self.media_url = media_url  # type: str
        self.project_id = project_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitLiveEditingJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_url is not None:
            result['MediaURL'] = self.media_url
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaURL') is not None:
            self.media_url = m.get('MediaURL')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitLiveEditingJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitLiveEditingJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitLiveEditingJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitLiveEditingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaCensorJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaCensorJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaCensorJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        self.pipeline_id = pipeline_id  # type: str
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaCensorJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaCensorJobRequest(TeaModel):
    def __init__(self, barrages=None, cover_images=None, description=None, input=None, notify_url=None, output=None,
                 schedule_config=None, template_id=None, title=None, user_data=None):
        self.barrages = barrages  # type: str
        self.cover_images = cover_images  # type: str
        self.description = description  # type: str
        self.input = input  # type: SubmitMediaCensorJobRequestInput
        self.notify_url = notify_url  # type: str
        self.output = output  # type: str
        self.schedule_config = schedule_config  # type: SubmitMediaCensorJobRequestScheduleConfig
        self.template_id = template_id  # type: str
        self.title = title  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitMediaCensorJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrages is not None:
            result['Barrages'] = self.barrages
        if self.cover_images is not None:
            result['CoverImages'] = self.cover_images
        if self.description is not None:
            result['Description'] = self.description
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.output is not None:
            result['Output'] = self.output
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Barrages') is not None:
            self.barrages = m.get('Barrages')
        if m.get('CoverImages') is not None:
            self.cover_images = m.get('CoverImages')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            temp_model = SubmitMediaCensorJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaCensorJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaCensorJobShrinkRequest(TeaModel):
    def __init__(self, barrages=None, cover_images=None, description=None, input_shrink=None, notify_url=None,
                 output=None, schedule_config_shrink=None, template_id=None, title=None, user_data=None):
        self.barrages = barrages  # type: str
        self.cover_images = cover_images  # type: str
        self.description = description  # type: str
        self.input_shrink = input_shrink  # type: str
        self.notify_url = notify_url  # type: str
        self.output = output  # type: str
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        self.template_id = template_id  # type: str
        self.title = title  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaCensorJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.barrages is not None:
            result['Barrages'] = self.barrages
        if self.cover_images is not None:
            result['CoverImages'] = self.cover_images
        if self.description is not None:
            result['Description'] = self.description
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.notify_url is not None:
            result['NotifyUrl'] = self.notify_url
        if self.output is not None:
            result['Output'] = self.output
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Barrages') is not None:
            self.barrages = m.get('Barrages')
        if m.get('CoverImages') is not None:
            self.cover_images = m.get('CoverImages')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('NotifyUrl') is not None:
            self.notify_url = m.get('NotifyUrl')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaCensorJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        self.job_id = job_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaCensorJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaCensorJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitMediaCensorJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitMediaCensorJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaCensorJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaInfoJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaInfoJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaInfoJobRequest(TeaModel):
    def __init__(self, input=None, name=None, schedule_config=None, user_data=None):
        # 任务输入
        self.input = input  # type: SubmitMediaInfoJobRequestInput
        # 任务名字
        self.name = name  # type: str
        # 调度参数
        self.schedule_config = schedule_config  # type: SubmitMediaInfoJobRequestScheduleConfig
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitMediaInfoJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaInfoJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobShrinkRequest(TeaModel):
    def __init__(self, input_shrink=None, name=None, schedule_config_shrink=None, user_data=None):
        # 任务输入
        self.input_shrink = input_shrink  # type: str
        # 任务名字
        self.name = name  # type: str
        # 调度参数
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(self, async=None, finish_time=None, input=None, job_id=None, media_info_property=None, name=None,
                 request_id=None, schedule_config=None, status=None, submit_result_json=None, submit_time=None,
                 trigger_source=None, user_data=None):
        # 是否异步处理
        self.async = async  # type: bool
        # 任务完成时间
        self.finish_time = finish_time  # type: str
        # 任务输入
        self.input = input  # type: SubmitMediaInfoJobResponseBodyMediaInfoJobInput
        # 任务 id
        self.job_id = job_id  # type: str
        # 媒体信息详情
        self.media_info_property = media_info_property  # type: SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty
        # 任务名字
        self.name = name  # type: str
        # 请求 id
        self.request_id = request_id  # type: str
        # 调度信息
        self.schedule_config = schedule_config  # type: SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig
        # 任务状态 - Init: 已提交, Success: 成功, Fail: 失败
        self.status = status  # type: str
        # 任务提交信息
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBodyMediaInfoJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaInfoJobResponseBody(TeaModel):
    def __init__(self, media_info_job=None, request_id=None):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job  # type: SubmitMediaInfoJobResponseBodyMediaInfoJob
        # 请求 id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitMediaInfoJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitMediaInfoJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitMediaInfoJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitMediaProducingJobRequest(TeaModel):
    def __init__(self, client_token=None, clips_param=None, editing_produce_config=None, output_media_config=None,
                 output_media_target=None, project_id=None, project_metadata=None, source=None, template_id=None, timeline=None,
                 user_data=None):
        self.client_token = client_token  # type: str
        self.clips_param = clips_param  # type: str
        self.editing_produce_config = editing_produce_config  # type: str
        self.output_media_config = output_media_config  # type: str
        self.output_media_target = output_media_target  # type: str
        self.project_id = project_id  # type: str
        self.project_metadata = project_metadata  # type: str
        self.source = source  # type: str
        self.template_id = template_id  # type: str
        self.timeline = timeline  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaProducingJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.editing_produce_config is not None:
            result['EditingProduceConfig'] = self.editing_produce_config
        if self.output_media_config is not None:
            result['OutputMediaConfig'] = self.output_media_config
        if self.output_media_target is not None:
            result['OutputMediaTarget'] = self.output_media_target
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.project_metadata is not None:
            result['ProjectMetadata'] = self.project_metadata
        if self.source is not None:
            result['Source'] = self.source
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('EditingProduceConfig') is not None:
            self.editing_produce_config = m.get('EditingProduceConfig')
        if m.get('OutputMediaConfig') is not None:
            self.output_media_config = m.get('OutputMediaConfig')
        if m.get('OutputMediaTarget') is not None:
            self.output_media_target = m.get('OutputMediaTarget')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('ProjectMetadata') is not None:
            self.project_metadata = m.get('ProjectMetadata')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitMediaProducingJobResponseBody(TeaModel):
    def __init__(self, job_id=None, media_id=None, project_id=None, request_id=None, vod_media_id=None):
        # 合成作业Id
        self.job_id = job_id  # type: str
        # 合成ICE媒资Id
        self.media_id = media_id  # type: str
        # 剪辑工程Id
        self.project_id = project_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str
        # vod媒资id
        self.vod_media_id = vod_media_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitMediaProducingJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vod_media_id is not None:
            result['VodMediaId'] = self.vod_media_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VodMediaId') is not None:
            self.vod_media_id = m.get('VodMediaId')
        return self


class SubmitMediaProducingJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitMediaProducingJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitMediaProducingJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitMediaProducingJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSnapshotJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSnapshotJobRequestOutput(TeaModel):
    def __init__(self, media=None, type=None):
        self.media = media  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSnapshotJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None):
        self.pipeline_id = pipeline_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        return self


class SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig(TeaModel):
    def __init__(self, cell_height=None, cell_width=None, color=None, columns=None, lines=None, margin=None,
                 padding=None):
        self.cell_height = cell_height  # type: int
        self.cell_width = cell_width  # type: int
        self.color = color  # type: str
        self.columns = columns  # type: int
        self.lines = lines  # type: int
        self.margin = margin  # type: int
        self.padding = padding  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cell_height is not None:
            result['CellHeight'] = self.cell_height
        if self.cell_width is not None:
            result['CellWidth'] = self.cell_width
        if self.color is not None:
            result['Color'] = self.color
        if self.columns is not None:
            result['Columns'] = self.columns
        if self.lines is not None:
            result['Lines'] = self.lines
        if self.margin is not None:
            result['Margin'] = self.margin
        if self.padding is not None:
            result['Padding'] = self.padding
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CellHeight') is not None:
            self.cell_height = m.get('CellHeight')
        if m.get('CellWidth') is not None:
            self.cell_width = m.get('CellWidth')
        if m.get('Color') is not None:
            self.color = m.get('Color')
        if m.get('Columns') is not None:
            self.columns = m.get('Columns')
        if m.get('Lines') is not None:
            self.lines = m.get('Lines')
        if m.get('Margin') is not None:
            self.margin = m.get('Margin')
        if m.get('Padding') is not None:
            self.padding = m.get('Padding')
        return self


class SubmitSnapshotJobRequestTemplateConfigOverwriteParams(TeaModel):
    def __init__(self, black_level=None, count=None, frame_type=None, height=None, interval=None, is_spt_frag=None,
                 pixel_black_threshold=None, sprite_snapshot_config=None, time=None, type=None, width=None):
        self.black_level = black_level  # type: int
        self.count = count  # type: long
        # 截图公共参数
        self.frame_type = frame_type  # type: str
        self.height = height  # type: int
        self.interval = interval  # type: long
        # Webvtt截图配置:是否拼合输出
        self.is_spt_frag = is_spt_frag  # type: bool
        self.pixel_black_threshold = pixel_black_threshold  # type: int
        # 雪碧图配置
        self.sprite_snapshot_config = sprite_snapshot_config  # type: SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig
        self.time = time  # type: long
        self.type = type  # type: str
        self.width = width  # type: int

    def validate(self):
        if self.sprite_snapshot_config:
            self.sprite_snapshot_config.validate()

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestTemplateConfigOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_level is not None:
            result['BlackLevel'] = self.black_level
        if self.count is not None:
            result['Count'] = self.count
        if self.frame_type is not None:
            result['FrameType'] = self.frame_type
        if self.height is not None:
            result['Height'] = self.height
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.is_spt_frag is not None:
            result['IsSptFrag'] = self.is_spt_frag
        if self.pixel_black_threshold is not None:
            result['PixelBlackThreshold'] = self.pixel_black_threshold
        if self.sprite_snapshot_config is not None:
            result['SpriteSnapshotConfig'] = self.sprite_snapshot_config.to_map()
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlackLevel') is not None:
            self.black_level = m.get('BlackLevel')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('FrameType') is not None:
            self.frame_type = m.get('FrameType')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IsSptFrag') is not None:
            self.is_spt_frag = m.get('IsSptFrag')
        if m.get('PixelBlackThreshold') is not None:
            self.pixel_black_threshold = m.get('PixelBlackThreshold')
        if m.get('SpriteSnapshotConfig') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfigOverwriteParamsSpriteSnapshotConfig()
            self.sprite_snapshot_config = temp_model.from_map(m['SpriteSnapshotConfig'])
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSnapshotJobRequestTemplateConfig(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        self.overwrite_params = overwrite_params  # type: SubmitSnapshotJobRequestTemplateConfigOverwriteParams
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitSnapshotJobRequestTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfigOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitSnapshotJobRequest(TeaModel):
    def __init__(self, input=None, name=None, output=None, schedule_config=None, template_config=None,
                 user_data=None):
        self.input = input  # type: SubmitSnapshotJobRequestInput
        self.name = name  # type: str
        self.output = output  # type: SubmitSnapshotJobRequestOutput
        self.schedule_config = schedule_config  # type: SubmitSnapshotJobRequestScheduleConfig
        self.template_config = template_config  # type: SubmitSnapshotJobRequestTemplateConfig
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.output:
            self.output.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super(SubmitSnapshotJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitSnapshotJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            temp_model = SubmitSnapshotJobRequestOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSnapshotJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('TemplateConfig') is not None:
            temp_model = SubmitSnapshotJobRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobShrinkRequest(TeaModel):
    def __init__(self, input_shrink=None, name=None, output_shrink=None, schedule_config_shrink=None,
                 template_config_shrink=None, user_data=None):
        self.input_shrink = input_shrink  # type: str
        self.name = name  # type: str
        self.output_shrink = output_shrink  # type: str
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        self.template_config_shrink = template_config_shrink  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_shrink is not None:
            result['Output'] = self.output_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Output') is not None:
            self.output_shrink = m.get('Output')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSnapshotJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        self.job_id = job_id  # type: str
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSnapshotJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSnapshotJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitSnapshotJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitSnapshotJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSnapshotJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSubtitleProduceJobRequest(TeaModel):
    def __init__(self, description=None, editing_config=None, input_config=None, is_async=None, output_config=None,
                 title=None, type=None, user_data=None):
        self.description = description  # type: str
        self.editing_config = editing_config  # type: str
        self.input_config = input_config  # type: str
        self.is_async = is_async  # type: long
        self.output_config = output_config  # type: str
        self.title = title  # type: str
        self.type = type  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSubtitleProduceJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.editing_config is not None:
            result['EditingConfig'] = self.editing_config
        if self.input_config is not None:
            result['InputConfig'] = self.input_config
        if self.is_async is not None:
            result['IsAsync'] = self.is_async
        if self.output_config is not None:
            result['OutputConfig'] = self.output_config
        if self.title is not None:
            result['Title'] = self.title
        if self.type is not None:
            result['Type'] = self.type
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EditingConfig') is not None:
            self.editing_config = m.get('EditingConfig')
        if m.get('InputConfig') is not None:
            self.input_config = m.get('InputConfig')
        if m.get('IsAsync') is not None:
            self.is_async = m.get('IsAsync')
        if m.get('OutputConfig') is not None:
            self.output_config = m.get('OutputConfig')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSubtitleProduceJobResponseBody(TeaModel):
    def __init__(self, job_id=None, request_id=None):
        self.job_id = job_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSubtitleProduceJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSubtitleProduceJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitSubtitleProduceJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitSubtitleProduceJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSubtitleProduceJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitSyncMediaInfoJobRequestInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobRequestInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSyncMediaInfoJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitSyncMediaInfoJobRequest(TeaModel):
    def __init__(self, input=None, name=None, schedule_config=None, user_data=None):
        # 任务输入
        self.input = input  # type: SubmitSyncMediaInfoJobRequestInput
        # 任务名字
        self.name = name  # type: str
        # 调度参数
        self.schedule_config = schedule_config  # type: SubmitSyncMediaInfoJobRequestScheduleConfig
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            temp_model = SubmitSyncMediaInfoJobRequestInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSyncMediaInfoJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobShrinkRequest(TeaModel):
    def __init__(self, input_shrink=None, name=None, schedule_config_shrink=None, user_data=None):
        # 任务输入
        self.input_shrink = input_shrink  # type: str
        # 任务名字
        self.name = name  # type: str
        # 调度参数
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_shrink is not None:
            result['Input'] = self.input_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Input') is not None:
            self.input_shrink = m.get('Input')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoPropertyVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitSyncMediaInfoJobResponseBodyMediaInfoJob(TeaModel):
    def __init__(self, async=None, finish_time=None, input=None, job_id=None, media_info_property=None, name=None,
                 request_id=None, schedule_config=None, status=None, submit_result_json=None, submit_time=None,
                 trigger_source=None, user_data=None):
        # 是否异步处理
        self.async = async  # type: bool
        # 任务完成时间
        self.finish_time = finish_time  # type: str
        # 任务输入
        self.input = input  # type: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput
        # 任务 id
        self.job_id = job_id  # type: str
        # 媒体信息详情
        self.media_info_property = media_info_property  # type: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty
        # 任务名字
        self.name = name  # type: str
        # 请求 id
        self.request_id = request_id  # type: str
        # 调度信息
        self.schedule_config = schedule_config  # type: SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig
        # 任务状态 - Init: 已提交, Success: 成功, Fail: 失败
        self.status = status  # type: str
        # 任务提交信息
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input:
            self.input.validate()
        if self.media_info_property:
            self.media_info_property.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBodyMediaInfoJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async is not None:
            result['Async'] = self.async
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.input is not None:
            result['Input'] = self.input.to_map()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_info_property is not None:
            result['MediaInfoProperty'] = self.media_info_property.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('Input') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobInput()
            self.input = temp_model.from_map(m['Input'])
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaInfoProperty') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobMediaInfoProperty()
            self.media_info_property = temp_model.from_map(m['MediaInfoProperty'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitSyncMediaInfoJobResponseBody(TeaModel):
    def __init__(self, media_info_job=None, request_id=None):
        # MediaInfoJobDTO
        self.media_info_job = media_info_job  # type: SubmitSyncMediaInfoJobResponseBodyMediaInfoJob
        # 请求 id
        self.request_id = request_id  # type: str

    def validate(self):
        if self.media_info_job:
            self.media_info_job.validate()

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_info_job is not None:
            result['MediaInfoJob'] = self.media_info_job.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaInfoJob') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBodyMediaInfoJob()
            self.media_info_job = temp_model.from_map(m['MediaInfoJob'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SubmitSyncMediaInfoJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitSyncMediaInfoJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitSyncMediaInfoJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitSyncMediaInfoJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SubmitTranscodeJobRequestInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobRequestOutputGroupProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroupProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobRequestOutputGroup(TeaModel):
    def __init__(self, output=None, process_config=None):
        # 输出媒体配置
        self.output = output  # type: SubmitTranscodeJobRequestOutputGroupOutput
        # 任务处理配置
        self.process_config = process_config  # type: SubmitTranscodeJobRequestOutputGroupProcessConfig

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestOutputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobRequestOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class SubmitTranscodeJobRequestScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobRequestScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobRequest(TeaModel):
    def __init__(self, input_group=None, name=None, output_group=None, schedule_config=None, user_data=None):
        # 任务输入组 (目前只支持一个)
        self.input_group = input_group  # type: list[SubmitTranscodeJobRequestInputGroup]
        # 任务名字
        self.name = name  # type: str
        # 任务输出组
        self.output_group = output_group  # type: list[SubmitTranscodeJobRequestOutputGroup]
        # 任务调度信息
        self.schedule_config = schedule_config  # type: SubmitTranscodeJobRequestScheduleConfig
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobRequestInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = SubmitTranscodeJobRequestOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobRequestScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobShrinkRequest(TeaModel):
    def __init__(self, input_group_shrink=None, name=None, output_group_shrink=None, schedule_config_shrink=None,
                 user_data=None):
        # 任务输入组 (目前只支持一个)
        self.input_group_shrink = input_group_shrink  # type: str
        # 任务名字
        self.name = name  # type: str
        # 任务输出组
        self.output_group_shrink = output_group_shrink  # type: str
        # 任务调度信息
        self.schedule_config_shrink = schedule_config_shrink  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_group_shrink is not None:
            result['InputGroup'] = self.input_group_shrink
        if self.name is not None:
            result['Name'] = self.name
        if self.output_group_shrink is not None:
            result['OutputGroup'] = self.output_group_shrink
        if self.schedule_config_shrink is not None:
            result['ScheduleConfig'] = self.schedule_config_shrink
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputGroup') is not None:
            self.input_group_shrink = m.get('InputGroup')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutputGroup') is not None:
            self.output_group_shrink = m.get('OutputGroup')
        if m.get('ScheduleConfig') is not None:
            self.schedule_config_shrink = m.get('ScheduleConfig')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup(TeaModel):
    def __init__(self, output=None, process_config=None):
        # 输出媒体配置
        self.output = output  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput
        # 任务处理配置
        self.process_config = process_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig

    def validate(self):
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroupProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList(TeaModel):
    def __init__(self, bitrate=None, channel_layout=None, channels=None, codec_long_name=None, codec_name=None,
                 codec_tag=None, codec_tag_string=None, codec_time_base=None, duration=None, index=None, lang=None,
                 sample_fmt=None, sample_rate=None, start_time=None, timebase=None):
        # 码率
        self.bitrate = bitrate  # type: str
        # 声道布局
        self.channel_layout = channel_layout  # type: str
        # 声道数
        self.channels = channels  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码器标签
        self.codec_tag = codec_tag  # type: str
        # 编码器标签名
        self.codec_tag_string = codec_tag_string  # type: str
        # 编码器时间基
        self.codec_time_base = codec_time_base  # type: str
        # 时长
        self.duration = duration  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        self.sample_fmt = sample_fmt  # type: str
        # 采样率
        self.sample_rate = sample_rate  # type: str
        # 开始时间
        self.start_time = start_time  # type: str
        # 时间基
        self.timebase = timebase  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channel_layout is not None:
            result['ChannelLayout'] = self.channel_layout
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec_long_name is not None:
            result['CodecLongName'] = self.codec_long_name
        if self.codec_name is not None:
            result['CodecName'] = self.codec_name
        if self.codec_tag is not None:
            result['CodecTag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['CodecTagString'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['CodecTimeBase'] = self.codec_time_base
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.sample_fmt is not None:
            result['SampleFmt'] = self.sample_fmt
        if self.sample_rate is not None:
            result['SampleRate'] = self.sample_rate
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.timebase is not None:
            result['Timebase'] = self.timebase
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('ChannelLayout') is not None:
            self.channel_layout = m.get('ChannelLayout')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('CodecLongName') is not None:
            self.codec_long_name = m.get('CodecLongName')
        if m.get('CodecName') is not None:
            self.codec_name = m.get('CodecName')
        if m.get('CodecTag') is not None:
            self.codec_tag = m.get('CodecTag')
        if m.get('CodecTagString') is not None:
            self.codec_tag_string = m.get('CodecTagString')
        if m.get('CodecTimeBase') is not None:
            self.codec_time_base = m.get('CodecTimeBase')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('SampleFmt') is not None:
            self.sample_fmt = m.get('SampleFmt')
        if m.get('SampleRate') is not None:
            self.sample_rate = m.get('SampleRate')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Timebase') is not None:
            self.timebase = m.get('Timebase')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo(TeaModel):
    def __init__(self, bitrate=None, duration=None, file_name=None, file_size=None, file_status=None, file_type=None,
                 file_url=None, format_name=None, height=None, media_id=None, region=None, width=None):
        # 视频码率
        self.bitrate = bitrate  # type: str
        # 视频时长
        self.duration = duration  # type: str
        # 文件名
        self.file_name = file_name  # type: str
        # 文件大小
        self.file_size = file_size  # type: str
        # 文件状态
        self.file_status = file_status  # type: str
        # 文件类型
        self.file_type = file_type  # type: str
        # 文件url
        self.file_url = file_url  # type: str
        # 视频格式名称
        self.format_name = format_name  # type: str
        # 高
        self.height = height  # type: str
        # 媒资ID
        self.media_id = media_id  # type: str
        # 文件所在区域
        self.region = region  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_size is not None:
            result['FileSize'] = self.file_size
        if self.file_status is not None:
            result['FileStatus'] = self.file_status
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.file_url is not None:
            result['FileUrl'] = self.file_url
        if self.format_name is not None:
            result['FormatName'] = self.format_name
        if self.height is not None:
            result['Height'] = self.height
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.region is not None:
            result['Region'] = self.region
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileSize') is not None:
            self.file_size = m.get('FileSize')
        if m.get('FileStatus') is not None:
            self.file_status = m.get('FileStatus')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('FileUrl') is not None:
            self.file_url = m.get('FileUrl')
        if m.get('FormatName') is not None:
            self.format_name = m.get('FormatName')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList(TeaModel):
    def __init__(self, avg_fps=None, bit_rate=None, codec_long_name=None, codec_name=None, codec_tag=None,
                 codec_tag_string=None, codec_time_base=None, dar=None, duration=None, fps=None, has_bframes=None, height=None,
                 index=None, lang=None, level=None, num_frames=None, pix_fmt=None, profile=None, rotate=None, sar=None,
                 start_time=None, time_base=None, width=None):
        self.avg_fps = avg_fps  # type: str
        self.bit_rate = bit_rate  # type: str
        # 编码格式名
        self.codec_long_name = codec_long_name  # type: str
        # 编码格式
        self.codec_name = codec_name  # type: str
        # 编码格式标记
        self.codec_tag = codec_tag  # type: str
        # 编码格式标记文本
        self.codec_tag_string = codec_tag_string  # type: str
        self.codec_time_base = codec_time_base  # type: str
        # 图像显示宽高比
        self.dar = dar  # type: str
        # 时长
        self.duration = duration  # type: str
        # 帧率
        self.fps = fps  # type: str
        self.has_bframes = has_bframes  # type: str
        # 高
        self.height = height  # type: str
        # 流序号
        self.index = index  # type: str
        # 语言
        self.lang = lang  # type: str
        # 编码等级
        self.level = level  # type: str
        # 总帧数
        self.num_frames = num_frames  # type: str
        # 颜色存储格式
        self.pix_fmt = pix_fmt  # type: str
        # 编码器预设
        self.profile = profile  # type: str
        # 视频画面旋转角度
        self.rotate = rotate  # type: str
        # 采集点数宽高比
        self.sar = sar  # type: str
        # 起始时间
        self.start_time = start_time  # type: str
        self.time_base = time_base  # type: str
        # 宽
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.avg_fps is not None:
            result['Avg_fps'] = self.avg_fps
        if self.bit_rate is not None:
            result['Bit_rate'] = self.bit_rate
        if self.codec_long_name is not None:
            result['Codec_long_name'] = self.codec_long_name
        if self.codec_name is not None:
            result['Codec_name'] = self.codec_name
        if self.codec_tag is not None:
            result['Codec_tag'] = self.codec_tag
        if self.codec_tag_string is not None:
            result['Codec_tag_string'] = self.codec_tag_string
        if self.codec_time_base is not None:
            result['Codec_time_base'] = self.codec_time_base
        if self.dar is not None:
            result['Dar'] = self.dar
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.has_bframes is not None:
            result['Has_b_frames'] = self.has_bframes
        if self.height is not None:
            result['Height'] = self.height
        if self.index is not None:
            result['Index'] = self.index
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.level is not None:
            result['Level'] = self.level
        if self.num_frames is not None:
            result['NumFrames'] = self.num_frames
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.rotate is not None:
            result['Rotate'] = self.rotate
        if self.sar is not None:
            result['Sar'] = self.sar
        if self.start_time is not None:
            result['Start_time'] = self.start_time
        if self.time_base is not None:
            result['Time_base'] = self.time_base
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Avg_fps') is not None:
            self.avg_fps = m.get('Avg_fps')
        if m.get('Bit_rate') is not None:
            self.bit_rate = m.get('Bit_rate')
        if m.get('Codec_long_name') is not None:
            self.codec_long_name = m.get('Codec_long_name')
        if m.get('Codec_name') is not None:
            self.codec_name = m.get('Codec_name')
        if m.get('Codec_tag') is not None:
            self.codec_tag = m.get('Codec_tag')
        if m.get('Codec_tag_string') is not None:
            self.codec_tag_string = m.get('Codec_tag_string')
        if m.get('Codec_time_base') is not None:
            self.codec_time_base = m.get('Codec_time_base')
        if m.get('Dar') is not None:
            self.dar = m.get('Dar')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Has_b_frames') is not None:
            self.has_bframes = m.get('Has_b_frames')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('NumFrames') is not None:
            self.num_frames = m.get('NumFrames')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Rotate') is not None:
            self.rotate = m.get('Rotate')
        if m.get('Sar') is not None:
            self.sar = m.get('Sar')
        if m.get('Start_time') is not None:
            self.start_time = m.get('Start_time')
        if m.get('Time_base') is not None:
            self.time_base = m.get('Time_base')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta(TeaModel):
    def __init__(self, audio_stream_info_list=None, file_basic_info=None, video_stream_info_list=None):
        # 音频流信息
        self.audio_stream_info_list = audio_stream_info_list  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList]
        # 基础文件信息
        self.file_basic_info = file_basic_info  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo
        # 视频流信息
        self.video_stream_info_list = video_stream_info_list  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList]

    def validate(self):
        if self.audio_stream_info_list:
            for k in self.audio_stream_info_list:
                if k:
                    k.validate()
        if self.file_basic_info:
            self.file_basic_info.validate()
        if self.video_stream_info_list:
            for k in self.video_stream_info_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AudioStreamInfoList'] = []
        if self.audio_stream_info_list is not None:
            for k in self.audio_stream_info_list:
                result['AudioStreamInfoList'].append(k.to_map() if k else None)
        if self.file_basic_info is not None:
            result['FileBasicInfo'] = self.file_basic_info.to_map()
        result['VideoStreamInfoList'] = []
        if self.video_stream_info_list is not None:
            for k in self.video_stream_info_list:
                result['VideoStreamInfoList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.audio_stream_info_list = []
        if m.get('AudioStreamInfoList') is not None:
            for k in m.get('AudioStreamInfoList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaAudioStreamInfoList()
                self.audio_stream_info_list.append(temp_model.from_map(k))
        if m.get('FileBasicInfo') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaFileBasicInfo()
            self.file_basic_info = temp_model.from_map(m['FileBasicInfo'])
        self.video_stream_info_list = []
        if m.get('VideoStreamInfoList') is not None:
            for k in m.get('VideoStreamInfoList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMetaVideoStreamInfoList()
                self.video_stream_info_list.append(temp_model.from_map(k))
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline(TeaModel):
    def __init__(self, duration=None, start=None):
        # 显示时长，秒数 或者 "ToEND"
        self.duration = duration  # type: str
        # 开始时间
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams(TeaModel):
    def __init__(self, dx=None, dy=None, file=None, height=None, refer_pos=None, timeline=None, width=None):
        # 水印位置，x
        self.dx = dx  # type: str
        # 水印位置，y
        self.dy = dy  # type: str
        # 水印文件oss路径
        self.file = file  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile
        # 高
        self.height = height  # type: str
        # 参考位置: TopLeft, TopRight, BottomLeft, BottomRight  default: TopLeft
        self.refer_pos = refer_pos  # type: str
        # 显示时间设置
        self.timeline = timeline  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline
        # 宽
        self.width = width  # type: str

    def validate(self):
        if self.file:
            self.file.validate()
        if self.timeline:
            self.timeline.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dx is not None:
            result['Dx'] = self.dx
        if self.dy is not None:
            result['Dy'] = self.dy
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.height is not None:
            result['Height'] = self.height
        if self.refer_pos is not None:
            result['ReferPos'] = self.refer_pos
        if self.timeline is not None:
            result['Timeline'] = self.timeline.to_map()
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dx') is not None:
            self.dx = m.get('Dx')
        if m.get('Dy') is not None:
            self.dy = m.get('Dy')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('ReferPos') is not None:
            self.refer_pos = m.get('ReferPos')
        if m.get('Timeline') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParamsTimeline()
            self.timeline = temp_model.from_map(m['Timeline'])
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile(TeaModel):
    def __init__(self, media=None, type=None):
        # 媒体值：
        #       type 为 OSS 时，为 url, 支持 oss 协议和 http 协议；
        #       type 为 Media 时，为媒资 id。
        self.media = media  # type: str
        # 媒体对象类型 - OSS: oss文件, Media: 媒资 ID
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media is not None:
            result['Media'] = self.media
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Media') is not None:
            self.media = m.get('Media')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams(TeaModel):
    def __init__(self, char_enc=None, file=None, format=None):
        # 文件 encoding 格式
        self.char_enc = char_enc  # type: str
        # 字幕文件
        self.file = file  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile
        # 字幕文件格式
        self.format = format  # type: str

    def validate(self):
        if self.file:
            self.file.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.char_enc is not None:
            result['CharEnc'] = self.char_enc
        if self.file is not None:
            result['File'] = self.file.to_map()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CharEnc') is not None:
            self.char_enc = m.get('CharEnc')
        if m.get('File') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParamsFile()
            self.file = temp_model.from_map(m['File'])
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitlesOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams(TeaModel):
    def __init__(self, adaptive=None, border_color=None, border_width=None, content=None, font_alpha=None,
                 font_color=None, font_name=None, font_size=None, left=None, top=None):
        # 根据输出视频大小调整字体 size。 true / false, default: false
        self.adaptive = adaptive  # type: str
        # 边框颜色
        self.border_color = border_color  # type: str
        # 边框宽度
        self.border_width = border_width  # type: int
        # 水印文本，不需要 base64 encode，字符串需要 utf-8 编码
        self.content = content  # type: str
        # 透明度
        self.font_alpha = font_alpha  # type: str
        # 颜色
        self.font_color = font_color  # type: str
        # 字体
        self.font_name = font_name  # type: str
        # 字体大小
        self.font_size = font_size  # type: int
        # 水印位置，距离左边距离
        self.left = left  # type: str
        # 水印位置，距离上边距离
        self.top = top  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adaptive is not None:
            result['Adaptive'] = self.adaptive
        if self.border_color is not None:
            result['BorderColor'] = self.border_color
        if self.border_width is not None:
            result['BorderWidth'] = self.border_width
        if self.content is not None:
            result['Content'] = self.content
        if self.font_alpha is not None:
            result['FontAlpha'] = self.font_alpha
        if self.font_color is not None:
            result['FontColor'] = self.font_color
        if self.font_name is not None:
            result['FontName'] = self.font_name
        if self.font_size is not None:
            result['FontSize'] = self.font_size
        if self.left is not None:
            result['Left'] = self.left
        if self.top is not None:
            result['Top'] = self.top
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Adaptive') is not None:
            self.adaptive = m.get('Adaptive')
        if m.get('BorderColor') is not None:
            self.border_color = m.get('BorderColor')
        if m.get('BorderWidth') is not None:
            self.border_width = m.get('BorderWidth')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('FontAlpha') is not None:
            self.font_alpha = m.get('FontAlpha')
        if m.get('FontColor') is not None:
            self.font_color = m.get('FontColor')
        if m.get('FontName') is not None:
            self.font_name = m.get('FontName')
        if m.get('FontSize') is not None:
            self.font_size = m.get('FontSize')
        if m.get('Left') is not None:
            self.left = m.get('Left')
        if m.get('Top') is not None:
            self.top = m.get('Top')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarksOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume(TeaModel):
    def __init__(self, integrated_loudness_target=None, loudness_range_target=None, method=None, true_peak=None):
        # 目标音量
        self.integrated_loudness_target = integrated_loudness_target  # type: str
        # 音量范围
        self.loudness_range_target = loudness_range_target  # type: str
        # 音量调整方式
        self.method = method  # type: str
        # 最大峰值
        self.true_peak = true_peak  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.integrated_loudness_target is not None:
            result['IntegratedLoudnessTarget'] = self.integrated_loudness_target
        if self.loudness_range_target is not None:
            result['LoudnessRangeTarget'] = self.loudness_range_target
        if self.method is not None:
            result['Method'] = self.method
        if self.true_peak is not None:
            result['TruePeak'] = self.true_peak
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IntegratedLoudnessTarget') is not None:
            self.integrated_loudness_target = m.get('IntegratedLoudnessTarget')
        if m.get('LoudnessRangeTarget') is not None:
            self.loudness_range_target = m.get('LoudnessRangeTarget')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('TruePeak') is not None:
            self.true_peak = m.get('TruePeak')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, remove=None, samplerate=None,
                 volume=None):
        # 输出文件的音频码率。
        self.bitrate = bitrate  # type: str
        # 声道数。
        self.channels = channels  # type: str
        # 音频编解码格式，AAC、MP3、VORBIS、FLAC。
        self.codec = codec  # type: str
        # 音频编码预置。
        self.profile = profile  # type: str
        # 是否删除音频流。
        self.remove = remove  # type: str
        # 采样率。
        self.samplerate = samplerate  # type: str
        # 音量控制
        self.volume = volume  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume

    def validate(self):
        if self.volume:
            self.volume.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        if self.volume is not None:
            result['Volume'] = self.volume.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        if m.get('Volume') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudioVolume()
            self.volume = temp_model.from_map(m['Volume'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer(TeaModel):
    def __init__(self, format=None):
        # 容器格式
        self.format = format  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.format is not None:
            result['Format'] = self.format
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Format') is not None:
            self.format = m.get('Format')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment(TeaModel):
    def __init__(self, duration=None, force_seg_time=None):
        # 切片时长
        self.duration = duration  # type: str
        # 强制切片时间点
        self.force_seg_time = force_seg_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.force_seg_time is not None:
            result['ForceSegTime'] = self.force_seg_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('ForceSegTime') is not None:
            self.force_seg_time = m.get('ForceSegTime')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig(TeaModel):
    def __init__(self, segment=None):
        # 切片设置
        self.segment = segment  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment

    def validate(self):
        if self.segment:
            self.segment.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.segment is not None:
            result['Segment'] = self.segment.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Segment') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfigSegment()
            self.segment = temp_model.from_map(m['Segment'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo(TeaModel):
    def __init__(self, abr_max=None, bitrate=None, bufsize=None, codec=None, crf=None, crop=None, fps=None, gop=None,
                 height=None, long_short_mode=None, maxrate=None, pad=None, pix_fmt=None, preset=None, profile=None,
                 remove=None, scan_mode=None, width=None):
        self.abr_max = abr_max  # type: str
        # 视频平均码率。
        self.bitrate = bitrate  # type: str
        # 缓冲区大小
        self.bufsize = bufsize  # type: str
        # 编码格式
        self.codec = codec  # type: str
        # 码率-质量控制因子。
        self.crf = crf  # type: str
        # 视频画面裁切
        self.crop = crop  # type: str
        # 帧率。
        self.fps = fps  # type: str
        # 关键帧间最大帧数。
        self.gop = gop  # type: str
        # 高。
        self.height = height  # type: str
        # 是否开启横竖屏自适应（即：长短边模式）
        self.long_short_mode = long_short_mode  # type: str
        # 视频码率峰值
        self.maxrate = maxrate  # type: str
        # 视频贴黑边
        self.pad = pad  # type: str
        # 视频颜色格式。
        self.pix_fmt = pix_fmt  # type: str
        # 只有H264支持该参数
        self.preset = preset  # type: str
        # 编码级别。
        self.profile = profile  # type: str
        # 是否去掉视频
        self.remove = remove  # type: str
        # 扫描模式。
        self.scan_mode = scan_mode  # type: str
        # 宽。
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.abr_max is not None:
            result['AbrMax'] = self.abr_max
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.bufsize is not None:
            result['Bufsize'] = self.bufsize
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.crf is not None:
            result['Crf'] = self.crf
        if self.crop is not None:
            result['Crop'] = self.crop
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.long_short_mode is not None:
            result['LongShortMode'] = self.long_short_mode
        if self.maxrate is not None:
            result['Maxrate'] = self.maxrate
        if self.pad is not None:
            result['Pad'] = self.pad
        if self.pix_fmt is not None:
            result['PixFmt'] = self.pix_fmt
        if self.preset is not None:
            result['Preset'] = self.preset
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.remove is not None:
            result['Remove'] = self.remove
        if self.scan_mode is not None:
            result['ScanMode'] = self.scan_mode
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AbrMax') is not None:
            self.abr_max = m.get('AbrMax')
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Bufsize') is not None:
            self.bufsize = m.get('Bufsize')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Crf') is not None:
            self.crf = m.get('Crf')
        if m.get('Crop') is not None:
            self.crop = m.get('Crop')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('LongShortMode') is not None:
            self.long_short_mode = m.get('LongShortMode')
        if m.get('Maxrate') is not None:
            self.maxrate = m.get('Maxrate')
        if m.get('Pad') is not None:
            self.pad = m.get('Pad')
        if m.get('PixFmt') is not None:
            self.pix_fmt = m.get('PixFmt')
        if m.get('Preset') is not None:
            self.preset = m.get('Preset')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Remove') is not None:
            self.remove = m.get('Remove')
        if m.get('ScanMode') is not None:
            self.scan_mode = m.get('ScanMode')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams(TeaModel):
    def __init__(self, audio=None, container=None, mux_config=None, video=None):
        # audio 设置
        self.audio = audio  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio
        # 封装格式设置
        self.container = container  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer
        # 封装设置
        self.mux_config = mux_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig
        # video 设置
        self.video = video  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo

    def validate(self):
        if self.audio:
            self.audio.validate()
        if self.container:
            self.container.validate()
        if self.mux_config:
            self.mux_config.validate()
        if self.video:
            self.video.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio is not None:
            result['Audio'] = self.audio.to_map()
        if self.container is not None:
            result['Container'] = self.container.to_map()
        if self.mux_config is not None:
            result['MuxConfig'] = self.mux_config.to_map()
        if self.video is not None:
            result['Video'] = self.video.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Audio') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsAudio()
            self.audio = temp_model.from_map(m['Audio'])
        if m.get('Container') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsContainer()
            self.container = temp_model.from_map(m['Container'])
        if m.get('MuxConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsMuxConfig()
            self.mux_config = temp_model.from_map(m['MuxConfig'])
        if m.get('Video') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParamsVideo()
            self.video = temp_model.from_map(m['Video'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode(TeaModel):
    def __init__(self, overwrite_params=None, template_id=None):
        # 覆盖参数, 若填写会覆盖模板对应参数
        self.overwrite_params = overwrite_params  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams
        # 模板 id
        self.template_id = template_id  # type: str

    def validate(self):
        if self.overwrite_params:
            self.overwrite_params.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite_params is not None:
            result['OverwriteParams'] = self.overwrite_params.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OverwriteParams') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscodeOverwriteParams()
            self.overwrite_params = temp_model.from_map(m['OverwriteParams'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig(TeaModel):
    def __init__(self, image_watermarks=None, subtitles=None, text_watermarks=None, transcode=None):
        # 图片水印配置
        self.image_watermarks = image_watermarks  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks]
        # 字幕压制配置
        self.subtitles = subtitles  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles]
        # 文字水印配置
        self.text_watermarks = text_watermarks  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks]
        # 转码配置
        self.transcode = transcode  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode

    def validate(self):
        if self.image_watermarks:
            for k in self.image_watermarks:
                if k:
                    k.validate()
        if self.subtitles:
            for k in self.subtitles:
                if k:
                    k.validate()
        if self.text_watermarks:
            for k in self.text_watermarks:
                if k:
                    k.validate()
        if self.transcode:
            self.transcode.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageWatermarks'] = []
        if self.image_watermarks is not None:
            for k in self.image_watermarks:
                result['ImageWatermarks'].append(k.to_map() if k else None)
        result['Subtitles'] = []
        if self.subtitles is not None:
            for k in self.subtitles:
                result['Subtitles'].append(k.to_map() if k else None)
        result['TextWatermarks'] = []
        if self.text_watermarks is not None:
            for k in self.text_watermarks:
                result['TextWatermarks'].append(k.to_map() if k else None)
        if self.transcode is not None:
            result['Transcode'] = self.transcode.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_watermarks = []
        if m.get('ImageWatermarks') is not None:
            for k in m.get('ImageWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigImageWatermarks()
                self.image_watermarks.append(temp_model.from_map(k))
        self.subtitles = []
        if m.get('Subtitles') is not None:
            for k in m.get('Subtitles'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigSubtitles()
                self.subtitles.append(temp_model.from_map(k))
        self.text_watermarks = []
        if m.get('TextWatermarks') is not None:
            for k in m.get('TextWatermarks'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTextWatermarks()
                self.text_watermarks.append(temp_model.from_map(k))
        if m.get('Transcode') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfigTranscode()
            self.transcode = temp_model.from_map(m['Transcode'])
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig(TeaModel):
    def __init__(self, pipeline_id=None, priority=None):
        # 管道 id
        self.pipeline_id = pipeline_id  # type: str
        # 任务优先级，取值范围：1~10
        self.priority = priority  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input_group=None, job_id=None, job_index=None, name=None,
                 out_file_meta=None, output=None, parent_job_id=None, process_config=None, request_id=None, schedule_config=None,
                 status=None, submit_result_json=None, submit_time=None, user_data=None):
        # 任务创建时间
        self.create_time = create_time  # type: str
        # 任务结束时间
        self.finish_time = finish_time  # type: str
        # 任务输入组 (目前只支持单个输入)
        self.input_group = input_group  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup]
        # 子任务 id
        self.job_id = job_id  # type: str
        # 子任务在整个任务中的索引号
        self.job_index = job_index  # type: int
        # 任务名
        self.name = name  # type: str
        # 任务生成视频 media 信息
        self.out_file_meta = out_file_meta  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta
        # 输出媒体配置
        self.output = output  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput
        # 主任务 id
        self.parent_job_id = parent_job_id  # type: str
        # 转码处理配置
        self.process_config = process_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig
        # 请求 id
        self.request_id = request_id  # type: str
        # 任务调度信息
        self.schedule_config = schedule_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig
        # 转码任务任务状态 - Init: 已提交, Processing: 转码中, Success: 转码成功, Fail: 转码失败, Deleted: 已删除
        self.status = status  # type: str
        # 任务提交结果
        self.submit_result_json = submit_result_json  # type: dict[str, any]
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.out_file_meta:
            self.out_file_meta.validate()
        if self.output:
            self.output.validate()
        if self.process_config:
            self.process_config.validate()
        if self.schedule_config:
            self.schedule_config.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.job_index is not None:
            result['JobIndex'] = self.job_index
        if self.name is not None:
            result['Name'] = self.name
        if self.out_file_meta is not None:
            result['OutFileMeta'] = self.out_file_meta.to_map()
        if self.output is not None:
            result['Output'] = self.output.to_map()
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.process_config is not None:
            result['ProcessConfig'] = self.process_config.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_result_json is not None:
            result['SubmitResultJson'] = self.submit_result_json
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('JobIndex') is not None:
            self.job_index = m.get('JobIndex')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OutFileMeta') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutFileMeta()
            self.out_file_meta = temp_model.from_map(m['OutFileMeta'])
        if m.get('Output') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListOutput()
            self.output = temp_model.from_map(m['Output'])
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('ProcessConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListProcessConfig()
            self.process_config = temp_model.from_map(m['ProcessConfig'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobListScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitResultJson') is not None:
            self.submit_result_json = m.get('SubmitResultJson')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBodyTranscodeParentJob(TeaModel):
    def __init__(self, create_time=None, finish_time=None, input_group=None, job_count=None, name=None,
                 output_group=None, parent_job_id=None, percent=None, request_id=None, schedule_config=None, status=None,
                 submit_time=None, transcode_job_list=None, trigger_source=None, user_data=None):
        # 任务创建时间
        self.create_time = create_time  # type: str
        # 任务结束时间
        self.finish_time = finish_time  # type: str
        # 任务输入组 (目前只支持单个输入)
        self.input_group = input_group  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup]
        # 子任务数量
        self.job_count = job_count  # type: int
        # 任务名
        self.name = name  # type: str
        # 任务输出组
        self.output_group = output_group  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup]
        # 主任务 id
        self.parent_job_id = parent_job_id  # type: str
        # 任务完成百分比
        self.percent = percent  # type: int
        # 提交任务时请求 id
        self.request_id = request_id  # type: str
        # 任务调度配置
        self.schedule_config = schedule_config  # type: SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig
        # 任务状态 Success: 有子任务成功, Fail: 所有子任务失败
        self.status = status  # type: str
        # 任务提交时间
        self.submit_time = submit_time  # type: str
        # 子任务列表
        self.transcode_job_list = transcode_job_list  # type: list[SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList]
        # 任务来源 - API, WorkFlow, Console
        self.trigger_source = trigger_source  # type: str
        # 用户数据
        self.user_data = user_data  # type: str

    def validate(self):
        if self.input_group:
            for k in self.input_group:
                if k:
                    k.validate()
        if self.output_group:
            for k in self.output_group:
                if k:
                    k.validate()
        if self.schedule_config:
            self.schedule_config.validate()
        if self.transcode_job_list:
            for k in self.transcode_job_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBodyTranscodeParentJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        result['InputGroup'] = []
        if self.input_group is not None:
            for k in self.input_group:
                result['InputGroup'].append(k.to_map() if k else None)
        if self.job_count is not None:
            result['JobCount'] = self.job_count
        if self.name is not None:
            result['Name'] = self.name
        result['OutputGroup'] = []
        if self.output_group is not None:
            for k in self.output_group:
                result['OutputGroup'].append(k.to_map() if k else None)
        if self.parent_job_id is not None:
            result['ParentJobId'] = self.parent_job_id
        if self.percent is not None:
            result['Percent'] = self.percent
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.schedule_config is not None:
            result['ScheduleConfig'] = self.schedule_config.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.submit_time is not None:
            result['SubmitTime'] = self.submit_time
        result['TranscodeJobList'] = []
        if self.transcode_job_list is not None:
            for k in self.transcode_job_list:
                result['TranscodeJobList'].append(k.to_map() if k else None)
        if self.trigger_source is not None:
            result['TriggerSource'] = self.trigger_source
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        self.input_group = []
        if m.get('InputGroup') is not None:
            for k in m.get('InputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobInputGroup()
                self.input_group.append(temp_model.from_map(k))
        if m.get('JobCount') is not None:
            self.job_count = m.get('JobCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.output_group = []
        if m.get('OutputGroup') is not None:
            for k in m.get('OutputGroup'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobOutputGroup()
                self.output_group.append(temp_model.from_map(k))
        if m.get('ParentJobId') is not None:
            self.parent_job_id = m.get('ParentJobId')
        if m.get('Percent') is not None:
            self.percent = m.get('Percent')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScheduleConfig') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobScheduleConfig()
            self.schedule_config = temp_model.from_map(m['ScheduleConfig'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubmitTime') is not None:
            self.submit_time = m.get('SubmitTime')
        self.transcode_job_list = []
        if m.get('TranscodeJobList') is not None:
            for k in m.get('TranscodeJobList'):
                temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJobTranscodeJobList()
                self.transcode_job_list.append(temp_model.from_map(k))
        if m.get('TriggerSource') is not None:
            self.trigger_source = m.get('TriggerSource')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class SubmitTranscodeJobResponseBody(TeaModel):
    def __init__(self, request_id=None, transcode_parent_job=None):
        # 请求 id
        self.request_id = request_id  # type: str
        # TranscodeParentJobWithSubJobDTO
        self.transcode_parent_job = transcode_parent_job  # type: SubmitTranscodeJobResponseBodyTranscodeParentJob

    def validate(self):
        if self.transcode_parent_job:
            self.transcode_parent_job.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.transcode_parent_job is not None:
            result['TranscodeParentJob'] = self.transcode_parent_job.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TranscodeParentJob') is not None:
            temp_model = SubmitTranscodeJobResponseBodyTranscodeParentJob()
            self.transcode_parent_job = temp_model.from_map(m['TranscodeParentJob'])
        return self


class SubmitTranscodeJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SubmitTranscodeJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SubmitTranscodeJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SubmitTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCategoryRequest(TeaModel):
    def __init__(self, cate_id=None, cate_name=None):
        self.cate_id = cate_id  # type: long
        self.cate_name = cate_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateCategoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.cate_name is not None:
            result['CateName'] = self.cate_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('CateName') is not None:
            self.cate_name = m.get('CateName')
        return self


class UpdateCategoryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateCategoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateCategoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateCategoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateCategoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCategoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateCustomTemplateRequest(TeaModel):
    def __init__(self, name=None, template_config=None, template_id=None):
        # 模板名称
        self.name = name  # type: str
        # 模板参数
        self.template_config = template_config  # type: str
        # 模板ID
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateCustomTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            self.template_config = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateCustomTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateCustomTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdateCustomTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateCustomTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateCustomTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateCustomTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateEditingProjectRequest(TeaModel):
    def __init__(self, business_status=None, clips_param=None, cover_url=None, description=None, project_id=None,
                 template_id=None, timeline=None, title=None):
        self.business_status = business_status  # type: str
        # 模板对应的素材参数
        self.clips_param = clips_param  # type: str
        # 云剪辑工程封面
        self.cover_url = cover_url  # type: str
        # 云剪辑工程描述
        self.description = description  # type: str
        # 云剪辑工程ID
        self.project_id = project_id  # type: str
        # 模板Id
        self.template_id = template_id  # type: str
        # 云剪辑工程时间线，Json格式
        self.timeline = timeline  # type: str
        # 云剪辑工程标题
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateEditingProjectRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.clips_param is not None:
            result['ClipsParam'] = self.clips_param
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.project_id is not None:
            result['ProjectId'] = self.project_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        if self.timeline is not None:
            result['Timeline'] = self.timeline
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ClipsParam') is not None:
            self.clips_param = m.get('ClipsParam')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ProjectId') is not None:
            self.project_id = m.get('ProjectId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        if m.get('Timeline') is not None:
            self.timeline = m.get('Timeline')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class UpdateEditingProjectResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateEditingProjectResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateEditingProjectResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateEditingProjectResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateEditingProjectResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateEditingProjectResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveTranscodeJobRequestStreamInput(TeaModel):
    def __init__(self, input_url=None, type=None):
        self.input_url = input_url  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobRequestStreamInput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.input_url is not None:
            result['InputUrl'] = self.input_url
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InputUrl') is not None:
            self.input_url = m.get('InputUrl')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateLiveTranscodeJobRequestTimedConfig(TeaModel):
    def __init__(self, end_time=None, start_time=None):
        self.end_time = end_time  # type: str
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobRequestTimedConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class UpdateLiveTranscodeJobRequestTranscodeOutput(TeaModel):
    def __init__(self, domain_name=None, type=None):
        self.domain_name = domain_name  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobRequestTranscodeOutput, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class UpdateLiveTranscodeJobRequest(TeaModel):
    def __init__(self, job_id=None, name=None, stream_input=None, timed_config=None, transcode_output=None):
        self.job_id = job_id  # type: str
        self.name = name  # type: str
        self.stream_input = stream_input  # type: UpdateLiveTranscodeJobRequestStreamInput
        self.timed_config = timed_config  # type: UpdateLiveTranscodeJobRequestTimedConfig
        self.transcode_output = transcode_output  # type: UpdateLiveTranscodeJobRequestTranscodeOutput

    def validate(self):
        if self.stream_input:
            self.stream_input.validate()
        if self.timed_config:
            self.timed_config.validate()
        if self.transcode_output:
            self.transcode_output.validate()

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.stream_input is not None:
            result['StreamInput'] = self.stream_input.to_map()
        if self.timed_config is not None:
            result['TimedConfig'] = self.timed_config.to_map()
        if self.transcode_output is not None:
            result['TranscodeOutput'] = self.transcode_output.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StreamInput') is not None:
            temp_model = UpdateLiveTranscodeJobRequestStreamInput()
            self.stream_input = temp_model.from_map(m['StreamInput'])
        if m.get('TimedConfig') is not None:
            temp_model = UpdateLiveTranscodeJobRequestTimedConfig()
            self.timed_config = temp_model.from_map(m['TimedConfig'])
        if m.get('TranscodeOutput') is not None:
            temp_model = UpdateLiveTranscodeJobRequestTranscodeOutput()
            self.transcode_output = temp_model.from_map(m['TranscodeOutput'])
        return self


class UpdateLiveTranscodeJobShrinkRequest(TeaModel):
    def __init__(self, job_id=None, name=None, stream_input_shrink=None, timed_config_shrink=None,
                 transcode_output_shrink=None):
        self.job_id = job_id  # type: str
        self.name = name  # type: str
        self.stream_input_shrink = stream_input_shrink  # type: str
        self.timed_config_shrink = timed_config_shrink  # type: str
        self.transcode_output_shrink = transcode_output_shrink  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.name is not None:
            result['Name'] = self.name
        if self.stream_input_shrink is not None:
            result['StreamInput'] = self.stream_input_shrink
        if self.timed_config_shrink is not None:
            result['TimedConfig'] = self.timed_config_shrink
        if self.transcode_output_shrink is not None:
            result['TranscodeOutput'] = self.transcode_output_shrink
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StreamInput') is not None:
            self.stream_input_shrink = m.get('StreamInput')
        if m.get('TimedConfig') is not None:
            self.timed_config_shrink = m.get('TimedConfig')
        if m.get('TranscodeOutput') is not None:
            self.transcode_output_shrink = m.get('TranscodeOutput')
        return self


class UpdateLiveTranscodeJobResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveTranscodeJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateLiveTranscodeJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateLiveTranscodeJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveTranscodeJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams(TeaModel):
    def __init__(self, bitrate=None, channels=None, codec=None, profile=None, samplerate=None):
        self.bitrate = bitrate  # type: str
        self.channels = channels  # type: str
        self.codec = codec  # type: str
        self.profile = profile  # type: str
        self.samplerate = samplerate  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.channels is not None:
            result['Channels'] = self.channels
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.samplerate is not None:
            result['Samplerate'] = self.samplerate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Channels') is not None:
            self.channels = m.get('Channels')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Samplerate') is not None:
            self.samplerate = m.get('Samplerate')
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams(TeaModel):
    def __init__(self, bitrate=None, codec=None, fps=None, gop=None, height=None, profile=None, width=None):
        self.bitrate = bitrate  # type: str
        self.codec = codec  # type: str
        self.fps = fps  # type: str
        self.gop = gop  # type: str
        self.height = height  # type: str
        self.profile = profile  # type: str
        self.width = width  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bitrate is not None:
            result['Bitrate'] = self.bitrate
        if self.codec is not None:
            result['Codec'] = self.codec
        if self.fps is not None:
            result['Fps'] = self.fps
        if self.gop is not None:
            result['Gop'] = self.gop
        if self.height is not None:
            result['Height'] = self.height
        if self.profile is not None:
            result['Profile'] = self.profile
        if self.width is not None:
            result['Width'] = self.width
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bitrate') is not None:
            self.bitrate = m.get('Bitrate')
        if m.get('Codec') is not None:
            self.codec = m.get('Codec')
        if m.get('Fps') is not None:
            self.fps = m.get('Fps')
        if m.get('Gop') is not None:
            self.gop = m.get('Gop')
        if m.get('Height') is not None:
            self.height = m.get('Height')
        if m.get('Profile') is not None:
            self.profile = m.get('Profile')
        if m.get('Width') is not None:
            self.width = m.get('Width')
        return self


class UpdateLiveTranscodeTemplateRequestTemplateConfig(TeaModel):
    def __init__(self, audio_params=None, video_params=None):
        self.audio_params = audio_params  # type: UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams
        self.video_params = video_params  # type: UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams

    def validate(self):
        if self.audio_params:
            self.audio_params.validate()
        if self.video_params:
            self.video_params.validate()

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateRequestTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.audio_params is not None:
            result['AudioParams'] = self.audio_params.to_map()
        if self.video_params is not None:
            result['VideoParams'] = self.video_params.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AudioParams') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfigAudioParams()
            self.audio_params = temp_model.from_map(m['AudioParams'])
        if m.get('VideoParams') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfigVideoParams()
            self.video_params = temp_model.from_map(m['VideoParams'])
        return self


class UpdateLiveTranscodeTemplateRequest(TeaModel):
    def __init__(self, name=None, template_config=None, template_id=None):
        self.name = name  # type: str
        self.template_config = template_config  # type: UpdateLiveTranscodeTemplateRequestTemplateConfig
        self.template_id = template_id  # type: str

    def validate(self):
        if self.template_config:
            self.template_config.validate()

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config is not None:
            result['TemplateConfig'] = self.template_config.to_map()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            temp_model = UpdateLiveTranscodeTemplateRequestTemplateConfig()
            self.template_config = temp_model.from_map(m['TemplateConfig'])
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveTranscodeTemplateShrinkRequest(TeaModel):
    def __init__(self, name=None, template_config_shrink=None, template_id=None):
        self.name = name  # type: str
        self.template_config_shrink = template_config_shrink  # type: str
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.template_config_shrink is not None:
            result['TemplateConfig'] = self.template_config_shrink
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TemplateConfig') is not None:
            self.template_config_shrink = m.get('TemplateConfig')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateLiveTranscodeTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateLiveTranscodeTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateLiveTranscodeTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateLiveTranscodeTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateLiveTranscodeTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateMediaInfoRequest(TeaModel):
    def __init__(self, append_tags=None, business_type=None, cate_id=None, category=None, cover_url=None,
                 description=None, input_url=None, media_id=None, media_tags=None, title=None, user_data=None):
        # 是否以append的形式更新Tags字段
        self.append_tags = append_tags  # type: bool
        # 媒资业务类型
        self.business_type = business_type  # type: str
        self.cate_id = cate_id  # type: long
        # 分类
        self.category = category  # type: str
        # 封面图，仅视频媒资有效
        self.cover_url = cover_url  # type: str
        # 描述
        self.description = description  # type: str
        # 媒资媒体类型
        self.input_url = input_url  # type: str
        # 媒资Id
        self.media_id = media_id  # type: str
        # 标签,如果有多个标签用逗号隔开
        self.media_tags = media_tags  # type: str
        # 标题
        self.title = title  # type: str
        # 用户数据，最大1024字节
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateMediaInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.append_tags is not None:
            result['AppendTags'] = self.append_tags
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.cate_id is not None:
            result['CateId'] = self.cate_id
        if self.category is not None:
            result['Category'] = self.category
        if self.cover_url is not None:
            result['CoverURL'] = self.cover_url
        if self.description is not None:
            result['Description'] = self.description
        if self.input_url is not None:
            result['InputURL'] = self.input_url
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.media_tags is not None:
            result['MediaTags'] = self.media_tags
        if self.title is not None:
            result['Title'] = self.title
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppendTags') is not None:
            self.append_tags = m.get('AppendTags')
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('CateId') is not None:
            self.cate_id = m.get('CateId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CoverURL') is not None:
            self.cover_url = m.get('CoverURL')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InputURL') is not None:
            self.input_url = m.get('InputURL')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('MediaTags') is not None:
            self.media_tags = m.get('MediaTags')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UpdateMediaInfoResponseBody(TeaModel):
    def __init__(self, media_id=None, request_id=None):
        # ICE媒资ID
        self.media_id = media_id  # type: str
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateMediaInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateMediaInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateMediaInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateMediaInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateMediaInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdatePipelineRequest(TeaModel):
    def __init__(self, name=None, pipeline_id=None, priority=None, status=None):
        # 管道名称
        self.name = name  # type: str
        # 管道ID
        self.pipeline_id = pipeline_id  # type: str
        # 优先级
        self.priority = priority  # type: int
        # 管道状态。
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdatePipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.pipeline_id is not None:
            result['PipelineId'] = self.pipeline_id
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PipelineId') is not None:
            self.pipeline_id = m.get('PipelineId')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class UpdatePipelineResponseBody(TeaModel):
    def __init__(self, request_id=None, success=None):
        # 请求ID
        self.request_id = request_id  # type: str
        # 是否成功
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdatePipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UpdatePipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdatePipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdatePipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdatePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateSmartJobRequest(TeaModel):
    def __init__(self, feextend=None, job_id=None):
        self.feextend = feextend  # type: str
        self.job_id = job_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateSmartJobRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feextend is not None:
            result['FEExtend'] = self.feextend
        if self.job_id is not None:
            result['JobId'] = self.job_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FEExtend') is not None:
            self.feextend = m.get('FEExtend')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        return self


class UpdateSmartJobResponseBody(TeaModel):
    def __init__(self, feextend=None, job_id=None, request_id=None):
        self.feextend = feextend  # type: str
        self.job_id = job_id  # type: str
        # Id of the request
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateSmartJobResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.feextend is not None:
            result['FEExtend'] = self.feextend
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FEExtend') is not None:
            self.feextend = m.get('FEExtend')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateSmartJobResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateSmartJobResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateSmartJobResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateSmartJobResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateTemplateRequest(TeaModel):
    def __init__(self, config=None, cover_url=None, name=None, preview_media=None, related_mediaids=None,
                 source=None, status=None, template_id=None):
        # 参见模板Config文档
        self.config = config  # type: str
        # 模板封面
        self.cover_url = cover_url  # type: str
        # 模板名称
        self.name = name  # type: str
        # 预览视频媒资id
        self.preview_media = preview_media  # type: str
        # 模板相关素材，模板编辑器使用
        self.related_mediaids = related_mediaids  # type: str
        # 修改来源，默认OpenAPI
        self.source = source  # type: str
        # 模板状态
        self.status = status  # type: str
        # 模板ID
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config is not None:
            result['Config'] = self.config
        if self.cover_url is not None:
            result['CoverUrl'] = self.cover_url
        if self.name is not None:
            result['Name'] = self.name
        if self.preview_media is not None:
            result['PreviewMedia'] = self.preview_media
        if self.related_mediaids is not None:
            result['RelatedMediaids'] = self.related_mediaids
        if self.source is not None:
            result['Source'] = self.source
        if self.status is not None:
            result['Status'] = self.status
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Config') is not None:
            self.config = m.get('Config')
        if m.get('CoverUrl') is not None:
            self.cover_url = m.get('CoverUrl')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PreviewMedia') is not None:
            self.preview_media = m.get('PreviewMedia')
        if m.get('RelatedMediaids') is not None:
            self.related_mediaids = m.get('RelatedMediaids')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class UpdateTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # 请求ID
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadMediaByURLRequest(TeaModel):
    def __init__(self, app_id=None, entity_id=None, media_meta_data=None, post_process_config=None,
                 upload_target_config=None, upload_urls=None, user_data=None):
        self.app_id = app_id  # type: str
        self.entity_id = entity_id  # type: str
        self.media_meta_data = media_meta_data  # type: str
        self.post_process_config = post_process_config  # type: str
        self.upload_target_config = upload_target_config  # type: str
        self.upload_urls = upload_urls  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadMediaByURLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_id is not None:
            result['AppId'] = self.app_id
        if self.entity_id is not None:
            result['EntityId'] = self.entity_id
        if self.media_meta_data is not None:
            result['MediaMetaData'] = self.media_meta_data
        if self.post_process_config is not None:
            result['PostProcessConfig'] = self.post_process_config
        if self.upload_target_config is not None:
            result['UploadTargetConfig'] = self.upload_target_config
        if self.upload_urls is not None:
            result['UploadURLs'] = self.upload_urls
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppId') is not None:
            self.app_id = m.get('AppId')
        if m.get('EntityId') is not None:
            self.entity_id = m.get('EntityId')
        if m.get('MediaMetaData') is not None:
            self.media_meta_data = m.get('MediaMetaData')
        if m.get('PostProcessConfig') is not None:
            self.post_process_config = m.get('PostProcessConfig')
        if m.get('UploadTargetConfig') is not None:
            self.upload_target_config = m.get('UploadTargetConfig')
        if m.get('UploadURLs') is not None:
            self.upload_urls = m.get('UploadURLs')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UploadMediaByURLResponseBodyUploadJobs(TeaModel):
    def __init__(self, job_id=None, media_id=None, source_url=None):
        self.job_id = job_id  # type: str
        self.media_id = media_id  # type: str
        self.source_url = source_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadMediaByURLResponseBodyUploadJobs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.source_url is not None:
            result['SourceURL'] = self.source_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('SourceURL') is not None:
            self.source_url = m.get('SourceURL')
        return self


class UploadMediaByURLResponseBody(TeaModel):
    def __init__(self, request_id=None, upload_jobs=None):
        # RequestId
        self.request_id = request_id  # type: str
        self.upload_jobs = upload_jobs  # type: list[UploadMediaByURLResponseBodyUploadJobs]

    def validate(self):
        if self.upload_jobs:
            for k in self.upload_jobs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(UploadMediaByURLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['UploadJobs'] = []
        if self.upload_jobs is not None:
            for k in self.upload_jobs:
                result['UploadJobs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.upload_jobs = []
        if m.get('UploadJobs') is not None:
            for k in m.get('UploadJobs'):
                temp_model = UploadMediaByURLResponseBodyUploadJobs()
                self.upload_jobs.append(temp_model.from_map(k))
        return self


class UploadMediaByURLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UploadMediaByURLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UploadMediaByURLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadMediaByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadStreamByURLRequest(TeaModel):
    def __init__(self, definition=None, file_extension=None, hdrtype=None, media_id=None, stream_url=None,
                 user_data=None):
        self.definition = definition  # type: str
        self.file_extension = file_extension  # type: str
        self.hdrtype = hdrtype  # type: str
        self.media_id = media_id  # type: str
        self.stream_url = stream_url  # type: str
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadStreamByURLRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.definition is not None:
            result['Definition'] = self.definition
        if self.file_extension is not None:
            result['FileExtension'] = self.file_extension
        if self.hdrtype is not None:
            result['HDRType'] = self.hdrtype
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.stream_url is not None:
            result['StreamURL'] = self.stream_url
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Definition') is not None:
            self.definition = m.get('Definition')
        if m.get('FileExtension') is not None:
            self.file_extension = m.get('FileExtension')
        if m.get('HDRType') is not None:
            self.hdrtype = m.get('HDRType')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('StreamURL') is not None:
            self.stream_url = m.get('StreamURL')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class UploadStreamByURLResponseBody(TeaModel):
    def __init__(self, file_url=None, job_id=None, media_id=None, request_id=None, source_url=None):
        self.file_url = file_url  # type: str
        self.job_id = job_id  # type: str
        self.media_id = media_id  # type: str
        self.request_id = request_id  # type: str
        self.source_url = source_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadStreamByURLResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_url is not None:
            result['FileURL'] = self.file_url
        if self.job_id is not None:
            result['JobId'] = self.job_id
        if self.media_id is not None:
            result['MediaId'] = self.media_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.source_url is not None:
            result['SourceURL'] = self.source_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileURL') is not None:
            self.file_url = m.get('FileURL')
        if m.get('JobId') is not None:
            self.job_id = m.get('JobId')
        if m.get('MediaId') is not None:
            self.media_id = m.get('MediaId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SourceURL') is not None:
            self.source_url = m.get('SourceURL')
        return self


class UploadStreamByURLResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UploadStreamByURLResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UploadStreamByURLResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadStreamByURLResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


