# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class AcceptInquiredSystemEventRequest(TeaModel):
    def __init__(self, choice=None, event_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # > This parameter is in invitational preview and is unavailable.
        self.choice = choice  # type: str
        # The ID of the system event.
        self.event_id = event_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the system event. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AcceptInquiredSystemEventRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.choice is not None:
            result['Choice'] = self.choice
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Choice') is not None:
            self.choice = m.get('Choice')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AcceptInquiredSystemEventResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AcceptInquiredSystemEventResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AcceptInquiredSystemEventResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AcceptInquiredSystemEventResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AcceptInquiredSystemEventResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AcceptInquiredSystemEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ActivateRouterInterfaceRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 router_interface_id=None):
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ActivateRouterInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        return self


class ActivateRouterInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ActivateRouterInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ActivateRouterInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ActivateRouterInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ActivateRouterInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ActivateRouterInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddBandwidthPackageIpsRequest(TeaModel):
    def __init__(self, bandwidth_package_id=None, client_token=None, ip_count=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.client_token = client_token  # type: str
        self.ip_count = ip_count  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddBandwidthPackageIpsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AddBandwidthPackageIpsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddBandwidthPackageIpsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddBandwidthPackageIpsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddBandwidthPackageIpsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddBandwidthPackageIpsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddBandwidthPackageIpsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to be bound to the resource. Valid values of N: 1 to 20 The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.key = key  # type: str
        # The value of tag N to be bound to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddTagsRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_id=None, resource_owner_account=None,
                 resource_owner_id=None, resource_type=None, tag=None):
        self.owner_id = owner_id  # type: long
        # The ID of the region to which the ECS resource belongs. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource. When the resources are instances, this parameter can be interpreted as InstanceId.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   disk
        # *   instance
        # *   image
        # *   securitygroup
        # *   snapshot
        # 
        # All values must be lowercase.
        self.resource_type = resource_type  # type: str
        # The tags.
        self.tag = tag  # type: list[AddTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = AddTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class AddTagsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AllocateDedicatedHostsRequestNetworkAttributes(TeaModel):
    def __init__(self, slb_udp_timeout=None, udp_timeout=None):
        # The timeout period for a UDP session between a Server Load Balancer (SLB) instance and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        self.slb_udp_timeout = slb_udp_timeout  # type: int
        # The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        self.udp_timeout = udp_timeout  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocateDedicatedHostsRequestNetworkAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slb_udp_timeout is not None:
            result['SlbUdpTimeout'] = self.slb_udp_timeout
        if self.udp_timeout is not None:
            result['UdpTimeout'] = self.udp_timeout
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SlbUdpTimeout') is not None:
            self.slb_udp_timeout = m.get('SlbUdpTimeout')
        if m.get('UdpTimeout') is not None:
            self.udp_timeout = m.get('UdpTimeout')
        return self


class AllocateDedicatedHostsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag to be added to the dedicated host.
        # 
        # The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag to the dedicated host.
        # 
        # The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with acs: or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocateDedicatedHostsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AllocateDedicatedHostsRequest(TeaModel):
    def __init__(self, network_attributes=None, action_on_maintenance=None, auto_placement=None,
                 auto_release_time=None, auto_renew=None, auto_renew_period=None, charge_type=None, client_token=None,
                 cpu_over_commit_ratio=None, dedicated_host_cluster_id=None, dedicated_host_name=None, dedicated_host_type=None,
                 description=None, min_quantity=None, owner_account=None, owner_id=None, period=None, period_unit=None,
                 quantity=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None, zone_id=None):
        self.network_attributes = network_attributes  # type: AllocateDedicatedHostsRequestNetworkAttributes
        # The policy used to migrate the instances deployed on the dedicated host when the dedicated host fails or needs to be repaired online. Valid values:
        # 
        # *   Migrate: Instances are migrated to another physical server and restarted.
        # 
        #     If the dedicated host is attached with cloud disks, the default value is Migrate.
        # 
        # *   Stop: The instances are stopped. If the dedicated host cannot be repaired, the instances are migrated to another physical server and restarted.
        # 
        #     If the dedicated host is attached with local disks, the default value is Stop.
        self.action_on_maintenance = action_on_maintenance  # type: str
        # Specifies whether to add the dedicated host to the resource pool for automatic deployment. If you create an ECS instance on a dedicated host without specifying the **DedicatedHostId** parameter, Alibaba Cloud selects a dedicated host from the resource pool to host the instance. For more information, see [Automatic deployment](~~118938~~). Valid values:
        # 
        # *   on: The dedicated host is added to the resource pool for automatic deployment.
        # *   off: The dedicated host is not added to the resource pool for automatic deployment.
        # 
        # Default value: on.
        # 
        # >  If you do not want to add the dedicated host to the resource pool for automatic deployment, set the value to off.
        self.auto_placement = auto_placement  # type: str
        # The automatic release time of the dedicated host. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # > *   It must be at least half an hour later than the current time.
        # > *   It must be at most three years later than the current time.
        # > *   If the value of seconds (ss) is not 00, it is automatically set to 00.
        self.auto_release_time = auto_release_time  # type: str
        # Specifies whether to automatically renew the subscription dedicated host.
        # 
        # >  The **AutoRenew** parameter takes effect only when the **ChargeType** parameter is set to PrePaid.
        # 
        # Default value: false.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal period of the dedicated host. Unit: months. Valid values: 1, 2, 3, 6, and 12.
        # 
        # >  The **AutoRenewPeriod** parameter takes effect and is required only when the **AutoRenew** parameter is set to true.
        self.auto_renew_period = auto_renew_period  # type: int
        # The billing method of the dedicated host. Default value: PostPaid. Valid values:
        # 
        # *   PrePaid: subscription. If you set this parameter to PrePaid, make sure that you have sufficient account balance or credit. Otherwise, InvalidPayMethod is returned.
        # *   PostPaid: pay-as-you-go.
        self.charge_type = charge_type  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The CPU overcommit ratio. You can configure CPU overcommit ratios only for the following dedicated host types: g6s, c6s, and r6s. Valid values: 1 to 5.
        # 
        # The CPU overcommit ratio affects the number of available vCPUs on a dedicated host. You can use the following formula to calculate the number of available vCPUs on a dedicated host: Number of available vCPUs = Number of physical CPU cores × 2 × CPU overcommit ratio. For example, the number of physical CPU cores on each g6s dedicated host is 52. If you set the CPU overcommit ratio of a g6s dedicated host to 4, the number of available vCPUs on the dedicated host is 416. For scenarios that have minimal requirements on CPU stability or where CPU load is not heavy, such as development and test environments, you can increase the number of available vCPUs on a dedicated host by increasing the CPU overcommit ratio. This way, you can deploy more ECS instances of the same specifications on the dedicated host and reduce the unit deployment cost.
        self.cpu_over_commit_ratio = cpu_over_commit_ratio  # type: float
        # The ID of the dedicated host cluster to which to assign the dedicated host.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The name of the dedicated host. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.dedicated_host_name = dedicated_host_name  # type: str
        # The type of the dedicated host. You can call the [DescribeDedicatedHostTypes](~~134240~~) operation to obtain the most recent list of dedicated host types.
        self.dedicated_host_type = dedicated_host_type  # type: str
        # The description of the dedicated host. The description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The minimum number of dedicated hosts to create. Valid values: 1 to 100.
        # 
        # >  If the number of available dedicated hosts is less than the minimum number of dedicated hosts to create, the dedicated hosts fail to be created.
        self.min_quantity = min_quantity  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The subscription period of the dedicated host. The `Period` parameter is required and takes effect only when the `ChargeType` parameter is set to `PrePaid`. Valid values:
        # 
        # *   Valid values when the PeriodUnit parameter is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, and 9.
        # *   Valid values when the PeriodUnit parameter is set to Year: 1, 2, 3, 4, and 5.
        self.period = period  # type: int
        # The unit of the subscription period of the dedicated host. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The number of dedicated hosts that you want to create. Valid values: 1 to 100.
        # 
        # Default: 1.
        self.quantity = quantity  # type: int
        # The ID of the region in which to create the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the dedicated host.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The list of the tags that you want to add. It can be up to 20.
        self.tag = tag  # type: list[AllocateDedicatedHostsRequestTag]
        # The ID of the zone in which to create the dedicated host.
        # 
        # This parameter is empty by default. If you do not specify a zone, the system selects a zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.network_attributes:
            self.network_attributes.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AllocateDedicatedHostsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_attributes is not None:
            result['NetworkAttributes'] = self.network_attributes.to_map()
        if self.action_on_maintenance is not None:
            result['ActionOnMaintenance'] = self.action_on_maintenance
        if self.auto_placement is not None:
            result['AutoPlacement'] = self.auto_placement
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cpu_over_commit_ratio is not None:
            result['CpuOverCommitRatio'] = self.cpu_over_commit_ratio
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.description is not None:
            result['Description'] = self.description
        if self.min_quantity is not None:
            result['MinQuantity'] = self.min_quantity
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.quantity is not None:
            result['Quantity'] = self.quantity
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkAttributes') is not None:
            temp_model = AllocateDedicatedHostsRequestNetworkAttributes()
            self.network_attributes = temp_model.from_map(m['NetworkAttributes'])
        if m.get('ActionOnMaintenance') is not None:
            self.action_on_maintenance = m.get('ActionOnMaintenance')
        if m.get('AutoPlacement') is not None:
            self.auto_placement = m.get('AutoPlacement')
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('CpuOverCommitRatio') is not None:
            self.cpu_over_commit_ratio = m.get('CpuOverCommitRatio')
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MinQuantity') is not None:
            self.min_quantity = m.get('MinQuantity')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Quantity') is not None:
            self.quantity = m.get('Quantity')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = AllocateDedicatedHostsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class AllocateDedicatedHostsResponseBodyDedicatedHostIdSets(TeaModel):
    def __init__(self, dedicated_host_id=None):
        self.dedicated_host_id = dedicated_host_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocateDedicatedHostsResponseBodyDedicatedHostIdSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        return self


class AllocateDedicatedHostsResponseBody(TeaModel):
    def __init__(self, dedicated_host_id_sets=None, request_id=None):
        # The IDs of the dedicated hosts.
        self.dedicated_host_id_sets = dedicated_host_id_sets  # type: AllocateDedicatedHostsResponseBodyDedicatedHostIdSets
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.dedicated_host_id_sets:
            self.dedicated_host_id_sets.validate()

    def to_map(self):
        _map = super(AllocateDedicatedHostsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id_sets is not None:
            result['DedicatedHostIdSets'] = self.dedicated_host_id_sets.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostIdSets') is not None:
            temp_model = AllocateDedicatedHostsResponseBodyDedicatedHostIdSets()
            self.dedicated_host_id_sets = temp_model.from_map(m['DedicatedHostIdSets'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AllocateDedicatedHostsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AllocateDedicatedHostsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AllocateDedicatedHostsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AllocateDedicatedHostsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AllocateEipAddressRequest(TeaModel):
    def __init__(self, activity_id=None, bandwidth=None, client_token=None, isp=None, internet_charge_type=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.activity_id = activity_id  # type: long
        self.bandwidth = bandwidth  # type: str
        self.client_token = client_token  # type: str
        self.isp = isp  # type: str
        self.internet_charge_type = internet_charge_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocateEipAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_id is not None:
            result['ActivityId'] = self.activity_id
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivityId') is not None:
            self.activity_id = m.get('ActivityId')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AllocateEipAddressResponseBody(TeaModel):
    def __init__(self, allocation_id=None, eip_address=None, request_id=None):
        self.allocation_id = allocation_id  # type: str
        self.eip_address = eip_address  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocateEipAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('EipAddress') is not None:
            self.eip_address = m.get('EipAddress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AllocateEipAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AllocateEipAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AllocateEipAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AllocateEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AllocatePublicIpAddressRequest(TeaModel):
    def __init__(self, instance_id=None, ip_address=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, vlan_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The public IP address. If you leave this parameter empty, the system randomly assigns a public IP address to the specified instance.
        self.ip_address = ip_address  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The virtual LAN (VLAN) ID of the instance.
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.vlan_id = vlan_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocatePublicIpAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        return self


class AllocatePublicIpAddressResponseBody(TeaModel):
    def __init__(self, ip_address=None, request_id=None):
        # The public IP address of the instance.
        self.ip_address = ip_address  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AllocatePublicIpAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AllocatePublicIpAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AllocatePublicIpAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AllocatePublicIpAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AllocatePublicIpAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, owner_id=None, resource_owner_account=None, resource_owner_id=None,
                 auto_snapshot_policy_id=None, disk_ids=None, region_id=None):
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the automatic snapshot policy.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The IDs of disks. The value is a JSON array that consists of disk IDs. Separate the disk IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        # The region ID of the automatic snapshot policy and the disks. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.auto_snapshot_policy_id is not None:
            result['autoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.disk_ids is not None:
            result['diskIds'] = self.disk_ids
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('autoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('autoSnapshotPolicyId')
        if m.get('diskIds') is not None:
            self.disk_ids = m.get('diskIds')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class ApplyAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ApplyAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApplyAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssignIpv6AddressesRequest(TeaModel):
    def __init__(self, ipv_6address=None, ipv_6address_count=None, ipv_6prefix=None, ipv_6prefix_count=None,
                 network_interface_id=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # IPv6 address N to assign to the ENI. Valid values of N: 1 to 10.
        # 
        # Example: Ipv6Address.1=2001:db8:1234:1a00::\*\*\*\*\
        # 
        # > You must specify `Ipv6Addresses.N` or `Ipv6AddressCount` but cannot specify both.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The number of IPv6 addresses to randomly generate for the ENI. Valid values: 1 to 10.
        # 
        # >  You must specify `Ipv6Addresses.N` or `Ipv6AddressCount` but cannot specify both.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix = ipv_6prefix  # type: list[str]
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix_count = ipv_6prefix_count  # type: int
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignIpv6AddressesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        if self.ipv_6prefix_count is not None:
            result['Ipv6PrefixCount'] = self.ipv_6prefix_count
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        if m.get('Ipv6PrefixCount') is not None:
            self.ipv_6prefix_count = m.get('Ipv6PrefixCount')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AssignIpv6AddressesResponseBodyIpv6PrefixSets(TeaModel):
    def __init__(self, ipv_6prefix=None):
        self.ipv_6prefix = ipv_6prefix  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignIpv6AddressesResponseBodyIpv6PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        return self


class AssignIpv6AddressesResponseBodyIpv6Sets(TeaModel):
    def __init__(self, ipv_6address=None):
        self.ipv_6address = ipv_6address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignIpv6AddressesResponseBodyIpv6Sets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class AssignIpv6AddressesResponseBody(TeaModel):
    def __init__(self, ipv_6prefix_sets=None, ipv_6sets=None, network_interface_id=None, request_id=None):
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix_sets = ipv_6prefix_sets  # type: AssignIpv6AddressesResponseBodyIpv6PrefixSets
        # The IPv6 addresses assigned to the ENI.
        self.ipv_6sets = ipv_6sets  # type: AssignIpv6AddressesResponseBodyIpv6Sets
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.ipv_6prefix_sets:
            self.ipv_6prefix_sets.validate()
        if self.ipv_6sets:
            self.ipv_6sets.validate()

    def to_map(self):
        _map = super(AssignIpv6AddressesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix_sets is not None:
            result['Ipv6PrefixSets'] = self.ipv_6prefix_sets.to_map()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6PrefixSets') is not None:
            temp_model = AssignIpv6AddressesResponseBodyIpv6PrefixSets()
            self.ipv_6prefix_sets = temp_model.from_map(m['Ipv6PrefixSets'])
        if m.get('Ipv6Sets') is not None:
            temp_model = AssignIpv6AddressesResponseBodyIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssignIpv6AddressesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AssignIpv6AddressesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AssignIpv6AddressesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssignIpv6AddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssignPrivateIpAddressesRequest(TeaModel):
    def __init__(self, client_token=None, ipv_4prefix=None, ipv_4prefix_count=None, network_interface_id=None,
                 owner_account=None, owner_id=None, private_ip_address=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, secondary_private_ip_address_count=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # > This parameter is in invitational preview and is unavailable to general users.
        self.ipv_4prefix = ipv_4prefix  # type: list[str]
        # > This parameter is in invitational preview and is unavailable to general users.
        self.ipv_4prefix_count = ipv_4prefix_count  # type: int
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Secondary private IP address N, which is selected from within the CIDR block of the vSwitch that is connected to the ENI. Valid values of N:
        # 
        # *   When the ENI is in the Available (`Available`) state, the valid values of N are 1 to 32.
        # *   When the ENI is in the InUse (`InUse`) state, the valid values of N are subject to the instance type. For more information, see [Instance families](~~25378~~).
        # 
        # To assign secondary private IP addresses to the ENI, you cannot specify the `PrivateIpAddress.N` and `SecondaryPrivateIpAddressCount` parameters at the same time.
        self.private_ip_address = private_ip_address  # type: list[str]
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The number of private IP addresses to be automatically assigned from within the CIDR block of the vSwitch that is connected to the ENI.
        # 
        # To assign secondary private IP addresses to the ENI, you cannot specify the `PrivateIpAddress.N` and `SecondaryPrivateIpAddressCount` parameters at the same time.
        self.secondary_private_ip_address_count = secondary_private_ip_address_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignPrivateIpAddressesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        if self.ipv_4prefix_count is not None:
            result['Ipv4PrefixCount'] = self.ipv_4prefix_count
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.secondary_private_ip_address_count is not None:
            result['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        if m.get('Ipv4PrefixCount') is not None:
            self.ipv_4prefix_count = m.get('Ipv4PrefixCount')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecondaryPrivateIpAddressCount') is not None:
            self.secondary_private_ip_address_count = m.get('SecondaryPrivateIpAddressCount')
        return self


class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetIpv4PrefixSet(TeaModel):
    def __init__(self, ipv_4prefixes=None):
        self.ipv_4prefixes = ipv_4prefixes  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetIpv4PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefixes is not None:
            result['Ipv4Prefixes'] = self.ipv_4prefixes
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefixes') is not None:
            self.ipv_4prefixes = m.get('Ipv4Prefixes')
        return self


class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet(TeaModel):
    def __init__(self, private_ip_address=None):
        self.private_ip_address = private_ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet(TeaModel):
    def __init__(self, ipv_4prefix_set=None, network_interface_id=None, private_ip_set=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.ipv_4prefix_set = ipv_4prefix_set  # type: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetIpv4PrefixSet
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The private IP addresses assigned to the ENI.
        self.private_ip_set = private_ip_set  # type: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet

    def validate(self):
        if self.ipv_4prefix_set:
            self.ipv_4prefix_set.validate()
        if self.private_ip_set:
            self.private_ip_set.validate()

    def to_map(self):
        _map = super(AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix_set is not None:
            result['Ipv4PrefixSet'] = self.ipv_4prefix_set.to_map()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.private_ip_set is not None:
            result['PrivateIpSet'] = self.private_ip_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4PrefixSet') is not None:
            temp_model = AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetIpv4PrefixSet()
            self.ipv_4prefix_set = temp_model.from_map(m['Ipv4PrefixSet'])
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('PrivateIpSet') is not None:
            temp_model = AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSetPrivateIpSet()
            self.private_ip_set = temp_model.from_map(m['PrivateIpSet'])
        return self


class AssignPrivateIpAddressesResponseBody(TeaModel):
    def __init__(self, assigned_private_ip_addresses_set=None, request_id=None):
        # Details about the ENI.
        self.assigned_private_ip_addresses_set = assigned_private_ip_addresses_set  # type: AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.assigned_private_ip_addresses_set:
            self.assigned_private_ip_addresses_set.validate()

    def to_map(self):
        _map = super(AssignPrivateIpAddressesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assigned_private_ip_addresses_set is not None:
            result['AssignedPrivateIpAddressesSet'] = self.assigned_private_ip_addresses_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssignedPrivateIpAddressesSet') is not None:
            temp_model = AssignPrivateIpAddressesResponseBodyAssignedPrivateIpAddressesSet()
            self.assigned_private_ip_addresses_set = temp_model.from_map(m['AssignedPrivateIpAddressesSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssignPrivateIpAddressesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AssignPrivateIpAddressesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AssignPrivateIpAddressesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssignPrivateIpAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateEipAddressRequest(TeaModel):
    def __init__(self, allocation_id=None, instance_id=None, instance_type=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.allocation_id = allocation_id  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateEipAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AssociateEipAddressResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateEipAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssociateEipAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AssociateEipAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AssociateEipAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateHaVipRequest(TeaModel):
    def __init__(self, client_token=None, ha_vip_id=None, instance_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.client_token = client_token  # type: str
        self.ha_vip_id = ha_vip_id  # type: str
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateHaVipRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AssociateHaVipResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateHaVipResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssociateHaVipResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AssociateHaVipResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AssociateHaVipResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachClassicLinkVpcRequest(TeaModel):
    def __init__(self, instance_id=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, vpc_id=None):
        # The ID of the classic network-type instance. You can call the [DescribeInstances](~~25506~~) operation to query available instances.
        self.instance_id = instance_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the VPC for which the ClassicLink feature is enabled. You can call the [DescribeVpcs](~~35739~~) operation to query available VPCs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachClassicLinkVpcRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class AttachClassicLinkVpcResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachClassicLinkVpcResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachClassicLinkVpcResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachClassicLinkVpcResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachClassicLinkVpcResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachClassicLinkVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachDiskRequest(TeaModel):
    def __init__(self, bootable=None, delete_with_instance=None, device=None, disk_id=None, instance_id=None,
                 key_pair_name=None, owner_account=None, owner_id=None, password=None, resource_owner_account=None,
                 resource_owner_id=None):
        # Specifies whether to attach the disk as a system disk.
        # 
        # Default value: false.
        # 
        # > If the `Bootable` parameter is set to true, the instance must be in the No System Disk state.
        self.bootable = bootable  # type: bool
        # Specifies whether to release the disk when the instance is released. Valid values:
        # 
        # *   true: releases the disk when the instance is released.
        # *   false: does not release the data disk when the instance is released. The disk is retained as a pay-as-you-go data disk.
        # 
        # Default value: false.
        # 
        # When you specify this parameter, take note of the following items:
        # 
        # *   If `OperationLocks` in the DescribeInstances response contains `"LockReason" : "security"` for the instance to which the disk is attached, the instance is locked for security reasons. Even if `DeleteWithInstance` is set to `false`, the DeleteWithInstance parameter is ignored, and the disk is released when the instance is released.
        # *   This parameter cannot be specified for disks for which the multi-attach feature is enabled.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The device name of the disk.
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The ID of the disk. The disk specified by the `DiskId` parameter and the instance specified by the `InstanceId` parameter must reside in the same zone.
        # 
        # > For more information about the limits on attaching a data disk and system disk, see the "Description" section of this topic.
        self.disk_id = disk_id  # type: str
        # The ID of the instance to which to attach the disk.
        self.instance_id = instance_id  # type: str
        # The name of the SSH key pair that you bind to the Linux instance when you attach the system disk.
        # 
        # *   Windows instances do not support logons based on SSH key pairs. The `Password` parameter takes effect even if the KeyPairName parameter is specified.
        # *   For Linux instances, the username and password-based logon method is disabled by default.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The password set when you attach the system disk. The password is applicable only to the administrator and root users. The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        #     ( ) ` ~ ! @ # $ % ^ & * - _ + = | { } [ ] : ; \" < > , . ? /\
        # 
        # The password of a Windows instance cannot start with a forward slash (/).
        # 
        # > If the `Password` parameter is specified, we recommend that you send requests over HTTPS to prevent password leaks.
        self.password = password  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bootable is not None:
            result['Bootable'] = self.bootable
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bootable') is not None:
            self.bootable = m.get('Bootable')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AttachDiskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachInstanceRamRoleRequest(TeaModel):
    def __init__(self, instance_ids=None, owner_id=None, policy=None, ram_role_name=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. The value can be a JSON array that consists of up to 100 instance IDs. Separate the IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        self.owner_id = owner_id  # type: long
        # The policy. The policy must be 1 to 1,024 characters in length. When you attach an instance RAM role to one or more instances, you can specify an additional policy to further restrict the permissions of the role. For more information, see [Policy overview](~~93732~~).
        self.policy = policy  # type: str
        # The name of the instance RAM role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created.
        self.ram_role_name = ram_role_name  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachInstanceRamRoleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult(TeaModel):
    def __init__(self, code=None, instance_id=None, message=None, success=None):
        # Indicates whether the instance RAM role was attached. If 200 is returned, the instance RAM role was attached. If any other value is returned, the instance RAM role failed to be attached. For more information, see the "Error codes" section.
        self.code = code  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Indicates whether the instance RAM role was attached. If success is returned, the instance RAM role was attached. If any other value is returned, the instance RAM role failed to be attached. For more information, see the "Error codes" section.
        self.message = message  # type: str
        # Indicates whether the instance RAM role was attached.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults(TeaModel):
    def __init__(self, attach_instance_ram_role_result=None):
        self.attach_instance_ram_role_result = attach_instance_ram_role_result  # type: list[AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult]

    def validate(self):
        if self.attach_instance_ram_role_result:
            for k in self.attach_instance_ram_role_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttachInstanceRamRoleResult'] = []
        if self.attach_instance_ram_role_result is not None:
            for k in self.attach_instance_ram_role_result:
                result['AttachInstanceRamRoleResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.attach_instance_ram_role_result = []
        if m.get('AttachInstanceRamRoleResult') is not None:
            for k in m.get('AttachInstanceRamRoleResult'):
                temp_model = AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResultsAttachInstanceRamRoleResult()
                self.attach_instance_ram_role_result.append(temp_model.from_map(k))
        return self


class AttachInstanceRamRoleResponseBody(TeaModel):
    def __init__(self, attach_instance_ram_role_results=None, fail_count=None, ram_role_name=None, request_id=None,
                 total_count=None):
        # Details about the results of attaching the instance RAM role.
        self.attach_instance_ram_role_results = attach_instance_ram_role_results  # type: AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults
        # The number of the instances to which the instance RAM role failed to be attached.
        self.fail_count = fail_count  # type: int
        # The name of the instance RAM role.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances to which you attempted to attach the instance RAM role.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.attach_instance_ram_role_results:
            self.attach_instance_ram_role_results.validate()

    def to_map(self):
        _map = super(AttachInstanceRamRoleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attach_instance_ram_role_results is not None:
            result['AttachInstanceRamRoleResults'] = self.attach_instance_ram_role_results.to_map()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachInstanceRamRoleResults') is not None:
            temp_model = AttachInstanceRamRoleResponseBodyAttachInstanceRamRoleResults()
            self.attach_instance_ram_role_results = temp_model.from_map(m['AttachInstanceRamRoleResults'])
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class AttachInstanceRamRoleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachInstanceRamRoleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachInstanceRamRoleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachInstanceRamRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachKeyPairRequest(TeaModel):
    def __init__(self, instance_ids=None, key_pair_name=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances to which you want to attach the SSH key pair. The value can be a JSON array that consists of up to 50 instance IDs. Separate multiple instance IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # The name of the SSH key pair.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the SSH key pair. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachKeyPairRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class AttachKeyPairResponseBodyResultsResult(TeaModel):
    def __init__(self, code=None, instance_id=None, message=None, success=None):
        # The operation status code returned. 200 indicates that the operation was successful.
        self.code = code  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The operation information returned. When the value of Code is 200, the value of Message is successful.
        self.message = message  # type: str
        # Indicates whether the operation was successful.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachKeyPairResponseBodyResultsResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AttachKeyPairResponseBodyResults(TeaModel):
    def __init__(self, result=None):
        self.result = result  # type: list[AttachKeyPairResponseBodyResultsResult]

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AttachKeyPairResponseBodyResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = AttachKeyPairResponseBodyResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class AttachKeyPairResponseBody(TeaModel):
    def __init__(self, fail_count=None, key_pair_name=None, request_id=None, results=None, total_count=None):
        # The number of instances to which the key pair fails to be attached.
        self.fail_count = fail_count  # type: str
        # The name of the key pair.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # An array that contains the results of the operation.
        self.results = results  # type: AttachKeyPairResponseBodyResults
        # The total number of instances to which the SSH key pair is attached.
        self.total_count = total_count  # type: str

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super(AttachKeyPairResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.results is not None:
            result['Results'] = self.results.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Results') is not None:
            temp_model = AttachKeyPairResponseBodyResults()
            self.results = temp_model.from_map(m['Results'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class AttachKeyPairResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachKeyPairResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachKeyPairResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachNetworkInterfaceRequest(TeaModel):
    def __init__(self, instance_id=None, network_card_index=None, network_interface_id=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 trunk_network_instance_id=None, wait_for_network_configuration_ready=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The index of the network interface controller (NIC).
        # 
        # > The value of this parameter varies based on the instance family of the specified instance. If the instance type of the specified instance does not support NICs, leave this parameter empty. If the instance type supports NICs, set this parameter to a valid value. For information about the valid values of this parameter, see [Instance families](~~25378~~).
        self.network_card_index = network_card_index  # type: int
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the trunk ENI.
        # 
        # > This parameter is unavailable for use.
        self.trunk_network_instance_id = trunk_network_instance_id  # type: str
        # > This parameter is no longer used.
        self.wait_for_network_configuration_ready = wait_for_network_configuration_ready  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachNetworkInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_card_index is not None:
            result['NetworkCardIndex'] = self.network_card_index
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trunk_network_instance_id is not None:
            result['TrunkNetworkInstanceId'] = self.trunk_network_instance_id
        if self.wait_for_network_configuration_ready is not None:
            result['WaitForNetworkConfigurationReady'] = self.wait_for_network_configuration_ready
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkCardIndex') is not None:
            self.network_card_index = m.get('NetworkCardIndex')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TrunkNetworkInstanceId') is not None:
            self.trunk_network_instance_id = m.get('TrunkNetworkInstanceId')
        if m.get('WaitForNetworkConfigurationReady') is not None:
            self.wait_for_network_configuration_ready = m.get('WaitForNetworkConfigurationReady')
        return self


class AttachNetworkInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachNetworkInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachNetworkInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachNetworkInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachNetworkInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeSecurityGroupRequestPermissions(TeaModel):
    def __init__(self, description=None, dest_cidr_ip=None, ip_protocol=None, ipv_6dest_cidr_ip=None,
                 ipv_6source_cidr_ip=None, nic_type=None, policy=None, port_range=None, priority=None, source_cidr_ip=None,
                 source_group_id=None, source_group_owner_account=None, source_group_owner_id=None, source_port_range=None,
                 source_prefix_list_id=None):
        # The description of security group rule N. The description must be 1 to 512 characters in length.
        # 
        # Valid values of N: 1 to 100.
        self.description = description  # type: str
        # The destination IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The transport layer protocol of security group rule N. The value of this parameter is case-insensitive. Valid values:
        # 
        # *   TCP
        # *   UDP
        # *   ICMP
        # *   ICMPv6
        # *   GRE
        # *   ALL: All protocols are supported.
        # 
        # Valid values of N: 1 to 100.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6DestCidrIp parameter is valid only when the destination is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `DestCidrIp` parameter.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6SourceCidrIp parameter is valid only when the source is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `SourceCidrIp` parameter.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of security group rule N when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # *   intranet: internal NIC
        # 
        # If the security group is in a VPC, this parameter is set to intranet by default and cannot be modified.
        # 
        # If you specify only DestGroupId when you configure access between security groups, this parameter must be set to intranet.
        # 
        # Default value: internet.
        # 
        # Valid values of N: 1 to 100.
        self.nic_type = nic_type  # type: str
        # The action of security group rule N that determines whether to allow inbound access. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses. In this case, the request times out or the connection cannot be established.
        # 
        # Default value: accept.
        # 
        # Valid values of N: 1 to 100.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # For more information, see [Typical applications of commonly used ports](~~40724~~).
        # 
        # Valid values of N: 1 to 100.
        self.port_range = port_range  # type: str
        # The priority of security group rule N. A smaller value indicates a higher priority. Valid values: 1 to 100.
        # 
        # Default value: 1.
        # 
        # Valid values of N: 1 to 100.
        self.priority = priority  # type: str
        # The source IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The ID of the source security group to be referenced in security group rule N.
        # 
        # *   At least one of `SourceGroupId`, `SourceCidrIp`, `Ipv6SourceCidrIp`, and `SourcePrefixListId` must be specified.
        # *   If `SourceGroupId` is specified but `SourceCidrIp` or `Ipv6SourceCidrIp` is not specified, `NicType` must be set to `intranet`.
        # *   If both `SourceGroupId` and `SourceCidrIp` are specified, `SourceCidrIp` takes precedence.
        # 
        # Valid values of N: 1 to 100.
        # 
        # Take note of the following items:
        # 
        # *   For advanced security groups, security groups cannot be used as authorization objects.
        # *   For each basic security group, a maximum of 20 security groups can be used as authorization objects.
        self.source_group_id = source_group_id  # type: str
        # The Alibaba Cloud account that manages the source security group when you set security group rule N across accounts.
        # 
        # *   If both `SourceGroupOwnerAccount` and `SourceGroupOwnerId` are not specified, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerAccount` parameter is invalid.
        # 
        # Valid values of N: 1 to 100.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # The ID of the Alibaba Cloud account that manages the source security group when you set security group rule N across accounts.
        # 
        # *   If both `SourceGroupOwnerAccount` and `SourceGroupOwnerId` are not specified, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerAccount` parameter is invalid.
        # 
        # Valid values of N: 1 to 100.
        self.source_group_owner_id = source_group_owner_id  # type: long
        # The range of source ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_port_range = source_port_range  # type: str
        # The ID of the source prefix list to be referenced in security group rule N. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # Valid values of N: 1 to 100.
        # 
        # Take note of the following items:
        # 
        # *   If a security group is in the classic network, prefix lists cannot be referenced in the security group rules. For information about the limits on security groups and prefix lists, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # *   If you specify the `SourceCidrIp`, `Ipv6SourceCidrIp`, or `SourceGroupId` parameter, this parameter is ignored.
        self.source_prefix_list_id = source_prefix_list_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AuthorizeSecurityGroupRequestPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_group_owner_id is not None:
            result['SourceGroupOwnerId'] = self.source_group_owner_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourceGroupOwnerId') is not None:
            self.source_group_owner_id = m.get('SourceGroupOwnerId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        return self


class AuthorizeSecurityGroupRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, permissions=None,
                 policy=None, port_range=None, priority=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None, source_cidr_ip=None, source_group_id=None,
                 source_group_owner_account=None, source_group_owner_id=None, source_port_range=None, source_prefix_list_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # This parameter is discontinued. Use `Permissions.N.Description` to specify the description of security group rule N.
        self.description = description  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestCidrIp` to specify the destination IPv4 CIDR block.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.IpProtocol` to specify the transport layer protocol.
        self.ip_protocol = ip_protocol  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6DestCidrIp` to specify the destination IPv6 CIDR block.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6SourceCidrIp` to specify the source IPv6 CIDR block.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.NicType` to specify the NIC type.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Details about the security group rules.
        self.permissions = permissions  # type: list[AuthorizeSecurityGroupRequestPermissions]
        # This parameter is discontinued. Use `Permissions.N.Policy` to specify whether to allow inbound access.
        self.policy = policy  # type: str
        # This parameter is discontinued. Use `Permissions.N.PortRange` to specify the range of destination ports.
        self.port_range = port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.Priority` to specify the rule priority.
        self.priority = priority  # type: str
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceCidrIp` to specify the source IPv4 CIDR block.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupId` to specify the ID of the source security group.
        self.source_group_id = source_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupOwnerAccount` to specify the Alibaba Cloud account that manages the source security group.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupOwnerId` to specify the ID of the Alibaba Cloud account that manages the source security group.
        self.source_group_owner_id = source_group_owner_id  # type: long
        # This parameter is discontinued. Use `Permissions.N.SourcePortRange` to specify the range of source ports.
        self.source_port_range = source_port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourcePrefixListId` to specify the ID of the source prefix list.
        self.source_prefix_list_id = source_prefix_list_id  # type: str

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AuthorizeSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['Permissions'].append(k.to_map() if k else None)
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_group_owner_id is not None:
            result['SourceGroupOwnerId'] = self.source_group_owner_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.permissions = []
        if m.get('Permissions') is not None:
            for k in m.get('Permissions'):
                temp_model = AuthorizeSecurityGroupRequestPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourceGroupOwnerId') is not None:
            self.source_group_owner_id = m.get('SourceGroupOwnerId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        return self


class AuthorizeSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AuthorizeSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AuthorizeSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AuthorizeSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AuthorizeSecurityGroupEgressRequestPermissions(TeaModel):
    def __init__(self, description=None, dest_cidr_ip=None, dest_group_id=None, dest_group_owner_account=None,
                 dest_group_owner_id=None, dest_prefix_list_id=None, ip_protocol=None, ipv_6dest_cidr_ip=None,
                 ipv_6source_cidr_ip=None, nic_type=None, policy=None, port_range=None, priority=None, source_cidr_ip=None,
                 source_port_range=None):
        # The description of security group rule N. The description must be 1 to 512 characters in length.
        # 
        # Valid values of N: 1 to 100.
        self.description = description  # type: str
        # The destination IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The ID of the destination security group to be referenced in security group rule N.
        # 
        # *   At least one of `DestGroupId`, `DestCidrIp`, `Ipv6DestCidrIp`, and `DestPrefixListId` must be specified.
        # *   If `DestGroupId` is specified but `DestCidrIp` is not specified, the `NicType` parameter must be set to intranet.
        # *   If both `DestGroupId` and `DestCidrIp` are specified, `DestCidrIp` takes precedence.
        # 
        # Valid values of N: 1 to 100.
        # 
        # Take note of the following items:
        # 
        # *   For advanced security groups, security groups cannot be used as authorization objects.
        # *   For each basic security group, a maximum of 20 security groups can be used as authorization objects.
        self.dest_group_id = dest_group_id  # type: str
        # The Alibaba Cloud account that manages the destination security group when you set security group rule N across accounts.
        # 
        # *   If both `DestGroupOwnerAccount` and `DestGroupOwnerId` are not specified, the rule is created to control access to another security group within your Alibaba Cloud account.
        # *   If `DestCidrIp` is specified, `DestGroupOwnerAccount` is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # The ID of the Alibaba Cloud account that manages the destination security group when you set security group rule N across accounts.
        # 
        # *   If both `DestGroupOwnerId` and `DestGroupOwnerAccount` are not specified, the rule is created to control access to another security group within your Alibaba Cloud account.
        # *   If you specify the `DestCidrIp` parameter, the `DestGroupOwnerId` parameter is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.dest_group_owner_id = dest_group_owner_id  # type: long
        # The ID of the destination prefix list to be referenced in security group rule N. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # Take note of the following items:
        # 
        # *   If a security group is in the classic network, you cannot reference prefix lists in the security group rules. For information about the limits on security groups and prefix lists, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # *   If you specify `DestCidrIp`, `Ipv6DestCidrIp`, or `DestGroupId`, Permissions.N.DestPrefixListId is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # The transport layer protocol of security group rule N. The value of this parameter is case-insensitive. Valid values:
        # 
        # *   TCP
        # *   UDP
        # *   ICMP
        # *   ICMPv6
        # *   GRE
        # *   ALL: All protocols are supported.
        # 
        # Valid values of N: 1 to 100.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6DestCidrIp parameter is valid only when the destination is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the`DestCidrIp` parameter.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6SourceCidrIp parameter is valid only when the source is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `DestCidrIp` parameter.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of security group rule N when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # 
        # *   intranet: internal NIC
        # 
        #     *   If the security group is in a VPC, this parameter is set to intranet by default and cannot be changed.
        #     *   If you specify only DestGroupId when you configure access between security groups, this parameter must be set to intranet.
        # 
        # Default value: internet.
        # 
        # Valid values of N: 1 to 100.
        self.nic_type = nic_type  # type: str
        # The action of security group rule N that determines whether to allow outbound access. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses. In this case, the request times out or the connection cannot be established.
        # 
        # Default value: accept.
        # 
        # Valid values of N: 1 to 100.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # Valid values of N: 1 to 100.
        self.port_range = port_range  # type: str
        # The priority of security group rule N. A smaller value indicates a higher priority. Valid values: 1 to 100.
        # 
        # Default value: 1.
        # 
        # Valid values of N: 1 to 100.
        self.priority = priority  # type: str
        # The source IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The range of source ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_port_range = source_port_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AuthorizeSecurityGroupEgressRequestPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_group_owner_id is not None:
            result['DestGroupOwnerId'] = self.dest_group_owner_id
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestGroupOwnerId') is not None:
            self.dest_group_owner_id = m.get('DestGroupOwnerId')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class AuthorizeSecurityGroupEgressRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, dest_group_id=None,
                 dest_group_owner_account=None, dest_group_owner_id=None, dest_prefix_list_id=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, permissions=None,
                 policy=None, port_range=None, priority=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None, source_cidr_ip=None, source_port_range=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # This parameter is discontinued. Use `Permissions.N.Description` to specify the description of security group rule N.
        self.description = description  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestCidrIp` to specify the destination IPv4 CIDR block.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupId` to specify the ID of the destination security group.
        self.dest_group_id = dest_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupOwnerAccount` to specify the Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupOwnerId` to specify the ID of the Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_id = dest_group_owner_id  # type: long
        # This parameter is discontinued. Use `Permissions.N.DestPrefixListId` to specify the ID of the destination prefix list.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.IpProtocol` to specify the transport layer protocol.
        self.ip_protocol = ip_protocol  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6DestCidrIp` to specify the destination IPv6 CIDR block.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6SourceCidrIp` to specify the source IPv6 CIDR block.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.NicType` to specify the NIC type.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Details about the security group rules.
        self.permissions = permissions  # type: list[AuthorizeSecurityGroupEgressRequestPermissions]
        # This parameter is discontinued. Use `Permissions.N.Policy` to specify whether to allow outbound access.
        self.policy = policy  # type: str
        # This parameter is discontinued. Use `Permissions.N.PortRange` to specify the range of destination ports.
        self.port_range = port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.Priority` to specify the rule priority.
        self.priority = priority  # type: str
        # The region ID of the source security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceCidrIp` to specify the source IPv4 CIDR block.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourcePortRange` to specify the range of source ports.
        self.source_port_range = source_port_range  # type: str

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AuthorizeSecurityGroupEgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_group_owner_id is not None:
            result['DestGroupOwnerId'] = self.dest_group_owner_id
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['Permissions'].append(k.to_map() if k else None)
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestGroupOwnerId') is not None:
            self.dest_group_owner_id = m.get('DestGroupOwnerId')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.permissions = []
        if m.get('Permissions') is not None:
            for k in m.get('Permissions'):
                temp_model = AuthorizeSecurityGroupEgressRequestPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class AuthorizeSecurityGroupEgressResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AuthorizeSecurityGroupEgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AuthorizeSecurityGroupEgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AuthorizeSecurityGroupEgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AuthorizeSecurityGroupEgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AuthorizeSecurityGroupEgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, owner_id=None, resource_owner_account=None, resource_owner_id=None, disk_ids=None,
                 region_id=None):
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of the disks for which you want to disable the automatic snapshot policy. To disable the automatic snapshot policy for multiple disks, you can set this parameter to a JSON array that consists of multiple disk IDs, such as \["dxxxxxxxxx", "dyyyyyyyyy", … "dzzzzzzzzz"]. Separate the disk IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        # The region ID of the automatic snapshot policy and the disks. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.disk_ids is not None:
            result['diskIds'] = self.disk_ids
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('diskIds') is not None:
            self.disk_ids = m.get('diskIds')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class CancelAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelCopyImageRequest(TeaModel):
    def __init__(self, image_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the image that is being copied.
        self.image_id = image_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image copy. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCopyImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CancelCopyImageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCopyImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelCopyImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelCopyImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelCopyImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelCopyImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelImagePipelineExecutionRequestTemplateTag(TeaModel):
    def __init__(self, key=None, value=None):
        # >  This parameter is deprecated.
        self.key = key  # type: str
        # >  This parameter is deprecated.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelImagePipelineExecutionRequestTemplateTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CancelImagePipelineExecutionRequest(TeaModel):
    def __init__(self, execution_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, template_tag=None):
        # The ID of the image build task.
        self.execution_id = execution_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image build task. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # > This parameter is deprecated.
        self.template_tag = template_tag  # type: list[CancelImagePipelineExecutionRequestTemplateTag]

    def validate(self):
        if self.template_tag:
            for k in self.template_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CancelImagePipelineExecutionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execution_id is not None:
            result['ExecutionId'] = self.execution_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['TemplateTag'] = []
        if self.template_tag is not None:
            for k in self.template_tag:
                result['TemplateTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecutionId') is not None:
            self.execution_id = m.get('ExecutionId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.template_tag = []
        if m.get('TemplateTag') is not None:
            for k in m.get('TemplateTag'):
                temp_model = CancelImagePipelineExecutionRequestTemplateTag()
                self.template_tag.append(temp_model.from_map(k))
        return self


class CancelImagePipelineExecutionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelImagePipelineExecutionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelImagePipelineExecutionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelImagePipelineExecutionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelImagePipelineExecutionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelImagePipelineExecutionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelPhysicalConnectionRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelPhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class CancelPhysicalConnectionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelPhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelPhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelPhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelPhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelPhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelSimulatedSystemEventsRequest(TeaModel):
    def __init__(self, event_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of system events. You can specify up to 100 system event IDs.
        self.event_id = event_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the system event. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelSimulatedSystemEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CancelSimulatedSystemEventsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelSimulatedSystemEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelSimulatedSystemEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelSimulatedSystemEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelSimulatedSystemEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelSimulatedSystemEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelTaskRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 task_id=None):
        self.owner_id = owner_id  # type: long
        # The region ID. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the task. You can call the [DescribeTasks](~~25622~~) operation to query the list of task IDs.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CancelTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConnectRouterInterfaceRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 router_interface_id=None):
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConnectRouterInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        return self


class ConnectRouterInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConnectRouterInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConnectRouterInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ConnectRouterInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ConnectRouterInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConnectRouterInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConvertNatPublicIpToEipRequest(TeaModel):
    def __init__(self, instance_id=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the instance whose public IP address you want to convert into an EIP.
        self.instance_id = instance_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConvertNatPublicIpToEipRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ConvertNatPublicIpToEipResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConvertNatPublicIpToEipResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConvertNatPublicIpToEipResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ConvertNatPublicIpToEipResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ConvertNatPublicIpToEipResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConvertNatPublicIpToEipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyImageRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the image copy.
        # 
        # The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag of the image copy.
        # 
        # The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyImageRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CopyImageRequest(TeaModel):
    def __init__(self, destination_description=None, destination_image_name=None, destination_region_id=None,
                 encrypt_algorithm=None, encrypted=None, image_id=None, kmskey_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None, tag=None):
        # The description of the image copy. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.destination_description = destination_description  # type: str
        # The name of the image copy. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        self.destination_image_name = destination_image_name  # type: str
        # The ID of the destination region to which to copy the source custom image.
        self.destination_region_id = destination_region_id  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt the image copy.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the source custom image.
        self.image_id = image_id  # type: str
        # The ID of the key used to encrypt the image copy.
        self.kmskey_id = kmskey_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the source custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the image copy belongs. If you do not specify this parameter, the image copy belongs to the default resource group.
        # 
        # >  If you use a RAM user that is not authorized to manage the default resource group to call the CopyImage operation and do not specify the `ResourceGroupId` parameter, the `Forbbiden: User not authorized to operate on the specified resource` error message is returned. You must specify the ID of a resource group that the RAM user is authorized to manage or authorize the RAM user to manage the default resource group before you call the CopyImage operation again.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags of the image copy. You can specify up to 20 tags.
        self.tag = tag  # type: list[CopyImageRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CopyImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_description is not None:
            result['DestinationDescription'] = self.destination_description
        if self.destination_image_name is not None:
            result['DestinationImageName'] = self.destination_image_name
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestinationDescription') is not None:
            self.destination_description = m.get('DestinationDescription')
        if m.get('DestinationImageName') is not None:
            self.destination_image_name = m.get('DestinationImageName')
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CopyImageRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CopyImageResponseBody(TeaModel):
    def __init__(self, image_id=None, request_id=None):
        # The ID of the image copy.
        self.image_id = image_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopyImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CopyImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CopyImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopySnapshotRequestArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # > This parameter is in invitational preview and is unavailable.
        self.assume_role_for = assume_role_for  # type: long
        # > This parameter is in invitational preview and is unavailable.
        self.role_type = role_type  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopySnapshotRequestArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class CopySnapshotRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to be bound to the new snapshot. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain http:// or https://. It cannot start with acs: or aliyun.
        self.key = key  # type: str
        # The value of tag N to be bound to the new snapshot. The tag value can be an empty string. It can be up to 128 characters in length and cannot contain http:// or https://. It cannot start with acs: or aliyun.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopySnapshotRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CopySnapshotRequest(TeaModel):
    def __init__(self, arn=None, destination_region_id=None, destination_snapshot_description=None,
                 destination_snapshot_name=None, encrypted=None, kmskey_id=None, owner_id=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, retention_days=None, snapshot_id=None, tag=None):
        # > This parameter is in invitational preview and is unavailable.
        self.arn = arn  # type: list[CopySnapshotRequestArn]
        # The region ID of the new snapshot.
        self.destination_region_id = destination_region_id  # type: str
        # The description of the new snapshot. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.destination_snapshot_description = destination_snapshot_description  # type: str
        # The name of the new snapshot. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.destination_snapshot_name = destination_snapshot_name  # type: str
        # Specifies whether to query only encrypted cloud disks.
        # 
        # *   true: queries only encrypted cloud disks.
        # *   false: does not query encrypted cloud disks.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the Key Management Service (KMS) key used for the data disk.
        self.kmskey_id = kmskey_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the source snapshot. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The retention period of the new snapshot. Unit: days. The new snapshot will be automatically released when it expires. Valid values: 1 to 65536.
        # 
        # This parameter is empty by default, which indicates that the snapshot will not be automatically released.
        self.retention_days = retention_days  # type: int
        # The ID of the source snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The tags of the new snapshot.
        self.tag = tag  # type: list[CopySnapshotRequestTag]

    def validate(self):
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CopySnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.destination_snapshot_description is not None:
            result['DestinationSnapshotDescription'] = self.destination_snapshot_description
        if self.destination_snapshot_name is not None:
            result['DestinationSnapshotName'] = self.destination_snapshot_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = CopySnapshotRequestArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('DestinationSnapshotDescription') is not None:
            self.destination_snapshot_description = m.get('DestinationSnapshotDescription')
        if m.get('DestinationSnapshotName') is not None:
            self.destination_snapshot_name = m.get('DestinationSnapshotName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CopySnapshotRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CopySnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the new snapshot.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopySnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CopySnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CopySnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CopySnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopySnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateActivationRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateActivationRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateActivationRequest(TeaModel):
    def __init__(self, description=None, instance_count=None, instance_name=None, ip_address_range=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, tag=None,
                 time_to_live_in_hours=None):
        # The description of the activation code. The description can be 1 to 100 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The maximum number of times that the activation code can be used to register managed instances. Valid values: 1 to 1000.
        # 
        # Default value: 10.
        self.instance_count = instance_count  # type: int
        # The default instance name prefix. The instance name prefix must be 1 to 50 characters in length. It must start with a letter and cannot start with `http://` or `https://`. The instance name prefix can contain letters, digits, periods (.), underscores (\_), hyphens (-), and colons (:).
        # 
        # If you use the activation code created by calling the CreateActivation operation to register managed instances, the instances are assigned sequential names that are prefixed by the value of this parameter. You can also specify a new instance name to override the assigned sequential name when you register a managed instance.
        # 
        # If you specify InstanceName when you register a managed instance, an instance name in the format of `<InstanceName>-<Number>` is generated. The number of digits in the \<Number> value is determined by that in the `InstanceCount` value. Example: `001`. If you do not specify InstanceName, the hostname (Hostname) is used as the instance name.
        self.instance_name = instance_name  # type: str
        # The IP addresses of hosts that are allowed to use the activation code. The value can be IPv4 addresses, IPv6 addresses, or CIDR blocks.
        self.ip_address_range = ip_address_range  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the activation code. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.tag = tag  # type: list[CreateActivationRequestTag]
        # The validity period of the activation code. The activation code cannot be used to register new instances after the validity period expires. Unit: hours. Valid values: 1 to 24.
        # 
        # Default value: 4.
        self.time_to_live_in_hours = time_to_live_in_hours  # type: long

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateActivationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip_address_range is not None:
            result['IpAddressRange'] = self.ip_address_range
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.time_to_live_in_hours is not None:
            result['TimeToLiveInHours'] = self.time_to_live_in_hours
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IpAddressRange') is not None:
            self.ip_address_range = m.get('IpAddressRange')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateActivationRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TimeToLiveInHours') is not None:
            self.time_to_live_in_hours = m.get('TimeToLiveInHours')
        return self


class CreateActivationResponseBody(TeaModel):
    def __init__(self, activation_code=None, activation_id=None, request_id=None):
        # The value of the activation code. The value is returned only once after the CreateActivation operation is called and cannot be subsequently queried. You must properly save the return value.
        self.activation_code = activation_code  # type: str
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateActivationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_code is not None:
            result['ActivationCode'] = self.activation_code
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationCode') is not None:
            self.activation_code = m.get('ActivationCode')
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateActivationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateActivationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateActivationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateActivationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAutoProvisioningGroupRequestLaunchConfigurationArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # >  This parameter is in invitational preview and unavailable for general users.
        self.assume_role_for = assume_role_for  # type: long
        # >  This parameter is in invitational preview and unavailable for general users.
        self.role_type = role_type  # type: str
        # >  This parameter is in invitational preview and unavailable for general users.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchConfigurationArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk(TeaModel):
    def __init__(self, category=None, delete_with_instance=None, description=None, device=None, disk_name=None,
                 encrypted=None, kms_key_id=None, performance_level=None, size=None, snapshot_id=None):
        # The category of data disk N. Valid values of N: 1 to 16. Valid values of this parameter:
        # 
        # - cloud_efficiency: ultra disk
        # - cloud_ssd: standard SSD
        # - cloud_essd: ESSD
        # - cloud: basic disk
        # 
        # For I/O optimized instances, the default value is cloud_efficiency. For non-I/O optimized instances, the default value is cloud.  
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.category = category  # type: str
        # Specifies whether to release data disk N when its associated instance is released. Valid values: 
        # 
        # - true: releases data disk N when the instance is released.
        # - false: does not release data disk N when the instance is released.
        # 
        # Default value: true. 
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of data disk N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`. When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.description = description  # type: str
        # The mount point of data disk N. When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.device = device  # type: str
        # The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (_), and hyphens (-).  
        # 
        # This parameter is empty by default. 
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.disk_name = disk_name  # type: str
        # Specifies whether to encrypt data disk N. Valid values:
        # 
        # - true: encrypts data disk N.
        # - false: does not encrypt data disk N.
        # 
        # Default value: false. 
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.encrypted = encrypted  # type: bool
        # The ID of the Key Management Service (KMS) key to be used for data disk N. When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.kms_key_id = kms_key_id  # type: str
        # The performance level of the ESSD to be used as data disk N. The value of N must be the same as that of N in the `LaunchConfiguration.DataDisk.N.Category` parameter. Default value: PL1. Valid values: 
        # 
        # - PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # - PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # - PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # - PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/essds).  
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.performance_level = performance_level  # type: str
        # The size of data disk N. Valid values of N: 1 to 16. Unit: GiB. Valid values of this parameter: 
        # 
        # - Valid values when LaunchConfiguration.DataDisk.N.Category is set to cloud_efficiency: 20 to 32768.
        # - Valid values when LaunchConfiguration.DataDisk.N.Category is set to cloud_ssd: 20 to 32768.
        # - Valid values when LaunchConfiguration.DataDisk.N.Category is set to cloud_essd: depend on the `LaunchConfiguration.DataDisk.N.PerformanceLevel` value.    - Valid values when LaunchConfiguration.DataDisk.N.PerformanceLevel is set to PL0: 40 to 32768.
        #   - Valid values when LaunchConfiguration.DataDisk.N.PerformanceLevel is set to PL1: 20 to 32768.
        #   - Valid values when LaunchConfiguration.DataDisk.N.PerformanceLevel is set to PL2: 461 to 32768.
        #   - Valid values when LaunchConfiguration.DataDisk.N.PerformanceLevel is set to PL3: 1261 to 32768.
        # - Valid values when LaunchConfiguration.DataDisk.N.Category is set to cloud: 5 to 2000.
        # 
        # >  The value of LaunchConfiguration.DataDisk.N.Size must be greater than or equal to the size of the snapshot specified by the `LaunchConfiguration.DataDisk.N.SnapshotId` parameter.  When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.size = size  # type: int
        # The ID of the snapshot to be used to create data disk N. Valid values of N: 1 to 16. 
        # 
        # After this parameter is specified, the `LaunchConfiguration.DataDisk.N.Size` parameter is ignored. The size of data disk N is the same as that of the snapshot specified by this parameter. Use snapshots that were created on or after July 15, 2013. Otherwise, an error is returned and your request is rejected.  
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kms_key_id is not None:
            result['KmsKeyId'] = self.kms_key_id
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KmsKeyId') is not None:
            self.kms_key_id = m.get('KmsKeyId')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateAutoProvisioningGroupRequestLaunchConfigurationSystemDisk(TeaModel):
    def __init__(self, encrypt_algorithm=None, encrypted=None, kmskey_id=None):
        # > This parameter is in invitational preview and is unavailable.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt the disk. Valid values:
        # 
        # *   true: encrypts the disk.
        # *   false: does not encrypt the disk.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: str
        # The ID of the Key Management Service (KMS) key used by the cloud disk.
        self.kmskey_id = kmskey_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchConfigurationSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        return self


class CreateAutoProvisioningGroupRequestLaunchConfigurationTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the instance.
        # 
        # The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain `http://` or `https://`.
        # 
        # When both the `LaunchTemplateId` and `LaunchConfiguration.*` parameters are specified, the `LaunchTemplateId` parameter takes precedence.
        self.key = key  # type: str
        # The value of tag of the instance.
        # 
        # The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with acs: or contain `http://` or `https://`.
        # 
        # When both the `LaunchTemplateId` and `LaunchConfiguration.*` parameters are specified, the `LaunchTemplateId` parameter takes precedence.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchConfigurationTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateAutoProvisioningGroupRequestLaunchConfiguration(TeaModel):
    def __init__(self, arn=None, credit_specification=None, data_disk=None, deployment_set_id=None, host_name=None,
                 host_names=None, image_id=None, instance_description=None, instance_name=None, internet_charge_type=None,
                 internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None, key_pair_name=None, password=None,
                 password_inherit=None, ram_role_name=None, resource_group_id=None, security_enhancement_strategy=None,
                 security_group_id=None, security_group_ids=None, system_disk=None, system_disk_category=None,
                 system_disk_description=None, system_disk_name=None, system_disk_performance_level=None, system_disk_size=None, tag=None,
                 user_data=None):
        # >  This parameter is in invitational preview and unavailable for general users.
        self.arn = arn  # type: list[CreateAutoProvisioningGroupRequestLaunchConfigurationArn]
        # The performance mode of the burstable instance. Valid values:
        # 
        # *   Standard: the standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
        # *   Unlimited: the unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).
        # 
        # This parameter is empty by default.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.credit_specification = credit_specification  # type: str
        # The details of data disks.
        self.data_disk = data_disk  # type: list[CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk]
        # The ID of the deployment set to which to deploy the instance.
        self.deployment_set_id = deployment_set_id  # type: str
        # The hostname of the instance. Take note of the following items:
        # 
        # *   The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # *   For Windows instances, the hostname must be 2 to 15 characters in length and cannot contain periods (.) or contain only digits. It can contain letters, digits, and hyphens (-).
        # *   For instances that run other operating systems such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        # *   You cannot specify both the `LaunchConfiguration.HostName` and `LaunchConfiguration.HostNames.N` parameters. Otherwise, an error is returned.
        # *   When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.host_name = host_name  # type: str
        # The hostnames of instances. You can use this parameter to specify different hostnames for multiple instances.
        self.host_names = host_names  # type: list[str]
        # The ID of the image to be used to create the instance. You can call the [DescribeImages](~~25534~~) operation to query available image resources. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.image_id = image_id  # type: str
        # The description of the instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.instance_description = instance_description  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). The default value of this parameter is the `InstanceId` value.
        # 
        # When you batch create instances, you can batch configure sequential names for the instances. For more information, see [Batch configure sequential names or hostnames for multiple instances](~~196048~~).
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.instance_name = instance_name  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # >  When the pay-by-traffic billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as the upper limits of bandwidth instead of guaranteed performance specifications. When demands outstrip resource supplies, the maximum bandwidth may be affected. If you want guaranteed bandwidth for your instance, use the pay-by-bandwidth billing method.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of this parameter are 1 to 10 and the default value is 10.
        # *   When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the value of `LaunchConfiguration.InternetMaxBandwidthOut`, and the default value is the value of `LaunchConfiguration.InternetMaxBandwidthOut`.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # Default value: 0.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        # 
        # For instances of retired instance types, the default value is none. For instances of other instance types, the default value is optimized.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.io_optimized = io_optimized  # type: str
        # The name of the key pair to be bound to the instance.
        # 
        # *   For Windows instances, this parameter is ignored. This parameter is empty by default.
        # *   For Linux instances, the password-based logon method is disabled by default.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.key_pair_name = key_pair_name  # type: str
        # The password of the instance. The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        # ``( ) ` ~ ! @ # $ % ^ & * - _ + = | { }  ``: ; \" < > , . ? /``  For Windows instances, the password cannot start with a forward slash (/). When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence. `
        self.password = password  # type: str
        # Specifies whether to use the password preset in the image. Valid values:
        # 
        # *   true: uses the preset password.
        # *   false: does not use the preset password.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.password_inherit = password_inherit  # type: bool
        # The name of the instance Resource Access Management (RAM) role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the resource group to which to assign the instance. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.resource_group_id = resource_group_id  # type: str
        # Specifies whether to enable security hardening. Valid values:
        # 
        # *   Active: enables security hardening. This value is applicable only to public images.
        # *   Deactive: does not enable security hardening. This value is applicable to all images.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to assign the instance.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The information of the system disk on the instance. When both the LaunchTemplateId and LaunchConfiguration.* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk = system_disk  # type: CreateAutoProvisioningGroupRequestLaunchConfigurationSystemDisk
        # The category of the system disk. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: enhanced SSD (ESSD)
        # *   cloud: basic disk
        # 
        # For non-I/O optimized instances of a retired instance type, the default value is cloud. For other types of instances, the default value is cloud_efficiency.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk_category = system_disk_category  # type: str
        # The description of the system disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk_description = system_disk_description  # type: str
        # The name of the system disk. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk_name = system_disk_name  # type: str
        # The performance level of the ESSD to be used as the system disk. Default value: PL0. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk_performance_level = system_disk_performance_level  # type: str
        # The size of the system disk. Valid values: 20 to 500. Unit: GiB. This parameter value must be at least 20 and greater than or equal to the size of the image specified by the LaunchConfiguration.ImageId parameter.
        # 
        # Default value: 40 or the size of the image specified by the LaunchConfiguration.ImageId parameter, whichever is greater.
        # 
        # When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.system_disk_size = system_disk_size  # type: int
        # The tags of the instance. You can specify up to 20 tags.
        self.tag = tag  # type: list[CreateAutoProvisioningGroupRequestLaunchConfigurationTag]
        # The user data of the instance. The user data must be encoded in Base64. The raw data can be up to 16 KB in size. When both the LaunchTemplateId and LaunchConfiguration.\* parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.user_data = user_data  # type: str

    def validate(self):
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchConfiguration, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.host_names is not None:
            result['HostNames'] = self.host_names
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_description is not None:
            result['InstanceDescription'] = self.instance_description
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.system_disk_description is not None:
            result['SystemDiskDescription'] = self.system_disk_description
        if self.system_disk_name is not None:
            result['SystemDiskName'] = self.system_disk_name
        if self.system_disk_performance_level is not None:
            result['SystemDiskPerformanceLevel'] = self.system_disk_performance_level
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = CreateAutoProvisioningGroupRequestLaunchConfigurationArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = CreateAutoProvisioningGroupRequestLaunchConfigurationDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('HostNames') is not None:
            self.host_names = m.get('HostNames')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceDescription') is not None:
            self.instance_description = m.get('InstanceDescription')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('SystemDisk') is not None:
            temp_model = CreateAutoProvisioningGroupRequestLaunchConfigurationSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('SystemDiskDescription') is not None:
            self.system_disk_description = m.get('SystemDiskDescription')
        if m.get('SystemDiskName') is not None:
            self.system_disk_name = m.get('SystemDiskName')
        if m.get('SystemDiskPerformanceLevel') is not None:
            self.system_disk_performance_level = m.get('SystemDiskPerformanceLevel')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateAutoProvisioningGroupRequestLaunchConfigurationTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class CreateAutoProvisioningGroupRequestDataDiskConfig(TeaModel):
    def __init__(self, disk_category=None):
        # The category of data disk N. You can use this parameter to specify multiple disk categories, and the disk categories are prioritized in the order in which they are specified. If a specified disk category is unavailable, the system uses the next available disk category. Valid values: 
        # 
        # - cloud_efficiency: ultra disk
        # - cloud_ssd: standard SSD
        # - cloud_essd: ESSD
        # - cloud: basic disk
        self.disk_category = disk_category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestDataDiskConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_category is not None:
            result['DiskCategory'] = self.disk_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskCategory') is not None:
            self.disk_category = m.get('DiskCategory')
        return self


class CreateAutoProvisioningGroupRequestLaunchTemplateConfig(TeaModel):
    def __init__(self, architectures=None, burstable_performance=None, cores=None, excluded_instance_types=None,
                 instance_family_level=None, instance_type=None, max_price=None, max_quantity=None, memories=None, priority=None,
                 v_switch_id=None, weighted_capacity=None):
        self.architectures = architectures  # type: list[str]
        self.burstable_performance = burstable_performance  # type: str
        self.cores = cores  # type: list[int]
        self.excluded_instance_types = excluded_instance_types  # type: list[str]
        self.instance_family_level = instance_family_level  # type: str
        # The instance type in extended configuration N. Valid values of N: 1 to 20. For more information about the valid values of this parameter, see [Instance families](~~25378~~).
        self.instance_type = instance_type  # type: str
        # The maximum price of preemptible instances in extended configuration N.
        # 
        # >  If you set one or more other `LaunchTemplateConfig.N.*` parameters, you must also set the `LaunchTemplateConfig.N.MaxPrice` parameter.
        self.max_price = max_price  # type: float
        self.max_quantity = max_quantity  # type: int
        self.memories = memories  # type: list[float]
        # The priority of extended configuration N. A value of 0 indicates the highest priority. Valid values: 0 to ∞.
        self.priority = priority  # type: int
        # The ID of the vSwitch in extended configuration N. The zone of the ECS instances created from the extended configuration is determined by the vSwitch.
        # 
        # >  If you set one or more other `LaunchTemplateConfig.N.*` parameters, you must also set the `LaunchTemplateConfig.N.VSwitchId` parameter.
        self.v_switch_id = v_switch_id  # type: str
        # The weight of the instance type specified in extended configuration N. A greater weight indicates that a single instance has more computing power and that fewer instances are required. The value must be greater than 0.
        # 
        # The weight is calculated based on the computing power of the instance type and the minimum computing power of a single instance in the cluster to be created by the auto provisioning group. For example, assume that the minimum computing power of a single instance is 8 vCPUs and 60 GiB of memory.
        # 
        # *   For an instance type with 8 vCPUs and 60 GiB of memory, you can set the weight to 1.
        # *   For an instance type with 16 vCPUs and 120 GiB of memory, you can set the weight to 2.
        self.weighted_capacity = weighted_capacity  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestLaunchTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architectures is not None:
            result['Architectures'] = self.architectures
        if self.burstable_performance is not None:
            result['BurstablePerformance'] = self.burstable_performance
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.excluded_instance_types is not None:
            result['ExcludedInstanceTypes'] = self.excluded_instance_types
        if self.instance_family_level is not None:
            result['InstanceFamilyLevel'] = self.instance_family_level
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_price is not None:
            result['MaxPrice'] = self.max_price
        if self.max_quantity is not None:
            result['MaxQuantity'] = self.max_quantity
        if self.memories is not None:
            result['Memories'] = self.memories
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.weighted_capacity is not None:
            result['WeightedCapacity'] = self.weighted_capacity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Architectures') is not None:
            self.architectures = m.get('Architectures')
        if m.get('BurstablePerformance') is not None:
            self.burstable_performance = m.get('BurstablePerformance')
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('ExcludedInstanceTypes') is not None:
            self.excluded_instance_types = m.get('ExcludedInstanceTypes')
        if m.get('InstanceFamilyLevel') is not None:
            self.instance_family_level = m.get('InstanceFamilyLevel')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxPrice') is not None:
            self.max_price = m.get('MaxPrice')
        if m.get('MaxQuantity') is not None:
            self.max_quantity = m.get('MaxQuantity')
        if m.get('Memories') is not None:
            self.memories = m.get('Memories')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('WeightedCapacity') is not None:
            self.weighted_capacity = m.get('WeightedCapacity')
        return self


class CreateAutoProvisioningGroupRequestSystemDiskConfig(TeaModel):
    def __init__(self, disk_category=None):
        # The category of system disk N. You can use this parameter to specify multiple disk categories, and the disk categories are prioritized in the order in which they are specified. If a specified disk category is unavailable, the system uses the next available disk category. Valid values: 
        # 
        # - cloud_efficiency: ultra disk
        # - cloud_ssd: standard SSD
        # - cloud_essd: ESSD
        # - cloud: basic disk
        self.disk_category = disk_category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequestSystemDiskConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_category is not None:
            result['DiskCategory'] = self.disk_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskCategory') is not None:
            self.disk_category = m.get('DiskCategory')
        return self


class CreateAutoProvisioningGroupRequest(TeaModel):
    def __init__(self, launch_configuration=None, auto_provisioning_group_name=None,
                 auto_provisioning_group_type=None, client_token=None, data_disk_config=None, default_target_capacity_type=None,
                 description=None, excess_capacity_termination_policy=None, hibernation_options_configured=None,
                 launch_template_config=None, launch_template_id=None, launch_template_version=None, max_spot_price=None,
                 min_target_capacity=None, owner_account=None, owner_id=None, pay_as_you_go_allocation_strategy=None,
                 pay_as_you_go_target_capacity=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 spot_allocation_strategy=None, spot_instance_interruption_behavior=None, spot_instance_pools_to_use_count=None,
                 spot_target_capacity=None, system_disk_config=None, terminate_instances=None,
                 terminate_instances_with_expiration=None, total_target_capacity=None, valid_from=None, valid_until=None):
        self.launch_configuration = launch_configuration  # type: CreateAutoProvisioningGroupRequestLaunchConfiguration
        # The name of the auto provisioning group. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.auto_provisioning_group_name = auto_provisioning_group_name  # type: str
        # The delivery type of the auto provisioning group. Valid values:
        # 
        # *   request: one-time asynchronous delivery. When the auto provisioning group is started, it attempts to asynchronously deliver an instance cluster that meets the target capacity only once. The group does not retry the operation regardless of whether all the instances are delivered.
        # *   instant: one-time synchronous delivery. When the auto provisioning group is started, it attempts to synchronously deliver an instance cluster that meets the target capacity only once. The list of delivered instances and the causes of delivery failures are returned in the response.
        # *   maintain: continuous delivery. When the auto provisioning group is started, it attempts to deliver an instance cluster that meets the target capacity, and monitors the real-time capacity. If the target capacity of the auto provisioning group is not reached, the auto provisioning group continues to create instances until the target capacity is reached.
        # 
        # Default value: maintain.
        self.auto_provisioning_group_type = auto_provisioning_group_type  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The configs of data disks.
        self.data_disk_config = data_disk_config  # type: list[CreateAutoProvisioningGroupRequestDataDiskConfig]
        # The type of supplemental instances. When the sum of the `PayAsYouGoTargetCapacity` and `SpotTargetCapacity` values is smaller than the value of `TotalTargetCapacity`, the auto provisioning group creates instances of the specified type to meet the target capacity. Valid values:
        # 
        # *   PayAsYouGo: pay-as-you-go instances
        # *   Spot: preemptible instances
        # 
        # Default value: Spot.
        self.default_target_capacity_type = default_target_capacity_type  # type: str
        # The description of the auto provisioning group.
        self.description = description  # type: str
        # Specifies whether to release the removed instances when the real-time capacity of the auto provisioning group exceeds the target capacity and a scale-in event is triggered. Valid values:
        # 
        # *   termination: releases the removed instances.
        # *   no-termination: only removes the instances from the auto provisioning group but does not release them.
        # 
        # Default value: no-termination.
        self.excess_capacity_termination_policy = excess_capacity_termination_policy  # type: str
        # >  This parameter is in invitational preview and unavailable for general users.
        self.hibernation_options_configured = hibernation_options_configured  # type: bool
        # The configurations of launch template.
        self.launch_template_config = launch_template_config  # type: list[CreateAutoProvisioningGroupRequestLaunchTemplateConfig]
        # The ID of the launch template associated with the auto provisioning group. You can call the [DescribeLaunchTemplates](~~73759~~) operation to query available launch templates. When both the LaunchTemplateId and `LaunchConfiguration.*` parameters are specified, the LaunchTemplateId parameter takes precedence.
        self.launch_template_id = launch_template_id  # type: str
        # The version of the launch template associated with the auto provisioning group. You can call the [DescribeLaunchTemplateVersions](~~73761~~) operation to query the versions of available launch templates.
        # 
        # Default value: the default version of the launch template.
        self.launch_template_version = launch_template_version  # type: str
        # The maximum price of preemptible instances in the auto provisioning group.
        # 
        # >  When both the `MaxSpotPrice` and `LaunchTemplateConfig.N.MaxPrice` parameters are specified, the smaller one of the two parameter values is used.
        self.max_spot_price = max_spot_price  # type: float
        # The minimum target capacity of the auto provisioning group. The value must be a positive integer.  
        # 
        # When you specify this parameter, take note of the following items:
        # 
        # - This parameter takes effect only when `AutoProvisioningGroupType` is set to instant.
        # - If the number of instances that can be created in the current region is smaller than the value of this parameter, the operation cannot be called and no instances are created.
        # - If the number of instances that can be created in the current region is greater than the value of this parameter, instances can be created based on specified parameters.
        self.min_target_capacity = min_target_capacity  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The policy for creating pay-as-you-go instances. Valid values:
        # 
        # *   lowest-price: cost optimization policy. The auto provisioning group attempts to create instances of the lowest-priced instance type.
        # *   prioritized: priority-based policy. The auto provisioning group attempts to create instances based on the priority specified by the `LaunchTemplateConfig.N.Priority` parameter.
        # 
        # Default value: lowest-price.
        self.pay_as_you_go_allocation_strategy = pay_as_you_go_allocation_strategy  # type: str
        # The target capacity of pay-as-you-go instances in the auto provisioning group. The value must be smaller than the `TotalTargetCapacity` value.
        self.pay_as_you_go_target_capacity = pay_as_you_go_target_capacity  # type: str
        # The ID of the region in which to create the auto provisioning group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the auto provisioning group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The policy for creating preemptible instances. Valid values:
        # 
        # *   lowest-price: cost optimization policy. The auto provisioning group attempts to create instances of the lowest-priced instance type.
        # *   diversified: balanced distribution policy. The auto provisioning group attempts to create instances in zones that are specified in extended configurations and then evenly distribute the instances across the zones.
        # *   capacity-optimized: capacity-optimized distribution policy. The auto provisioning group attempts to create instances that are of the optimal instance types across the optimal zones based on resource availability.
        # 
        # Default value: lowest-price.
        self.spot_allocation_strategy = spot_allocation_strategy  # type: str
        # The operation to be performed on the preemptible instance when it is interrupted. Valid values:
        # 
        # *   stop: stops the preemptible instance.
        # *   terminate: releases the preemptible instance.
        # 
        # Default value: terminate.
        self.spot_instance_interruption_behavior = spot_instance_interruption_behavior  # type: str
        # The number of preemptible instances of the lowest-priced instance type to be created by the auto provisioning group. This parameter takes effect when the `SpotAllocationStrategy` parameter is set to `lowest-price`.
        # 
        # The value of SpotInstancePoolsToUseCount must be smaller than the N value specified in `LaunchTemplateConfig.N.*` parameters.
        self.spot_instance_pools_to_use_count = spot_instance_pools_to_use_count  # type: int
        # The target capacity of preemptible instances in the auto provisioning group. The value must be smaller than the `TotalTargetCapacity` value.
        self.spot_target_capacity = spot_target_capacity  # type: str
        # The configs of system disks.
        self.system_disk_config = system_disk_config  # type: list[CreateAutoProvisioningGroupRequestSystemDiskConfig]
        # Specifies whether to release instances in the auto provisioning group when the auto provisioning group is deleted. Valid values:
        # 
        # *   true: releases instances in the auto provisioning group.
        # *   false: retains instances in the auto provisioning group.
        # 
        # Default value: false.
        self.terminate_instances = terminate_instances  # type: bool
        # Specifies whether to release instances in the auto provisioning group when the auto provisioning group expires. Valid values:
        # 
        # *   true: releases instances in the auto provisioning group.
        # *   false: only removes instances from the auto provisioning group but does not release them.
        # 
        # Default value: false.
        self.terminate_instances_with_expiration = terminate_instances_with_expiration  # type: bool
        # The total target capacity of the auto provisioning group. The value must be a positive integer.
        # 
        # The total target capacity of the auto provisioning group must be greater than or equal to the sum of the target capacity of pay-as-you-go instances specified by the `PayAsYouGoTargetCapacity` parameter and the target capacity of preemptible instances specified by the `SpotTargetCapacity` parameter.
        self.total_target_capacity = total_target_capacity  # type: str
        # The time at which to start the auto provisioning group. The period of time between this point in time and the point in time specified by the `ValidUntil` parameter is the effective time period of the auto provisioning group.
        # 
        # Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # By default, an auto provisioning group is started immediately after it is created.
        self.valid_from = valid_from  # type: str
        # The expiration time of the auto provisioning group. The period of time between this point in time and the point in time specified by the `ValidFrom` parameter is the effective time period of the auto provisioning group.
        # 
        # Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # Default value: 2099-12-31T23:59:59Z.
        self.valid_until = valid_until  # type: str

    def validate(self):
        if self.launch_configuration:
            self.launch_configuration.validate()
        if self.data_disk_config:
            for k in self.data_disk_config:
                if k:
                    k.validate()
        if self.launch_template_config:
            for k in self.launch_template_config:
                if k:
                    k.validate()
        if self.system_disk_config:
            for k in self.system_disk_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_configuration is not None:
            result['LaunchConfiguration'] = self.launch_configuration.to_map()
        if self.auto_provisioning_group_name is not None:
            result['AutoProvisioningGroupName'] = self.auto_provisioning_group_name
        if self.auto_provisioning_group_type is not None:
            result['AutoProvisioningGroupType'] = self.auto_provisioning_group_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        result['DataDiskConfig'] = []
        if self.data_disk_config is not None:
            for k in self.data_disk_config:
                result['DataDiskConfig'].append(k.to_map() if k else None)
        if self.default_target_capacity_type is not None:
            result['DefaultTargetCapacityType'] = self.default_target_capacity_type
        if self.description is not None:
            result['Description'] = self.description
        if self.excess_capacity_termination_policy is not None:
            result['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy
        if self.hibernation_options_configured is not None:
            result['HibernationOptionsConfigured'] = self.hibernation_options_configured
        result['LaunchTemplateConfig'] = []
        if self.launch_template_config is not None:
            for k in self.launch_template_config:
                result['LaunchTemplateConfig'].append(k.to_map() if k else None)
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_version is not None:
            result['LaunchTemplateVersion'] = self.launch_template_version
        if self.max_spot_price is not None:
            result['MaxSpotPrice'] = self.max_spot_price
        if self.min_target_capacity is not None:
            result['MinTargetCapacity'] = self.min_target_capacity
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pay_as_you_go_allocation_strategy is not None:
            result['PayAsYouGoAllocationStrategy'] = self.pay_as_you_go_allocation_strategy
        if self.pay_as_you_go_target_capacity is not None:
            result['PayAsYouGoTargetCapacity'] = self.pay_as_you_go_target_capacity
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.spot_allocation_strategy is not None:
            result['SpotAllocationStrategy'] = self.spot_allocation_strategy
        if self.spot_instance_interruption_behavior is not None:
            result['SpotInstanceInterruptionBehavior'] = self.spot_instance_interruption_behavior
        if self.spot_instance_pools_to_use_count is not None:
            result['SpotInstancePoolsToUseCount'] = self.spot_instance_pools_to_use_count
        if self.spot_target_capacity is not None:
            result['SpotTargetCapacity'] = self.spot_target_capacity
        result['SystemDiskConfig'] = []
        if self.system_disk_config is not None:
            for k in self.system_disk_config:
                result['SystemDiskConfig'].append(k.to_map() if k else None)
        if self.terminate_instances is not None:
            result['TerminateInstances'] = self.terminate_instances
        if self.terminate_instances_with_expiration is not None:
            result['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration
        if self.total_target_capacity is not None:
            result['TotalTargetCapacity'] = self.total_target_capacity
        if self.valid_from is not None:
            result['ValidFrom'] = self.valid_from
        if self.valid_until is not None:
            result['ValidUntil'] = self.valid_until
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchConfiguration') is not None:
            temp_model = CreateAutoProvisioningGroupRequestLaunchConfiguration()
            self.launch_configuration = temp_model.from_map(m['LaunchConfiguration'])
        if m.get('AutoProvisioningGroupName') is not None:
            self.auto_provisioning_group_name = m.get('AutoProvisioningGroupName')
        if m.get('AutoProvisioningGroupType') is not None:
            self.auto_provisioning_group_type = m.get('AutoProvisioningGroupType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        self.data_disk_config = []
        if m.get('DataDiskConfig') is not None:
            for k in m.get('DataDiskConfig'):
                temp_model = CreateAutoProvisioningGroupRequestDataDiskConfig()
                self.data_disk_config.append(temp_model.from_map(k))
        if m.get('DefaultTargetCapacityType') is not None:
            self.default_target_capacity_type = m.get('DefaultTargetCapacityType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExcessCapacityTerminationPolicy') is not None:
            self.excess_capacity_termination_policy = m.get('ExcessCapacityTerminationPolicy')
        if m.get('HibernationOptionsConfigured') is not None:
            self.hibernation_options_configured = m.get('HibernationOptionsConfigured')
        self.launch_template_config = []
        if m.get('LaunchTemplateConfig') is not None:
            for k in m.get('LaunchTemplateConfig'):
                temp_model = CreateAutoProvisioningGroupRequestLaunchTemplateConfig()
                self.launch_template_config.append(temp_model.from_map(k))
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateVersion') is not None:
            self.launch_template_version = m.get('LaunchTemplateVersion')
        if m.get('MaxSpotPrice') is not None:
            self.max_spot_price = m.get('MaxSpotPrice')
        if m.get('MinTargetCapacity') is not None:
            self.min_target_capacity = m.get('MinTargetCapacity')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PayAsYouGoAllocationStrategy') is not None:
            self.pay_as_you_go_allocation_strategy = m.get('PayAsYouGoAllocationStrategy')
        if m.get('PayAsYouGoTargetCapacity') is not None:
            self.pay_as_you_go_target_capacity = m.get('PayAsYouGoTargetCapacity')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SpotAllocationStrategy') is not None:
            self.spot_allocation_strategy = m.get('SpotAllocationStrategy')
        if m.get('SpotInstanceInterruptionBehavior') is not None:
            self.spot_instance_interruption_behavior = m.get('SpotInstanceInterruptionBehavior')
        if m.get('SpotInstancePoolsToUseCount') is not None:
            self.spot_instance_pools_to_use_count = m.get('SpotInstancePoolsToUseCount')
        if m.get('SpotTargetCapacity') is not None:
            self.spot_target_capacity = m.get('SpotTargetCapacity')
        self.system_disk_config = []
        if m.get('SystemDiskConfig') is not None:
            for k in m.get('SystemDiskConfig'):
                temp_model = CreateAutoProvisioningGroupRequestSystemDiskConfig()
                self.system_disk_config.append(temp_model.from_map(k))
        if m.get('TerminateInstances') is not None:
            self.terminate_instances = m.get('TerminateInstances')
        if m.get('TerminateInstancesWithExpiration') is not None:
            self.terminate_instances_with_expiration = m.get('TerminateInstancesWithExpiration')
        if m.get('TotalTargetCapacity') is not None:
            self.total_target_capacity = m.get('TotalTargetCapacity')
        if m.get('ValidFrom') is not None:
            self.valid_from = m.get('ValidFrom')
        if m.get('ValidUntil') is not None:
            self.valid_until = m.get('ValidUntil')
        return self


class CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds(TeaModel):
    def __init__(self, instance_id=None):
        self.instance_id = instance_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult(TeaModel):
    def __init__(self, error_code=None, error_msg=None, instance_ids=None, instance_type=None, spot_strategy=None,
                 zone_id=None):
        # The error code returned when the instance cannot be created.
        self.error_code = error_code  # type: str
        # The error message returned when the instance cannot be created.
        self.error_msg = error_msg  # type: str
        # The IDs of created instances.
        self.instance_ids = instance_ids  # type: CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The bidding policy for the pay-as-you-go instance. Valid values:
        # 
        # *   NoSpot: The instance is created as a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        self.spot_strategy = spot_strategy  # type: str
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.instance_ids:
            self.instance_ids.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('InstanceIds') is not None:
            temp_model = CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResultInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateAutoProvisioningGroupResponseBodyLaunchResults(TeaModel):
    def __init__(self, launch_result=None):
        self.launch_result = launch_result  # type: list[CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult]

    def validate(self):
        if self.launch_result:
            for k in self.launch_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupResponseBodyLaunchResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LaunchResult'] = []
        if self.launch_result is not None:
            for k in self.launch_result:
                result['LaunchResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.launch_result = []
        if m.get('LaunchResult') is not None:
            for k in m.get('LaunchResult'):
                temp_model = CreateAutoProvisioningGroupResponseBodyLaunchResultsLaunchResult()
                self.launch_result.append(temp_model.from_map(k))
        return self


class CreateAutoProvisioningGroupResponseBody(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, launch_results=None, request_id=None):
        # The ID of the auto provisioning group.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        # Details about the instances created by the auto provisioning group. The values of parameters in this array are returned only when AutoProvisioningGroupType is set to `instant`.
        self.launch_results = launch_results  # type: CreateAutoProvisioningGroupResponseBodyLaunchResults
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.launch_results:
            self.launch_results.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.launch_results is not None:
            result['LaunchResults'] = self.launch_results.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('LaunchResults') is not None:
            temp_model = CreateAutoProvisioningGroupResponseBodyLaunchResults()
            self.launch_results = temp_model.from_map(m['LaunchResults'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAutoProvisioningGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAutoProvisioningGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAutoProvisioningGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAutoProvisioningGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAutoSnapshotPolicyRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the automatic snapshot policy. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.key = key  # type: str
        # The value of tag N of the automatic snapshot policy. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, copied_snapshots_retention_days=None, enable_cross_region_copy=None, owner_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, storage_location_arn=None, tag=None,
                 target_copy_regions=None, auto_snapshot_policy_name=None, region_id=None, repeat_weekdays=None, retention_days=None,
                 time_points=None):
        # The retention period of the snapshot copy in the destination region. Unit: days. Valid values:
        # 
        # *   \-1: The snapshot copy is permanently retained.
        # *   1 to 65535: The snapshot copy is retained for the specified number of days.
        # 
        # Default value: -1.
        self.copied_snapshots_retention_days = copied_snapshots_retention_days  # type: int
        # Specifies whether to enable cross-region replication for snapshots.
        # 
        # *   true: enables cross-region replication for snapshots.
        # *   false: disables cross-region replication for snapshots.
        self.enable_cross_region_copy = enable_cross_region_copy  # type: bool
        self.owner_id = owner_id  # type: long
        # The ID of the resource group to which the automatic snapshot policy belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # > This parameter is in invitational preview and is unavailable.
        self.storage_location_arn = storage_location_arn  # type: str
        # The tags.
        self.tag = tag  # type: list[CreateAutoSnapshotPolicyRequestTag]
        # The destination region to which to copy snapshots. You can set only a single destination region.
        self.target_copy_regions = target_copy_regions  # type: str
        # The name of the automatic snapshot policy. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.auto_snapshot_policy_name = auto_snapshot_policy_name  # type: str
        # The ID of the region in which to create the automatic snapshot policy. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The days of the week on which to create automatic snapshots. Valid values: 1 to 7, which correspond to Monday to Sunday. 1 indicates Monday.
        # 
        # *   Set this parameter to a JSON-formatted array. For example, a value of \["1"] specifies automatic snapshots to be created every Monday.
        # *   To schedule multiple automatic snapshots to be created in a week, you can specify multiple values. Separate the values with commas (,). You can specify a maximum of seven days. For example, a value of \["1","3","5"] specifies automatic snapshots to be created every Monday, Wednesday, and Friday.
        self.repeat_weekdays = repeat_weekdays  # type: str
        # The retention period of the automatic snapshot. Unit: days. Valid values:
        # 
        # *   \-1: The snapshot is permanently retained.
        # *   1 to 65535: The automatic snapshot is retained for the specified number of days.
        # 
        # Default value: -1.
        self.retention_days = retention_days  # type: int
        # The points in time of the day at which to create automatic snapshots. The time must be in UTC+8. Unit: hours. Valid values are 0 to 23, which correspond to the 24 points in time on the hour from 00:00:00 to 23:00:00. 1 indicates 01:00:00.
        # 
        # *   You must set this parameter to a JSON-formatted array. For example, a value of \["1"] specifies automatic snapshots to be created at 01:00:00.
        # *   To schedule multiple automatic snapshots to be created in a day, you can specify multiple values. Separate the values with commas (,). You can specify a maximum of 24 points in time. For example, a value of \["1","3","5"] specifies automatic snapshots to be created at 01:00:00, 03:00:00, and 05:00:00.
        self.time_points = time_points  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copied_snapshots_retention_days is not None:
            result['CopiedSnapshotsRetentionDays'] = self.copied_snapshots_retention_days
        if self.enable_cross_region_copy is not None:
            result['EnableCrossRegionCopy'] = self.enable_cross_region_copy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_location_arn is not None:
            result['StorageLocationArn'] = self.storage_location_arn
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.target_copy_regions is not None:
            result['TargetCopyRegions'] = self.target_copy_regions
        if self.auto_snapshot_policy_name is not None:
            result['autoSnapshotPolicyName'] = self.auto_snapshot_policy_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.repeat_weekdays is not None:
            result['repeatWeekdays'] = self.repeat_weekdays
        if self.retention_days is not None:
            result['retentionDays'] = self.retention_days
        if self.time_points is not None:
            result['timePoints'] = self.time_points
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CopiedSnapshotsRetentionDays') is not None:
            self.copied_snapshots_retention_days = m.get('CopiedSnapshotsRetentionDays')
        if m.get('EnableCrossRegionCopy') is not None:
            self.enable_cross_region_copy = m.get('EnableCrossRegionCopy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageLocationArn') is not None:
            self.storage_location_arn = m.get('StorageLocationArn')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateAutoSnapshotPolicyRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TargetCopyRegions') is not None:
            self.target_copy_regions = m.get('TargetCopyRegions')
        if m.get('autoSnapshotPolicyName') is not None:
            self.auto_snapshot_policy_name = m.get('autoSnapshotPolicyName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('repeatWeekdays') is not None:
            self.repeat_weekdays = m.get('repeatWeekdays')
        if m.get('retentionDays') is not None:
            self.retention_days = m.get('retentionDays')
        if m.get('timePoints') is not None:
            self.time_points = m.get('timePoints')
        return self


class CreateAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, request_id=None):
        # The ID of the automatic snapshot policy.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCapacityReservationRequestPrivatePoolOptions(TeaModel):
    def __init__(self, match_criteria=None, name=None):
        # The type of the private pool to be generated after the capacity reservation takes effect. Valid values:
        # 
        # *   Open: open private pool
        # *   Target: specified private pool
        # 
        # Default value: Open.
        self.match_criteria = match_criteria  # type: str
        # The name of the capacity reservation. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCapacityReservationRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateCapacityReservationRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the capacity reservation. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the capacity reservation. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCapacityReservationRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateCapacityReservationRequest(TeaModel):
    def __init__(self, private_pool_options=None, client_token=None, description=None, end_time=None,
                 end_time_type=None, instance_amount=None, instance_type=None, owner_account=None, owner_id=None, platform=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 start_time=None, tag=None, zone_id=None):
        self.private_pool_options = private_pool_options  # type: CreateCapacityReservationRequestPrivatePoolOptions
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The `ClientToken` value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the capacity reservation. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The expiration time of the capacity reservation. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC. For more information, see [ISO 8601](~~25696~~).
        self.end_time = end_time  # type: str
        # The release mode of the capacity reservation. Valid values:
        # 
        # *   Limited: The capacity reservation is released at the specified time. If you specify this parameter, you must also specify the `EndTime` parameter.
        # *   Unlimited: The capacity reservation must be manually released. You can release it at any time.
        self.end_time_type = end_time_type  # type: str
        # The total number of instances for which to reserve capacity of an instance type.
        self.instance_amount = instance_amount  # type: int
        # The instance type. A capacity reservation can be created to reserve the capacity of a single instance type.
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The operating system of the image used by the instance. This parameter corresponds to the `Platform` parameter of regional reserved instances. If the operating system of a capacity reservation matches that of a regional reserved instance, the regional reserved instance can be applied to offset bills of the unused capacity of the capacity reservation. Valid values:
        # 
        # *   Windows: Windows Server operating systems
        # *   Linux: Linux and Unix-like operating systems
        # 
        # Default value: Linux.
        # 
        # >  This parameter is unavailable.
        self.platform = platform  # type: str
        # The ID of the region in which to create the capacity reservation. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the capacity reservation.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The mode in which the capacity reservation takes effect. You can specify a time value for this parameter to create the capacity reservation as a scheduled capacity reservation that takes effect at the specified time. Only immediate capacity reservations are supported. You do not need to specify this parameter.
        # 
        # >  If this parameter is empty, the capacity reservation is created as an immediate capacity reservation.
        self.start_time = start_time  # type: str
        # The tags to add to the capacity reservation. You can specify up to 20 tags.
        self.tag = tag  # type: list[CreateCapacityReservationRequestTag]
        # The IDs of zones within the region in which to create the capacity reservation. A capacity reservation can reserve resources within a single zone.
        self.zone_id = zone_id  # type: list[str]

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateCapacityReservationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_time_type is not None:
            result['EndTimeType'] = self.end_time_type
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = CreateCapacityReservationRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimeType') is not None:
            self.end_time_type = m.get('EndTimeType')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateCapacityReservationRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateCapacityReservationResponseBody(TeaModel):
    def __init__(self, private_pool_options_id=None, request_id=None):
        # The ID of the capacity reservation.
        self.private_pool_options_id = private_pool_options_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCapacityReservationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options_id is not None:
            result['PrivatePoolOptionsId'] = self.private_pool_options_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptionsId') is not None:
            self.private_pool_options_id = m.get('PrivatePoolOptionsId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCapacityReservationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCapacityReservationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCapacityReservationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCapacityReservationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCommandRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # It can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCommandRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateCommandRequest(TeaModel):
    def __init__(self, command_content=None, content_encoding=None, description=None, enable_parameter=None,
                 name=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, tag=None, timeout=None, type=None, working_dir=None):
        # The Base64-encoded content of the command.
        # 
        # *   The parameter value must be Base64-encoded and cannot exceed 18 KB in size.
        # 
        # *   Custom parameters can be added to the command. To enable the custom parameter feature, you must set `EnableParameter` to true.
        # 
        #     *   Custom parameters are defined in the `{{}}` format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
        #     *   The number of custom parameters cannot exceed 20.
        #     *   A custom parameter name can contain only letters, digits, underscores (\_), and hyphens (-). The name is case-insensitive.
        #     *   Each custom parameter name cannot exceed 64 bytes in length.
        # 
        # *   You can specify built-in environment parameters as custom parameters. Then, when you run the command, these parameters are automatically specified by Cloud Assistant. You can specify the following built-in environment parameters:
        # 
        #     *   `{{ACS::RegionId}}`: the ID of the region.
        # 
        #     *   `{{ACS::AccountId}}`: the UID of the Alibaba Cloud account.
        # 
        #     *   `{{ACS::InstanceId}}`: the ID of the instance. When the command is run on multiple instances, if you want to specify `{{ACS::InstanceId}}` as a built-in environment variable, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::InstanceName}}`: the name of the instance. If you want to run the command on multiple instances and specify `{{ACS::InstanceName}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.344
        #         *   Windows: 2.1.3.344
        # 
        #     *   `{{ACS::InvokeId}}`: the ID of the command task. If you want to specify `{{ACS::InvokeId}}` as a built-in environment variable, make sure that the version of the Cloud Assistant client is not earlier than the following one:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::CommandId}}`: the ID of the command. When you call the [RunCommand](~~141751~~) operation, if you want to specify `{{ACS::CommandId}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        self.command_content = command_content  # type: str
        # The encoding mode of the command content (CommandContent). Valid values:
        # 
        # *   PlainText: The command content is not encoded.
        # *   Base64: The command content is Base64-encoded.
        # 
        # Default value: Base64.
        # 
        # > If the specified value of this parameter is invalid, Base64 is used by default.
        self.content_encoding = content_encoding  # type: str
        # The description of the command. The description supports all character sets and can be up to 512 characters in length.
        self.description = description  # type: str
        # Specifies whether to use custom parameters in the command.
        # 
        # Default value: false.
        self.enable_parameter = enable_parameter  # type: bool
        # The name of the command. The name supports all character sets and can be up to 128 characters in length.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags to add to the command.
        self.tag = tag  # type: list[CreateCommandRequestTag]
        # The maximum timeout period for the command execution on the instance. Unit: seconds. When a command cannot be run, a timeout error occurs. After that, the command process is forcefully terminated by canceling the PID of the command.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long
        # The command type. Valid values:
        # 
        # *   RunBatScript: batch commands. These commands are applicable to Windows instances.
        # *   RunPowerShellScript: PowerShell commands. These commands are applicable to Windows instances.
        # *   RunShellScript: shell commands. These commands are applicable to Linux instances.
        self.type = type  # type: str
        # The working directory of the command on the instance.
        # 
        # Default value:
        # 
        # *   For Linux instances, the default value is the home directory of the root user, which is the `/root` directory.
        # *   For Windows instances, the default value is the directory where the Cloud Assistant client process resides. Example: `C:\Windows\System32\`.
        self.working_dir = working_dir  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_parameter is not None:
            result['EnableParameter'] = self.enable_parameter
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableParameter') is not None:
            self.enable_parameter = m.get('EnableParameter')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateCommandRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class CreateCommandResponseBody(TeaModel):
    def __init__(self, command_id=None, request_id=None):
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDedicatedHostClusterRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the dedicated host cluster. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the dedicated host cluster. Valid values of N: 1 to 20. The tag value cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDedicatedHostClusterRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDedicatedHostClusterRequest(TeaModel):
    def __init__(self, dedicated_host_cluster_name=None, description=None, dry_run=None, owner_account=None,
                 owner_id=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None, zone_id=None):
        # The name of the dedicated host cluster. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot contain `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.dedicated_host_cluster_name = dedicated_host_cluster_name  # type: str
        # The description of the dedicated host cluster. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether RAM users are authorized, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned and the request is made.
        # 
        # Default value: false
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the dedicated host cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the dedicated host cluster.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags of the resource. You can enter most at 20 tags for the resource.
        self.tag = tag  # type: list[CreateDedicatedHostClusterRequestTag]
        # The ID of the zone in which to create the dedicated host cluster. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDedicatedHostClusterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_name is not None:
            result['DedicatedHostClusterName'] = self.dedicated_host_cluster_name
        if self.description is not None:
            result['Description'] = self.description
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterName') is not None:
            self.dedicated_host_cluster_name = m.get('DedicatedHostClusterName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateDedicatedHostClusterRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateDedicatedHostClusterResponseBody(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None, request_id=None):
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDedicatedHostClusterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDedicatedHostClusterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDedicatedHostClusterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDedicatedHostClusterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDedicatedHostClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDemandRequest(TeaModel):
    def __init__(self, amount=None, client_token=None, demand_description=None, demand_name=None, end_time=None,
                 instance_charge_type=None, instance_type=None, owner_account=None, owner_id=None, period=None, period_unit=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, start_time=None, zone_id=None):
        # The required quantity of instances of the filed instance type. Valid values: 1 to 100000.
        self.amount = amount  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value that is unique among different requests. The `ClientToken` value can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the requirement. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.demand_description = demand_description  # type: str
        # The name of the requirement. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        # 
        # The default value is the instance type name.
        self.demand_name = demand_name  # type: str
        # The end time of the subscription period. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-dd HH:mm:ss format. The time must be in UTC.
        # 
        # If the value of seconds (ss) is not 00, the time is automatically set to the start time of the current minute (mm).
        # 
        # The value of EndTime is later than the value of Starttime.
        # 
        # Typically, the interval between the two time cannot be more than 10 days.
        self.end_time = end_time  # type: str
        # The billing method of the filed instance. Default value: PostPaid. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type of the filed instance. See [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the performance data of the target instance type, or see [Select instance types](~~58291~~) to learn how to select instance types.
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The subscription period of the resource. Valid values:
        # 
        # *   When the value of PeriodUnit is Day, the valid values of Period are 1, 2, 3, 4, 5, and 6.
        # *   When the value of PeriodUnit is Week, the valid values of Period are 1, 2, 3, and 4.
        # *   When the value of PeriodUnit is Month, the valid values of Period are 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The unit of the subscription period. Default value: Month. Valid values:
        # 
        # *   Day
        # *   Week
        # *   Month
        self.period_unit = period_unit  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start time of the subscription period. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-dd HH:mm:ss format. The time must be in UTC.
        # 
        # If the value of seconds (ss) is not 00, the time is automatically set to the start time of the current minute (mm).
        # 
        # The value of EndTime is later than the value of Starttime.
        # 
        # Typically, the interval between the two time cannot be more than 10 days.
        self.start_time = start_time  # type: str
        # The ID of the zone to which the filed instance belongs. For more information, call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        # 
        # This parameter is empty by default. If you do not specify a zone, the system randomly selects a zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDemandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.demand_description is not None:
            result['DemandDescription'] = self.demand_description
        if self.demand_name is not None:
            result['DemandName'] = self.demand_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DemandDescription') is not None:
            self.demand_description = m.get('DemandDescription')
        if m.get('DemandName') is not None:
            self.demand_name = m.get('DemandName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateDemandResponseBody(TeaModel):
    def __init__(self, demand_id=None, request_id=None):
        # The ID of the requirement.
        self.demand_id = demand_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDemandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demand_id is not None:
            result['DemandId'] = self.demand_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DemandId') is not None:
            self.demand_id = m.get('DemandId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDemandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDemandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDemandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDemandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDeploymentSetRequest(TeaModel):
    def __init__(self, client_token=None, deployment_set_name=None, description=None, domain=None, granularity=None,
                 group_count=None, on_unable_to_redeploy_failed_instance=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, strategy=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The name of the deployment set. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.deployment_set_name = deployment_set_name  # type: str
        # The description of the deployment set. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The deployment domain. Set the value to Default.
        # 
        # Default: Instances in the deployment set are distributed only within the current zone.
        self.domain = domain  # type: str
        # The deployment granularity. Set the value to host.
        # 
        # host: Instances in the deployment set are dispersed at the granularity of hosts.
        self.granularity = granularity  # type: str
        # The number of deployment set groups in the deployment set. Valid values: 1 to 7.
        # 
        # Default value: 3.
        # 
        # >  This parameter is valid only when `Strategy` is set to AvailabilityGroup.
        self.group_count = group_count  # type: long
        # The emergency solution to use in the following situation: Instances in the deployment set cannot be evenly distributed to different zones due to resource insufficiency after the instances are failed over from faulty physical machines to normal physical machines. Valid values:
        # 
        # *   CancelMembershipAndStart: removes the instances from the deployment set and starts the instances immediately after they are failed over.
        # *   KeepStopped: leaves the instances in the Stopped state and starts them after resources are replenished.
        # 
        # Default value: CancelMembershipAndStart.
        self.on_unable_to_redeploy_failed_instance = on_unable_to_redeploy_failed_instance  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the deployment set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The deployment strategy. Valid values:
        # 
        # *   Availability: high availability strategy.
        # *   AvailabilityGroup: high availability group strategy.
        # 
        # Default value: Availability.
        self.strategy = strategy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDeploymentSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.deployment_set_name is not None:
            result['DeploymentSetName'] = self.deployment_set_name
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.granularity is not None:
            result['Granularity'] = self.granularity
        if self.group_count is not None:
            result['GroupCount'] = self.group_count
        if self.on_unable_to_redeploy_failed_instance is not None:
            result['OnUnableToRedeployFailedInstance'] = self.on_unable_to_redeploy_failed_instance
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DeploymentSetName') is not None:
            self.deployment_set_name = m.get('DeploymentSetName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Granularity') is not None:
            self.granularity = m.get('Granularity')
        if m.get('GroupCount') is not None:
            self.group_count = m.get('GroupCount')
        if m.get('OnUnableToRedeployFailedInstance') is not None:
            self.on_unable_to_redeploy_failed_instance = m.get('OnUnableToRedeployFailedInstance')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        return self


class CreateDeploymentSetResponseBody(TeaModel):
    def __init__(self, deployment_set_id=None, request_id=None):
        # The ID of the deployment set.
        self.deployment_set_id = deployment_set_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDeploymentSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDeploymentSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDeploymentSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDeploymentSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDeploymentSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDiagnosticMetricSetRequest(TeaModel):
    def __init__(self, description=None, metric_ids=None, metric_set_name=None, region_id=None, resource_type=None):
        # The description of the diagnostic metric set.
        self.description = description  # type: str
        # The IDs of diagnostic metrics. You can specify up to 100 diagnostic metric IDs.
        self.metric_ids = metric_ids  # type: list[str]
        # The name of the diagnostic metric set.
        self.metric_set_name = metric_set_name  # type: str
        # The ID of the region in which to create the diagnostic metric set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of the resource.
        # 
        # Default value: instance.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiagnosticMetricSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.metric_ids is not None:
            result['MetricIds'] = self.metric_ids
        if self.metric_set_name is not None:
            result['MetricSetName'] = self.metric_set_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MetricIds') is not None:
            self.metric_ids = m.get('MetricIds')
        if m.get('MetricSetName') is not None:
            self.metric_set_name = m.get('MetricSetName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class CreateDiagnosticMetricSetResponseBody(TeaModel):
    def __init__(self, metric_set_id=None, request_id=None):
        # The ID of the diagnostic metric set, which is the unique identifier of the set.
        self.metric_set_id = metric_set_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiagnosticMetricSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDiagnosticMetricSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDiagnosticMetricSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDiagnosticMetricSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDiagnosticMetricSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDiagnosticReportRequest(TeaModel):
    def __init__(self, end_time=None, metric_set_id=None, region_id=None, resource_id=None, start_time=None):
        # The end of the reporting period. This parameter takes effect only for diagnostic metrics that do not need to be assessed by running Cloud Assistant commands in guest operating systems.
        self.end_time = end_time  # type: str
        # The ID of the diagnostic metric set. If this parameter is left empty, the dms-instancedefault set is used, which is the default diagnostic metric set provided for Elastic Compute Service (ECS) instances.
        self.metric_set_id = metric_set_id  # type: str
        # The ID of the region in which to create a diagnostic report. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The beginning of the reporting period. This parameter takes effect only for diagnostic metrics that do not need to be assessed by running Cloud Assistant commands in guest operating systems.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiagnosticReportRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateDiagnosticReportResponseBody(TeaModel):
    def __init__(self, report_id=None, request_id=None):
        # The ID of the diagnostic report, which is the unique identifier of the report.
        self.report_id = report_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiagnosticReportResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDiagnosticReportResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDiagnosticReportResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDiagnosticReportResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDiagnosticReportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDiskRequestArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # This parameter is unavailable.
        self.assume_role_for = assume_role_for  # type: long
        # This parameter is unavailable.
        self.role_type = role_type  # type: str
        # This parameter is unavailable.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiskRequestArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class CreateDiskRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the disk. Valid values of N: 1 to 20. The key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the disk. Valid values of N: 1 to 20. The value can be an empty string. It can be up to 128 characters in length. It cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiskRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDiskRequest(TeaModel):
    def __init__(self, advanced_features=None, arn=None, bursting_enabled=None, client_token=None, description=None,
                 disk_category=None, disk_name=None, encrypt_algorithm=None, encrypted=None, instance_id=None, kmskey_id=None,
                 multi_attach=None, owner_account=None, owner_id=None, performance_level=None, provisioned_iops=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None, size=None,
                 snapshot_id=None, storage_cluster_id=None, storage_set_id=None, storage_set_partition_number=None, tag=None,
                 zone_id=None):
        # This parameter is unavailable.
        self.advanced_features = advanced_features  # type: str
        # 该参数暂未开放使用。
        self.arn = arn  # type: list[CreateDiskRequestArn]
        # This parameter is unavailable.
        self.bursting_enabled = bursting_enabled  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The category of the data disk. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # 
        # Default value: cloud.
        self.disk_category = disk_category  # type: str
        # The name of the disk. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.disk_name = disk_name  # type: str
        # This parameter is unavailable.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt the disk. Valid values:
        # 
        # *   true: encrypts the disk.
        # *   false: does not encrypt the disk.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the instance to which the created subscription disk is automatically attached.
        # 
        # *   After you specify the instance ID, the specified ResourceGroupId, Tag.N.Key, Tag.N.Value, ClientToken, and KMSKeyId parameters are ignored.
        # *   You cannot specify ZoneId and InstanceId at the same time.
        # 
        # This parameter is empty by default. This indicates that a pay-as-you-go disk is created. The RegionId and ZoneId parameters specify where the disk resides.
        self.instance_id = instance_id  # type: str
        # The ID of the Key Management Service (KMS) key used by the disk.
        self.kmskey_id = kmskey_id  # type: str
        # Specifies whether to enable the multi-attach feature for the disk. Valid values:
        # 
        # *   Disabled: disables the multi-attach feature.
        # *   Enabled: enables the multi-attach feature. Set the value to `Enabled` only for ESSDs.
        # 
        # Default value: Disabled.
        # 
        # >  Disks for which the multi-attach feature is enabled support only the pay-as-you-go billing method. When the `MultiAttach` parameter is set to Enabled, you cannot specify the `InstanceId` parameter. You can call the [AttachDisk](~~25515~~) operation to attach disks to instances after the disks are created. Disks for which the multi-attach feature is enabled can be attached only as data disks.
        self.multi_attach = multi_attach  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The performance level of the ESSD. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: An ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # Default value: PL1.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # This parameter is unavailable.
        self.provisioned_iops = provisioned_iops  # type: long
        # The ID of the region in which to create the disk. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the disk.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The size of the disk. Unit: GiB. This parameter is required. Valid values:
        # 
        # *   Valid values when DiskCategory is set to cloud: 5 to 2,000
        # 
        # *   Valid values when DiskCategory is set to cloud_efficiency: 20 to 32,768
        # 
        # *   Valid values when DiskCategory is set to cloud_ssd: 20 to 32,768
        # 
        # *   Valid values when DiskCategory is set to cloud_essd: depends on the `PerformanceLevel` value.
        # 
        #     *   Valid values when PerformanceLevel is set to PL0: 40 to 32,768
        #     *   Valid values when PerformanceLevel is set to PL1: 20 to 32,768
        #     *   Valid values when PerformanceLevel is set to PL2: 461 to 32,768
        #     *   Valid values when PerformanceLevel is set to PL3: 1,261 to 32,768
        # 
        # If the `SnapshotId` parameter is specified, the following limits apply to the `SnapshotId` and `Size` parameters:
        # 
        # *   If the size of the snapshot specified by the `SnapshotId` parameter is greater than the specified `Size` value, the size of the created disk is equal to the specified snapshot size.
        # *   If the size of the snapshot specified by the `SnapshotId` parameter is smaller than the specified `Size` value, the size of the created disk is equal to the specified `Size` value.
        self.size = size  # type: int
        # The ID of the snapshot used to create the disk. Snapshots that were created on or before July 15, 2013 cannot be used to create disks.
        # 
        # The following limits apply to the `SnapshotId` and `Size` parameters:
        # 
        # *   If the size of the snapshot specified by the `SnapshotId` parameter is greater than the specified `Size` value, the size of the created disk is equal to the specified snapshot size.
        # *   If the size of the snapshot specified by the `SnapshotId` parameter is smaller than the specified `Size` value, the size of the created disk is equal to the specified `Size` value.
        self.snapshot_id = snapshot_id  # type: str
        # The ID of the dedicated block storage cluster. To create a disk in a specific dedicated block storage cluster, specify this parameter. For more information about dedicated block storage clusters, see [What is Dedicated Block Storage Cluster?](~~208883~~)
        # 
        # >  You can specify only one of the storage set-related parameters (`StorageSetId` and `StorageSetPartitionNumber`) and dedicated block storage cluster-related parameter (`StorageClusterId`). If you specify more than one of the preceding parameters, the call fails.
        self.storage_cluster_id = storage_cluster_id  # type: str
        # The ID of the storage set.
        # 
        # >  You can specify only one of the storage set-related parameters (`StorageSetId` and `StorageSetPartitionNumber`) and dedicated block storage cluster-related parameter (`StorageClusterId`). If you specify more than one of the preceding parameters, the call fails.
        self.storage_set_id = storage_set_id  # type: str
        # The number of partitions in the storage set. The value must be greater than or equal to 2, but cannot exceed the quota obtained by calling the [DescribeAccountAttributes](~~73772~~) operation.
        # 
        # Default value: 2.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # 云盘的标签信息列表。
        self.tag = tag  # type: list[CreateDiskRequestTag]
        # The ID of the zone in which to create the pay-as-you-go disk.
        # 
        # *   If the InstanceId parameter is not specified, the ZoneId parameter is required.
        # *   You cannot specify ZoneId and InstanceId at the same time.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.advanced_features is not None:
            result['AdvancedFeatures'] = self.advanced_features
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_category is not None:
            result['DiskCategory'] = self.disk_category
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.multi_attach is not None:
            result['MultiAttach'] = self.multi_attach
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdvancedFeatures') is not None:
            self.advanced_features = m.get('AdvancedFeatures')
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = CreateDiskRequestArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskCategory') is not None:
            self.disk_category = m.get('DiskCategory')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('MultiAttach') is not None:
            self.multi_attach = m.get('MultiAttach')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateDiskRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateDiskResponseBody(TeaModel):
    def __init__(self, disk_id=None, order_id=None, request_id=None):
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The ID of the order.
        # 
        # >  This parameter is returned only when you create a subscription disk.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateElasticityAssuranceRequestPrivatePoolOptions(TeaModel):
    def __init__(self, match_criteria=None, name=None):
        # The type of the private pool associated with the elasticity assurance. Valid values:
        # 
        # *   Open: open private pool
        # *   Target: targeted private pool
        # 
        # Default value: Open.
        self.match_criteria = match_criteria  # type: str
        # The name of the elasticity assurance. The description must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateElasticityAssuranceRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class CreateElasticityAssuranceRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the elasticity assurance. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It must not start with `acs:` or `aliyun`.
        self.key = key  # type: str
        # The value of tag N of the elasticity assurance. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateElasticityAssuranceRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateElasticityAssuranceRequest(TeaModel):
    def __init__(self, private_pool_options=None, assurance_times=None, client_token=None, description=None,
                 instance_amount=None, instance_cpu_core_count=None, instance_type=None, owner_account=None, owner_id=None,
                 period=None, period_unit=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, start_time=None, tag=None, zone_id=None):
        self.private_pool_options = private_pool_options  # type: CreateElasticityAssuranceRequestPrivatePoolOptions
        # The total number of times that the elasticity assurance can be applied. Set the value to Unlimited. This value indicates that the elasticity assurance can be applied an unlimited number of times within its effective duration.
        # 
        # Default value: Unlimited.
        self.assurance_times = assurance_times  # type: str
        # The client token that you want to use to ensure the idempotency of the request. You can use the client to generate a client token. Make sure that a unique client token is used for different requests. The value of the `ClientToken` parameter can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the elasticity assurance. The description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The total number of instances for which to reserve the capacity of an instance type.
        # 
        # Valid values: 1 to 1000.
        self.instance_amount = instance_amount  # type: int
        # > The parameter was deprecated.
        self.instance_cpu_core_count = instance_cpu_core_count  # type: int
        # Instance types. Currently, an elasticity assurance can be created to reserve the capacity of a single instance type.
        self.instance_type = instance_type  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The effective duration of the elasticity assurance. The unit of the duration is determined by the `PeriodUnit` value. Valid values:
        # 
        # *   When the value of the `PeriodUnit` parameter is set to `Month`, valid values are: 1, 2, 3, 4, 5, 6, 7, 8, and 9.
        # *   When the value of the `PeriodUnit` parameter is set to `Year`, valid values are: 1, 2, 3, 4, and 5.
        # 
        # Default: 1.
        self.period = period  # type: int
        # The unit of the effective duration of the elasticity assurance. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Year.
        self.period_unit = period_unit  # type: str
        # The ID of the region in which to create the elasticity assurance. You can call the [DescribeRegions](~~25609~~) operation to query the current list of regions.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the elasticity assurance.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The time when the elasticity assurance takes effect. The default value is the time when the CreateElasticityAssurance operation is called to create the elasticity assurance. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC. For more information, see [ISO 8601](~~25696~~).
        self.start_time = start_time  # type: str
        # The tags.
        self.tag = tag  # type: list[CreateElasticityAssuranceRequestTag]
        # The IDs of the zones.
        self.zone_id = zone_id  # type: list[str]

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateElasticityAssuranceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.assurance_times is not None:
            result['AssuranceTimes'] = self.assurance_times
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_cpu_core_count is not None:
            result['InstanceCpuCoreCount'] = self.instance_cpu_core_count
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = CreateElasticityAssuranceRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('AssuranceTimes') is not None:
            self.assurance_times = m.get('AssuranceTimes')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceCpuCoreCount') is not None:
            self.instance_cpu_core_count = m.get('InstanceCpuCoreCount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateElasticityAssuranceRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateElasticityAssuranceResponseBody(TeaModel):
    def __init__(self, order_id=None, private_pool_options_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the elasticity assurance.
        self.private_pool_options_id = private_pool_options_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateElasticityAssuranceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.private_pool_options_id is not None:
            result['PrivatePoolOptionsId'] = self.private_pool_options_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('PrivatePoolOptionsId') is not None:
            self.private_pool_options_id = m.get('PrivatePoolOptionsId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateElasticityAssuranceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateElasticityAssuranceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateElasticityAssuranceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateElasticityAssuranceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateForwardEntryRequest(TeaModel):
    def __init__(self, external_ip=None, external_port=None, forward_table_id=None, internal_ip=None,
                 internal_port=None, ip_protocol=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.external_ip = external_ip  # type: str
        self.external_port = external_port  # type: str
        self.forward_table_id = forward_table_id  # type: str
        self.internal_ip = internal_ip  # type: str
        self.internal_port = internal_port  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateForwardEntryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateForwardEntryResponseBody(TeaModel):
    def __init__(self, forward_entry_id=None, request_id=None):
        self.forward_entry_id = forward_entry_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateForwardEntryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateForwardEntryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateForwardEntryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateForwardEntryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHaVipRequest(TeaModel):
    def __init__(self, client_token=None, description=None, ip_address=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, v_switch_id=None):
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.ip_address = ip_address  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHaVipRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateHaVipResponseBody(TeaModel):
    def __init__(self, ha_vip_id=None, request_id=None):
        self.ha_vip_id = ha_vip_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHaVipResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateHaVipResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHaVipResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHaVipResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHpcClusterRequest(TeaModel):
    def __init__(self, client_token=None, description=None, name=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value must contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the HPC cluster. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The name of the HPC cluster. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with http:// or https://. It can contain letters, digits, underscores (\_), and hyphens (-).
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the HPC cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHpcClusterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateHpcClusterResponseBody(TeaModel):
    def __init__(self, hpc_cluster_id=None, request_id=None):
        # The ID of the HPC cluster.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHpcClusterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateHpcClusterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHpcClusterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHpcClusterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHpcClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateImageRequestDiskDeviceMapping(TeaModel):
    def __init__(self, device=None, disk_type=None, size=None, snapshot_id=None):
        # The device name of disk N in the custom image. Valid values:
        # 
        # *   For disk categories other than basic disks, such as standard SSDs, ultra disks, and enhanced SSDs (ESSDs), the valid values are in alphabetical order from /dev/vda to /dev/vdz.
        # *   For basic disks, the valid values are in alphabetical order from /dev/xvda to /dev/xvdz.
        self.device = device  # type: str
        # The type of disk N in the custom image. You can set this parameter to create the system disk of the custom image from a data disk snapshot. If you do not set this parameter, the disk type is determined by the corresponding snapshot. Valid values:
        # 
        # *   system: system disk
        # *   data: data disk
        self.disk_type = disk_type  # type: str
        # The size of disk N in the custom image. Unit: GiB. The valid values and default value of DiskDeviceMapping.N.Size depend on DiskDeviceMapping.N.SnapshotId.
        # 
        # *   If no corresponding snapshot IDs are specified in the DiskDeviceMapping.N.SnapshotId value, the following valid values and default values are available for DiskDeviceMapping.N.Size:
        # 
        #     *   For basic disks, the valid values are 5 to 2000, and the default value is 5.
        #     *   For other disk categories, the valid values are 20 to 32768, and the default value is 20.
        # 
        # *   If a corresponding snapshot ID is specified in the DiskDeviceMapping.N.SnapshotId value, the value of DiskDeviceMapping.N.Size must be greater than or equal to the size of the specified snapshot. The default value of DiskDeviceMapping.N.Size is the size of the specified snapshot.
        self.size = size  # type: int
        # The ID of the snapshot that is used to create the custom image.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageRequestDiskDeviceMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateImageRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the custom image. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
        self.key = key  # type: str
        # The value of tag N of the custom image. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateImageRequest(TeaModel):
    def __init__(self, architecture=None, boot_mode=None, client_token=None, description=None,
                 detection_strategy=None, disk_device_mapping=None, image_family=None, image_name=None, image_version=None,
                 instance_id=None, owner_account=None, owner_id=None, platform=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, snapshot_id=None, tag=None):
        # The system architecture of the system disk. If you specify a data disk snapshot to create the system disk of the custom image, you must use the Architecture parameter to specify the system architecture of the system disk. Valid values:
        # 
        # *   i386
        # *   x86\_64
        # *   arm64
        # 
        # Default value: x86\_64.
        self.architecture = architecture  # type: str
        # The boot mode of the custom image. Valid values:
        # 
        # *   BIOS
        # *   UEFI
        # 
        # > You must be aware of the boot modes supported by the specified image. When you use this parameter to change the boot mode of the image, specify a boot mode supported by the image to ensure that instances that use this image can start as expected.
        self.boot_mode = boot_mode  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The **ClientToken** value can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        # The mode in which to check the source image. If you do not specify this parameter, the source image is not checked. Only Linux images can be checked. Set the value to Standard, which indicates standard check mode.
        # 
        # The following items are checked in standard check mode:
        # 
        # *   Virtio: whether the virtio driver is installed.
        # *   Fstab: whether mounting configurations in the fstab file are correct.
        # *   Grub: whether GRand Unified Bootloader (GRUB) configurations are correct.
        # *   SystemImage: whether the image is valid. Do not import images that are in the ISO format or empty.
        # *   CloudInit: whether cloud-init is installed.
        # *   NVMe: whether the NVMe driver is installed.
        # *   Selinux: whether SElinux is enabled.
        # *   OnlineResizeFS: whether the root partition can be automatically resized.
        # *   Dhcp: whether Dynamic Host Configuration Protocol (DHCP) is enabled for network interface controllers (NICs).
        # *   RtcTimeMode: the RTC time mode.
        # *   Platform: the platform. Example: Linux or Windows.
        # *   OSVersion: the operating system version. Example: Centos 7.9.
        # *   Architecture: the architecture. Example: ARM or x86\_64.
        # *   BootMode: the boot mode. Example: UEFI or Legacy.
        # *   KernelVersion: the kernel version.
        # *   CloudAssistant: whether the Cloud Assistant client is installed.
        # *   SecurityCenterAgent: whether the Security Center agent is installed.
        self.detection_strategy = detection_strategy  # type: str
        # Details about the custom images.
        self.disk_device_mapping = disk_device_mapping  # type: list[CreateImageRequestDiskDeviceMapping]
        self.image_family = image_family  # type: str
        self.image_name = image_name  # type: str
        # The version of the custom image.
        # 
        # > If you specify an instance by setting `InstanceId` and the instance uses an Alibaba Cloud Marketplace image or a custom image derived from an Alibaba Cloud Marketplace image, this parameter must be left empty or set to the value of the ImageVersion parameter of the instance.
        self.image_version = image_version  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The distribution of the operating system for the system disk in the custom image. If you specify a data disk snapshot to create the system disk of the custom image, you must use the Platform parameter to specify the distribution of the operating system for the system disk. Valid values:
        # 
        # *   CentOS
        # *   Ubuntu
        # *   SUSE
        # *   OpenSUSE
        # *   RedHat
        # *   Debian
        # *   CoreOS
        # *   Aliyun
        # *   Windows Server 2012
        # *   Windows 7
        # *   Customized Linux
        # *   Others Linux
        # 
        # Default value: Others Linux.
        self.platform = platform  # type: str
        # The ID of the region in which to create the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the custom image. If you do not specify this parameter, the image is assigned to the default resource group.
        # 
        # > If you call the CopyImage operation as a Resource Access Management (RAM) user who is not authorized to manage the default resource group and do not specify the `ResourceGroupId` parameter, the `Forbbiden: User not authorized to operate on the specified resource` error message is returned. You must specify the ID of a resource group that the RAM user is authorized to manage or authorize the RAM user to manage the default resource group before you call the CreateImage operation again.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot that is used to create the custom image.
        self.snapshot_id = snapshot_id  # type: str
        # The tags of the custom image.
        self.tag = tag  # type: list[CreateImageRequestTag]

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.boot_mode is not None:
            result['BootMode'] = self.boot_mode
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.detection_strategy is not None:
            result['DetectionStrategy'] = self.detection_strategy
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_version is not None:
            result['ImageVersion'] = self.image_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('BootMode') is not None:
            self.boot_mode = m.get('BootMode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DetectionStrategy') is not None:
            self.detection_strategy = m.get('DetectionStrategy')
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = CreateImageRequestDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageVersion') is not None:
            self.image_version = m.get('ImageVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateImageRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateImageResponseBody(TeaModel):
    def __init__(self, image_id=None, request_id=None):
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateImageComponentRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.key = key  # type: str
        # The value of tag N. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageComponentRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateImageComponentRequest(TeaModel):
    def __init__(self, client_token=None, component_type=None, content=None, description=None, name=None,
                 owner_account=None, owner_id=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, system_type=None, tag=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The type of the image component. Only image building components are supported. Set the value to Build.
        # 
        # Default value: Build.
        self.component_type = component_type  # type: str
        # The content of the image component. The content can consist of up to 127 commands.
        self.content = content  # type: str
        # The description of the image component. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description  # type: str
        # The name of the image component. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
        # 
        # >  If you do not specify the `Name` parameter, the return value of `ImageComponentId` is used by default.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the image component. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the image component.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The operating system type supported by the image component. Only Linux is supported. Set the value to Linux.
        # 
        # Default value: Linux.
        self.system_type = system_type  # type: str
        # The tags.
        self.tag = tag  # type: list[CreateImageComponentRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateImageComponentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.content is not None:
            result['Content'] = self.content
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateImageComponentRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateImageComponentResponseBody(TeaModel):
    def __init__(self, image_component_id=None, request_id=None):
        # The ID of the image component.
        self.image_component_id = image_component_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageComponentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_component_id is not None:
            result['ImageComponentId'] = self.image_component_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageComponentId') is not None:
            self.image_component_id = m.get('ImageComponentId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateImageComponentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateImageComponentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateImageComponentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateImageComponentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateImagePipelineRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImagePipelineRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateImagePipelineRequest(TeaModel):
    def __init__(self, add_account=None, base_image=None, base_image_type=None, build_content=None,
                 client_token=None, delete_instance_on_failure=None, description=None, image_name=None, instance_type=None,
                 internet_max_bandwidth_out=None, name=None, owner_account=None, owner_id=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, system_disk_size=None, tag=None, to_region_id=None, v_switch_id=None):
        self.add_account = add_account  # type: list[long]
        # The source image.
        # 
        # *   When you set `BaseImageType` to IMAGE, set BaseImage to the ID of a custom image.
        # *   When you set `BaseImageType` to IMAGE_FAMILY, set BaseImage to the name of an image family.
        self.base_image = base_image  # type: str
        # The type of the source image. Valid values:
        # 
        # *   IMAGE: custom image
        # *   IMAGE_FAMILY: image family
        self.base_image_type = base_image_type  # type: str
        # The content of the image template. The content cannot be greater than 16 KB in size, and can contain up to 127 commands. For more information about the commands that are supported, see the "Description" section in this topic.
        self.build_content = build_content  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # Specifies whether to release the intermediate instance if the image cannot be created. Valid values:
        # 
        # *   true: releases the intermediate instance if the image cannot be created.
        # *   false: does not release the intermediate instance if the image cannot be created.
        # 
        # Default value: true.
        # 
        # >  If the intermediate instance cannot be started, the instance is released by default.
        self.delete_instance_on_failure = delete_instance_on_failure  # type: bool
        # The description of the image template. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The name prefix of the image to be created. The prefix must be 2 to 64 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), periods (.),and hyphens (-).
        # 
        # The system generates the final complete image name that consists of the prefix and the ID of the image build task (`ExecutionId`) in the format of `{ImageName}_{ExecutionId}`.
        self.image_name = image_name  # type: str
        # The instance type of the instance. You can call the [DescribeInstanceTypes](~~25620~~) operation to query instance types.
        # 
        # If you do not specify this parameter, an instance type that provides the fewest vCPUs and memory resources is automatically selected. This configuration is subject to resource availability of instance types. For example, the ecs.g6.large instance type is selected by default. If available ecs.g6.large resources are insufficient, the ecs.g6.xlarge instance type is selected.
        self.instance_type = instance_type  # type: str
        # The size of the outbound public bandwidth for the intermediate instance. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # Default value: 0.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # The name of the image template. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), periods (.),and hyphens (-).
        # 
        # >  If you do not specify the `Name` parameter, the return value of `ImagePipelineId` is used by default.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the image template.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The size of the system disk of the intermediate instance. Unit: GiB. Valid values: 20 to 500.
        # 
        # Default value: 40.
        self.system_disk_size = system_disk_size  # type: int
        self.tag = tag  # type: list[CreateImagePipelineRequestTag]
        self.to_region_id = to_region_id  # type: list[str]
        # The ID of the vSwitch.
        # 
        # If you do not specify this parameter, a virtual private cloud (VPC) and a vSwitch are created by default. Make sure that the VPC quota in your account is sufficient. For more information, see [Limits](~~27750~~).
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateImagePipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_account is not None:
            result['AddAccount'] = self.add_account
        if self.base_image is not None:
            result['BaseImage'] = self.base_image
        if self.base_image_type is not None:
            result['BaseImageType'] = self.base_image_type
        if self.build_content is not None:
            result['BuildContent'] = self.build_content
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.delete_instance_on_failure is not None:
            result['DeleteInstanceOnFailure'] = self.delete_instance_on_failure
        if self.description is not None:
            result['Description'] = self.description
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.to_region_id is not None:
            result['ToRegionId'] = self.to_region_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddAccount') is not None:
            self.add_account = m.get('AddAccount')
        if m.get('BaseImage') is not None:
            self.base_image = m.get('BaseImage')
        if m.get('BaseImageType') is not None:
            self.base_image_type = m.get('BaseImageType')
        if m.get('BuildContent') is not None:
            self.build_content = m.get('BuildContent')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DeleteInstanceOnFailure') is not None:
            self.delete_instance_on_failure = m.get('DeleteInstanceOnFailure')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateImagePipelineRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ToRegionId') is not None:
            self.to_region_id = m.get('ToRegionId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateImagePipelineResponseBody(TeaModel):
    def __init__(self, image_pipeline_id=None, request_id=None):
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImagePipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateImagePipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateImagePipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateImagePipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateImagePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstanceRequestHibernationOptions(TeaModel):
    def __init__(self, configured=None):
        # > This parameter is in invitational preview and is unavailable.
        self.configured = configured  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestHibernationOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configured is not None:
            result['Configured'] = self.configured
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Configured') is not None:
            self.configured = m.get('Configured')
        return self


class CreateInstanceRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None, match_criteria=None):
        # The ID of the private pool to use to create the instance. The ID of a private pool is the same as that of the elasticity assurance or capacity reservation for which the private pool is generated.
        self.id = id  # type: str
        # The type of the private pool to use to create the instance. A private pool is generated when an elasticity assurance or a capacity reservation takes effect. You can select a private pool when you create an instance. Valid values:
        # 
        # * Open: open private pool. The system selects a matching open private pool to create the instance. If no matching open private pools are found, resources in the public pool are used. When you set this parameter to Open, you can leave the `PrivatePoolOptions.Id` parameter empty.
        # * Target: specified private pool. The system uses the capacity in a specified private pool to create the instance. If the specified private pool is unavailable, the instance cannot be created. If you set this parameter to Target, you must specify the `PrivatePoolOptions.Id` parameter.
        # * None: no private pool. The capacity in private pools is not used.
        # 
        # Default value: None.
        # 
        # In the following scenarios, the PrivatePoolOptions.MatchCriteria parameter can be set only to `None` or left empty:
        # 
        # * Create a preemptible instance.
        # * Create an instance in the classic network.
        # * Create an instance on a dedicated host.
        self.match_criteria = match_criteria  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        return self


class CreateInstanceRequestSystemDisk(TeaModel):
    def __init__(self, category=None, description=None, disk_name=None, performance_level=None, size=None,
                 storage_cluster_id=None):
        # The category of the system disk. Valid values:
        # 
        # * cloud_essd: ESSD. When the parameter is set to this value, you can use the `SystemDisk.PerformanceLevel` parameter to specify the performance level of the disk.
        # * cloud_efficiency: ultra disk.
        # * cloud_ssd: standard SSD.
        # * cloud: basic disk.
        # 
        # For non-I/O optimized instances of retired instance types, the default value is cloud. For other instances, the default value is cloud_efficiency.
        self.category = category  # type: str
        # The description of the system disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The name of the system disk. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.disk_name = disk_name  # type: str
        # The performance level of the ESSD to use as the system disk. Default value: PL1. Valid values:
        # 
        # * PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # * PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # * PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # * PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # The size of the system disk. Unit: GiB. Valid values: 20 to 500.
        # 
        # The value of this parameter must be at least 20 and greater than or equal to the size of the specified image.
        # 
        # Default value: 40 or the size of the image, whichever is greater.
        self.size = size  # type: int
        # The ID of the dedicated block storage cluster. If you want to use a disk in a dedicated block storage cluster as the system disk when you create the instance, you must specify this parameter. For more information about dedicated block storage clusters, see [What is Dedicated Block Storage Cluster?](~~208883~~)
        self.storage_cluster_id = storage_cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        return self


class CreateInstanceRequestArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # > This parameter is in invitational preview and is unavailable.
        self.assume_role_for = assume_role_for  # type: long
        # > This parameter is in invitational preview and is unavailable.
        self.role_type = role_type  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class CreateInstanceRequestDataDisk(TeaModel):
    def __init__(self, category=None, delete_with_instance=None, description=None, device=None, disk_name=None,
                 encrypt_algorithm=None, encrypted=None, kmskey_id=None, performance_level=None, size=None, snapshot_id=None,
                 storage_cluster_id=None):
        # The category of data disk N. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # *   cloud: basic disk
        # 
        # For I/O optimized instances, the default value is cloud_efficiency. For non-I/O optimized instances, the default value is cloud.
        self.category = category  # type: str
        # Specifies whether to release data disk N when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of data disk N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The mount point of data disk N.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # The algorithm to use to encrypt data disk N.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt data disk N.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the Key Management Service (KMS) key to use for data disk N.
        self.kmskey_id = kmskey_id  # type: str
        # The performance level of the ESSD to use as data disk N. The N value must be the same as that in `DataDisk.N.Category` when DataDisk.N.Category is set to cloud_essd. Default value: PL1. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # The size of data disk N. Valid values of N: 1 to 16. Unit: GiB. Valid values:
        # 
        # * Valid values when DataDisk.N.Category is set to cloud_efficiency: 20 to 32768.
        # 
        # * Valid values when DataDisk.N.Category is set to cloud_ssd: 20 to 32768.
        # 
        # * Valid values when DataDisk.N.Category is set to cloud_essd: depend on the `DataDisk.N.PerformanceLevel` value.
        # 
        #     * Valid values when the DataDisk.N.PerformanceLevel parameter is set to PL0: 40 to 32768.
        #     * Valid values when the DataDisk.N.PerformanceLevel parameter is set to PL1: 20 to 32768.
        #     * Valid values when the DataDisk.N.PerformanceLevel parameter is set to PL2: 461 to 32768.
        #     * Valid values when the DataDisk.N.PerformanceLevel parameter is set to PL3: 1261 to 32768.
        # 
        # * Valid values when DataDisk.N.Category is set to cloud: 5 to 2000.
        # 
        # The value of this parameter must be greater than or equal to the size of the snapshot specified by the `SnapshotId` parameter.
        self.size = size  # type: int
        # The ID of the snapshot to use to create data disk N. Valid values of N: 1 to 16.
        # 
        # *   If the `DataDisk.N.SnapshotId` parameter is specified, the `DataDisk.N.Size` parameter is ignored and the data disk is created with the size of the specified snapshot.
        # *   Use snapshots created after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        self.snapshot_id = snapshot_id  # type: str
        # The ID of the dedicated block storage cluster. If you want to use a disk in a dedicated block storage cluster as data disk N when you create the instance, you must specify this parameter.
        self.storage_cluster_id = storage_cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        return self


class CreateInstanceRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the instance, disks, and primary elastic network interface (ENI). Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N to add to the instance, disks, and primary ENI. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateInstanceRequest(TeaModel):
    def __init__(self, hibernation_options=None, private_pool_options=None, system_disk=None, affinity=None,
                 arn=None, auto_renew=None, auto_renew_period=None, client_token=None, cluster_id=None,
                 credit_specification=None, data_disk=None, dedicated_host_id=None, deletion_protection=None,
                 deployment_set_group_no=None, deployment_set_id=None, description=None, dry_run=None, host_name=None, hpc_cluster_id=None,
                 http_endpoint=None, http_put_response_hop_limit=None, http_tokens=None, image_family=None, image_id=None,
                 inner_ip_address=None, instance_charge_type=None, instance_name=None, instance_type=None,
                 internet_charge_type=None, internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None,
                 key_pair_name=None, node_controller_id=None, owner_account=None, owner_id=None, password=None,
                 password_inherit=None, period=None, period_unit=None, private_ip_address=None, ram_role_name=None, region_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, security_enhancement_strategy=None,
                 security_group_id=None, spot_duration=None, spot_interruption_behavior=None, spot_price_limit=None,
                 spot_strategy=None, storage_set_id=None, storage_set_partition_number=None, tag=None, tenancy=None,
                 use_additional_service=None, user_data=None, v_switch_id=None, vlan_id=None, zone_id=None):
        self.hibernation_options = hibernation_options  # type: CreateInstanceRequestHibernationOptions
        self.private_pool_options = private_pool_options  # type: CreateInstanceRequestPrivatePoolOptions
        self.system_disk = system_disk  # type: CreateInstanceRequestSystemDisk
        # Specifies whether to associate the instance on a dedicated host with the dedicated host. Valid values:
        # 
        # *   default: does not associate the instance with the dedicated host. When you start an instance that was stopped in economical mode, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool if the available resources of the original dedicated host are insufficient.
        # *   host: associates the instance with the dedicated host. When you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the available resources of the original dedicated host are insufficient, the instance cannot start.
        # 
        # Default value: default.
        self.affinity = affinity  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.arn = arn  # type: list[CreateInstanceRequestArn]
        # Specifies whether to enable auto-renewal for the instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PrePaid`. Default value: false. Valid values:
        # 
        # * true: enables auto-renewal.
        # * false: does not enable auto-renewal.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal cycle of the instance. This parameter is required when AutoRenew is set to true.
        # 
        # Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, and 12
        self.auto_renew_period = auto_renew_period  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the cluster in which to create the instance.
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.cluster_id = cluster_id  # type: str
        # The performance mode of the burstable instance. Valid values:
        # 
        # *   Standard: the standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
        # *   Unlimited: the unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).
        self.credit_specification = credit_specification  # type: str
        # The list of data disks.
        self.data_disk = data_disk  # type: list[CreateInstanceRequestDataDisk]
        # The ID of the dedicated host on which to create the instance.
        # 
        # You can call the [DescribeDedicatedHosts](~~134242~~) operation to query the list of dedicated host IDs.
        # 
        # If the `DedicatedHostId` parameter is specified, the `SpotStrategy` and `SpotPriceLimit` parameters are ignored. This is because preemptible instances cannot be created on dedicated hosts.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # Specifies whether to enable release protection for the instance. This parameter determines whether you can use the ECS console or call the [DeleteInstance](~~25507~~) operation to release the instance. Default value: false. Valid values:
        # 
        # *   true: enables release protection.
        # *   false: disables release protection.
        # 
        # >  This parameter is applicable only to pay-as-you-go instances. It can protect instances against manual releases, but not against automatic releases.
        self.deletion_protection = deletion_protection  # type: bool
        # The number of the deployment set group to which to deploy the instance. If the deployment set specified by the DeploymentSetId parameter uses the high availability group strategy (AvailabilityGroup), you can use the DeploymentSetGroupNo parameter to specify a deployment set group in the deployment set. Valid values: 1 to 7.
        self.deployment_set_group_no = deployment_set_group_no  # type: int
        # The ID of the deployment set to which to deploy the instance.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether required parameters are specified, the request format, service limits, and available ECS resources. If the check fails, the corresponding error code is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked, and the request is made if the check succeeds.
        self.dry_run = dry_run  # type: bool
        # The hostname of the instance.
        # 
        # * The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # * For a Windows instance, the hostname must be 2 to 15 characters in length and cannot contain periods (.) or contain only digits. It can contain letters, digits, and hyphens (-).
        # * For an instance that runs another type of operating system such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate the hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        self.host_name = host_name  # type: str
        # The ID of the HPC cluster to which to assign the instance.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # Specifies whether to enable the access channel for instance metadata. Valid values:
        # 
        # *   enabled: enables the access channel for instance metadata.
        # *   disabled: disables the access channel for instance metadata.
        # 
        # Default value: enabled.
        # 
        # >  For more information about instance metadata, see [Overview of ECS instance metadata](~~49122~~).
        self.http_endpoint = http_endpoint  # type: str
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.http_put_response_hop_limit = http_put_response_hop_limit  # type: int
        # Specifies whether to forcefully use the security-enhanced mode (IMDSv2) to access instance metadata. Valid values:
        # 
        # *   optional: does not forcibly use the security-enhanced mode (IMDSv2).
        # *   required: forcefully uses the security-enhanced mode (IMDSv2). After you set this parameter to required, you cannot access instance metadata in normal mode.
        # 
        # Default value: optional.
        # 
        # >  For more information about modes of accessing instance metadata, see [Access mode of instance metadata](~~150575~~).
        self.http_tokens = http_tokens  # type: str
        # The name of the image family. You can set this parameter to obtain the latest available custom image from the specified image family to create the instance.
        # 
        # * ImageFamily must be empty if `ImageId` is specified.
        # * ImageFamily can be specified if `ImageId` is not specified.
        self.image_family = image_family  # type: str
        # The ID of the image to use to create the instance. To use an Alibaba Cloud Marketplace image, you can view the `image ID` on the product page of the Alibaba Cloud Marketplace image. This parameter is required if you do not specify the `ImageFamily` parameter to obtain the latest available custom image from the specified image family.
        self.image_id = image_id  # type: str
        # The internal IP address to assign to the instance.
        self.inner_ip_address = inner_ip_address  # type: str
        # The billing method of the instance. Default value: PostPaid. Valid values:
        # 
        # * PrePaid: subscription. If you set this parameter to PrePaid, make sure that you have sufficient balance or credit in your account. Otherwise, an `InvalidPayMethod` error is returned.
        # * PostPaid: pay-as-you-go.
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). If you do not specify this parameter, the instance ID is used as the instance name by default.
        self.instance_name = instance_name  # type: str
        # The instance type.
        # 
        # * Select an instance type. See [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the performance data of an instance type, or see [Best practices for instance type selection](~~58291~~) to learn about how to select instance types.
        # * Query available resources. You can call the [DescribeAvailableResource](~~66186~~) operation to query available resources in a specific region or zone.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage. Default value: PayByTraffic. Valid values:
        # 
        # * PayByBandwidth: pay-by-bandwidth
        # * PayByTraffic: pay-by-traffic
        # 
        # > When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # * When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of this parameter are 1 to 10 and the default value is 10.
        # * When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the `InternetMaxBandwidthOut` value and the default value is the `InternetMaxBandwidthOut` value.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # Default value: 0.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        # 
        # For retired instance types, the default value is none. For more information, see [Retired instance types](~~55263~~).
        # 
        # For other instance types, the default value is optimized.
        self.io_optimized = io_optimized  # type: str
        # The name of the key pair.
        # 
        # >  For Windows instances, this parameter is ignored. This parameter is empty by default. The `Password` parameter takes effect even if the KeyPairName parameter is specified.
        self.key_pair_name = key_pair_name  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.node_controller_id = node_controller_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The password of the instance. The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        # ```plain
        # ( ) ` ~ ! @ # $ % ^ & * - _ + = | { } [ ] : ; \" < > , . ? /\
        # ```
        # 
        # Take note of the following items:
        # 
        # * For security reasons, we recommend that you use HTTPS to send requests if the Password parameter is specified.
        # * Passwords of Windows instances cannot start with a forward slash (/).
        # * Passwords cannot be set for instances that run some types of operating systems such as Others Linux and Fedora CoreOS. For these instances, only key pairs can be set.
        self.password = password  # type: str
        # Specifies whether to use the password preset in the image. When you use this parameter, leave Password empty and make sure that the selected image has a password preset.
        self.password_inherit = password_inherit  # type: bool
        # The subscription period of the instance. The unit is specified by the `PeriodUnit` parameter. This parameter is valid and required only when `InstanceChargeType` is set to `PrePaid`. If the `DedicatedHostId` parameter is specified, the value of Period must not exceed the subscription period of the specified dedicated host. Valid values:
        # 
        # Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, and 12
        self.period = period  # type: int
        # The unit of the subscription period. Valid values:
        # 
        # Month
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The private IP address to assign to the instance. The private IP address must be an available IP address within the CIDR block of the specified vSwitch.
        self.private_ip_address = private_ip_address  # type: str
        # The name of the instance Resource Access Management (RAM) role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the region in which to create the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the instance.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to enable security hardening. Valid values:
        # 
        # *   Active: enables security hardening. This value is applicable only to public images.
        # *   Deactive: does not enable security hardening. This value is applicable to all images.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance. Instances in the same security group can communicate with each other.
        self.security_group_id = security_group_id  # type: str
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies to release the instance.
        self.spot_interruption_behavior = spot_interruption_behavior  # type: str
        # The maximum hourly price of the instance. The value is accurate to three decimal places. This parameter is valid only when the `SpotStrategy` parameter is set to `SpotWithPriceLimit`.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Default value: NoSpot. Valid values:
        # 
        # *   NoSpot: The instance is created as a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        self.spot_strategy = spot_strategy  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The maximum number of partitions in the storage set. Valid values: greater than or equal to 2.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # The tags.
        self.tag = tag  # type: list[CreateInstanceRequestTag]
        # Specifies whether to create the instance on a dedicated host. Valid values:
        # 
        # *   default: creates the instance on a non-dedicated host.
        # *   host: creates the instance on a dedicated host. If you do not specify the `DedicatedHostId` parameter, Alibaba Cloud selects a dedicated host for the instance.
        # 
        # Default value: default.
        self.tenancy = tenancy  # type: str
        # Specifies whether to use the system configurations for virtual machines provided by Alibaba Cloud (Windows: NTP and KMS. Linux: NTP and YUM).
        self.use_additional_service = use_additional_service  # type: bool
        # The user data of the instance. The user data must be encoded in Base64. The maximum size of raw data is 16 KB.
        self.user_data = user_data  # type: str
        # The ID of the vSwitch to which to connect the instance. This parameter is required when you create an instance in a VPC. You can call the [DescribeVSwitches](~~35748~~) operation to query available vSwitches.
        # 
        # >  If the `VSwitchId` parameter is specified, the zone specified by the `ZoneId` parameter must be the zone where the specified vSwitch is located. You can also leave the `ZoneId` parameter empty. Then, the system selects the zone where the specified vSwitch is located.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the virtual LAN (VLAN).
        self.vlan_id = vlan_id  # type: str
        # The ID of the zone in which to create the instance. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        # 
        # >  If the `VSwitchId` parameter is specified, the zone specified by the `ZoneId` parameter must be the zone where the specified vSwitch is located. You can also leave the `ZoneId` parameter empty. Then, the system selects the zone where the specified vSwitch is located.
        # 
        # This parameter is empty by default.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.hibernation_options:
            self.hibernation_options.validate()
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hibernation_options is not None:
            result['HibernationOptions'] = self.hibernation_options.to_map()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.affinity is not None:
            result['Affinity'] = self.affinity
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deployment_set_group_no is not None:
            result['DeploymentSetGroupNo'] = self.deployment_set_group_no
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.http_endpoint is not None:
            result['HttpEndpoint'] = self.http_endpoint
        if self.http_put_response_hop_limit is not None:
            result['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit
        if self.http_tokens is not None:
            result['HttpTokens'] = self.http_tokens
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.inner_ip_address is not None:
            result['InnerIpAddress'] = self.inner_ip_address
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.node_controller_id is not None:
            result['NodeControllerId'] = self.node_controller_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_interruption_behavior is not None:
            result['SpotInterruptionBehavior'] = self.spot_interruption_behavior
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.tenancy is not None:
            result['Tenancy'] = self.tenancy
        if self.use_additional_service is not None:
            result['UseAdditionalService'] = self.use_additional_service
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HibernationOptions') is not None:
            temp_model = CreateInstanceRequestHibernationOptions()
            self.hibernation_options = temp_model.from_map(m['HibernationOptions'])
        if m.get('PrivatePoolOptions') is not None:
            temp_model = CreateInstanceRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('SystemDisk') is not None:
            temp_model = CreateInstanceRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Affinity') is not None:
            self.affinity = m.get('Affinity')
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = CreateInstanceRequestArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = CreateInstanceRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeploymentSetGroupNo') is not None:
            self.deployment_set_group_no = m.get('DeploymentSetGroupNo')
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('HttpEndpoint') is not None:
            self.http_endpoint = m.get('HttpEndpoint')
        if m.get('HttpPutResponseHopLimit') is not None:
            self.http_put_response_hop_limit = m.get('HttpPutResponseHopLimit')
        if m.get('HttpTokens') is not None:
            self.http_tokens = m.get('HttpTokens')
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InnerIpAddress') is not None:
            self.inner_ip_address = m.get('InnerIpAddress')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('NodeControllerId') is not None:
            self.node_controller_id = m.get('NodeControllerId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotInterruptionBehavior') is not None:
            self.spot_interruption_behavior = m.get('SpotInterruptionBehavior')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateInstanceRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Tenancy') is not None:
            self.tenancy = m.get('Tenancy')
        if m.get('UseAdditionalService') is not None:
            self.use_additional_service = m.get('UseAdditionalService')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateInstanceResponseBody(TeaModel):
    def __init__(self, instance_id=None, order_id=None, request_id=None, trade_price=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the order. This parameter is returned only when `InstanceChargeType` is set to PrePaid.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The transaction price.
        self.trade_price = trade_price  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class CreateInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateKeyPairRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to be bound to the key pair. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
        self.key = key  # type: str
        # The value of tag N of the key pair. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain http:// or https://. It cannot start with acs:.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateKeyPairRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateKeyPairRequest(TeaModel):
    def __init__(self, key_pair_name=None, owner_id=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None):
        # The name of the key pair. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.key_pair_name = key_pair_name  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region in which to create the key pair. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the enterprise resource group to which the SSH key pair belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[CreateKeyPairRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateKeyPairRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateKeyPairRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateKeyPairResponseBody(TeaModel):
    def __init__(self, key_pair_finger_print=None, key_pair_id=None, key_pair_name=None, private_key_body=None,
                 request_id=None):
        # The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716. For more information, see [RFC 4716](https://tools.ietf.org/html/rfc4716).
        self.key_pair_finger_print = key_pair_finger_print  # type: str
        # The ID of the SSH key pair.
        self.key_pair_id = key_pair_id  # type: str
        # The name of the SSH key pair.
        self.key_pair_name = key_pair_name  # type: str
        # The private key of the key pair. The private key is encoded with PEM in the PKCS#8 format.
        self.private_key_body = private_key_body  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateKeyPairResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_id is not None:
            result['KeyPairId'] = self.key_pair_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.private_key_body is not None:
            result['PrivateKeyBody'] = self.private_key_body
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairId') is not None:
            self.key_pair_id = m.get('KeyPairId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('PrivateKeyBody') is not None:
            self.private_key_body = m.get('PrivateKeyBody')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateKeyPairResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateKeyPairResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateKeyPairResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLaunchTemplateRequestSystemDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, disk_name=None, encrypted=None, iops=None, performance_level=None,
                 provisioned_iops=None, size=None):
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of the system disk. Valid values:
        # 
        # *   cloud: basic disk.
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: standard SSD.
        # *   cloud_essd: enhanced SSD (ESSD). You can use the `SystemDisk.PerformanceLevel` parameter to set the performance level of the ESSD used as the system disk.
        # 
        # For non-I/O optimized instances of retired instance types, the default value is cloud. For other instances, the default value is cloud_efficiency.
        self.category = category  # type: str
        # Specifies whether to release the system disk when the instance is released. Valid values:
        # 
        # *   true: releases the system disk when the instance is released.
        # *   false: does not release the system disk when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of the system disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The name of the system disk. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        self.encrypted = encrypted  # type: str
        self.iops = iops  # type: int
        # The performance level of the ESSD that is used as the system disk. Default value: PL0. Valid values:
        # 
        # * PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # * PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # * PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # * PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of the system disk. Unit: GiB. Valid values: 20 to 500.
        # 
        # The value of this parameter must be at least 20 and greater than or equal to the image size.
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.iops is not None:
            result['Iops'] = self.iops
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('Iops') is not None:
            self.iops = m.get('Iops')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateLaunchTemplateRequestDataDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, device=None, disk_name=None, encrypted=None, performance_level=None,
                 provisioned_iops=None, size=None, snapshot_id=None):
        # The ID of the automatic snapshot policy to apply to data disk.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # This parameter is unavailable.
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of data disk N. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # 
        # For I/O optimized instances, the default value is cloud_efficiency. For non-I/O optimized instances, the default value is cloud.
        self.category = category  # type: str
        # Specifies whether to release data disk N when the instance is released. Valid values:
        # 
        # *   true: releases data disk N when the instance is released.
        # *   false: does not release data disk N when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of data disk N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The mount point of data disk.
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # Specifies whether to encrypt data disk N.
        self.encrypted = encrypted  # type: str
        # The performance level of the ESSD used as data disk N. The N value must be the same as that in `DataDisk.N.Category` when DataDisk.N.Category is set to cloud_essd. Default value: PL1. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # This parameter is unavailable.
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of data disk N. Valid values of N: 1 to 16. Unit: GiB. Valid values:
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud: 5 to 2000
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_efficiency: 20 to 32768
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_ssd: 20 to 32768
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_essd: depend on the `DataDisk.N.PerformanceLevel` value.
        # 
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL0: 40 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL1: 20 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL2: 461 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL3: 1261 to 32768.
        # 
        # The value of this parameter must be greater than or equal to the size of the snapshot specified by the `SnapshotId` parameter.
        self.size = size  # type: int
        # The ID of the snapshot used to create data disk N. Valid values of N: 1 to 16. When the `DataDisk.N.SnapshotId` parameter is specified, the `DataDisk.N.Size` parameter is ignored. The data disk is created based on the size of the specified snapshot.
        # 
        # Use snapshots created after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateLaunchTemplateRequestNetworkInterface(TeaModel):
    def __init__(self, description=None, instance_type=None, network_interface_name=None,
                 network_interface_traffic_mode=None, primary_ip_address=None, security_group_id=None, security_group_ids=None, v_switch_id=None):
        # The description of secondary ENI N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`. The value of N in `NetworkInterface.N` cannot be greater than 1.
        self.description = description  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The name of ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you can configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you do not need to set this parameter.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of primary ENI N. Valid values:
        # 
        # *   Standard: uses the TCP communication mode.
        # *   HighPerformance: enables the Elastic RDMA Interface (ERI) and uses the remote direct memory access (RDMA) communication mode.
        # 
        # Take note of the following items:
        # 
        # *   This parameter is valid only when `NetworkInterface.N.InstanceType` is set to `Primary`. If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, you cannot set this parameter.
        # *   If you set this parameter to HighPerformance, you can create instances only of the c7re RDMA-enhanced instance family. The maximum number of ENIs in RDMA mode that can be bound to a c7re instance is determined based on the instance type. The c7re instance family is in invitational preview in Beijing Zone K. For more information, see [Instance family](~~25378~~).
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The primary IP address to assign to ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2.
        # 
        #     *   If the value of N is 1, you can configure a primary or secondary ENI. If this parameter is specified, `Amount` is set to a numeric value greater than 1, and NetworkInterface.N.InstanceType is set to Primary, the specified number of instances are created and consecutive primary IP addresses starting from the specified one are assigned to the instances. In this case, you cannot bind secondary ENIs to these instances.
        #     *   If the value of N is 2, you can configure a primary ENI and a secondary ENI. If this parameter is specified, `Amount` is set to a numeric value greater than 1, and NetworkInterface.N.InstanceType is set to Primary, you cannot set `NetworkInterface.2.InstanceType` to Secondary to bind a secondary ENI.
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, this parameter is equivalent to `PrivateIpAddress` and you cannot specify `PrivateIpAddress`.
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, the specified primary IP address is assigned to the secondary ENI. The default value is an IP address that is randomly selected from within the CIDR block of the vSwitch with which to associate the secondary ENI.
        # 
        # >  You can bind only a single secondary ENI when you create an instance. After the instance is created, you can call the [CreateNetworkInterface](~~58504~~) and [AttachNetworkInterface](~~58515~~) operations to bind more secondary ENIs.
        self.primary_ip_address = primary_ip_address  # type: str
        # The ID of the security group to which to assign ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you can configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you must set this parameter. In this case, this parameter is equivalent to `SecurityGroupId` and you cannot specify `SecurityGroupId`, `SecurityGroupIds.N`, or `NetworkInterface.N.SecurityGroupIds.N`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, this parameter is optional. The default value is the ID of the security group to which to assign the ECS instance.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to which the ENI belongs.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The ID of the vSwitch with which to associate ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you can configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you must set this parameter. In this case, this parameter is equivalent to `VSwitchId` and you cannot specify `VSwitchId`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, this parameter is optional. The default value is the ID of the vSwitch to which to connect the ECS instance.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateRequestNetworkInterface, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateLaunchTemplateRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the instance, EBS device, or ENI. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N to add to the instance, EBS device, or ENI. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateLaunchTemplateRequestTemplateTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the launch template. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N to add to the launch template. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateRequestTemplateTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateLaunchTemplateRequest(TeaModel):
    def __init__(self, system_disk=None, auto_release_time=None, data_disk=None, deployment_set_id=None,
                 description=None, enable_vm_os_config=None, host_name=None, image_id=None, image_owner_alias=None,
                 instance_charge_type=None, instance_name=None, instance_type=None, internet_charge_type=None,
                 internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None, ipv_6address_count=None,
                 key_pair_name=None, launch_template_name=None, network_interface=None, network_type=None, owner_account=None,
                 owner_id=None, password_inherit=None, period=None, private_ip_address=None, ram_role_name=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 security_enhancement_strategy=None, security_group_id=None, security_group_ids=None, spot_duration=None, spot_price_limit=None,
                 spot_strategy=None, tag=None, template_resource_group_id=None, template_tag=None, user_data=None,
                 v_switch_id=None, version_description=None, vpc_id=None, zone_id=None):
        self.system_disk = system_disk  # type: CreateLaunchTemplateRequestSystemDisk
        # The automatic release time of the dedicated host. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   If the value of seconds (`ss`) is not `00`, the time is automatically rounded to the nearest minute based on the value of minutes (`mm`).
        # *   The specified time must be at least 30 minutes later than the current time.
        # *   The specified time must be at most three years from the current time.
        self.auto_release_time = auto_release_time  # type: str
        # The list of data disks.
        self.data_disk = data_disk  # type: list[CreateLaunchTemplateRequestDataDisk]
        # The ID of the deployment set to which to deploy the instance.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # Specifies whether to enable the operating system configuration of the instance.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.enable_vm_os_config = enable_vm_os_config  # type: bool
        # The hostname of the instance.
        # 
        # *   The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # *   For Windows instances, the hostname must be 2 to 15 characters in length and cannot contain periods (.) or contain only digits. It can contain letters, digits, and hyphens (-).
        # *   For instances that run other operating systems such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate the hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        self.host_name = host_name  # type: str
        # The ID of the image used to create the instance. You can call the [DescribeImages](~~25534~~) operation to query available images.
        self.image_id = image_id  # type: str
        # The source of the image. Valid values:
        # 
        # *   system: public images provided by Alibaba Cloud.
        # *   self: custom images that you create.
        # *   others: shared images from other Alibaba Cloud accounts.
        # *   marketplace: [Alibaba Cloud Marketplace](https://marketplace.alibabacloud.com/) images. If Alibaba Cloud Marketplace images are found, you can use these images without prior subscription. You must pay attention to the billing details of Alibaba Cloud Marketplace images.
        self.image_owner_alias = image_owner_alias  # type: str
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription. If you set this parameter to PrePaid, make sure that your account supports payment by credit. Otherwise, an `InvalidPayMethod` error is returned.
        # *   PostPaid: pay-as-you-go.
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.instance_name = instance_name  # type: str
        # The instance type of the instance. For more information, see [Instance families](~~25378~~). Alternatively, you can call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidths may be limited. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of InternetMaxBandwidthIn are 1 to 10, and the default value is 10.
        # *   When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the `InternetMaxBandwidthOut` value, and the default value is the `InternetMaxBandwidthOut` value.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # The number of IPv6 addresses to be randomly generated for the primary ENI. Valid values: 1 to 10.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # The name of the key pair.
        # 
        # *   For Windows instances, this parameter is ignored The `Password` parameter takes effect even if the KeyPairName parameter is specified.
        # *   For Linux instances, the password-based logon method is disabled by default.
        self.key_pair_name = key_pair_name  # type: str
        # The name of the launch template. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (.), underscores (\_), and hyphens (-).
        self.launch_template_name = launch_template_name  # type: str
        # The list of the ENIs.
        self.network_interface = network_interface  # type: list[CreateLaunchTemplateRequestNetworkInterface]
        # The network type of the instance. Valid values:
        # 
        # *   classic
        # *   vpc
        self.network_type = network_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Specifies whether to use the password preset in the image.
        # 
        # >  When you use this parameter, leave Password empty and make sure that the selected image has a password preset.
        self.password_inherit = password_inherit  # type: bool
        # The subscription period of the instance. Unit: months. This parameter is valid and required only when `InstanceChargeType` is set to `PrePaid`. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The private IP address to assign to the instance.
        # 
        # To assign a private IP address to an instance of the VPC type, make sure that the IP address is an idle IP address within the CIDR block of the vSwitch specified by the `VSwitchId` parameter.
        self.private_ip_address = private_ip_address  # type: str
        # The name of the instance RAM role. You can call the [ListRoles](~~28713~~) operation provided by Resource Access Management (RAM) to query the instance RAM roles that you created.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the region in which to create the launch template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the instance, Elastic Block Storage (EBS) device, and elastic network interface (ENI).
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to enable security hardening for the operating system. Valid values:
        # 
        # *   Active: enables security hardening. This value is applicable only to public images.
        # *   Deactive: does not enable security hardening. This value is applicable to all image types.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance. Instances in the same security group can communicate with each other. One security group can contain a maximum of 1,000 instances.
        # 
        # >  You cannot specify both the `SecurityGroupId` and `SecurityGroupIds.N` parameters.
        self.security_group_id = security_group_id  # type: str
        # The IDs of security groups to which to assign the instance. The valid values of N are based on the maximum number of security groups to which the instance can belong. For more information, see the "Security group limits" section in [Limits](~~25412~~).
        # 
        # >  You cannot specify both `SecurityGroupId` and `SecurityGroupIds`.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The maximum hourly price of the instance. The value is accurate to three decimal places. This parameter is valid only when the `SpotStrategy` parameter is set to `SpotWithPriceLimit`.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        self.spot_strategy = spot_strategy  # type: str
        # The list of the tags that you want to add.
        self.tag = tag  # type: list[CreateLaunchTemplateRequestTag]
        # The ID of the resource group to which to assign the launch template.
        self.template_resource_group_id = template_resource_group_id  # type: str
        # The tags of the launch template.
        self.template_tag = template_tag  # type: list[CreateLaunchTemplateRequestTemplateTag]
        # The user data of the instance. The user data must be encoded in Base64. The maximum size of raw data is 16 KB.
        self.user_data = user_data  # type: str
        # The ID of the vSwitch to which to connect the instance. This parameter is required if you specify the VpcId parameter.
        self.v_switch_id = v_switch_id  # type: str
        # The description of the launch template version. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.version_description = version_description  # type: str
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id  # type: str
        # The ID of the zone in which to create the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.network_interface:
            for k in self.network_interface:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()
        if self.template_tag:
            for k in self.template_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateLaunchTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_vm_os_config is not None:
            result['EnableVmOsConfig'] = self.enable_vm_os_config
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        result['NetworkInterface'] = []
        if self.network_interface is not None:
            for k in self.network_interface:
                result['NetworkInterface'].append(k.to_map() if k else None)
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.template_resource_group_id is not None:
            result['TemplateResourceGroupId'] = self.template_resource_group_id
        result['TemplateTag'] = []
        if self.template_tag is not None:
            for k in self.template_tag:
                result['TemplateTag'].append(k.to_map() if k else None)
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.version_description is not None:
            result['VersionDescription'] = self.version_description
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = CreateLaunchTemplateRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = CreateLaunchTemplateRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableVmOsConfig') is not None:
            self.enable_vm_os_config = m.get('EnableVmOsConfig')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        self.network_interface = []
        if m.get('NetworkInterface') is not None:
            for k in m.get('NetworkInterface'):
                temp_model = CreateLaunchTemplateRequestNetworkInterface()
                self.network_interface.append(temp_model.from_map(k))
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateLaunchTemplateRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('TemplateResourceGroupId') is not None:
            self.template_resource_group_id = m.get('TemplateResourceGroupId')
        self.template_tag = []
        if m.get('TemplateTag') is not None:
            for k in m.get('TemplateTag'):
                temp_model = CreateLaunchTemplateRequestTemplateTag()
                self.template_tag.append(temp_model.from_map(k))
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VersionDescription') is not None:
            self.version_description = m.get('VersionDescription')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateLaunchTemplateResponseBody(TeaModel):
    def __init__(self, launch_template_id=None, request_id=None):
        # The ID of the launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLaunchTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLaunchTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLaunchTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLaunchTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateLaunchTemplateVersionRequestSystemDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, disk_name=None, encrypted=None, iops=None, performance_level=None,
                 provisioned_iops=None, size=None):
        # The ID of the automatic snapshot policy to apply to the system disk.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # This parameter is unavailable.
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of the system disk. Valid values:
        # 
        # *   cloud: basic disk.
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: standard SSD.
        # *   cloud_essd: enhanced SSD (ESSD). You can use the `SystemDisk.PerformanceLevel` parameter to set the performance level of the ESSD used as the system disk.
        # 
        # For non-I/O optimized instances of retired instance types, the default value is cloud. For other instances, the default value is cloud_efficiency.
        self.category = category  # type: str
        # Specifies whether to release the system disk when the instance is released. Valid values:
        # 
        # *   true: releases the system disk when the instance is released.
        # *   false: does not release the system disk when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of the system disk. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The name of the system disk. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (.), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        self.encrypted = encrypted  # type: str
        self.iops = iops  # type: int
        # The performance level of the ESSD used as the system disk. Default value: PL0. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # This parameter is unavailable.
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of the system disk. Unit: GiB. Valid values: 20 to 500.
        # 
        # The value of this parameter must be at least 20 and greater than or equal to the image size.
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.iops is not None:
            result['Iops'] = self.iops
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('Iops') is not None:
            self.iops = m.get('Iops')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class CreateLaunchTemplateVersionRequestDataDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, device=None, disk_name=None, encrypted=None, performance_level=None,
                 provisioned_iops=None, size=None, snapshot_id=None):
        # The ID of the automatic snapshot policy to apply to data disk N.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of data disk N. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # 
        # For I/O optimized instances, the default value is cloud_efficiency. For non-I/O optimized instances, the default value is cloud.
        self.category = category  # type: str
        # Specifies whether to release data disk N when the instance is released. Valid values:
        # 
        # *   true: releases data disk N when the instance is released.
        # *   false: does not release data disk N when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of data disk N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # Specifies whether to encrypt data disk N.
        self.encrypted = encrypted  # type: str
        # The performance level of the ESSD used as data disk N. The value of N must be the same as that in `DataDisk.N.Category` when DataDisk.N.Category is set to cloud_essd. Default value: PL1. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of data disk N. Valid values of N: 1 to 16. Unit: GiB. Valid values:
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud: 5 to 2000.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_efficiency: 20 to 32768.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_ssd: 20 to 32768.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_essd: depend on the `DataDisk.N.PerformanceLevel` value.
        # 
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL0: 40 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL1: 20 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL2: 461 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL3: 1261 to 32768.
        # 
        # The value of this parameter must be greater than or equal to the size of the snapshot specified by the `SnapshotId` parameter.
        self.size = size  # type: int
        # The ID of the snapshot used to create data disk N. Valid values of N: 1 to 16. When the `DataDisk.N.SnapshotId` parameter is specified, the `DataDisk.N.Size` parameter is ignored. The data disk is created based on the size of the specified snapshot.
        # 
        # Use snapshots created after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateLaunchTemplateVersionRequestNetworkInterface(TeaModel):
    def __init__(self, description=None, instance_type=None, network_interface_name=None,
                 network_interface_traffic_mode=None, primary_ip_address=None, security_group_id=None, security_group_ids=None, v_switch_id=None):
        # The description of secondary ENI N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`. The value of N in `NetworkInterface.N` cannot be greater than 1.
        self.description = description  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The name of secondary ENI N. The value of N in `NetworkInterface.N` cannot be greater than 1.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of primary ENI N. Valid values:
        # 
        # *   Standard: uses the TCP communication mode.
        # *   HighPerformance: enables the Elastic RDMA Interface (ERI) and uses the remote direct memory access (RDMA) communication mode.
        # 
        # Take note of the following items:
        # 
        # *   This parameter is valid only when `NetworkInterface.N.InstanceType` is set to `Primary`. If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, you cannot set this parameter.
        # *   If you set this parameter to HighPerformance, you can create instances only of the c7re RDMA-enhanced instance family. The maximum number of ENIs in RDMA mode that can be bound to a c7re instance is determined based on the instance type. The c7re instance family is in invitational preview in Beijing Zone K. For more information, see [Instance family](~~25378~~).
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The primary private IP address of secondary ENI N. The value of N in `NetworkInterface.N` cannot be greater than 1.
        self.primary_ip_address = primary_ip_address  # type: str
        # The ID of the security group to which to assign secondary ENI N. The security groups of secondary ENI N and of the instance must belong to the same VPC. The value of N in `NetworkInterface.N` cannot be greater than 1.
        # 
        # >  You cannot specify both the `NetworkInterface.N.SecurityGroupId` and `NetworkInterface.N.SecurityGroupIds.N` parameters.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to which the ENI belongs.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The ID of the vSwitch to which to connect secondary ENI N. The instance and the ENI must be located within the same zone of the same VPC, but they can be connected to different vSwitches. The value of N in `NetworkInterface.N` cannot be greater than 1.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionRequestNetworkInterface, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateLaunchTemplateVersionRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the instance, Elastic Block Storage (EBS) devices, or primary ENI. Valid values of N: 1 to 5. The tag key cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the instance, EBS devices, or primary ENI. Valid values of N: 1 to 5. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateLaunchTemplateVersionRequest(TeaModel):
    def __init__(self, system_disk=None, auto_release_time=None, data_disk=None, deployment_set_id=None,
                 description=None, enable_vm_os_config=None, host_name=None, image_id=None, image_owner_alias=None,
                 instance_charge_type=None, instance_name=None, instance_type=None, internet_charge_type=None,
                 internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None, ipv_6address_count=None,
                 key_pair_name=None, launch_template_id=None, launch_template_name=None, network_interface=None,
                 network_type=None, owner_account=None, owner_id=None, password_inherit=None, period=None,
                 private_ip_address=None, ram_role_name=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_enhancement_strategy=None, security_group_id=None, security_group_ids=None,
                 spot_duration=None, spot_price_limit=None, spot_strategy=None, tag=None, user_data=None, v_switch_id=None,
                 version_description=None, vpc_id=None, zone_id=None):
        self.system_disk = system_disk  # type: CreateLaunchTemplateVersionRequestSystemDisk
        # The automatic release time of the instance. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   If the value of seconds (`ss`) is not `00`, the time is automatically rounded to the nearest minute based on the value of minutes (`mm`).
        # *   The specified time must be at least 30 minutes later than the current time.
        # *   The specified time must be at most three years from the current time.
        self.auto_release_time = auto_release_time  # type: str
        # The list of data disks.
        self.data_disk = data_disk  # type: list[CreateLaunchTemplateVersionRequestDataDisk]
        # The ID of the deployment set.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # Specifies whether to enable the operating system configuration of the instance.
        self.enable_vm_os_config = enable_vm_os_config  # type: bool
        # The hostname of the instance.
        # 
        # *   The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # *   For Windows instances, the hostname must be 2 to 15 characters in length and cannot contain periods (.) or contain only digits. It can contain letters, digits, and hyphens (-).
        # *   For instances that run other operating systems such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate the hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        self.host_name = host_name  # type: str
        # The ID of the image to use to create the Elastic Compute Service (ECS) instance. You can call the [DescribeImages](~~25534~~) operation to query available images.
        self.image_id = image_id  # type: str
        # The source of the image.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.image_owner_alias = image_owner_alias  # type: str
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription. If you set this parameter to PrePaid, make sure that your account supports payment by credit. Otherwise, an `InvalidPayMethod` error is returned.
        # *   PostPaid: pay-as-you-go.
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.instance_name = instance_name  # type: str
        # The instance type. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidths may be limited. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   If the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of InternetMaxBandwidthIn are 1 to 10, and the default value is 10.
        # *   If the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the `InternetMaxBandwidthOut` value, and the default value is the `InternetMaxBandwidthOut` value.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # The number of IPv6 addresses to be randomly generated for the primary elastic network interface (ENI). Valid values: 1 to 10.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # The name of the key pair.
        # 
        # *   For Windows instances, this parameter is ignored. The `Password` parameter takes effect even if the KeyPairName parameter is specified.
        # *   For Linux instances, the password-based logon method is disabled by default.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the launch template. For more information, see [DescribeLaunchTemplates](~~73759~~). You must specify `LaunchTemplateId` or `LaunchTemplateName` to determine a launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.launch_template_name = launch_template_name  # type: str
        self.network_interface = network_interface  # type: list[CreateLaunchTemplateVersionRequestNetworkInterface]
        # The network type of the instance. Valid values:
        # 
        # *   classic: classic network
        # *   vpc: VPC
        self.network_type = network_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Specifies whether to use the password preset in the image.
        # 
        # >  When you use this parameter, leave Password empty and make sure that the selected image has a password preset.
        self.password_inherit = password_inherit  # type: bool
        # The subscription period of the instance. Unit: months. This parameter is valid and required only when `InstanceChargeType` is set to `PrePaid`. Valid values: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The private IP address of the instance.
        # 
        # To assign a private IP address to an instance of the VPC type, make sure that the IP address is an idle IP address within the CIDR block of the vSwitch specified by the `VSwitchId` parameter.
        self.private_ip_address = private_ip_address  # type: str
        # The name of the instance Resource Access Management (RAM) role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created.
        self.ram_role_name = ram_role_name  # type: str
        # The region ID of the launch template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to enable security hardening for the operating system. Valid values:
        # 
        # *   Active: enables security hardening. This value is applicable only to public images.
        # *   Deactive: disables security hardening. This value is applicable to all image types.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance. Instances within the same security group can access each other.
        # 
        # >  You cannot specify both `SecurityGroupId` and `SecurityGroupIds.N`.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to assign the instance.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The maximum hourly price of the instance. A maximum of three decimal places are allowed.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        self.spot_strategy = spot_strategy  # type: str
        # The tags.
        self.tag = tag  # type: list[CreateLaunchTemplateVersionRequestTag]
        # The user data of the instance. The user data must be encoded in Base64. The maximum size of raw data is 16 KB.
        self.user_data = user_data  # type: str
        # The ID of the vSwitch to which to connect the instance. This parameter is required if you specify the VpcId parameter.
        self.v_switch_id = v_switch_id  # type: str
        # The description of the launch template version. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.version_description = version_description  # type: str
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id  # type: str
        # The ID of the zone in which to create the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.network_interface:
            for k in self.network_interface:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_vm_os_config is not None:
            result['EnableVmOsConfig'] = self.enable_vm_os_config
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        result['NetworkInterface'] = []
        if self.network_interface is not None:
            for k in self.network_interface:
                result['NetworkInterface'].append(k.to_map() if k else None)
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.version_description is not None:
            result['VersionDescription'] = self.version_description
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = CreateLaunchTemplateVersionRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = CreateLaunchTemplateVersionRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableVmOsConfig') is not None:
            self.enable_vm_os_config = m.get('EnableVmOsConfig')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        self.network_interface = []
        if m.get('NetworkInterface') is not None:
            for k in m.get('NetworkInterface'):
                temp_model = CreateLaunchTemplateVersionRequestNetworkInterface()
                self.network_interface.append(temp_model.from_map(k))
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateLaunchTemplateVersionRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VersionDescription') is not None:
            self.version_description = m.get('VersionDescription')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateLaunchTemplateVersionResponseBody(TeaModel):
    def __init__(self, launch_template_version_number=None, request_id=None):
        # The version number of the launch template.
        self.launch_template_version_number = launch_template_version_number  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_version_number is not None:
            result['LaunchTemplateVersionNumber'] = self.launch_template_version_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateVersionNumber') is not None:
            self.launch_template_version_number = m.get('LaunchTemplateVersionNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateLaunchTemplateVersionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateLaunchTemplateVersionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateLaunchTemplateVersionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateLaunchTemplateVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNatGatewayRequestBandwidthPackage(TeaModel):
    def __init__(self, bandwidth=None, ip_count=None, zone=None):
        self.bandwidth = bandwidth  # type: int
        self.ip_count = ip_count  # type: int
        self.zone = zone  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNatGatewayRequestBandwidthPackage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.zone is not None:
            result['Zone'] = self.zone
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('Zone') is not None:
            self.zone = m.get('Zone')
        return self


class CreateNatGatewayRequest(TeaModel):
    def __init__(self, bandwidth_package=None, client_token=None, description=None, name=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, vpc_id=None):
        self.bandwidth_package = bandwidth_package  # type: list[CreateNatGatewayRequestBandwidthPackage]
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.bandwidth_package:
            for k in self.bandwidth_package:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNatGatewayRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandwidthPackage'] = []
        if self.bandwidth_package is not None:
            for k in self.bandwidth_package:
                result['BandwidthPackage'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bandwidth_package = []
        if m.get('BandwidthPackage') is not None:
            for k in m.get('BandwidthPackage'):
                temp_model = CreateNatGatewayRequestBandwidthPackage()
                self.bandwidth_package.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateNatGatewayResponseBodyBandwidthPackageIds(TeaModel):
    def __init__(self, bandwidth_package_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNatGatewayResponseBodyBandwidthPackageIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        return self


class CreateNatGatewayResponseBodyForwardTableIds(TeaModel):
    def __init__(self, forward_table_id=None):
        self.forward_table_id = forward_table_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNatGatewayResponseBodyForwardTableIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        return self


class CreateNatGatewayResponseBody(TeaModel):
    def __init__(self, bandwidth_package_ids=None, forward_table_ids=None, nat_gateway_id=None, request_id=None):
        self.bandwidth_package_ids = bandwidth_package_ids  # type: CreateNatGatewayResponseBodyBandwidthPackageIds
        self.forward_table_ids = forward_table_ids  # type: CreateNatGatewayResponseBodyForwardTableIds
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        if self.bandwidth_package_ids:
            self.bandwidth_package_ids.validate()
        if self.forward_table_ids:
            self.forward_table_ids.validate()

    def to_map(self):
        _map = super(CreateNatGatewayResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_ids is not None:
            result['BandwidthPackageIds'] = self.bandwidth_package_ids.to_map()
        if self.forward_table_ids is not None:
            result['ForwardTableIds'] = self.forward_table_ids.to_map()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageIds') is not None:
            temp_model = CreateNatGatewayResponseBodyBandwidthPackageIds()
            self.bandwidth_package_ids = temp_model.from_map(m['BandwidthPackageIds'])
        if m.get('ForwardTableIds') is not None:
            temp_model = CreateNatGatewayResponseBodyForwardTableIds()
            self.forward_table_ids = temp_model.from_map(m['ForwardTableIds'])
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNatGatewayResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateNatGatewayResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateNatGatewayResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNatGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkInterfaceRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the ENI. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N to add to the ENI. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateNetworkInterfaceRequest(TeaModel):
    def __init__(self, business_type=None, client_token=None, description=None, instance_type=None,
                 ipv_4prefix=None, ipv_4prefix_count=None, ipv_6address=None, ipv_6address_count=None, ipv_6prefix=None,
                 ipv_6prefix_count=None, network_interface_name=None, network_interface_traffic_mode=None, owner_account=None,
                 owner_id=None, primary_ip_address=None, private_ip_address=None, queue_number=None, queue_pair_number=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 secondary_private_ip_address_count=None, security_group_id=None, security_group_ids=None, tag=None, v_switch_id=None, visible=None):
        # > This parameter is no longer used.
        self.business_type = business_type  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the ENI. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # > This parameter is no longer used.
        self.instance_type = instance_type  # type: str
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_4prefix = ipv_4prefix  # type: list[str]
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_4prefix_count = ipv_4prefix_count  # type: int
        # IPv6 address N to assign to the ENI. Valid values of N: 1 to 10.
        # 
        # Example: Ipv6Address.1=2001:db8:1234:1a00::\*\*\*\*\
        # 
        # > To assign IPv6 addresses to the ENI, you must specify `Ipv6Addresses.N` or `Ipv6AddressCount` but not both.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The number of IPv6 addresses to randomly generate for the ENI. Valid values: 1 to 10.
        # 
        # > To assign IPv6 addresses to the ENI, you must specify `Ipv6Addresses.N` or `Ipv6AddressCount` but not both.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix = ipv_6prefix  # type: list[str]
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix_count = ipv_6prefix_count  # type: int
        # The name of the ENI. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of the ENI. Valid values:
        # 
        # *   Standard: uses the TCP communication mode.
        # *   HighPerformance: enables Elastic RDMA Interface (ERI) and uses the remote direct memory access (RDMA) communication mode.
        # 
        # > HighPerformance supports only the c7re RDMA-enhanced instance family. The maximum number of ENIs in RDMA mode that can be attached to a c7re instance is determined based on the instance type. The c7re instance family is in invitational preview in Beijing Zone K. For more information, see [Instance families](~~25378~~).
        # 
        # Default value: Standard.
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The primary private IP address of the ENI.
        # 
        # The specified IP address must be an idle IP address within the CIDR block of the vSwitch with which to associate the ENI. If this parameter is not specified, an idle IP address is assigned from within the CIDR block of the vSwitch at random.
        self.primary_ip_address = primary_ip_address  # type: str
        # Secondary private IP address N to assign to the ENI. The IP address must be an idle IP address within the CIDR block of the vSwitch with which to associate the ENI. Valid values of N: 0 to 10.
        # 
        # > To assign secondary private IP addresses to the ENI, you cannot specify the `PrivateIpAddress.N` and `SecondaryPrivateIpAddressCount` parameters at the same time.
        self.private_ip_address = private_ip_address  # type: list[str]
        # The number of queues supported by the ENI. Valid values: 1 to 2048.
        # 
        # When you attach an ENI to an instance, make sure that the value of this parameter for the ENI is smaller than the maximum number of queues per ENI allowed for the instance type. To view the maximum number of queues per ENI allowed for an instance type, you can call the [DescribeInstanceTypes](~~25620~~) operation and then check the `MaximumQueueNumberPerEni` response parameter.
        # 
        # This parameter is empty by default. If you do not specify this parameter, the default number of queues per ENI for the instance type of an instance is used when you attach the ENI to the instance. To view the default number of queues per ENI for an instance type, you can call the [DescribeInstanceTypes](~~25620~~) operation and then check the `SecondaryEniQueueNumber` response parameter.
        self.queue_number = queue_number  # type: int
        # > This parameter is in invitational preview and is unavailable to general users.
        self.queue_pair_number = queue_pair_number  # type: int
        # The ID of the region in which to create the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the ENI. You can call the [ListResourceGroups](~~158855~~) operation to query the most recent resource group list.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The number of private IP addresses to be automatically created by ECS.
        self.secondary_private_ip_address_count = secondary_private_ip_address_count  # type: int
        # The ID of the security group to which to assign the ENI. The security group and the ENI must belong to the same VPC.
        # 
        # > You must specify `SecurityGroupId` or `SecurityGroupIds.N` but not both.
        self.security_group_id = security_group_id  # type: str
        # The ID of security group N to which to assign the ENI. The security group and the ENI must belong to the same VPC. The valid values of N are determined based on the maximum number of security groups to which an ENI can be assigned. For more information, see [Limits](~~25412~~).
        # 
        # > You must specify `SecurityGroupId` or `SecurityGroupIds.N` but not both.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The tags to add to the ENI.
        self.tag = tag  # type: list[CreateNetworkInterfaceRequestTag]
        # The ID of the vSwitch with which to associate the ENI. Private IP addresses are assigned to the ENI from within the CIDR block of the vSwitch.
        self.v_switch_id = v_switch_id  # type: str
        # > This parameter is no longer used.
        self.visible = visible  # type: bool

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.business_type is not None:
            result['BusinessType'] = self.business_type
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        if self.ipv_4prefix_count is not None:
            result['Ipv4PrefixCount'] = self.ipv_4prefix_count
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        if self.ipv_6prefix_count is not None:
            result['Ipv6PrefixCount'] = self.ipv_6prefix_count
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.queue_number is not None:
            result['QueueNumber'] = self.queue_number
        if self.queue_pair_number is not None:
            result['QueuePairNumber'] = self.queue_pair_number
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.secondary_private_ip_address_count is not None:
            result['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.visible is not None:
            result['Visible'] = self.visible
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BusinessType') is not None:
            self.business_type = m.get('BusinessType')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        if m.get('Ipv4PrefixCount') is not None:
            self.ipv_4prefix_count = m.get('Ipv4PrefixCount')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        if m.get('Ipv6PrefixCount') is not None:
            self.ipv_6prefix_count = m.get('Ipv6PrefixCount')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('QueueNumber') is not None:
            self.queue_number = m.get('QueueNumber')
        if m.get('QueuePairNumber') is not None:
            self.queue_pair_number = m.get('QueuePairNumber')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecondaryPrivateIpAddressCount') is not None:
            self.secondary_private_ip_address_count = m.get('SecondaryPrivateIpAddressCount')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateNetworkInterfaceRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('Visible') is not None:
            self.visible = m.get('Visible')
        return self


class CreateNetworkInterfaceResponseBodyIpv4PrefixSetsIpv4PrefixSet(TeaModel):
    def __init__(self, ipv_4prefix=None):
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_4prefix = ipv_4prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv4PrefixSetsIpv4PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        return self


class CreateNetworkInterfaceResponseBodyIpv4PrefixSets(TeaModel):
    def __init__(self, ipv_4prefix_set=None):
        self.ipv_4prefix_set = ipv_4prefix_set  # type: list[CreateNetworkInterfaceResponseBodyIpv4PrefixSetsIpv4PrefixSet]

    def validate(self):
        if self.ipv_4prefix_set:
            for k in self.ipv_4prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv4PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4PrefixSet'] = []
        if self.ipv_4prefix_set is not None:
            for k in self.ipv_4prefix_set:
                result['Ipv4PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_4prefix_set = []
        if m.get('Ipv4PrefixSet') is not None:
            for k in m.get('Ipv4PrefixSet'):
                temp_model = CreateNetworkInterfaceResponseBodyIpv4PrefixSetsIpv4PrefixSet()
                self.ipv_4prefix_set.append(temp_model.from_map(k))
        return self


class CreateNetworkInterfaceResponseBodyIpv6PrefixSetsIpv6PrefixSet(TeaModel):
    def __init__(self, ipv_6prefix=None):
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix = ipv_6prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv6PrefixSetsIpv6PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        return self


class CreateNetworkInterfaceResponseBodyIpv6PrefixSets(TeaModel):
    def __init__(self, ipv_6prefix_set=None):
        self.ipv_6prefix_set = ipv_6prefix_set  # type: list[CreateNetworkInterfaceResponseBodyIpv6PrefixSetsIpv6PrefixSet]

    def validate(self):
        if self.ipv_6prefix_set:
            for k in self.ipv_6prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv6PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6PrefixSet'] = []
        if self.ipv_6prefix_set is not None:
            for k in self.ipv_6prefix_set:
                result['Ipv6PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6prefix_set = []
        if m.get('Ipv6PrefixSet') is not None:
            for k in m.get('Ipv6PrefixSet'):
                temp_model = CreateNetworkInterfaceResponseBodyIpv6PrefixSetsIpv6PrefixSet()
                self.ipv_6prefix_set.append(temp_model.from_map(k))
        return self


class CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set(TeaModel):
    def __init__(self, ipv_6address=None):
        # The IPv6 address of the ENI.
        self.ipv_6address = ipv_6address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class CreateNetworkInterfaceResponseBodyIpv6Sets(TeaModel):
    def __init__(self, ipv_6set=None):
        self.ipv_6set = ipv_6set  # type: list[CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set]

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyIpv6Sets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = CreateNetworkInterfaceResponseBodyIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(self, primary=None, private_ip_address=None):
        # Indicates whether the IP address is the primary private IP address.
        self.primary = primary  # type: bool
        # The private IP address of the ENI.
        self.private_ip_address = private_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class CreateNetworkInterfaceResponseBodyPrivateIpSets(TeaModel):
    def __init__(self, private_ip_set=None):
        self.private_ip_set = private_ip_set  # type: list[CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet]

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyPrivateIpSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = CreateNetworkInterfaceResponseBodyPrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class CreateNetworkInterfaceResponseBodySecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodySecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class CreateNetworkInterfaceResponseBodyTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the ENI.
        self.tag_key = tag_key  # type: str
        # The tag value of the ENI.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class CreateNetworkInterfaceResponseBodyTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[CreateNetworkInterfaceResponseBodyTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBodyTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateNetworkInterfaceResponseBodyTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateNetworkInterfaceResponseBody(TeaModel):
    def __init__(self, description=None, ipv_4prefix_sets=None, ipv_6prefix_sets=None, ipv_6sets=None,
                 mac_address=None, network_interface_id=None, network_interface_name=None, owner_id=None,
                 private_ip_address=None, private_ip_sets=None, request_id=None, resource_group_id=None, security_group_ids=None,
                 service_id=None, service_managed=None, status=None, tags=None, type=None, v_switch_id=None, vpc_id=None,
                 zone_id=None):
        # The description of the ENI.
        self.description = description  # type: str
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_4prefix_sets = ipv_4prefix_sets  # type: CreateNetworkInterfaceResponseBodyIpv4PrefixSets
        # > 该参数正在邀测中，暂未开放使用。
        self.ipv_6prefix_sets = ipv_6prefix_sets  # type: CreateNetworkInterfaceResponseBodyIpv6PrefixSets
        # The IPv6 addresses of the ENI.
        self.ipv_6sets = ipv_6sets  # type: CreateNetworkInterfaceResponseBodyIpv6Sets
        # The media access control (MAC) address of the ENI.
        self.mac_address = mac_address  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The name of the ENI.
        self.network_interface_name = network_interface_name  # type: str
        # The ID of the account to which the ENI belongs.
        self.owner_id = owner_id  # type: str
        # The private IP address of the ENI.
        self.private_ip_address = private_ip_address  # type: str
        # Details about the private IP addresses.
        self.private_ip_sets = private_ip_sets  # type: CreateNetworkInterfaceResponseBodyPrivateIpSets
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the resource group to which the ENI belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The IDs of the security groups to which the ENI belongs.
        self.security_group_ids = security_group_ids  # type: CreateNetworkInterfaceResponseBodySecurityGroupIds
        # The ID of the distributor to which the ENI belongs.
        self.service_id = service_id  # type: long
        # Indicates whether the user of the ENI is an Alibaba Cloud service or a distributor.
        self.service_managed = service_managed  # type: bool
        # The state of the ENI.
        self.status = status  # type: str
        # The tags of the ENI.
        self.tags = tags  # type: CreateNetworkInterfaceResponseBodyTags
        # The type of the ENI.
        self.type = type  # type: str
        # The ID of the vSwitch with which the ENI is associated.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the VPC to which the ENI belongs.
        self.vpc_id = vpc_id  # type: str
        # The zone ID of the ENI.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.ipv_4prefix_sets:
            self.ipv_4prefix_sets.validate()
        if self.ipv_6prefix_sets:
            self.ipv_6prefix_sets.validate()
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.ipv_4prefix_sets is not None:
            result['Ipv4PrefixSets'] = self.ipv_4prefix_sets.to_map()
        if self.ipv_6prefix_sets is not None:
            result['Ipv6PrefixSets'] = self.ipv_6prefix_sets.to_map()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.service_id is not None:
            result['ServiceID'] = self.service_id
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Ipv4PrefixSets') is not None:
            temp_model = CreateNetworkInterfaceResponseBodyIpv4PrefixSets()
            self.ipv_4prefix_sets = temp_model.from_map(m['Ipv4PrefixSets'])
        if m.get('Ipv6PrefixSets') is not None:
            temp_model = CreateNetworkInterfaceResponseBodyIpv6PrefixSets()
            self.ipv_6prefix_sets = temp_model.from_map(m['Ipv6PrefixSets'])
        if m.get('Ipv6Sets') is not None:
            temp_model = CreateNetworkInterfaceResponseBodyIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PrivateIpSets') is not None:
            temp_model = CreateNetworkInterfaceResponseBodyPrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = CreateNetworkInterfaceResponseBodySecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('ServiceID') is not None:
            self.service_id = m.get('ServiceID')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = CreateNetworkInterfaceResponseBodyTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateNetworkInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateNetworkInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkInterfacePermissionRequest(TeaModel):
    def __init__(self, account_id=None, network_interface_id=None, owner_account=None, owner_id=None,
                 permission=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the Alibaba Cloud partner (a certified ISV) or individual user.
        self.account_id = account_id  # type: long
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The permission on the ENI. Set the value to InstanceAttach.
        # 
        # InstanceAttach: allows authorized users to attach the ENI to an ECS instance. The ENI and the ECS instance must reside in the same zone.
        self.permission = permission  # type: str
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfacePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.permission is not None:
            result['Permission'] = self.permission
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Permission') is not None:
            self.permission = m.get('Permission')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission(TeaModel):
    def __init__(self, account_id=None, network_interface_id=None, network_interface_permission_id=None,
                 permission=None, permission_state=None, service_name=None):
        # The ID of the Alibaba Cloud partner (a certified ISV).
        self.account_id = account_id  # type: long
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The ID of the permission on the ENI.
        self.network_interface_permission_id = network_interface_permission_id  # type: str
        # The permission on the ENI.
        self.permission = permission  # type: str
        # The state of the permission on the ENI. Valid values:
        # 
        # *   Pending: The permission is being granted.
        # *   Granted: The permission is granted.
        # *   Revoking: The permission is being revoked.
        # *   Revoked: The permission is revoked.
        self.permission_state = permission_state  # type: str
        # The name of the Alibaba Cloud service.
        self.service_name = service_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_permission_id is not None:
            result['NetworkInterfacePermissionId'] = self.network_interface_permission_id
        if self.permission is not None:
            result['Permission'] = self.permission
        if self.permission_state is not None:
            result['PermissionState'] = self.permission_state
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfacePermissionId') is not None:
            self.network_interface_permission_id = m.get('NetworkInterfacePermissionId')
        if m.get('Permission') is not None:
            self.permission = m.get('Permission')
        if m.get('PermissionState') is not None:
            self.permission_state = m.get('PermissionState')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class CreateNetworkInterfacePermissionResponseBody(TeaModel):
    def __init__(self, network_interface_permission=None, request_id=None):
        # Details about permissions on ENIs.
        self.network_interface_permission = network_interface_permission  # type: CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.network_interface_permission:
            self.network_interface_permission.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfacePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_permission is not None:
            result['NetworkInterfacePermission'] = self.network_interface_permission.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkInterfacePermission') is not None:
            temp_model = CreateNetworkInterfacePermissionResponseBodyNetworkInterfacePermission()
            self.network_interface_permission = temp_model.from_map(m['NetworkInterfacePermission'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkInterfacePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateNetworkInterfacePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateNetworkInterfacePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkInterfacePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePhysicalConnectionRequest(TeaModel):
    def __init__(self, access_point_id=None, circuit_code=None, client_token=None, description=None,
                 line_operator=None, name=None, owner_account=None, owner_id=None, peer_location=None, port_type=None,
                 redundant_physical_connection_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, type=None,
                 user_cidr=None, bandwidth=None):
        self.access_point_id = access_point_id  # type: str
        self.circuit_code = circuit_code  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.line_operator = line_operator  # type: str
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.peer_location = peer_location  # type: str
        self.port_type = port_type  # type: str
        self.redundant_physical_connection_id = redundant_physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.type = type  # type: str
        self.user_cidr = user_cidr  # type: str
        self.bandwidth = bandwidth  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.line_operator is not None:
            result['LineOperator'] = self.line_operator
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.peer_location is not None:
            result['PeerLocation'] = self.peer_location
        if self.port_type is not None:
            result['PortType'] = self.port_type
        if self.redundant_physical_connection_id is not None:
            result['RedundantPhysicalConnectionId'] = self.redundant_physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.type is not None:
            result['Type'] = self.type
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.bandwidth is not None:
            result['bandwidth'] = self.bandwidth
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LineOperator') is not None:
            self.line_operator = m.get('LineOperator')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeerLocation') is not None:
            self.peer_location = m.get('PeerLocation')
        if m.get('PortType') is not None:
            self.port_type = m.get('PortType')
        if m.get('RedundantPhysicalConnectionId') is not None:
            self.redundant_physical_connection_id = m.get('RedundantPhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('bandwidth') is not None:
            self.bandwidth = m.get('bandwidth')
        return self


class CreatePhysicalConnectionResponseBody(TeaModel):
    def __init__(self, physical_connection_id=None, request_id=None):
        self.physical_connection_id = physical_connection_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreatePhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreatePhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePrefixListRequestEntry(TeaModel):
    def __init__(self, cidr=None, description=None):
        # The CIDR block in entry N. Valid values of N: 0 to 200. Take note of the following items:
        # 
        # *   The total number of entries must not exceed the `MaxEntries` value.
        # *   CIDR block types are determined by the IP address family. You cannot combine IPv4 and IPv6 CIDR blocks in a single prefix list.
        # *   CIDR blocks must be unique across all entries in a prefix list. For example, you cannot specify 192.168.1.0/24 twice in the entries of the prefix list.
        # *   IP addresses are supported. The system converts IP addresses into CIDR blocks. For example, if you specify 192.168.1.100, the system converts it into the 192.168.1.100/32 CIDR block.
        # *   If an IPv6 CIDR block is used, the system converts it to the zero compression format and changes uppercase letters into lowercase ones. For example, if you specify 2001:0DB8:0000:0000:0000:0000:0000:0000/32, the system converts it into 2001:db8::/32.
        # 
        # For more information about CIDR blocks, see the "What is CIDR block?" section of the [Network FAQ](https://www.alibabacloud.com/help/doc-detail/40637.htm#title-gu4-uzk-12r) topic.
        # 
        # This parameter is empty by default.
        self.cidr = cidr  # type: str
        # The description in entry N. The description must be 2 to 32 characters in length and cannot start with `http://` or `https://`. Valid values of N: 0 to 200.
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePrefixListRequestEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr is not None:
            result['Cidr'] = self.cidr
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cidr') is not None:
            self.cidr = m.get('Cidr')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class CreatePrefixListRequest(TeaModel):
    def __init__(self, address_family=None, client_token=None, description=None, entry=None, max_entries=None,
                 owner_account=None, owner_id=None, prefix_list_name=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The IP address family. Valid values:
        # 
        # *   IPv4
        # *   IPv6
        self.address_family = address_family  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The `ClientToken` value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the prefix list. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # 前缀列表条目信息。
        self.entry = entry  # type: list[CreatePrefixListRequestEntry]
        # The maximum number of entries that the prefix list can contain. Valid values: 1 to 200.
        self.max_entries = max_entries  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The name of the prefix list. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://`, `https://`, `com.aliyun`, or `com.alibabacloud`. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
        self.prefix_list_name = prefix_list_name  # type: str
        # The ID of the region in which to create the prefix list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.entry:
            for k in self.entry:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreatePrefixListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_family is not None:
            result['AddressFamily'] = self.address_family
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        result['Entry'] = []
        if self.entry is not None:
            for k in self.entry:
                result['Entry'].append(k.to_map() if k else None)
        if self.max_entries is not None:
            result['MaxEntries'] = self.max_entries
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_name is not None:
            result['PrefixListName'] = self.prefix_list_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddressFamily') is not None:
            self.address_family = m.get('AddressFamily')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.entry = []
        if m.get('Entry') is not None:
            for k in m.get('Entry'):
                temp_model = CreatePrefixListRequestEntry()
                self.entry.append(temp_model.from_map(k))
        if m.get('MaxEntries') is not None:
            self.max_entries = m.get('MaxEntries')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListName') is not None:
            self.prefix_list_name = m.get('PrefixListName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreatePrefixListResponseBody(TeaModel):
    def __init__(self, prefix_list_id=None, request_id=None):
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePrefixListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePrefixListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreatePrefixListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreatePrefixListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePrefixListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRouteEntryRequestNextHopList(TeaModel):
    def __init__(self, next_hop_id=None, next_hop_type=None):
        self.next_hop_id = next_hop_id  # type: str
        self.next_hop_type = next_hop_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRouteEntryRequestNextHopList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        return self


class CreateRouteEntryRequest(TeaModel):
    def __init__(self, client_token=None, destination_cidr_block=None, next_hop_id=None, next_hop_list=None,
                 next_hop_type=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, route_table_id=None):
        self.client_token = client_token  # type: str
        self.destination_cidr_block = destination_cidr_block  # type: str
        self.next_hop_id = next_hop_id  # type: str
        self.next_hop_list = next_hop_list  # type: list[CreateRouteEntryRequestNextHopList]
        self.next_hop_type = next_hop_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.route_table_id = route_table_id  # type: str

    def validate(self):
        if self.next_hop_list:
            for k in self.next_hop_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateRouteEntryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        result['NextHopList'] = []
        if self.next_hop_list is not None:
            for k in self.next_hop_list:
                result['NextHopList'].append(k.to_map() if k else None)
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        self.next_hop_list = []
        if m.get('NextHopList') is not None:
            for k in m.get('NextHopList'):
                temp_model = CreateRouteEntryRequestNextHopList()
                self.next_hop_list.append(temp_model.from_map(k))
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class CreateRouteEntryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRouteEntryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRouteEntryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateRouteEntryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateRouteEntryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRouteEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRouterInterfaceRequest(TeaModel):
    def __init__(self, access_point_id=None, auto_pay=None, client_token=None, description=None,
                 health_check_source_ip=None, health_check_target_ip=None, instance_charge_type=None, name=None,
                 opposite_access_point_id=None, opposite_interface_id=None, opposite_interface_owner_id=None, opposite_region_id=None,
                 opposite_router_id=None, opposite_router_type=None, owner_account=None, owner_id=None, period=None,
                 pricing_cycle=None, region_id=None, resource_owner_account=None, resource_owner_id=None, role=None,
                 router_id=None, router_type=None, spec=None, user_cidr=None):
        self.access_point_id = access_point_id  # type: str
        self.auto_pay = auto_pay  # type: bool
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.health_check_source_ip = health_check_source_ip  # type: str
        self.health_check_target_ip = health_check_target_ip  # type: str
        self.instance_charge_type = instance_charge_type  # type: str
        self.name = name  # type: str
        self.opposite_access_point_id = opposite_access_point_id  # type: str
        self.opposite_interface_id = opposite_interface_id  # type: str
        self.opposite_interface_owner_id = opposite_interface_owner_id  # type: str
        self.opposite_region_id = opposite_region_id  # type: str
        self.opposite_router_id = opposite_router_id  # type: str
        self.opposite_router_type = opposite_router_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.period = period  # type: int
        self.pricing_cycle = pricing_cycle  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.role = role  # type: str
        self.router_id = router_id  # type: str
        self.router_type = router_type  # type: str
        self.spec = spec  # type: str
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRouterInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.health_check_source_ip is not None:
            result['HealthCheckSourceIp'] = self.health_check_source_ip
        if self.health_check_target_ip is not None:
            result['HealthCheckTargetIp'] = self.health_check_target_ip
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.name is not None:
            result['Name'] = self.name
        if self.opposite_access_point_id is not None:
            result['OppositeAccessPointId'] = self.opposite_access_point_id
        if self.opposite_interface_id is not None:
            result['OppositeInterfaceId'] = self.opposite_interface_id
        if self.opposite_interface_owner_id is not None:
            result['OppositeInterfaceOwnerId'] = self.opposite_interface_owner_id
        if self.opposite_region_id is not None:
            result['OppositeRegionId'] = self.opposite_region_id
        if self.opposite_router_id is not None:
            result['OppositeRouterId'] = self.opposite_router_id
        if self.opposite_router_type is not None:
            result['OppositeRouterType'] = self.opposite_router_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.pricing_cycle is not None:
            result['PricingCycle'] = self.pricing_cycle
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role is not None:
            result['Role'] = self.role
        if self.router_id is not None:
            result['RouterId'] = self.router_id
        if self.router_type is not None:
            result['RouterType'] = self.router_type
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HealthCheckSourceIp') is not None:
            self.health_check_source_ip = m.get('HealthCheckSourceIp')
        if m.get('HealthCheckTargetIp') is not None:
            self.health_check_target_ip = m.get('HealthCheckTargetIp')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OppositeAccessPointId') is not None:
            self.opposite_access_point_id = m.get('OppositeAccessPointId')
        if m.get('OppositeInterfaceId') is not None:
            self.opposite_interface_id = m.get('OppositeInterfaceId')
        if m.get('OppositeInterfaceOwnerId') is not None:
            self.opposite_interface_owner_id = m.get('OppositeInterfaceOwnerId')
        if m.get('OppositeRegionId') is not None:
            self.opposite_region_id = m.get('OppositeRegionId')
        if m.get('OppositeRouterId') is not None:
            self.opposite_router_id = m.get('OppositeRouterId')
        if m.get('OppositeRouterType') is not None:
            self.opposite_router_type = m.get('OppositeRouterType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PricingCycle') is not None:
            self.pricing_cycle = m.get('PricingCycle')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('RouterId') is not None:
            self.router_id = m.get('RouterId')
        if m.get('RouterType') is not None:
            self.router_type = m.get('RouterType')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class CreateRouterInterfaceResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None, router_interface_id=None):
        self.order_id = order_id  # type: long
        self.request_id = request_id  # type: str
        self.router_interface_id = router_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRouterInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        return self


class CreateRouterInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateRouterInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateRouterInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRouterInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSecurityGroupRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the security group. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.key = key  # type: str
        # The value of tag N of the security group. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSecurityGroupRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSecurityGroupRequest(TeaModel):
    def __init__(self, client_token=None, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, security_group_name=None,
                 security_group_type=None, service_managed=None, tag=None, vpc_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the security group. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the security group belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The name of the security group. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-). This parameter is empty by default.
        self.security_group_name = security_group_name  # type: str
        # The type of the security group. Valid values:
        # 
        # *   normal: basic security group
        # *   enterprise: advanced security group. For more information, see [Advanced security groups](~~120621~~).
        self.security_group_type = security_group_type  # type: str
        # This parameter is unavailable.
        self.service_managed = service_managed  # type: bool
        # The tags of the new security group.
        self.tag = tag  # type: list[CreateSecurityGroupRequestTag]
        # The ID of the VPC in which to create the security group.
        # 
        # >  If the specified region supports the classic network, you can create security groups of the classic network type without specifying the VpcId parameter. If the specified region does not support the classic network, you must specify the VpcId parameter to create security groups of the VPC type.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        if self.security_group_type is not None:
            result['SecurityGroupType'] = self.security_group_type
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        if m.get('SecurityGroupType') is not None:
            self.security_group_type = m.get('SecurityGroupType')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateSecurityGroupRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, security_group_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class CreateSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimulatedSystemEventsRequest(TeaModel):
    def __init__(self, event_type=None, instance_id=None, not_before=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The type of the system event. Valid values:
        # 
        # *   SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
        # *   SystemFailure.Reboot: The instance is restarted due to a system failure.
        # *   InstanceFailure.Reboot: The instance is restarted due to an instance failure.
        # *   SystemMaintenance.Stop: The instance is stopped due to system maintenance.
        # *   SystemMaintenance.Redeploy: The instance is redeployed due to system maintenance.
        # *   SystemFailure.Redeploy: The instance is redeployed due to a system failure.
        # *   SystemFailure.Stop: The instance is stopped due to a system failure.
        # *   InstanceFailure.Reboot: The instance is restarted due to an instance failure.
        self.event_type = event_type  # type: str
        # The IDs of the instances. You can specify the IDs of up to 100 instances.
        self.instance_id = instance_id  # type: list[str]
        # The start time of the scheduled event execution. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # > For events that occur due to system failures or instance failures, the simulated events enter the Executing (`Executing`) state when the simulated events are created. The value of `NotBefore` is the time when the simulated events enter the Executed (`Executed`) state.
        self.not_before = not_before  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimulatedSystemEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.not_before is not None:
            result['NotBefore'] = self.not_before
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NotBefore') is not None:
            self.not_before = m.get('NotBefore')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class CreateSimulatedSystemEventsResponseBodyEventIdSet(TeaModel):
    def __init__(self, event_id=None):
        self.event_id = event_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimulatedSystemEventsResponseBodyEventIdSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        return self


class CreateSimulatedSystemEventsResponseBody(TeaModel):
    def __init__(self, event_id_set=None, request_id=None):
        # The IDs of the simulated events.
        self.event_id_set = event_id_set  # type: CreateSimulatedSystemEventsResponseBodyEventIdSet
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.event_id_set:
            self.event_id_set.validate()

    def to_map(self):
        _map = super(CreateSimulatedSystemEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_id_set is not None:
            result['EventIdSet'] = self.event_id_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventIdSet') is not None:
            temp_model = CreateSimulatedSystemEventsResponseBodyEventIdSet()
            self.event_id_set = temp_model.from_map(m['EventIdSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSimulatedSystemEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSimulatedSystemEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSimulatedSystemEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSimulatedSystemEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSnapshotRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the snapshot. Valid values of N: 1 to 20. The tag key cannot be an empty string. It must be 1 to 128 characters in length. It cannot start with acs: or aliyun or contain [http:// or https://.](http://https://。)
        self.key = key  # type: str
        # The value of tag N to add to the snapshot. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain [http:// or https://.](http://https://。)
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSnapshotRequest(TeaModel):
    def __init__(self, category=None, client_token=None, description=None, disk_id=None, instant_access=None,
                 instant_access_retention_days=None, owner_account=None, owner_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, retention_days=None, snapshot_name=None, storage_location_arn=None, tag=None):
        # The type of the snapshot. Valid values:
        # 
        # *   Standard: normal snapshot
        # *   Flash: local snapshot
        # 
        # > This parameter will be removed in the future. We recommend that you use the `InstantAccess` parameter to ensure future compatibility. This parameter and the `InstantAccess` parameter cannot be specified at the same time. For more information, see the "Description" section of this topic.
        self.category = category  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # Specifies whether to enable the instant access feature. Valid values:
        # 
        # *   true: enables the instant access feature. This feature can be enabled only for enhanced SSDs (ESSDs).
        # 
        #     **\
        # 
        #     **Note**After the instant access feature is enabled, an instant access (IA) snapshot is created and can be used to roll back disks or create disks across zones even when the snapshot is being created. This feature ensures that a new snapshot of an ESSD becomes available for use within five seconds regardless of the ESSD size.
        # 
        # *   false: does not enable the instant access feature. If InstantAccess is set to false, a normal snapshot is created.
        # 
        # Default value: false.
        # 
        # > This parameter and the `Category` parameter cannot be specified at the same time. For more information, see the "Description" section of this topic.
        self.instant_access = instant_access  # type: bool
        # The validity period of the instant access feature. When the validity period ends, the feature is disabled and the IA snapshot is automatically released. This parameter takes effect only when `InstantAccess` is set to true. Unit: days. Valid values: 1 to 65535.
        # 
        # By default, the value of this parameter is the same as that of `RetentionDays`.
        self.instant_access_retention_days = instant_access_retention_days  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the resource group to which to assign the snapshot.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The retention period of the snapshot. Valid values: 1 to 65536. Unit: days. The snapshot is automatically released when its retention period expires.
        # 
        # This parameter is empty by default, which indicates that the snapshot is not automatically released.
        self.retention_days = retention_days  # type: int
        # The name of the snapshot. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # It cannot start with `auto` because snapshots whose names start with auto are recognized as automatic snapshots.
        self.snapshot_name = snapshot_name  # type: str
        # > This parameter is unavailable.
        self.storage_location_arn = storage_location_arn  # type: str
        # The tags to add to the snapshot.
        self.tag = tag  # type: list[CreateSnapshotRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.instant_access is not None:
            result['InstantAccess'] = self.instant_access
        if self.instant_access_retention_days is not None:
            result['InstantAccessRetentionDays'] = self.instant_access_retention_days
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.storage_location_arn is not None:
            result['StorageLocationArn'] = self.storage_location_arn
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InstantAccess') is not None:
            self.instant_access = m.get('InstantAccess')
        if m.get('InstantAccessRetentionDays') is not None:
            self.instant_access_retention_days = m.get('InstantAccessRetentionDays')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('StorageLocationArn') is not None:
            self.storage_location_arn = m.get('StorageLocationArn')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateSnapshotRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSnapshotGroupRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the snapshot-consistent group. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the snapshot-consistent group. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotGroupRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateSnapshotGroupRequest(TeaModel):
    def __init__(self, description=None, disk_id=None, exclude_disk_id=None, instance_id=None, instant_access=None,
                 instant_access_retention_days=None, name=None, owner_account=None, owner_id=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, storage_location_arn=None, tag=None):
        # The description of the snapshot-consistent group. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The ID of disk N for which you want to create snapshots. You can specify multiple disk IDs across instances within the same zone. Valid values of N: 1 to 16. A single snapshot-consistent group can contain snapshots of up to 16 disks and cannot exceed 32 TiB in size.
        # 
        # Take note of the following items:
        # 
        # *   You cannot specify both DiskId.N and `ExcludeDiskId.N`.
        # *   If `InstanceId` is set, you can use DiskId.N to specify only disks attached to the instance specified by InstanceId, and you cannot use DiskId.N to specify disks attached to multiple instances.
        self.disk_id = disk_id  # type: list[str]
        # The ID of disk N for which you do not need to create snapshots. After this parameter is specified, the created snapshot-consistent group does not contain snapshots of the disk. Valid values of N: 1 to 16.
        # 
        # This parameter is empty by default, which indicates that snapshots are created for all the disks of the instance.
        # 
        # > You cannot specify ExcludeDiskId.N and `DiskId.N`.
        self.exclude_disk_id = exclude_disk_id  # type: list[str]
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Specify whether to enable the instant access feature. Valid values:
        # 
        # *   true: enables the instant access feature.
        # *   false: disables the instant access feature.
        # 
        # Default value: false.
        self.instant_access = instant_access  # type: bool
        # Specify the number of days for which the instant access feature is available. Unit: days. Valid values: 1 to 65535.
        # 
        # This parameter takes effect only when `InstantAccess` is set to true. The instant access feature is automatically disabled when the specified duration of the instant access feature expires.
        # 
        # This parameter is empty by default, which indicates that the expiration time of the instant access feature is determined by the time when snapshots are released.
        self.instant_access_retention_days = instant_access_retention_days  # type: int
        # The name of the snapshot-consistent group. The name must be 2 to 128 characters in length, and contain letters, digits, periods (.), underscores (\_), hyphens (-), and colons (:). It must start with a letter and cannot start with `http://` or `https://`.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the snapshot-consistent group belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # > This parameter is unavailable.
        self.storage_location_arn = storage_location_arn  # type: str
        # The list of tags that are associated with the instances.
        self.tag = tag  # type: list[CreateSnapshotGroupRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateSnapshotGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.exclude_disk_id is not None:
            result['ExcludeDiskId'] = self.exclude_disk_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instant_access is not None:
            result['InstantAccess'] = self.instant_access
        if self.instant_access_retention_days is not None:
            result['InstantAccessRetentionDays'] = self.instant_access_retention_days
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_location_arn is not None:
            result['StorageLocationArn'] = self.storage_location_arn
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('ExcludeDiskId') is not None:
            self.exclude_disk_id = m.get('ExcludeDiskId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstantAccess') is not None:
            self.instant_access = m.get('InstantAccess')
        if m.get('InstantAccessRetentionDays') is not None:
            self.instant_access_retention_days = m.get('InstantAccessRetentionDays')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageLocationArn') is not None:
            self.storage_location_arn = m.get('StorageLocationArn')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateSnapshotGroupRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class CreateSnapshotGroupResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_group_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the snapshot-consistent group.
        self.snapshot_group_id = snapshot_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_group_id is not None:
            result['SnapshotGroupId'] = self.snapshot_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotGroupId') is not None:
            self.snapshot_group_id = m.get('SnapshotGroupId')
        return self


class CreateSnapshotGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSnapshotGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSnapshotGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSnapshotGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateStorageSetRequest(TeaModel):
    def __init__(self, client_token=None, description=None, max_partition_number=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, storage_set_name=None,
                 zone_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The value of **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the storage set.
        self.description = description  # type: str
        # The maximum number of partitions supported by the storage set. The value must be greater than or equal to 2, but cannot exceed the quota obtained by calling the [DescribeAccountAttributes](~~73772~~)operation.
        # 
        # Default value: 2.
        self.max_partition_number = max_partition_number  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region in which to create the storage set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The name of the storage set.
        self.storage_set_name = storage_set_name  # type: str
        # The zone in which to create the storage set. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStorageSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.max_partition_number is not None:
            result['MaxPartitionNumber'] = self.max_partition_number
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_set_name is not None:
            result['StorageSetName'] = self.storage_set_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MaxPartitionNumber') is not None:
            self.max_partition_number = m.get('MaxPartitionNumber')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageSetName') is not None:
            self.storage_set_name = m.get('StorageSetName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateStorageSetResponseBody(TeaModel):
    def __init__(self, request_id=None, storage_set_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateStorageSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        return self


class CreateStorageSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateStorageSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateStorageSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateStorageSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVSwitchRequest(TeaModel):
    def __init__(self, cidr_block=None, client_token=None, description=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, v_switch_name=None, vpc_id=None,
                 zone_id=None):
        self.cidr_block = cidr_block  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.v_switch_name = v_switch_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVSwitchRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class CreateVSwitchResponseBody(TeaModel):
    def __init__(self, request_id=None, v_switch_id=None):
        self.request_id = request_id  # type: str
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVSwitchResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateVSwitchResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateVSwitchResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateVSwitchResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVirtualBorderRouterRequest(TeaModel):
    def __init__(self, circuit_code=None, client_token=None, description=None, local_gateway_ip=None, name=None,
                 owner_account=None, owner_id=None, peer_gateway_ip=None, peering_subnet_mask=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None, vbr_owner_id=None,
                 vlan_id=None):
        self.circuit_code = circuit_code  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.local_gateway_ip = local_gateway_ip  # type: str
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.peer_gateway_ip = peer_gateway_ip  # type: str
        self.peering_subnet_mask = peering_subnet_mask  # type: str
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vbr_owner_id = vbr_owner_id  # type: long
        self.vlan_id = vlan_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVirtualBorderRouterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.local_gateway_ip is not None:
            result['LocalGatewayIp'] = self.local_gateway_ip
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.peer_gateway_ip is not None:
            result['PeerGatewayIp'] = self.peer_gateway_ip
        if self.peering_subnet_mask is not None:
            result['PeeringSubnetMask'] = self.peering_subnet_mask
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vbr_owner_id is not None:
            result['VbrOwnerId'] = self.vbr_owner_id
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LocalGatewayIp') is not None:
            self.local_gateway_ip = m.get('LocalGatewayIp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeerGatewayIp') is not None:
            self.peer_gateway_ip = m.get('PeerGatewayIp')
        if m.get('PeeringSubnetMask') is not None:
            self.peering_subnet_mask = m.get('PeeringSubnetMask')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VbrOwnerId') is not None:
            self.vbr_owner_id = m.get('VbrOwnerId')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        return self


class CreateVirtualBorderRouterResponseBody(TeaModel):
    def __init__(self, request_id=None, vbr_id=None):
        self.request_id = request_id  # type: str
        self.vbr_id = vbr_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVirtualBorderRouterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        return self


class CreateVirtualBorderRouterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateVirtualBorderRouterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateVirtualBorderRouterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVirtualBorderRouterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateVpcRequest(TeaModel):
    def __init__(self, cidr_block=None, client_token=None, description=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None, vpc_name=None):
        self.cidr_block = cidr_block  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vpc_name = vpc_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVpcRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class CreateVpcResponseBody(TeaModel):
    def __init__(self, request_id=None, route_table_id=None, vrouter_id=None, vpc_id=None):
        self.request_id = request_id  # type: str
        self.route_table_id = route_table_id  # type: str
        self.vrouter_id = vrouter_id  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateVpcResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateVpcResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateVpcResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateVpcResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeactivateRouterInterfaceRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 router_interface_id=None):
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeactivateRouterInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        return self


class DeactivateRouterInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeactivateRouterInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeactivateRouterInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeactivateRouterInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeactivateRouterInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeactivateRouterInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteActivationRequest(TeaModel):
    def __init__(self, activation_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the activation code. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteActivationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteActivationResponseBodyActivation(TeaModel):
    def __init__(self, activation_id=None, creation_time=None, deregistered_count=None, description=None,
                 instance_count=None, instance_name=None, ip_address_range=None, registered_count=None,
                 time_to_live_in_hours=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The time when the activation code was created.
        self.creation_time = creation_time  # type: str
        # The number of instances that were deregistered.
        self.deregistered_count = deregistered_count  # type: int
        # The description of the activation code.
        self.description = description  # type: str
        # The maximum number of times that the activation code can be used to register managed instances.
        self.instance_count = instance_count  # type: int
        # The default instance name prefix.
        self.instance_name = instance_name  # type: str
        # The IP addresses of hosts that are allowed to use the activation code.
        self.ip_address_range = ip_address_range  # type: str
        # The number of registered instances.
        self.registered_count = registered_count  # type: int
        # The validity period of the activation code. Unit: hours.
        self.time_to_live_in_hours = time_to_live_in_hours  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteActivationResponseBodyActivation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.deregistered_count is not None:
            result['DeregisteredCount'] = self.deregistered_count
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip_address_range is not None:
            result['IpAddressRange'] = self.ip_address_range
        if self.registered_count is not None:
            result['RegisteredCount'] = self.registered_count
        if self.time_to_live_in_hours is not None:
            result['TimeToLiveInHours'] = self.time_to_live_in_hours
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeregisteredCount') is not None:
            self.deregistered_count = m.get('DeregisteredCount')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IpAddressRange') is not None:
            self.ip_address_range = m.get('IpAddressRange')
        if m.get('RegisteredCount') is not None:
            self.registered_count = m.get('RegisteredCount')
        if m.get('TimeToLiveInHours') is not None:
            self.time_to_live_in_hours = m.get('TimeToLiveInHours')
        return self


class DeleteActivationResponseBody(TeaModel):
    def __init__(self, activation=None, request_id=None):
        # Details of the activation code and its usage information.
        self.activation = activation  # type: DeleteActivationResponseBodyActivation
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.activation:
            self.activation.validate()

    def to_map(self):
        _map = super(DeleteActivationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation is not None:
            result['Activation'] = self.activation.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Activation') is not None:
            temp_model = DeleteActivationResponseBodyActivation()
            self.activation = temp_model.from_map(m['Activation'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteActivationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteActivationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteActivationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteActivationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAutoProvisioningGroupRequest(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, terminate_instances=None):
        # The ID of the auto provisioning group to be deleted.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the auto provisioning group.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to release instances in the auto provisioning group. Valid values:
        # 
        # *   true: releases instances in the auto provisioning group.
        # *   false: retains instances in the auto provisioning group.
        self.terminate_instances = terminate_instances  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoProvisioningGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.terminate_instances is not None:
            result['TerminateInstances'] = self.terminate_instances
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TerminateInstances') is not None:
            self.terminate_instances = m.get('TerminateInstances')
        return self


class DeleteAutoProvisioningGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoProvisioningGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAutoProvisioningGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteAutoProvisioningGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteAutoProvisioningGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAutoProvisioningGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, owner_id=None, resource_owner_account=None, resource_owner_id=None,
                 auto_snapshot_policy_id=None, region_id=None):
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the automatic snapshot policy. You can call the [DescribeAutoSnapshotPolicyEx](~~25530~~) operation to query the available automatic snapshot policies.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The region ID of the automatic snapshot policy. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.auto_snapshot_policy_id is not None:
            result['autoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.region_id is not None:
            result['regionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('autoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('autoSnapshotPolicyId')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        return self


class DeleteAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBandwidthPackageRequest(TeaModel):
    def __init__(self, bandwidth_package_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBandwidthPackageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteBandwidthPackageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBandwidthPackageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBandwidthPackageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteBandwidthPackageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteBandwidthPackageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBandwidthPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCommandRequest(TeaModel):
    def __init__(self, command_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the command. You can call the [DescribeCommands](~~64843~~) operation to query all available command IDs.
        self.command_id = command_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteCommandResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDedicatedHostClusterRequest(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDedicatedHostClusterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDedicatedHostClusterResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDedicatedHostClusterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDedicatedHostClusterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDedicatedHostClusterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDedicatedHostClusterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDedicatedHostClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDemandRequest(TeaModel):
    def __init__(self, client_token=None, demand_id=None, owner_account=None, owner_id=None, reason=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value that is unique among different requests. The `ClientToken` value can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the requirement.
        self.demand_id = demand_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The reason for deleting the filing form. Enter details.
        self.reason = reason  # type: str
        # The region ID of the filed instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDemandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.demand_id is not None:
            result['DemandId'] = self.demand_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DemandId') is not None:
            self.demand_id = m.get('DemandId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDemandResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDemandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDemandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDemandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDemandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDemandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDeploymentSetRequest(TeaModel):
    def __init__(self, deployment_set_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the deployment set. You cannot delete a deployment set that contains instances.
        self.deployment_set_id = deployment_set_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the deployment set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDeploymentSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDeploymentSetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDeploymentSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDeploymentSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDeploymentSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDeploymentSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDeploymentSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDiagnosticMetricSetsRequest(TeaModel):
    def __init__(self, metric_set_ids=None, region_id=None):
        # The IDs of diagnostic metric sets. You can specify up to 10 set IDs.
        self.metric_set_ids = metric_set_ids  # type: list[str]
        # The region ID of the diagnostic metric set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiagnosticMetricSetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_set_ids is not None:
            result['MetricSetIds'] = self.metric_set_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricSetIds') is not None:
            self.metric_set_ids = m.get('MetricSetIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDiagnosticMetricSetsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiagnosticMetricSetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDiagnosticMetricSetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDiagnosticMetricSetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDiagnosticMetricSetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDiagnosticMetricSetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDiagnosticReportsRequest(TeaModel):
    def __init__(self, region_id=None, report_ids=None):
        # The region ID of the diagnostic report. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The IDs of diagnostic reports. You can specify up to 100 report IDs.
        self.report_ids = report_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiagnosticReportsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.report_ids is not None:
            result['ReportIds'] = self.report_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReportIds') is not None:
            self.report_ids = m.get('ReportIds')
        return self


class DeleteDiagnosticReportsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiagnosticReportsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDiagnosticReportsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDiagnosticReportsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDiagnosticReportsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDiagnosticReportsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDiskRequest(TeaModel):
    def __init__(self, disk_id=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the disk to be released.
        self.disk_id = disk_id  # type: str
        self.owner_account = owner_account  # type: str
        # RAM 用户的虚拟账号ID。
        self.owner_id = owner_id  # type: long
        # 资源主账号的账号名称。
        self.resource_owner_account = resource_owner_account  # type: str
        # 资源主账号的ID，亦即UID。
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteDiskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteForwardEntryRequest(TeaModel):
    def __init__(self, forward_entry_id=None, forward_table_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.forward_entry_id = forward_entry_id  # type: str
        self.forward_table_id = forward_table_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteForwardEntryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteForwardEntryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteForwardEntryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteForwardEntryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteForwardEntryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteForwardEntryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHaVipRequest(TeaModel):
    def __init__(self, client_token=None, ha_vip_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.client_token = client_token  # type: str
        self.ha_vip_id = ha_vip_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHaVipRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteHaVipResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHaVipResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteHaVipResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHaVipResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHaVipResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHpcClusterRequest(TeaModel):
    def __init__(self, client_token=None, hpc_cluster_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value must contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the HPC cluster.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the HPC cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHpcClusterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteHpcClusterResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHpcClusterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteHpcClusterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHpcClusterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHpcClusterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHpcClusterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteImageRequest(TeaModel):
    def __init__(self, force=None, image_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to forcibly delete the custom image. Valid values:
        # 
        # *   true: forcibly deletes the custom image, regardless of whether the image is being used by other instances.
        # *   false: verifies that the image is not being used by other instances and then deletes the image.
        # 
        # Default value: false.
        self.force = force  # type: bool
        # The ID of the image. If the specified custom image does not exist, the request is ignored.
        self.image_id = image_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteImageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteImageComponentRequest(TeaModel):
    def __init__(self, image_component_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the image component.
        self.image_component_id = image_component_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image component. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImageComponentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_component_id is not None:
            result['ImageComponentId'] = self.image_component_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageComponentId') is not None:
            self.image_component_id = m.get('ImageComponentId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteImageComponentResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImageComponentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteImageComponentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteImageComponentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteImageComponentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteImageComponentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteImagePipelineRequest(TeaModel):
    def __init__(self, image_pipeline_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImagePipelineRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteImagePipelineResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImagePipelineResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteImagePipelineResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteImagePipelineResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteImagePipelineResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteImagePipelineResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstanceRequest(TeaModel):
    def __init__(self, force=None, instance_id=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, terminate_subscription=None):
        # Specifies whether to forcefully release the instance in the **Running** (`Running`) state. Valid values:
        # 
        # *   true: forcefully releases the instance in the **Running** (`Running`) state. When the Force parameter is set to true, this operation is equivalent to the power-off operation. Temporary data in the memory and storage of the instance is erased and cannot be restored.
        # *   false: normally releases the instance. This value is valid only for instances in the **Stopped** (`Stopped`) state.
        # 
        # Default value: false.
        self.force = force  # type: bool
        # The ID of the instance that you want to release.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to release the expired subscription instance.
        # 
        # Default value: false.
        self.terminate_subscription = terminate_subscription  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.terminate_subscription is not None:
            result['TerminateSubscription'] = self.terminate_subscription
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TerminateSubscription') is not None:
            self.terminate_subscription = m.get('TerminateSubscription')
        return self


class DeleteInstanceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteInstancesRequest(TeaModel):
    def __init__(self, client_token=None, dry_run=None, force=None, instance_id=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 terminate_subscription=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, DRYRUN.SUCCESS is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned and the request is made.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to forcefully release the instance that is in the **Running** (`Running`) state. Default value: false. Valid values:
        # 
        # *   true: forcefully releases the instance that is in the **Running** (`Running`) state. When the Force parameter is set to true, this operation is equivalent to the power-off operation. Temporary data in the memory and storage of the instance is erased and cannot be recovered.
        # *   false: normally releases the instance. This value is valid only for instances that are in the **Stopped** (`Stopped`) state.
        self.force = force  # type: bool
        # The IDs of instances. You can specify up to 100 instance IDs in a single request.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to release an expired subscription instance.
        # 
        # Default value: false.
        self.terminate_subscription = terminate_subscription  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.terminate_subscription is not None:
            result['TerminateSubscription'] = self.terminate_subscription
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TerminateSubscription') is not None:
            self.terminate_subscription = m.get('TerminateSubscription')
        return self


class DeleteInstancesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteKeyPairsRequest(TeaModel):
    def __init__(self, key_pair_names=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The names of SSH key pairs. The value can be a JSON array that consists of up to 100 key pair names. Separate multiple key pair names with commas (,).
        self.key_pair_names = key_pair_names  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteKeyPairsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_names is not None:
            result['KeyPairNames'] = self.key_pair_names
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairNames') is not None:
            self.key_pair_names = m.get('KeyPairNames')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteKeyPairsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteKeyPairsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteKeyPairsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteKeyPairsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteKeyPairsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteKeyPairsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLaunchTemplateRequest(TeaModel):
    def __init__(self, launch_template_id=None, launch_template_name=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the instance launch template. For more information, call the [DescribeLaunchTemplates](~~73759~~) operation.
        # 
        # You must specify the `LaunchTemplateId` parameter or the `LaunchTemplateName` parameter to determine an instance launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the instance launch template.
        # 
        # You must specify the `LaunchTemplateId` parameter or the `LaunchTemplateName` parameter to determine an instance launch template.
        self.launch_template_name = launch_template_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance launch template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLaunchTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteLaunchTemplateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLaunchTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLaunchTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLaunchTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLaunchTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLaunchTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLaunchTemplateVersionRequest(TeaModel):
    def __init__(self, delete_version=None, launch_template_id=None, launch_template_name=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The version numbers of instance launch templates that to be deleted. You can specify at most 29 version numbers.
        self.delete_version = delete_version  # type: list[long]
        # The ID of the instance launch template. For more information, call the [DescribeLaunchTemplates](~~73759~~) operation.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the instance launch template.
        self.launch_template_name = launch_template_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region to which the instance lauch template belongs. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLaunchTemplateVersionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_version is not None:
            result['DeleteVersion'] = self.delete_version
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeleteVersion') is not None:
            self.delete_version = m.get('DeleteVersion')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteLaunchTemplateVersionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLaunchTemplateVersionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteLaunchTemplateVersionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLaunchTemplateVersionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLaunchTemplateVersionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLaunchTemplateVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNatGatewayRequest(TeaModel):
    def __init__(self, nat_gateway_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNatGatewayRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteNatGatewayResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNatGatewayResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNatGatewayResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteNatGatewayResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteNatGatewayResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNatGatewayResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkInterfaceRequest(TeaModel):
    def __init__(self, network_interface_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteNetworkInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteNetworkInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteNetworkInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkInterfacePermissionRequest(TeaModel):
    def __init__(self, force=None, network_interface_permission_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.force = force  # type: bool
        self.network_interface_permission_id = network_interface_permission_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkInterfacePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.network_interface_permission_id is not None:
            result['NetworkInterfacePermissionId'] = self.network_interface_permission_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('NetworkInterfacePermissionId') is not None:
            self.network_interface_permission_id = m.get('NetworkInterfacePermissionId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeleteNetworkInterfacePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkInterfacePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkInterfacePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteNetworkInterfacePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteNetworkInterfacePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkInterfacePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePhysicalConnectionRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeletePhysicalConnectionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeletePhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeletePhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePrefixListRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, prefix_list_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The region ID of the prefix list. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePrefixListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeletePrefixListResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePrefixListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePrefixListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeletePrefixListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeletePrefixListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePrefixListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRouteEntryRequestNextHopList(TeaModel):
    def __init__(self, next_hop_id=None, next_hop_type=None):
        self.next_hop_id = next_hop_id  # type: str
        self.next_hop_type = next_hop_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteRouteEntryRequestNextHopList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        return self


class DeleteRouteEntryRequest(TeaModel):
    def __init__(self, destination_cidr_block=None, next_hop_id=None, next_hop_list=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, route_table_id=None):
        self.destination_cidr_block = destination_cidr_block  # type: str
        self.next_hop_id = next_hop_id  # type: str
        self.next_hop_list = next_hop_list  # type: list[DeleteRouteEntryRequestNextHopList]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.route_table_id = route_table_id  # type: str

    def validate(self):
        if self.next_hop_list:
            for k in self.next_hop_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DeleteRouteEntryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        result['NextHopList'] = []
        if self.next_hop_list is not None:
            for k in self.next_hop_list:
                result['NextHopList'].append(k.to_map() if k else None)
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        self.next_hop_list = []
        if m.get('NextHopList') is not None:
            for k in m.get('NextHopList'):
                temp_model = DeleteRouteEntryRequestNextHopList()
                self.next_hop_list.append(temp_model.from_map(k))
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class DeleteRouteEntryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteRouteEntryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRouteEntryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteRouteEntryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteRouteEntryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRouteEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteRouterInterfaceRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, router_interface_id=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteRouterInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class DeleteRouterInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteRouterInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteRouterInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteRouterInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteRouterInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteRouterInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSecurityGroupRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group. You can call the [DescribeSecurityGroups](~~25556~~) to query the most recent list of security group IDs.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DeleteSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotRequest(TeaModel):
    def __init__(self, force=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, snapshot_id=None):
        # Specifies whether to force delete the snapshot that has been used to create disks. Valid values:
        # 
        # *   true: force deletes the snapshot. After the snapshot is force deleted, the disks created from this snapshot cannot be re-initialized.
        # *   false: does not force delete the snapshot.
        # 
        # Default value: false
        self.force = force  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DeleteSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotGroupRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, snapshot_group_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the snapshot-consistent group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot-consistent group. You can call the [DescribeSnapshotGroups](~~210940~~) operation to query the IDs of one or more snapshot-consistent groups.
        self.snapshot_group_id = snapshot_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_group_id is not None:
            result['SnapshotGroupId'] = self.snapshot_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotGroupId') is not None:
            self.snapshot_group_id = m.get('SnapshotGroupId')
        return self


class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(TeaModel):
    def __init__(self, name=None, value=None):
        # The name of the resource.
        self.name = name  # type: str
        # The ID of the resource.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet(TeaModel):
    def __init__(self, related_item=None):
        self.related_item = related_item  # type: list[DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem]

    def validate(self):
        if self.related_item:
            for k in self.related_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RelatedItem'] = []
        if self.related_item is not None:
            for k in self.related_item:
                result['RelatedItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.related_item = []
        if m.get('RelatedItem') is not None:
            for k in m.get('RelatedItem'):
                temp_model = DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem()
                self.related_item.append(temp_model.from_map(k))
        return self


class DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress(TeaModel):
    def __init__(self, error_code=None, error_msg=None, operation_status=None, related_item_set=None):
        # The error code. This parameter is empty when the operation was successful.
        # 
        # For information about error codes and error messages, visit the [API error center](https://error-center.alibabacloud.com/status/product/Ecs).
        self.error_code = error_code  # type: str
        # The error message. This parameter is empty when the operation was successful.
        # 
        # For information about error codes and error messages, visit the [API error center](https://error-center.alibabacloud.com/status/product/Ecs).
        self.error_msg = error_msg  # type: str
        # Indicates whether the operation was successful. If the operation was successful, a value of Success is returned. If the operation failed, an error code and an error message are returned.
        self.operation_status = operation_status  # type: str
        # Details about the resources.
        self.related_item_set = related_item_set  # type: DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet

    def validate(self):
        if self.related_item_set:
            self.related_item_set.validate()

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.operation_status is not None:
            result['OperationStatus'] = self.operation_status
        if self.related_item_set is not None:
            result['RelatedItemSet'] = self.related_item_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('OperationStatus') is not None:
            self.operation_status = m.get('OperationStatus')
        if m.get('RelatedItemSet') is not None:
            temp_model = DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgressRelatedItemSet()
            self.related_item_set = temp_model.from_map(m['RelatedItemSet'])
        return self


class DeleteSnapshotGroupResponseBodyOperationProgressSet(TeaModel):
    def __init__(self, operation_progress=None):
        self.operation_progress = operation_progress  # type: list[DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress]

    def validate(self):
        if self.operation_progress:
            for k in self.operation_progress:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponseBodyOperationProgressSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationProgress'] = []
        if self.operation_progress is not None:
            for k in self.operation_progress:
                result['OperationProgress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_progress = []
        if m.get('OperationProgress') is not None:
            for k in m.get('OperationProgress'):
                temp_model = DeleteSnapshotGroupResponseBodyOperationProgressSetOperationProgress()
                self.operation_progress.append(temp_model.from_map(k))
        return self


class DeleteSnapshotGroupResponseBody(TeaModel):
    def __init__(self, operation_progress_set=None, request_id=None):
        # Details about the delete operation.
        self.operation_progress_set = operation_progress_set  # type: DeleteSnapshotGroupResponseBodyOperationProgressSet
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.operation_progress_set:
            self.operation_progress_set.validate()

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_progress_set is not None:
            result['OperationProgressSet'] = self.operation_progress_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationProgressSet') is not None:
            temp_model = DeleteSnapshotGroupResponseBodyOperationProgressSet()
            self.operation_progress_set = temp_model.from_map(m['OperationProgressSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnapshotGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSnapshotGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSnapshotGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteStorageSetRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, storage_set_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The value of **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the storage set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteStorageSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        return self


class DeleteStorageSetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteStorageSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteStorageSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteStorageSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteStorageSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteStorageSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVSwitchRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, v_switch_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVSwitchRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DeleteVSwitchResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVSwitchResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVSwitchResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVSwitchResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVSwitchResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVSwitchResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVirtualBorderRouterRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, user_cidr=None, vbr_id=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vbr_id = vbr_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVirtualBorderRouterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        return self


class DeleteVirtualBorderRouterResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVirtualBorderRouterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVirtualBorderRouterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVirtualBorderRouterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVirtualBorderRouterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVirtualBorderRouterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVpcRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, vpc_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVpcRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DeleteVpcResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVpcResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVpcResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVpcResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVpcResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeregisterManagedInstanceRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the managed instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the secondary ENI. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeregisterManagedInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DeregisterManagedInstanceResponseBodyInstance(TeaModel):
    def __init__(self, activation_id=None, agent_version=None, hostname=None, instance_id=None, instance_name=None,
                 internet_ip=None, intranet_ip=None, invocation_count=None, last_invoked_time=None, machine_id=None,
                 os_type=None, os_version=None, registration_time=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The version number of the Cloud Assistant client.
        self.agent_version = agent_version  # type: str
        # The hostname of the managed instance.
        self.hostname = hostname  # type: str
        # The ID of the managed instance.
        self.instance_id = instance_id  # type: str
        # The name of the managed instance.
        self.instance_name = instance_name  # type: str
        # The public IP address of the managed instance.
        self.internet_ip = internet_ip  # type: str
        # The internal IP address of the managed instance.
        self.intranet_ip = intranet_ip  # type: str
        # The number of times that Cloud Assistant tasks were executed on the managed instance.
        self.invocation_count = invocation_count  # type: long
        # The last Cloud Assistant task execution time.
        self.last_invoked_time = last_invoked_time  # type: str
        # The machine code of the managed instance.
        self.machine_id = machine_id  # type: str
        # The operating system type of the managed instance.
        self.os_type = os_type  # type: str
        # The version information of the operating system.
        self.os_version = os_version  # type: str
        # The time when the managed instance was registered.
        self.registration_time = registration_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeregisterManagedInstanceResponseBodyInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.agent_version is not None:
            result['AgentVersion'] = self.agent_version
        if self.hostname is not None:
            result['Hostname'] = self.hostname
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.invocation_count is not None:
            result['InvocationCount'] = self.invocation_count
        if self.last_invoked_time is not None:
            result['LastInvokedTime'] = self.last_invoked_time
        if self.machine_id is not None:
            result['MachineId'] = self.machine_id
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.registration_time is not None:
            result['RegistrationTime'] = self.registration_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('AgentVersion') is not None:
            self.agent_version = m.get('AgentVersion')
        if m.get('Hostname') is not None:
            self.hostname = m.get('Hostname')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('InvocationCount') is not None:
            self.invocation_count = m.get('InvocationCount')
        if m.get('LastInvokedTime') is not None:
            self.last_invoked_time = m.get('LastInvokedTime')
        if m.get('MachineId') is not None:
            self.machine_id = m.get('MachineId')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('RegistrationTime') is not None:
            self.registration_time = m.get('RegistrationTime')
        return self


class DeregisterManagedInstanceResponseBody(TeaModel):
    def __init__(self, instance=None, request_id=None):
        # Details of the managed instance.
        self.instance = instance  # type: DeregisterManagedInstanceResponseBodyInstance
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super(DeregisterManagedInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instance') is not None:
            temp_model = DeregisterManagedInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeregisterManagedInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeregisterManagedInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeregisterManagedInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeregisterManagedInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccessPointsRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccessPointsRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAccessPointsRequest(TeaModel):
    def __init__(self, filter=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, type=None):
        self.filter = filter  # type: list[DescribeAccessPointsRequestFilter]
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.type = type  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAccessPointsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeAccessPointsRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAccessPointsResponseBodyAccessPointSetAccessPointType(TeaModel):
    def __init__(self, access_point_id=None, attached_region_no=None, description=None, host_operator=None,
                 location=None, name=None, status=None, type=None):
        self.access_point_id = access_point_id  # type: str
        self.attached_region_no = attached_region_no  # type: str
        self.description = description  # type: str
        self.host_operator = host_operator  # type: str
        self.location = location  # type: str
        self.name = name  # type: str
        self.status = status  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccessPointsResponseBodyAccessPointSetAccessPointType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.attached_region_no is not None:
            result['AttachedRegionNo'] = self.attached_region_no
        if self.description is not None:
            result['Description'] = self.description
        if self.host_operator is not None:
            result['HostOperator'] = self.host_operator
        if self.location is not None:
            result['Location'] = self.location
        if self.name is not None:
            result['Name'] = self.name
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('AttachedRegionNo') is not None:
            self.attached_region_no = m.get('AttachedRegionNo')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HostOperator') is not None:
            self.host_operator = m.get('HostOperator')
        if m.get('Location') is not None:
            self.location = m.get('Location')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAccessPointsResponseBodyAccessPointSet(TeaModel):
    def __init__(self, access_point_type=None):
        self.access_point_type = access_point_type  # type: list[DescribeAccessPointsResponseBodyAccessPointSetAccessPointType]

    def validate(self):
        if self.access_point_type:
            for k in self.access_point_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAccessPointsResponseBodyAccessPointSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccessPointType'] = []
        if self.access_point_type is not None:
            for k in self.access_point_type:
                result['AccessPointType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.access_point_type = []
        if m.get('AccessPointType') is not None:
            for k in m.get('AccessPointType'):
                temp_model = DescribeAccessPointsResponseBodyAccessPointSetAccessPointType()
                self.access_point_type.append(temp_model.from_map(k))
        return self


class DescribeAccessPointsResponseBody(TeaModel):
    def __init__(self, access_point_set=None, page_number=None, page_size=None, request_id=None, total_count=None):
        self.access_point_set = access_point_set  # type: DescribeAccessPointsResponseBodyAccessPointSet
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.access_point_set:
            self.access_point_set.validate()

    def to_map(self):
        _map = super(DescribeAccessPointsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_set is not None:
            result['AccessPointSet'] = self.access_point_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointSet') is not None:
            temp_model = DescribeAccessPointsResponseBodyAccessPointSet()
            self.access_point_set = temp_model.from_map(m['AccessPointSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAccessPointsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAccessPointsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAccessPointsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccessPointsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAccountAttributesRequest(TeaModel):
    def __init__(self, attribute_name=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, zone_id=None):
        # The list of attribute names.
        self.attribute_name = attribute_name  # type: list[str]
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccountAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute_name is not None:
            result['AttributeName'] = self.attribute_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttributeName') is not None:
            self.attribute_name = m.get('AttributeName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem(TeaModel):
    def __init__(self, count=None, disk_category=None, expired_time=None, instance_charge_type=None,
                 instance_type=None, value=None, zone_id=None):
        # The number of privilege attributes in the account.
        self.count = count  # type: int
        # The category of the data disk. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: enhanced SSD (ESSD)
        self.disk_category = disk_category  # type: str
        # The expiration time of a privilege. This parameter is returned only when the account privilege has an expiration time. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.expired_time = expired_time  # type: str
        # The billing method of the instance.
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The value of the resource quota in the specified region. Valid values:
        # 
        # The values returned for the resource quotas to which the following AttributeName values correspond are 0 or positive integers:
        # 
        # * max-security-groups
        # * max-elastic-network-interfaces
        # * max-postpaid-instance-vcpu-count
        # * max-spot-instance-vcpu-count
        # * used-postpaid-instance-vcpu-count
        # * used-spot-instance-vcpu-count
        # * max-postpaid-yundisk-capacity
        # * used-postpaid-yundisk-capacity
        # * max-dedicated-hosts
        # * max-axt-command-count
        # * max-axt-invocation-daily
        # * max-cloud-assistant-activation-count
        # 
        # When the AttributeName parameter is set to supported-postpay-instance-types, an instance type is returned. For more information, see [Instance families](~~25378~~).
        # 
        # When the AttributeName parameter is set to real-name-authentications, one of the following values is returned:
        # 
        # * yes
        # * none
        # * unnecessary
        # 
        # When the AttributeName parameter is set to instance-network-type, one of the following values is returned:
        # 
        # * vpc
        # * classic
        self.value = value  # type: str
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.disk_category is not None:
            result['DiskCategory'] = self.disk_category
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.value is not None:
            result['Value'] = self.value
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('DiskCategory') is not None:
            self.disk_category = m.get('DiskCategory')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues(TeaModel):
    def __init__(self, value_item=None):
        self.value_item = value_item  # type: list[DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem]

    def validate(self):
        if self.value_item:
            for k in self.value_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ValueItem'] = []
        if self.value_item is not None:
            for k in self.value_item:
                result['ValueItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.value_item = []
        if m.get('ValueItem') is not None:
            for k in m.get('ValueItem'):
                temp_model = DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValuesValueItem()
                self.value_item.append(temp_model.from_map(k))
        return self


class DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem(TeaModel):
    def __init__(self, attribute_name=None, attribute_values=None):
        # The type of the resource quota in the specified region. Valid values:
        # 
        # * instance-network-type: available network types
        # * max-security-groups: the maximum number of security groups
        # * max-elastic-network-interfaces: the maximum number of ENIs
        # * max-postpaid-instance-vcpu-count: the maximum number of vCPUs for pay-as-you-go instances
        # * max-spot-instance-vcpu-count: the maximum number of vCPUs for preemptible instances
        # * used-postpaid-instance-vcpu-count: the number of vCPUs that have been allocated to pay-as-you-go instances
        # * used-spot-instance-vcpu-count: the number of vCPUs that have been allocated to preemptible instances
        # * max-postpaid-yundisk-capacity: the maximum capacity of pay-as-you-go data disks
        # * used-postpaid-yundisk-capacity: the capacity of pay-as-you-go disks that have been created
        # * max-dedicated-hosts: the maximum number of dedicated hosts
        # * supported-postpaid-instance-types: the instance types of pay-as-you-go I/O optimized instances
        # * max-axt-command-count: the maximum number of Cloud Assistant commands
        # * max-axt-invocation-daily: the maximum number of Cloud Assistant command executions per day
        # * real-name-authentication: whether an account has completed real-name verification
        # * max-cloud-assistant-activation-count: the maximum number of activation codes that can be created to use to register managed instances
        self.attribute_name = attribute_name  # type: str
        # The specific values of resource quotas.
        self.attribute_values = attribute_values  # type: DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues

    def validate(self):
        if self.attribute_values:
            self.attribute_values.validate()

    def to_map(self):
        _map = super(DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute_name is not None:
            result['AttributeName'] = self.attribute_name
        if self.attribute_values is not None:
            result['AttributeValues'] = self.attribute_values.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttributeName') is not None:
            self.attribute_name = m.get('AttributeName')
        if m.get('AttributeValues') is not None:
            temp_model = DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItemAttributeValues()
            self.attribute_values = temp_model.from_map(m['AttributeValues'])
        return self


class DescribeAccountAttributesResponseBodyAccountAttributeItems(TeaModel):
    def __init__(self, account_attribute_item=None):
        self.account_attribute_item = account_attribute_item  # type: list[DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem]

    def validate(self):
        if self.account_attribute_item:
            for k in self.account_attribute_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAccountAttributesResponseBodyAccountAttributeItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AccountAttributeItem'] = []
        if self.account_attribute_item is not None:
            for k in self.account_attribute_item:
                result['AccountAttributeItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.account_attribute_item = []
        if m.get('AccountAttributeItem') is not None:
            for k in m.get('AccountAttributeItem'):
                temp_model = DescribeAccountAttributesResponseBodyAccountAttributeItemsAccountAttributeItem()
                self.account_attribute_item.append(temp_model.from_map(k))
        return self


class DescribeAccountAttributesResponseBody(TeaModel):
    def __init__(self, account_attribute_items=None, request_id=None):
        # Details about account privileges specified by AccountAttributeItem in the specified region.
        self.account_attribute_items = account_attribute_items  # type: DescribeAccountAttributesResponseBodyAccountAttributeItems
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.account_attribute_items:
            self.account_attribute_items.validate()

    def to_map(self):
        _map = super(DescribeAccountAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_attribute_items is not None:
            result['AccountAttributeItems'] = self.account_attribute_items.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountAttributeItems') is not None:
            temp_model = DescribeAccountAttributesResponseBodyAccountAttributeItems()
            self.account_attribute_items = temp_model.from_map(m['AccountAttributeItems'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAccountAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAccountAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAccountAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAccountAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeActivationsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActivationsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeActivationsRequest(TeaModel):
    def __init__(self, activation_id=None, instance_name=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None, tag=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The default instance name prefix.
        self.instance_name = instance_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The page number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the activation code. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.tag = tag  # type: list[DescribeActivationsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeActivationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeActivationsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeActivationsResponseBodyActivationListTags(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        self.tag_key = tag_key  # type: str
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActivationsResponseBodyActivationListTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeActivationsResponseBodyActivationList(TeaModel):
    def __init__(self, activation_id=None, creation_time=None, deregistered_count=None, description=None,
                 disabled=None, instance_count=None, instance_name=None, ip_address_range=None, registered_count=None,
                 tags=None, time_to_live_in_hours=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The time when the activation code was created.
        self.creation_time = creation_time  # type: str
        # The number of instances that were deregistered.
        self.deregistered_count = deregistered_count  # type: int
        # The description of the activation code.
        self.description = description  # type: str
        # Indicates whether the activation code is disabled.
        self.disabled = disabled  # type: bool
        # The maximum number of times that the activation code can be used to register managed instances.
        self.instance_count = instance_count  # type: int
        # The default instance name prefix.
        self.instance_name = instance_name  # type: str
        # The IP addresses of hosts that are allowed to use the activation code.
        self.ip_address_range = ip_address_range  # type: str
        # The number of instances that were registered.
        self.registered_count = registered_count  # type: int
        self.tags = tags  # type: list[DescribeActivationsResponseBodyActivationListTags]
        # The validity period of the activation code. Unit: hours.
        self.time_to_live_in_hours = time_to_live_in_hours  # type: long

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeActivationsResponseBodyActivationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.deregistered_count is not None:
            result['DeregisteredCount'] = self.deregistered_count
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip_address_range is not None:
            result['IpAddressRange'] = self.ip_address_range
        if self.registered_count is not None:
            result['RegisteredCount'] = self.registered_count
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.time_to_live_in_hours is not None:
            result['TimeToLiveInHours'] = self.time_to_live_in_hours
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeregisteredCount') is not None:
            self.deregistered_count = m.get('DeregisteredCount')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IpAddressRange') is not None:
            self.ip_address_range = m.get('IpAddressRange')
        if m.get('RegisteredCount') is not None:
            self.registered_count = m.get('RegisteredCount')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeActivationsResponseBodyActivationListTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('TimeToLiveInHours') is not None:
            self.time_to_live_in_hours = m.get('TimeToLiveInHours')
        return self


class DescribeActivationsResponseBody(TeaModel):
    def __init__(self, activation_list=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details of the activation codes and their usage information.
        self.activation_list = activation_list  # type: list[DescribeActivationsResponseBodyActivationList]
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.activation_list:
            for k in self.activation_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeActivationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActivationList'] = []
        if self.activation_list is not None:
            for k in self.activation_list:
                result['ActivationList'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.activation_list = []
        if m.get('ActivationList') is not None:
            for k in m.get('ActivationList'):
                temp_model = DescribeActivationsResponseBodyActivationList()
                self.activation_list.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeActivationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeActivationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeActivationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeActivationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoProvisioningGroupHistoryRequest(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, end_time=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 start_time=None):
        # The ID of the auto provisioning group.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        # The end of the time range of the queried data. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The page number of the returned page. Pages start from page 1.
        # 
        # Default value: 1
        self.page_number = page_number  # type: int
        # The number of entries returned per page. Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the auto provisioning group.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The beginning of the time range of the queried data. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail(TeaModel):
    def __init__(self, detail=None, status=None):
        # The execution details of instance creation performed by the single scheduling task.
        self.detail = detail  # type: str
        # The execution status of instance creation performed by the single scheduling task. Valid values:
        # 
        # *   Successful: Instances are created.
        # *   Failed: Instances failed to be created.
        # *   InProgress: Instances are being created.
        # *   Warning: Some instances are created.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails(TeaModel):
    def __init__(self, activity_detail=None):
        self.activity_detail = activity_detail  # type: list[DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail]

    def validate(self):
        if self.activity_detail:
            for k in self.activity_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ActivityDetail'] = []
        if self.activity_detail is not None:
            for k in self.activity_detail:
                result['ActivityDetail'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.activity_detail = []
        if m.get('ActivityDetail') is not None:
            for k in m.get('ActivityDetail'):
                temp_model = DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetailsActivityDetail()
                self.activity_detail.append(temp_model.from_map(k))
        return self


class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory(TeaModel):
    def __init__(self, activity_details=None, last_event_time=None, start_time=None, status=None, task_id=None):
        # An array consisting of ActivityDetail data.
        self.activity_details = activity_details  # type: DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails
        # The execution time of the last instance creation performed by the single scheduling task.
        self.last_event_time = last_event_time  # type: str
        # The start time of executing the single scheduling task.
        self.start_time = start_time  # type: str
        # The execution status of the single scheduling task. Valid values:
        # 
        # *   prepare: The scheduling task is being executed.
        # *   success: The scheduling task is executed.
        # *   failed: The scheduling task failed to be executed.
        self.status = status  # type: str
        # The ID of the scheduling task.
        self.task_id = task_id  # type: str

    def validate(self):
        if self.activity_details:
            self.activity_details.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activity_details is not None:
            result['ActivityDetails'] = self.activity_details.to_map()
        if self.last_event_time is not None:
            result['LastEventTime'] = self.last_event_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivityDetails') is not None:
            temp_model = DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistoryActivityDetails()
            self.activity_details = temp_model.from_map(m['ActivityDetails'])
        if m.get('LastEventTime') is not None:
            self.last_event_time = m.get('LastEventTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories(TeaModel):
    def __init__(self, auto_provisioning_group_history=None):
        self.auto_provisioning_group_history = auto_provisioning_group_history  # type: list[DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory]

    def validate(self):
        if self.auto_provisioning_group_history:
            for k in self.auto_provisioning_group_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AutoProvisioningGroupHistory'] = []
        if self.auto_provisioning_group_history is not None:
            for k in self.auto_provisioning_group_history:
                result['AutoProvisioningGroupHistory'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.auto_provisioning_group_history = []
        if m.get('AutoProvisioningGroupHistory') is not None:
            for k in m.get('AutoProvisioningGroupHistory'):
                temp_model = DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistoriesAutoProvisioningGroupHistory()
                self.auto_provisioning_group_history.append(temp_model.from_map(k))
        return self


class DescribeAutoProvisioningGroupHistoryResponseBody(TeaModel):
    def __init__(self, auto_provisioning_group_histories=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # An array consisting of AutoProvisioningGroupHistory data.
        self.auto_provisioning_group_histories = auto_provisioning_group_histories  # type: DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of queried scheduling tasks in the auto provisioning group.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.auto_provisioning_group_histories:
            self.auto_provisioning_group_histories.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_histories is not None:
            result['AutoProvisioningGroupHistories'] = self.auto_provisioning_group_histories.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupHistories') is not None:
            temp_model = DescribeAutoProvisioningGroupHistoryResponseBodyAutoProvisioningGroupHistories()
            self.auto_provisioning_group_histories = temp_model.from_map(m['AutoProvisioningGroupHistories'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAutoProvisioningGroupHistoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoProvisioningGroupHistoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupHistoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoProvisioningGroupHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoProvisioningGroupInstancesRequest(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the auto provisioning group.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the auto provisioning group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance(TeaModel):
    def __init__(self, cpu=None, creation_time=None, instance_id=None, instance_type=None, io_optimized=None,
                 is_spot=None, memory=None, network_type=None, os_type=None, region_id=None, status=None, zone_id=None):
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # The time when the instance was created.
        self.creation_time = creation_time  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The instance type of the ECS instance.
        self.instance_type = instance_type  # type: str
        # Indicates whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: bool
        # Indicates whether the instance is a preemptible instance.
        self.is_spot = is_spot  # type: bool
        # The memory size of the instance. Unit: MiB.
        self.memory = memory  # type: int
        # The network type of the instance. Valid values:
        # 
        # *   vpc
        # *   classic
        self.network_type = network_type  # type: str
        # The operating system type of the instance. Valid values:
        # 
        # *   windows
        # *   linux
        self.os_type = os_type  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The status of the instance.
        self.status = status  # type: str
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu is not None:
            result['CPU'] = self.cpu
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.is_spot is not None:
            result['IsSpot'] = self.is_spot
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CPU') is not None:
            self.cpu = m.get('CPU')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('IsSpot') is not None:
            self.is_spot = m.get('IsSpot')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeAutoProvisioningGroupInstancesResponseBodyInstances(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance]

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeAutoProvisioningGroupInstancesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeAutoProvisioningGroupInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # An array consisting of Instance data.
        self.instances = instances  # type: DescribeAutoProvisioningGroupInstancesResponseBodyInstances
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of queried instances in the auto provisioning group.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = DescribeAutoProvisioningGroupInstancesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAutoProvisioningGroupInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoProvisioningGroupInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoProvisioningGroupInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoProvisioningGroupsRequest(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, auto_provisioning_group_name=None,
                 auto_provisioning_group_status=None, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of auto provisioning groups. You can specify up to 20 auto provisioning group IDs.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: list[str]
        # The name of the auto provisioning group.
        self.auto_provisioning_group_name = auto_provisioning_group_name  # type: str
        # The statuses of auto provisioning groups.
        self.auto_provisioning_group_status = auto_provisioning_group_status  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the auto provisioning group.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.auto_provisioning_group_name is not None:
            result['AutoProvisioningGroupName'] = self.auto_provisioning_group_name
        if self.auto_provisioning_group_status is not None:
            result['AutoProvisioningGroupStatus'] = self.auto_provisioning_group_status
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('AutoProvisioningGroupName') is not None:
            self.auto_provisioning_group_name = m.get('AutoProvisioningGroupName')
        if m.get('AutoProvisioningGroupStatus') is not None:
            self.auto_provisioning_group_status = m.get('AutoProvisioningGroupStatus')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig(TeaModel):
    def __init__(self, instance_type=None, max_price=None, priority=None, v_switch_id=None, weighted_capacity=None):
        # The instance type specified in the extended configurations.
        self.instance_type = instance_type  # type: str
        # The maximum price of the instance type specified in the extended configurations.
        self.max_price = max_price  # type: float
        # The priority of the instance type specified in the extended configurations. A value of 0 indicates the highest priority.
        self.priority = priority  # type: float
        # The ID of the vSwitch specified in the extended configurations.
        self.v_switch_id = v_switch_id  # type: str
        # The weight of the instance type specified in the extended configurations.
        self.weighted_capacity = weighted_capacity  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_price is not None:
            result['MaxPrice'] = self.max_price
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.weighted_capacity is not None:
            result['WeightedCapacity'] = self.weighted_capacity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxPrice') is not None:
            self.max_price = m.get('MaxPrice')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('WeightedCapacity') is not None:
            self.weighted_capacity = m.get('WeightedCapacity')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs(TeaModel):
    def __init__(self, launch_template_config=None):
        self.launch_template_config = launch_template_config  # type: list[DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig]

    def validate(self):
        if self.launch_template_config:
            for k in self.launch_template_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LaunchTemplateConfig'] = []
        if self.launch_template_config is not None:
            for k in self.launch_template_config:
                result['LaunchTemplateConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.launch_template_config = []
        if m.get('LaunchTemplateConfig') is not None:
            for k in m.get('LaunchTemplateConfig'):
                temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigsLaunchTemplateConfig()
                self.launch_template_config.append(temp_model.from_map(k))
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions(TeaModel):
    def __init__(self, allocation_strategy=None):
        # The provisioning policy for pay-as-you-go instances. Valid values:
        # 
        # - lowest-price: the cost optimization policy. This policy indicates that instance types of the lowest cost are used to create instances.
        # - prioritized: the priority-based policy. This policy indicates that instances are created based on the priority specified by the LaunchTemplateConfig.N.Priority parameter.
        # 
        # >  The LaunchTemplateConfig.N.Priority parameter is set when the auto provisioning group is created, and cannot be modified.
        self.allocation_strategy = allocation_strategy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_strategy is not None:
            result['AllocationStrategy'] = self.allocation_strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationStrategy') is not None:
            self.allocation_strategy = m.get('AllocationStrategy')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions(TeaModel):
    def __init__(self, allocation_strategy=None, instance_interruption_behavior=None,
                 instance_pools_to_use_count=None):
        # The provisioning policy for preemptible instances. Valid values:
        # 
        # - lowest-price: the cost optimization policy. This policy indicates that instance types of the lowest cost are used to create instances.
        # - diversified: balanced distribution policy. This policy indicates that instances are created evenly across multiple zones specified in the extended configurations.
        self.allocation_strategy = allocation_strategy  # type: str
        # The action to be performed after the extra preemptible instances are stopped. Valid values: 
        # 
        # - stop: retains the extra preemptible instances in the stopped state.
        # - terminate: releases the extra preemptible instances.
        self.instance_interruption_behavior = instance_interruption_behavior  # type: str
        # The number of instances that the auto provisioning group used the instance type of the lowest cost to create. 
        # 
        # >  This parameter is set when the auto provisioning group is created, and cannot be modified.
        self.instance_pools_to_use_count = instance_pools_to_use_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_strategy is not None:
            result['AllocationStrategy'] = self.allocation_strategy
        if self.instance_interruption_behavior is not None:
            result['InstanceInterruptionBehavior'] = self.instance_interruption_behavior
        if self.instance_pools_to_use_count is not None:
            result['InstancePoolsToUseCount'] = self.instance_pools_to_use_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationStrategy') is not None:
            self.allocation_strategy = m.get('AllocationStrategy')
        if m.get('InstanceInterruptionBehavior') is not None:
            self.instance_interruption_behavior = m.get('InstanceInterruptionBehavior')
        if m.get('InstancePoolsToUseCount') is not None:
            self.instance_pools_to_use_count = m.get('InstancePoolsToUseCount')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification(TeaModel):
    def __init__(self, default_target_capacity_type=None, pay_as_you_go_target_capacity=None,
                 spot_target_capacity=None, total_target_capacity=None):
        # The billing method of supplemental instances. The target capacity of the auto provisioning group must be at least the sum of the pay-as-you-go instance capacity specified by the PayAsYouGoTargetCapacity parameter and the preemptible instance capacity specified by the SpotTargetCapacity parameter. Valid values: 
        # 
        # - PayAsYouGo: pay-as-you-go
        # - Spot: preemptible instance
        self.default_target_capacity_type = default_target_capacity_type  # type: str
        # The target capacity of pay-as-you-go instances in the auto provisioning group.
        self.pay_as_you_go_target_capacity = pay_as_you_go_target_capacity  # type: float
        # The target capacity of preemptible instances in the auto provisioning group.
        self.spot_target_capacity = spot_target_capacity  # type: float
        # The target capacity of the auto provisioning group. The capacity consists of the following three parts: 
        # 
        # - PayAsYouGoTargetCapacity
        # - SpotTargetCapacity
        # - The supplemental capacity besides instance capacities specified by the PayAsYouGoTargetCapacity and SpotTargetCapacity parameters
        self.total_target_capacity = total_target_capacity  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_target_capacity_type is not None:
            result['DefaultTargetCapacityType'] = self.default_target_capacity_type
        if self.pay_as_you_go_target_capacity is not None:
            result['PayAsYouGoTargetCapacity'] = self.pay_as_you_go_target_capacity
        if self.spot_target_capacity is not None:
            result['SpotTargetCapacity'] = self.spot_target_capacity
        if self.total_target_capacity is not None:
            result['TotalTargetCapacity'] = self.total_target_capacity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultTargetCapacityType') is not None:
            self.default_target_capacity_type = m.get('DefaultTargetCapacityType')
        if m.get('PayAsYouGoTargetCapacity') is not None:
            self.pay_as_you_go_target_capacity = m.get('PayAsYouGoTargetCapacity')
        if m.get('SpotTargetCapacity') is not None:
            self.spot_target_capacity = m.get('SpotTargetCapacity')
        if m.get('TotalTargetCapacity') is not None:
            self.total_target_capacity = m.get('TotalTargetCapacity')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, auto_provisioning_group_name=None,
                 auto_provisioning_group_type=None, creation_time=None, excess_capacity_termination_policy=None, launch_template_configs=None,
                 launch_template_id=None, launch_template_version=None, max_spot_price=None, pay_as_you_go_options=None,
                 region_id=None, spot_options=None, state=None, status=None, target_capacity_specification=None,
                 terminate_instances=None, terminate_instances_with_expiration=None, valid_from=None, valid_until=None):
        # The ID of the auto provisioning group.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        # The name of the auto provisioning group.
        self.auto_provisioning_group_name = auto_provisioning_group_name  # type: str
        # The delivery type of the auto provisioning group. Valid values:
        # 
        # *   request: one-time delivery.After the auto provisioning group is started, it attempts to deliver an instance cluster once. If the cluster fails to be delivered, the group does not retry the operation.
        # *   maintain: continuous delivery.After the auto provisioning group is started, it continuously attempts to deliver an instance cluster. The auto provisioning group compares the real-time capacity and the target cluster capacity. If the cluster does not meet the target capacity, the group creates instances until the cluster meets the target capacity.
        self.auto_provisioning_group_type = auto_provisioning_group_type  # type: str
        # The time when the auto provisioning group was created.
        self.creation_time = creation_time  # type: str
        # Indicates whether to release the scaled-in instances when the real-time capacity exceeds the target capacity and the group is triggered to scale in. Valid values:
        # 
        # *   termination: releases the scaled-in instances.
        # *   no-termination: removes the scaled-in instances from the auto provisioning group but not releases the instances.
        self.excess_capacity_termination_policy = excess_capacity_termination_policy  # type: str
        # Details about the extended configurations.
        self.launch_template_configs = launch_template_configs  # type: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs
        # The ID of the launch template associated with the auto provisioning group.
        self.launch_template_id = launch_template_id  # type: str
        # The version of the launch template associated with the auto provisioning group.
        self.launch_template_version = launch_template_version  # type: str
        # The maximum price for preemptible instances in the auto provisioning group.
        # 
        # >  If both the MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice parameters are specified, the maximum price is the lower value of the two parameters. The LaunchTemplateConfig.N.MaxPrice parameter is set when the auto provisioning group is created, and cannot be modified.
        self.max_spot_price = max_spot_price  # type: float
        # The policies related to pay-as-you-go instances.
        self.pay_as_you_go_options = pay_as_you_go_options  # type: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions
        # The region ID of the auto provisioning group.
        self.region_id = region_id  # type: str
        # The policy related to preemptible instances.
        self.spot_options = spot_options  # type: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions
        # The overall status of instance scheduling of the auto provisioning group. Valid values:
        # 
        # - fulfilled: Scheduling is complete and the instance cluster is delivered.
        # - pending-fulfillment: The instances are being created.
        # - pending-termination: The instances are being removed.
        # - error: An exception has occurred during scheduling and the instance cluster was not delivered.
        self.state = state  # type: str
        # The status of the auto provisioning group. Valid values:
        # 
        # - submitted: The auto provisioning group is created and has not started to execute scheduling tasks.
        # - active: The auto provisioning group is executing scheduling tasks.
        # - deleted: The auto provisioning group is deleted.
        # - deleted-running: The auto provisioning group is being deleted.
        # - modifying: The auto provisioning group is being modified.
        self.status = status  # type: str
        # The settings of the target capacity of the auto provisioning group.
        self.target_capacity_specification = target_capacity_specification  # type: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification
        # Indicates whether to release the instances in the auto provisioning group when the auto provisioning group is deleted. Valid values: 
        # 
        # - true: releases the instances.
        # - false: retains the instances.
        self.terminate_instances = terminate_instances  # type: bool
        # Indicates whether to release instances in the auto provisioning group when the auto provisioning group expires. Valid values: 
        # 
        # - true: releases the instances.
        # - false: removes the instances in the group from the auto provisioning group but not releases the instances.
        self.terminate_instances_with_expiration = terminate_instances_with_expiration  # type: bool
        # The time when the auto provisioning group was started. The period of time between this point in time and the point in time specified by the ValidUntil parameter is the effective time period of the auto provisioning group.
        self.valid_from = valid_from  # type: str
        # The time when the auto provisioning group expires. The period of time between this point in time and the point in time specified by the ValidFrom parameter is the effective time period of the auto provisioning group.
        self.valid_until = valid_until  # type: str

    def validate(self):
        if self.launch_template_configs:
            self.launch_template_configs.validate()
        if self.pay_as_you_go_options:
            self.pay_as_you_go_options.validate()
        if self.spot_options:
            self.spot_options.validate()
        if self.target_capacity_specification:
            self.target_capacity_specification.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.auto_provisioning_group_name is not None:
            result['AutoProvisioningGroupName'] = self.auto_provisioning_group_name
        if self.auto_provisioning_group_type is not None:
            result['AutoProvisioningGroupType'] = self.auto_provisioning_group_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.excess_capacity_termination_policy is not None:
            result['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy
        if self.launch_template_configs is not None:
            result['LaunchTemplateConfigs'] = self.launch_template_configs.to_map()
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_version is not None:
            result['LaunchTemplateVersion'] = self.launch_template_version
        if self.max_spot_price is not None:
            result['MaxSpotPrice'] = self.max_spot_price
        if self.pay_as_you_go_options is not None:
            result['PayAsYouGoOptions'] = self.pay_as_you_go_options.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.spot_options is not None:
            result['SpotOptions'] = self.spot_options.to_map()
        if self.state is not None:
            result['State'] = self.state
        if self.status is not None:
            result['Status'] = self.status
        if self.target_capacity_specification is not None:
            result['TargetCapacitySpecification'] = self.target_capacity_specification.to_map()
        if self.terminate_instances is not None:
            result['TerminateInstances'] = self.terminate_instances
        if self.terminate_instances_with_expiration is not None:
            result['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration
        if self.valid_from is not None:
            result['ValidFrom'] = self.valid_from
        if self.valid_until is not None:
            result['ValidUntil'] = self.valid_until
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('AutoProvisioningGroupName') is not None:
            self.auto_provisioning_group_name = m.get('AutoProvisioningGroupName')
        if m.get('AutoProvisioningGroupType') is not None:
            self.auto_provisioning_group_type = m.get('AutoProvisioningGroupType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ExcessCapacityTerminationPolicy') is not None:
            self.excess_capacity_termination_policy = m.get('ExcessCapacityTerminationPolicy')
        if m.get('LaunchTemplateConfigs') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupLaunchTemplateConfigs()
            self.launch_template_configs = temp_model.from_map(m['LaunchTemplateConfigs'])
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateVersion') is not None:
            self.launch_template_version = m.get('LaunchTemplateVersion')
        if m.get('MaxSpotPrice') is not None:
            self.max_spot_price = m.get('MaxSpotPrice')
        if m.get('PayAsYouGoOptions') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupPayAsYouGoOptions()
            self.pay_as_you_go_options = temp_model.from_map(m['PayAsYouGoOptions'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SpotOptions') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupSpotOptions()
            self.spot_options = temp_model.from_map(m['SpotOptions'])
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TargetCapacitySpecification') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroupTargetCapacitySpecification()
            self.target_capacity_specification = temp_model.from_map(m['TargetCapacitySpecification'])
        if m.get('TerminateInstances') is not None:
            self.terminate_instances = m.get('TerminateInstances')
        if m.get('TerminateInstancesWithExpiration') is not None:
            self.terminate_instances_with_expiration = m.get('TerminateInstancesWithExpiration')
        if m.get('ValidFrom') is not None:
            self.valid_from = m.get('ValidFrom')
        if m.get('ValidUntil') is not None:
            self.valid_until = m.get('ValidUntil')
        return self


class DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups(TeaModel):
    def __init__(self, auto_provisioning_group=None):
        self.auto_provisioning_group = auto_provisioning_group  # type: list[DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup]

    def validate(self):
        if self.auto_provisioning_group:
            for k in self.auto_provisioning_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AutoProvisioningGroup'] = []
        if self.auto_provisioning_group is not None:
            for k in self.auto_provisioning_group:
                result['AutoProvisioningGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.auto_provisioning_group = []
        if m.get('AutoProvisioningGroup') is not None:
            for k in m.get('AutoProvisioningGroup'):
                temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroupsAutoProvisioningGroup()
                self.auto_provisioning_group.append(temp_model.from_map(k))
        return self


class DescribeAutoProvisioningGroupsResponseBody(TeaModel):
    def __init__(self, auto_provisioning_groups=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the auto provisioning groups.
        self.auto_provisioning_groups = auto_provisioning_groups  # type: DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of queried auto provisioning groups.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.auto_provisioning_groups:
            self.auto_provisioning_groups.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_groups is not None:
            result['AutoProvisioningGroups'] = self.auto_provisioning_groups.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroups') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBodyAutoProvisioningGroups()
            self.auto_provisioning_groups = temp_model.from_map(m['AutoProvisioningGroups'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAutoProvisioningGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoProvisioningGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoProvisioningGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoProvisioningGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoSnapshotPolicyExRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the automatic snapshot policy. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with acs: or aliyun. It cannot contain http:// or https://.
        self.key = key  # type: str
        # The value of tag N of the automatic snapshot policy. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with acs: or contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAutoSnapshotPolicyExRequest(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, auto_snapshot_policy_name=None, owner_account=None,
                 owner_id=None, page_number=None, page_size=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None):
        # The ID of the automatic snapshot policy.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The name of the automatic snapshot policy.
        self.auto_snapshot_policy_name = auto_snapshot_policy_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Page start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the automatic snapshot policy. You can call the [DescribeRegions](~~25609~~) operation to query the current list of regions.
        self.region_id = region_id  # type: str
        # The ID of the resource group. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[DescribeAutoSnapshotPolicyExRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.auto_snapshot_policy_name is not None:
            result['AutoSnapshotPolicyName'] = self.auto_snapshot_policy_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('AutoSnapshotPolicyName') is not None:
            self.auto_snapshot_policy_name = m.get('AutoSnapshotPolicyName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeAutoSnapshotPolicyExRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the automatic snapshot policy.
        self.tag_key = tag_key  # type: str
        # The tag value of the automatic snapshot policy.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, auto_snapshot_policy_name=None,
                 copied_snapshots_retention_days=None, creation_time=None, disk_nums=None, enable_cross_region_copy=None, region_id=None,
                 repeat_weekdays=None, resource_group_id=None, retention_days=None, status=None, tags=None,
                 target_copy_regions=None, time_points=None, volume_nums=None):
        # The ID of the automatic snapshot policy.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The name of the automatic snapshot policy.
        self.auto_snapshot_policy_name = auto_snapshot_policy_name  # type: str
        # >  This parameter is in invitational preview and unavailable for general users.
        self.copied_snapshots_retention_days = copied_snapshots_retention_days  # type: int
        # The time when the automatic snapshot policy was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The number of disks to which the automatic snapshot policy is applied.
        self.disk_nums = disk_nums  # type: int
        # >  This parameter is in invitational preview and unavailable for general users.
        self.enable_cross_region_copy = enable_cross_region_copy  # type: bool
        # The region ID of the automatic snapshot policy.
        self.region_id = region_id  # type: str
        # The days of the week on which to create automatic snapshots. Valid values: 1 to 7, which correspond to the days of the week. 1 indicates Monday. One or more days can be specified.
        self.repeat_weekdays = repeat_weekdays  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The retention period of the automatic snapshot. Unit: days. Valid values:
        # 
        # *   \-1: The automatic snapshot is retained until it is deleted.
        # *   1 to 65536: The automatic snapshot is retained for the specified number of days.
        self.retention_days = retention_days  # type: int
        # The state of the automatic snapshot policy. Valid values:
        # 
        # *   Normal: The automatic snapshot policy is normal.
        # *   Expire: The automatic snapshot policy cannot be used because your account has overdue payments.
        self.status = status  # type: str
        # The tags of the automatic snapshot policy.
        self.tags = tags  # type: DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags
        # >  This parameter is in invitational preview and unavailable for general users.
        self.target_copy_regions = target_copy_regions  # type: str
        # The points in time of the day at which to create automatic snapshots.
        # 
        # The time is displayed in UTC+8. Unit: hours. Valid values are 0 to 23, which correspond to the 24 points in time on the hour from 00:00:00 to 23:00:00. 1 indicates 01:00:00. Multiple points in time can be specified.
        # 
        # The parameter value is a JSON array that contains up to 24 points in time separated by commas (,). Example: `["0", "1", ... "23"]`.
        self.time_points = time_points  # type: str
        # The number of extended volumes to which the automatic snapshot policy is applied.
        self.volume_nums = volume_nums  # type: int

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.auto_snapshot_policy_name is not None:
            result['AutoSnapshotPolicyName'] = self.auto_snapshot_policy_name
        if self.copied_snapshots_retention_days is not None:
            result['CopiedSnapshotsRetentionDays'] = self.copied_snapshots_retention_days
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.disk_nums is not None:
            result['DiskNums'] = self.disk_nums
        if self.enable_cross_region_copy is not None:
            result['EnableCrossRegionCopy'] = self.enable_cross_region_copy
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_weekdays is not None:
            result['RepeatWeekdays'] = self.repeat_weekdays
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.target_copy_regions is not None:
            result['TargetCopyRegions'] = self.target_copy_regions
        if self.time_points is not None:
            result['TimePoints'] = self.time_points
        if self.volume_nums is not None:
            result['VolumeNums'] = self.volume_nums
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('AutoSnapshotPolicyName') is not None:
            self.auto_snapshot_policy_name = m.get('AutoSnapshotPolicyName')
        if m.get('CopiedSnapshotsRetentionDays') is not None:
            self.copied_snapshots_retention_days = m.get('CopiedSnapshotsRetentionDays')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DiskNums') is not None:
            self.disk_nums = m.get('DiskNums')
        if m.get('EnableCrossRegionCopy') is not None:
            self.enable_cross_region_copy = m.get('EnableCrossRegionCopy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatWeekdays') is not None:
            self.repeat_weekdays = m.get('RepeatWeekdays')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicyTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TargetCopyRegions') is not None:
            self.target_copy_regions = m.get('TargetCopyRegions')
        if m.get('TimePoints') is not None:
            self.time_points = m.get('TimePoints')
        if m.get('VolumeNums') is not None:
            self.volume_nums = m.get('VolumeNums')
        return self


class DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies(TeaModel):
    def __init__(self, auto_snapshot_policy=None):
        self.auto_snapshot_policy = auto_snapshot_policy  # type: list[DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy]

    def validate(self):
        if self.auto_snapshot_policy:
            for k in self.auto_snapshot_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AutoSnapshotPolicy'] = []
        if self.auto_snapshot_policy is not None:
            for k in self.auto_snapshot_policy:
                result['AutoSnapshotPolicy'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.auto_snapshot_policy = []
        if m.get('AutoSnapshotPolicy') is not None:
            for k in m.get('AutoSnapshotPolicy'):
                temp_model = DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPoliciesAutoSnapshotPolicy()
                self.auto_snapshot_policy.append(temp_model.from_map(k))
        return self


class DescribeAutoSnapshotPolicyExResponseBody(TeaModel):
    def __init__(self, auto_snapshot_policies=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the automatic snapshot policies.
        self.auto_snapshot_policies = auto_snapshot_policies  # type: DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of automatic snapshot policies.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.auto_snapshot_policies:
            self.auto_snapshot_policies.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policies is not None:
            result['AutoSnapshotPolicies'] = self.auto_snapshot_policies.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicies') is not None:
            temp_model = DescribeAutoSnapshotPolicyExResponseBodyAutoSnapshotPolicies()
            self.auto_snapshot_policies = temp_model.from_map(m['AutoSnapshotPolicies'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeAutoSnapshotPolicyExResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoSnapshotPolicyExResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyExResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoSnapshotPolicyExResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAvailableResourceRequest(TeaModel):
    def __init__(self, cores=None, data_disk_category=None, dedicated_host_id=None, destination_resource=None,
                 instance_charge_type=None, instance_type=None, io_optimized=None, memory=None, network_category=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 resource_type=None, scope=None, spot_duration=None, spot_strategy=None, system_disk_category=None, zone_id=None):
        # The number of vCPUs of the instance type. For more information, see [Instance families](~~25378~~).
        # 
        # The Cores parameter takes effect only when the DestinationResource parameter is set to InstanceType.
        self.cores = cores  # type: int
        # The type of the data disk. Valid values:
        # 
        # *   cloud: basic disk.
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: standard SSD.
        # *   ephemeral_ssd: local SSD.
        # *   cloud_essd: ESSD.
        self.data_disk_category = data_disk_category  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The resource type to query. Valid values:
        # 
        # *   Zone: zone.
        # *   IoOptimized: I/O optimized resource.
        # *   InstanceType: instance type.
        # *   SystemDisk: system disk.
        # *   DataDisk: data disk.
        # *   Network: network type.
        # *   ddh: dedicated host.
        # 
        # For more information about how to configure the DestinationResource parameter, see the **Description** section of this topic.
        self.destination_resource = destination_resource  # type: str
        # The billing method of the resource. For more information, see [Billing overview](~~25398~~). Valid values:
        # 
        # *   PrePaid: subscription.
        # *   PostPaid: pay-as-you-go.
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance types. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list.
        # 
        # For more information about how to configure the InstanceType parameter, see the **Description** section of this topic.
        self.instance_type = instance_type  # type: str
        # Specifies whether the instance is an I/O optimized instance. Valid values:
        # 
        # *   none: The instance is a non-I/O optimized instance.
        # *   optimized: The instance is an I/O optimized instance.
        # 
        # Default value: optimized.
        self.io_optimized = io_optimized  # type: str
        # The memory size of the instance type. Unit: GiB. For more information, see [Instance families](~~25378~~).
        # 
        # The Memory parameter takes effect only when the DestinationResource parameter is set to InstanceType.
        self.memory = memory  # type: float
        # The network type of the cluster. Valid values:
        # 
        # *   vpc
        # *   classic
        self.network_category = network_category  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region for which to query resources. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance.
        # *   disk: cloud disk.
        # *   reservedinstance: reserved instance.
        # *   ddh: dedicated host.
        self.resource_type = resource_type  # type: str
        # The scope of the reserved instance. Valid values:
        # 
        # *   Region: regional.
        # *   Zone: zonal.
        self.scope = scope  # type: str
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   The following protection periods are available in invitational preview: 2, 3, 4, 5, and 6 hours. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The bidding policy for pay-as-you-go instances. Valid values:
        # 
        # *   NoSpot: The instance is a pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price is automatically used as the bid price. The market price can be up to the pay-as-you-go price.
        # 
        # Default value: NoSpot.
        # 
        # The SpotStrategy parameter takes effect only when the InstanceChargeType parameter is set to PostPaid.
        self.spot_strategy = spot_strategy  # type: str
        # The category of the system disk. Valid values:
        # 
        # *   cloud: basic disk.
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: standard SSD.
        # *   ephemeral_ssd: local SSD.
        # *   cloud_essd: enhanced SSD (ESSD).
        # 
        # Default value: cloud_efficiency.
        # 
        # > When the ResourceType parameter is set to instance and the DestinationResource parameter is set to DataDisk, you must set the SystemDiskCategory parameter. If you do not set this parameter, the default value takes effect.
        self.system_disk_category = system_disk_category  # type: str
        # The ID of the zone where the instance resides.
        # 
        # This parameter is empty by default. When this parameter is empty, the system returns resources that match the other criteria in all zones within the region specified by `RegionId`.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableResourceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.destination_resource is not None:
            result['DestinationResource'] = self.destination_resource
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.network_category is not None:
            result['NetworkCategory'] = self.network_category
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DestinationResource') is not None:
            self.destination_resource = m.get('DestinationResource')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NetworkCategory') is not None:
            self.network_category = m.get('NetworkCategory')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource(TeaModel):
    def __init__(self, max=None, min=None, status=None, status_category=None, unit=None, value=None):
        # The maximum number of available resources of a specific type. No value is returned when the parameter is empty.
        self.max = max  # type: int
        # The minimum number of available resources of a specific type. No value is returned when the parameter is empty.
        self.min = min  # type: int
        # The state of the resource. Valid values:
        # 
        # *   Available
        # *   SoldOut
        self.status = status  # type: str
        # The resource category based on the stock. Valid values:
        # 
        # *   WithStock: Resources are in sufficient stock.
        # *   ClosedWithStock: Resources are insufficient. We recommend that you use other resources that are in sufficient stock.
        # *   WithoutStock: Resources are sold out and will be replenished. We recommend that you use other resources that are in sufficient stock.
        # *   ClosedWithoutStock: Resources are sold out and will not be replenished. We recommend that you use other resources that are in sufficient stock.
        self.status_category = status_category  # type: str
        # The unit of the resource type. No value is returned when the parameter is empty.
        self.unit = unit  # type: str
        # The resource type.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.status is not None:
            result['Status'] = self.status
        if self.status_category is not None:
            result['StatusCategory'] = self.status_category
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusCategory') is not None:
            self.status_category = m.get('StatusCategory')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources(TeaModel):
    def __init__(self, supported_resource=None):
        self.supported_resource = supported_resource  # type: list[DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource]

    def validate(self):
        if self.supported_resource:
            for k in self.supported_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportedResource'] = []
        if self.supported_resource is not None:
            for k in self.supported_resource:
                result['SupportedResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.supported_resource = []
        if m.get('SupportedResource') is not None:
            for k in m.get('SupportedResource'):
                temp_model = DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource()
                self.supported_resource.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource(TeaModel):
    def __init__(self, supported_resources=None, type=None):
        # Details about the resources.
        self.supported_resources = supported_resources  # type: DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources
        # The type of a resource. Valid values:
        # 
        # *   Zone: zone.
        # *   IoOptimized: I/O optimized resource.
        # *   InstanceType: instance type.
        # *   SystemDisk: system disk.
        # *   DataDisk: data disk.
        # *   Network: network type.
        # *   ddh: dedicated host.
        self.type = type  # type: str

    def validate(self):
        if self.supported_resources:
            self.supported_resources.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_resources is not None:
            result['SupportedResources'] = self.supported_resources.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedResources') is not None:
            temp_model = DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources()
            self.supported_resources = temp_model.from_map(m['SupportedResources'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources(TeaModel):
    def __init__(self, available_resource=None):
        self.available_resource = available_resource  # type: list[DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource]

    def validate(self):
        if self.available_resource:
            for k in self.available_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableResource'] = []
        if self.available_resource is not None:
            for k in self.available_resource:
                result['AvailableResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_resource = []
        if m.get('AvailableResource') is not None:
            for k in m.get('AvailableResource'):
                temp_model = DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource()
                self.available_resource.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone(TeaModel):
    def __init__(self, available_resources=None, region_id=None, status=None, status_category=None, zone_id=None):
        # Details about the resources that can be created in the zone.
        self.available_resources = available_resources  # type: DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources
        # The ID of the region where the instance resides.
        self.region_id = region_id  # type: str
        # The state of resources in the zone. Valid values:
        # 
        # *   Available
        # *   SoldOut
        self.status = status  # type: str
        # The resource category based on the stock. Valid values:
        # 
        # *   WithStock: Resources are in sufficient stock.
        # *   ClosedWithStock: Resources are insufficient. We recommend that you use other resources that are in sufficient stock.
        # *   WithoutStock: Resources are sold out and will be replenished. We recommend that you use other resources that are in sufficient stock.
        # *   ClosedWithoutStock: Resources are sold out and will not be replenished. We recommend that you use other resources that are in sufficient stock.
        self.status_category = status_category  # type: str
        # The ID of the zone in which the instance resides.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.available_resources:
            self.available_resources.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_resources is not None:
            result['AvailableResources'] = self.available_resources.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.status_category is not None:
            result['StatusCategory'] = self.status_category
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableResources') is not None:
            temp_model = DescribeAvailableResourceResponseBodyAvailableZonesAvailableZoneAvailableResources()
            self.available_resources = temp_model.from_map(m['AvailableResources'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusCategory') is not None:
            self.status_category = m.get('StatusCategory')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeAvailableResourceResponseBodyAvailableZones(TeaModel):
    def __init__(self, available_zone=None):
        self.available_zone = available_zone  # type: list[DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone]

    def validate(self):
        if self.available_zone:
            for k in self.available_zone:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBodyAvailableZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableZone'] = []
        if self.available_zone is not None:
            for k in self.available_zone:
                result['AvailableZone'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_zone = []
        if m.get('AvailableZone') is not None:
            for k in m.get('AvailableZone'):
                temp_model = DescribeAvailableResourceResponseBodyAvailableZonesAvailableZone()
                self.available_zone.append(temp_model.from_map(k))
        return self


class DescribeAvailableResourceResponseBody(TeaModel):
    def __init__(self, available_zones=None, request_id=None):
        # Details about the zones in which resources are available.
        self.available_zones = available_zones  # type: DescribeAvailableResourceResponseBodyAvailableZones
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.available_zones:
            self.available_zones.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_zones is not None:
            result['AvailableZones'] = self.available_zones.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableZones') is not None:
            temp_model = DescribeAvailableResourceResponseBodyAvailableZones()
            self.available_zones = temp_model.from_map(m['AvailableZones'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAvailableResourceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAvailableResourceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAvailableResourceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAvailableResourceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBandwidthLimitationRequest(TeaModel):
    def __init__(self, instance_charge_type=None, instance_type=None, operation_type=None, owner_account=None,
                 owner_id=None, region_id=None, resource_id=None, resource_owner_account=None, resource_owner_id=None,
                 spot_strategy=None):
        # The billing method of the instance. For more information, see [Billing overview](~~25398~~). Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type. For more information about the values, see [Instance families](~~25378~~).
        # 
        # >  This parameter is required.
        self.instance_type = instance_type  # type: str
        # Specifies the operation for which to query the maximum public bandwidth. Valid values:
        # 
        # *   Upgrade: upgrades the public bandwidth.
        # *   Downgrade: downgrades the public bandwidth.
        # *   Create: creates an ECS instance.
        # 
        # Default value: Create.
        self.operation_type = operation_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource.
        # 
        # >  This parameter is required when the OperationType parameter is set to Upgrade or Downgrade.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The preemption policy for the preemptible or pay-as-you-go instance. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with user-defined maximum hourly prices.
        # *   SpotAsPriceGo: The system automatically offers a bid, which is not higher than the pay-as-you-go price for the same instance type.
        # 
        # Default value: NoSpot.
        # 
        # >  This parameter takes effect only when the InstanceChargeType parameter is set to PostPaid.
        self.spot_strategy = spot_strategy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBandwidthLimitationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        return self


class DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth(TeaModel):
    def __init__(self, internet_charge_type=None, max=None, min=None, unit=None):
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth
        # *   PayByTraffic
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum public bandwidth.
        self.max = max  # type: int
        # The minimum public bandwidth.
        self.min = min  # type: int
        # The unit of the public bandwidth.
        self.unit = unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class DescribeBandwidthLimitationResponseBodyBandwidths(TeaModel):
    def __init__(self, bandwidth=None):
        self.bandwidth = bandwidth  # type: list[DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth]

    def validate(self):
        if self.bandwidth:
            for k in self.bandwidth:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBandwidthLimitationResponseBodyBandwidths, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Bandwidth'] = []
        if self.bandwidth is not None:
            for k in self.bandwidth:
                result['Bandwidth'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bandwidth = []
        if m.get('Bandwidth') is not None:
            for k in m.get('Bandwidth'):
                temp_model = DescribeBandwidthLimitationResponseBodyBandwidthsBandwidth()
                self.bandwidth.append(temp_model.from_map(k))
        return self


class DescribeBandwidthLimitationResponseBody(TeaModel):
    def __init__(self, bandwidths=None, request_id=None):
        # Details about the maximum public bandwidth.
        self.bandwidths = bandwidths  # type: DescribeBandwidthLimitationResponseBodyBandwidths
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.bandwidths:
            self.bandwidths.validate()

    def to_map(self):
        _map = super(DescribeBandwidthLimitationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidths is not None:
            result['Bandwidths'] = self.bandwidths.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidths') is not None:
            temp_model = DescribeBandwidthLimitationResponseBodyBandwidths()
            self.bandwidths = temp_model.from_map(m['Bandwidths'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBandwidthLimitationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBandwidthLimitationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBandwidthLimitationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBandwidthLimitationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBandwidthPackagesRequest(TeaModel):
    def __init__(self, bandwidth_package_id=None, nat_gateway_id=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBandwidthPackagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse(TeaModel):
    def __init__(self, allocation_id=None, ip_address=None):
        self.allocation_id = allocation_id  # type: str
        self.ip_address = ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses(TeaModel):
    def __init__(self, public_ip_addresse=None):
        self.public_ip_addresse = public_ip_addresse  # type: list[DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse]

    def validate(self):
        if self.public_ip_addresse:
            for k in self.public_ip_addresse:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PublicIpAddresse'] = []
        if self.public_ip_addresse is not None:
            for k in self.public_ip_addresse:
                result['PublicIpAddresse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.public_ip_addresse = []
        if m.get('PublicIpAddresse') is not None:
            for k in m.get('PublicIpAddresse'):
                temp_model = DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddressesPublicIpAddresse()
                self.public_ip_addresse.append(temp_model.from_map(k))
        return self


class DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage(TeaModel):
    def __init__(self, bandwidth=None, bandwidth_package_id=None, business_status=None, creation_time=None,
                 description=None, isp=None, instance_charge_type=None, internet_charge_type=None, ip_count=None, name=None,
                 nat_gateway_id=None, public_ip_addresses=None, region_id=None, status=None, zone_id=None):
        self.bandwidth = bandwidth  # type: str
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.business_status = business_status  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.isp = isp  # type: str
        self.instance_charge_type = instance_charge_type  # type: str
        self.internet_charge_type = internet_charge_type  # type: str
        self.ip_count = ip_count  # type: str
        self.name = name  # type: str
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.public_ip_addresses = public_ip_addresses  # type: DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses
        self.region_id = region_id  # type: str
        self.status = status  # type: str
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.public_ip_addresses:
            self.public_ip_addresses.validate()

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_count is not None:
            result['IpCount'] = self.ip_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.public_ip_addresses is not None:
            result['PublicIpAddresses'] = self.public_ip_addresses.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpCount') is not None:
            self.ip_count = m.get('IpCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('PublicIpAddresses') is not None:
            temp_model = DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackagePublicIpAddresses()
            self.public_ip_addresses = temp_model.from_map(m['PublicIpAddresses'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeBandwidthPackagesResponseBodyBandwidthPackages(TeaModel):
    def __init__(self, bandwidth_package=None):
        self.bandwidth_package = bandwidth_package  # type: list[DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage]

    def validate(self):
        if self.bandwidth_package:
            for k in self.bandwidth_package:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponseBodyBandwidthPackages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BandwidthPackage'] = []
        if self.bandwidth_package is not None:
            for k in self.bandwidth_package:
                result['BandwidthPackage'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bandwidth_package = []
        if m.get('BandwidthPackage') is not None:
            for k in m.get('BandwidthPackage'):
                temp_model = DescribeBandwidthPackagesResponseBodyBandwidthPackagesBandwidthPackage()
                self.bandwidth_package.append(temp_model.from_map(k))
        return self


class DescribeBandwidthPackagesResponseBody(TeaModel):
    def __init__(self, bandwidth_packages=None, page_number=None, page_size=None, request_id=None, total_count=None):
        self.bandwidth_packages = bandwidth_packages  # type: DescribeBandwidthPackagesResponseBodyBandwidthPackages
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.bandwidth_packages:
            self.bandwidth_packages.validate()

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_packages is not None:
            result['BandwidthPackages'] = self.bandwidth_packages.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackages') is not None:
            temp_model = DescribeBandwidthPackagesResponseBodyBandwidthPackages()
            self.bandwidth_packages = temp_model.from_map(m['BandwidthPackages'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeBandwidthPackagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBandwidthPackagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBandwidthPackagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBandwidthPackagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCapacityReservationInstancesRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None):
        # The ID of the capacity reservation.
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeCapacityReservationInstancesRequest(TeaModel):
    def __init__(self, private_pool_options=None, max_results=None, next_token=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: DescribeCapacityReservationInstancesRequestPrivatePoolOptions
        # The number of entries to return on each page.
        # 
        # Maximum value: 100
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token used to start the query. The token is obtained from the response of the previous request.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the capacity reservation. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = DescribeCapacityReservationInstancesRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet(TeaModel):
    def __init__(self, instance_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem(TeaModel):
    def __init__(self, instance_id_set=None):
        self.instance_id_set = instance_id_set  # type: list[DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet]

    def validate(self):
        if self.instance_id_set:
            for k in self.instance_id_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceIdSet'] = []
        if self.instance_id_set is not None:
            for k in self.instance_id_set:
                result['InstanceIdSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_id_set = []
        if m.get('InstanceIdSet') is not None:
            for k in m.get('InstanceIdSet'):
                temp_model = DescribeCapacityReservationInstancesResponseBodyCapacityReservationItemInstanceIdSet()
                self.instance_id_set.append(temp_model.from_map(k))
        return self


class DescribeCapacityReservationInstancesResponseBody(TeaModel):
    def __init__(self, capacity_reservation_item=None, max_results=None, next_token=None, request_id=None,
                 total_count=None):
        # Details about the instances that were created by using the capacity reservation.
        self.capacity_reservation_item = capacity_reservation_item  # type: DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem
        # The number of entries returned per page.
        self.max_results = max_results  # type: int
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of entries that meet the query criteria.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.capacity_reservation_item:
            self.capacity_reservation_item.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_reservation_item is not None:
            result['CapacityReservationItem'] = self.capacity_reservation_item.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityReservationItem') is not None:
            temp_model = DescribeCapacityReservationInstancesResponseBodyCapacityReservationItem()
            self.capacity_reservation_item = temp_model.from_map(m['CapacityReservationItem'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCapacityReservationInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCapacityReservationInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCapacityReservationInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCapacityReservationsRequestPrivatePoolOptions(TeaModel):
    def __init__(self, ids=None):
        # The IDs of capacity reservations. The value can be a JSON array that consists of up to 100 capacity reservation IDs. Separate the IDs with commas (,).
        self.ids = ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationsRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class DescribeCapacityReservationsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the capacity reservation. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the capacity reservation. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCapacityReservationsRequest(TeaModel):
    def __init__(self, private_pool_options=None, instance_charge_type=None, instance_type=None, max_results=None,
                 next_token=None, owner_account=None, owner_id=None, platform=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, status=None, tag=None, zone_id=None):
        self.private_pool_options = private_pool_options  # type: DescribeCapacityReservationsRequestPrivatePoolOptions
        # The billing method of instances to be created by using the capacity reservation. Valid values:
        # 
        # *   PostPaid: pay-as-you-go
        # *   PrePaid: subscription
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The maximum number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token used to start the next query. Set the value to the NextToken value obtained from the response to the previous request.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The operating system type of instances to be created by using the capacity reservation. Valid values:
        # 
        # *   windows: Windows operating systems
        # *   linux: Linux operating systems
        # *   all: all operating system types
        # 
        # Default value: all.
        self.platform = platform  # type: str
        # The region ID of the capacity reservation. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the capacity reservation belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The state of the capacity reservation. Valid values:
        # 
        # *   All: All states.
        # *   Pending: The capacity reservation is being initialized. Scheduled capacity reservations enter the Pending state after they are created.
        # *   Preparing: The capacity reservation is being prepared. Scheduled capacity reservations are in the Preparing state while resources are being provisioned.
        # *   Prepared: The capacity reservation is to take effect. After resources are provisioned, scheduled capacity reservations remain in the Prepared state until they take effect.
        # *   Active: The capacity reservation is in effect.
        # *   Released: The capacity reservation has been released manually or automatically when it expired.
        # 
        # Default value: Active.
        self.status = status  # type: str
        # The tags.
        self.tag = tag  # type: list[DescribeCapacityReservationsRequestTag]
        # The zone ID of the capacity reservation.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = DescribeCapacityReservationsRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeCapacityReservationsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource(TeaModel):
    def __init__(self, instance_type=None, total_amount=None, used_amount=None, zone_id=None):
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The total number of instances for which capacity of an instance type is reserved.
        self.total_amount = total_amount  # type: int
        # The number of instances that have used the capacity reservation.
        self.used_amount = used_amount  # type: int
        # The zone ID.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.total_amount is not None:
            result['TotalAmount'] = self.total_amount
        if self.used_amount is not None:
            result['UsedAmount'] = self.used_amount
        if self.zone_id is not None:
            result['zoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('TotalAmount') is not None:
            self.total_amount = m.get('TotalAmount')
        if m.get('UsedAmount') is not None:
            self.used_amount = m.get('UsedAmount')
        if m.get('zoneId') is not None:
            self.zone_id = m.get('zoneId')
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources(TeaModel):
    def __init__(self, allocated_resource=None):
        self.allocated_resource = allocated_resource  # type: list[DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource]

    def validate(self):
        if self.allocated_resource:
            for k in self.allocated_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllocatedResource'] = []
        if self.allocated_resource is not None:
            for k in self.allocated_resource:
                result['AllocatedResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.allocated_resource = []
        if m.get('AllocatedResource') is not None:
            for k in m.get('AllocatedResource'):
                temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResourcesAllocatedResource()
                self.allocated_resource.append(temp_model.from_map(k))
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the capacity reservation.
        self.tag_key = tag_key  # type: str
        # The tag value of the capacity reservation.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem(TeaModel):
    def __init__(self, allocated_resources=None, description=None, end_time=None, end_time_type=None,
                 instance_charge_type=None, platform=None, private_pool_options_id=None, private_pool_options_match_criteria=None,
                 private_pool_options_name=None, region_id=None, reserved_instance_id=None, resource_group_id=None, saving_plan_id=None,
                 start_time=None, start_time_type=None, status=None, tags=None, time_slot=None):
        # Details about the allocated resources.
        self.allocated_resources = allocated_resources  # type: DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources
        # The description of the capacity reservation.
        self.description = description  # type: str
        # The time when the capacity reservation expires.
        self.end_time = end_time  # type: str
        # The release mode of the capacity reservation. Valid values:
        # 
        # *   Limited: The capacity reservation is automatically released at the specified time.
        # *   Unlimited: The capacity reservation is manually released. You can release it at anytime.
        self.end_time_type = end_time_type  # type: str
        # The billing method of instances to be created by using the capacity reservation. Valid values:
        # 
        # *   PostPaid: pay-as-you-go
        # *   PrePaid: subscription
        self.instance_charge_type = instance_charge_type  # type: str
        # The operating system type of instances to be created by using the capacity reservation. Valid values:
        # 
        # *   windows
        # *   linux
        self.platform = platform  # type: str
        # The ID of the capacity reservation.
        self.private_pool_options_id = private_pool_options_id  # type: str
        # The type of the private pool associated with the capacity reservation. Valid values:
        # 
        # *   Open: open private pool
        # *   Target: targeted private pool
        self.private_pool_options_match_criteria = private_pool_options_match_criteria  # type: str
        # The name of the capacity reservation.
        self.private_pool_options_name = private_pool_options_name  # type: str
        # The region ID of the capacity reservation.
        self.region_id = region_id  # type: str
        # The ID of the reserved instance used with the capacity reservation.
        self.reserved_instance_id = reserved_instance_id  # type: str
        # The ID of the resource group to which the capacity reservation belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of the savings plan used with the capacity reservation.
        self.saving_plan_id = saving_plan_id  # type: str
        # The time when the capacity reservation takes effect.
        self.start_time = start_time  # type: str
        # The mode in which the capacity reservation takes effect. Valid values:
        # 
        # - Now: The capacity reservation takes effect as soon as it is created.
        # - Later: The capacity reservation takes effect at the specified time.
        self.start_time_type = start_time_type  # type: str
        # The state of the capacity reservation. Valid values:
        # 
        # *   Pending: The capacity reservation is being initialized.
        # *   Preparing: The capacity reservation is being prepared.
        # *   Prepared: The capacity reservation is to take effect.
        # *   Active: The capacity reservation is in effect.
        # *   Released: The capacity reservation has been released manually or automatically when it expired.
        self.status = status  # type: str
        # The tags of the capacity reservation.
        self.tags = tags  # type: DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.time_slot = time_slot  # type: str

    def validate(self):
        if self.allocated_resources:
            self.allocated_resources.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocated_resources is not None:
            result['AllocatedResources'] = self.allocated_resources.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_time_type is not None:
            result['EndTimeType'] = self.end_time_type
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.private_pool_options_id is not None:
            result['PrivatePoolOptionsId'] = self.private_pool_options_id
        if self.private_pool_options_match_criteria is not None:
            result['PrivatePoolOptionsMatchCriteria'] = self.private_pool_options_match_criteria
        if self.private_pool_options_name is not None:
            result['PrivatePoolOptionsName'] = self.private_pool_options_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.saving_plan_id is not None:
            result['SavingPlanId'] = self.saving_plan_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_time_type is not None:
            result['StartTimeType'] = self.start_time_type
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.time_slot is not None:
            result['TimeSlot'] = self.time_slot
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocatedResources') is not None:
            temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemAllocatedResources()
            self.allocated_resources = temp_model.from_map(m['AllocatedResources'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimeType') is not None:
            self.end_time_type = m.get('EndTimeType')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('PrivatePoolOptionsId') is not None:
            self.private_pool_options_id = m.get('PrivatePoolOptionsId')
        if m.get('PrivatePoolOptionsMatchCriteria') is not None:
            self.private_pool_options_match_criteria = m.get('PrivatePoolOptionsMatchCriteria')
        if m.get('PrivatePoolOptionsName') is not None:
            self.private_pool_options_name = m.get('PrivatePoolOptionsName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SavingPlanId') is not None:
            self.saving_plan_id = m.get('SavingPlanId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimeType') is not None:
            self.start_time_type = m.get('StartTimeType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItemTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TimeSlot') is not None:
            self.time_slot = m.get('TimeSlot')
        return self


class DescribeCapacityReservationsResponseBodyCapacityReservationSet(TeaModel):
    def __init__(self, capacity_reservation_item=None):
        self.capacity_reservation_item = capacity_reservation_item  # type: list[DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem]

    def validate(self):
        if self.capacity_reservation_item:
            for k in self.capacity_reservation_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBodyCapacityReservationSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CapacityReservationItem'] = []
        if self.capacity_reservation_item is not None:
            for k in self.capacity_reservation_item:
                result['CapacityReservationItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.capacity_reservation_item = []
        if m.get('CapacityReservationItem') is not None:
            for k in m.get('CapacityReservationItem'):
                temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSetCapacityReservationItem()
                self.capacity_reservation_item.append(temp_model.from_map(k))
        return self


class DescribeCapacityReservationsResponseBody(TeaModel):
    def __init__(self, capacity_reservation_set=None, max_results=None, next_token=None, request_id=None,
                 total_count=None):
        # Details about the capacity reservations.
        self.capacity_reservation_set = capacity_reservation_set  # type: DescribeCapacityReservationsResponseBodyCapacityReservationSet
        # The maximum number of entries returned per page.
        self.max_results = max_results  # type: int
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.capacity_reservation_set:
            self.capacity_reservation_set.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_reservation_set is not None:
            result['CapacityReservationSet'] = self.capacity_reservation_set.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityReservationSet') is not None:
            temp_model = DescribeCapacityReservationsResponseBodyCapacityReservationSet()
            self.capacity_reservation_set = temp_model.from_map(m['CapacityReservationSet'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCapacityReservationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCapacityReservationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCapacityReservationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCapacityReservationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClassicLinkInstancesRequest(TeaModel):
    def __init__(self, instance_id=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, vpc_id=None):
        # The ID of the instance. You can specify up to 100 instance IDs in a single request. Separate the instance IDs with commas (,).
        self.instance_id = instance_id  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the VPC. The ClassicLink feature must be enabled for the specified VPC. For more information, see [Establish a ClassicLink connection](~~65413~~).
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClassicLinkInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeClassicLinkInstancesResponseBodyLinksLink(TeaModel):
    def __init__(self, instance_id=None, vpc_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the VPC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClassicLinkInstancesResponseBodyLinksLink, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeClassicLinkInstancesResponseBodyLinks(TeaModel):
    def __init__(self, link=None):
        self.link = link  # type: list[DescribeClassicLinkInstancesResponseBodyLinksLink]

    def validate(self):
        if self.link:
            for k in self.link:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClassicLinkInstancesResponseBodyLinks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Link'] = []
        if self.link is not None:
            for k in self.link:
                result['Link'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.link = []
        if m.get('Link') is not None:
            for k in m.get('Link'):
                temp_model = DescribeClassicLinkInstancesResponseBodyLinksLink()
                self.link.append(temp_model.from_map(k))
        return self


class DescribeClassicLinkInstancesResponseBody(TeaModel):
    def __init__(self, links=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # The details about the ClassicLink connections between the instances located in the classic network and the VPCs.
        self.links = links  # type: DescribeClassicLinkInstancesResponseBodyLinks
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of ClassicLink connections.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.links:
            self.links.validate()

    def to_map(self):
        _map = super(DescribeClassicLinkInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.links is not None:
            result['Links'] = self.links.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Links') is not None:
            temp_model = DescribeClassicLinkInstancesResponseBodyLinks()
            self.links = temp_model.from_map(m['Links'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeClassicLinkInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClassicLinkInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClassicLinkInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClassicLinkInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudAssistantStatusRequest(TeaModel):
    def __init__(self, instance_id=None, ostype=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. You can specify up to 100 instance IDs in each request.
        self.instance_id = instance_id  # type: list[str]
        # The operating system type of the instance. Valid values:
        # 
        # *   Windows
        # *   Linux
        self.ostype = ostype  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudAssistantStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus(TeaModel):
    def __init__(self, active_task_count=None, cloud_assistant_status=None, cloud_assistant_version=None,
                 instance_id=None, invocation_count=None, last_heartbeat_time=None, last_invoked_time=None, ostype=None,
                 support_session_manager=None):
        # The number of commands that are being run.
        self.active_task_count = active_task_count  # type: long
        # Indicates whether the Cloud Assistant client is installed on the instance.
        self.cloud_assistant_status = cloud_assistant_status  # type: str
        # The version number of the Cloud Assistant client.
        self.cloud_assistant_version = cloud_assistant_version  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The total number of commands that have been run.
        self.invocation_count = invocation_count  # type: long
        # The last heartbeat time of Cloud Assistant.
        self.last_heartbeat_time = last_heartbeat_time  # type: str
        # The time when commands were last run.
        self.last_invoked_time = last_invoked_time  # type: str
        # The operating system type of the instance. Valid values:
        # 
        # *   Windows
        # *   Linux
        self.ostype = ostype  # type: str
        # Indicates whether the version of the Cloud Assistant client supports the session management feature.
        self.support_session_manager = support_session_manager  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.active_task_count is not None:
            result['ActiveTaskCount'] = self.active_task_count
        if self.cloud_assistant_status is not None:
            result['CloudAssistantStatus'] = self.cloud_assistant_status
        if self.cloud_assistant_version is not None:
            result['CloudAssistantVersion'] = self.cloud_assistant_version
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invocation_count is not None:
            result['InvocationCount'] = self.invocation_count
        if self.last_heartbeat_time is not None:
            result['LastHeartbeatTime'] = self.last_heartbeat_time
        if self.last_invoked_time is not None:
            result['LastInvokedTime'] = self.last_invoked_time
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.support_session_manager is not None:
            result['SupportSessionManager'] = self.support_session_manager
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActiveTaskCount') is not None:
            self.active_task_count = m.get('ActiveTaskCount')
        if m.get('CloudAssistantStatus') is not None:
            self.cloud_assistant_status = m.get('CloudAssistantStatus')
        if m.get('CloudAssistantVersion') is not None:
            self.cloud_assistant_version = m.get('CloudAssistantVersion')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvocationCount') is not None:
            self.invocation_count = m.get('InvocationCount')
        if m.get('LastHeartbeatTime') is not None:
            self.last_heartbeat_time = m.get('LastHeartbeatTime')
        if m.get('LastInvokedTime') is not None:
            self.last_invoked_time = m.get('LastInvokedTime')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('SupportSessionManager') is not None:
            self.support_session_manager = m.get('SupportSessionManager')
        return self


class DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet(TeaModel):
    def __init__(self, instance_cloud_assistant_status=None):
        self.instance_cloud_assistant_status = instance_cloud_assistant_status  # type: list[DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus]

    def validate(self):
        if self.instance_cloud_assistant_status:
            for k in self.instance_cloud_assistant_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceCloudAssistantStatus'] = []
        if self.instance_cloud_assistant_status is not None:
            for k in self.instance_cloud_assistant_status:
                result['InstanceCloudAssistantStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_cloud_assistant_status = []
        if m.get('InstanceCloudAssistantStatus') is not None:
            for k in m.get('InstanceCloudAssistantStatus'):
                temp_model = DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSetInstanceCloudAssistantStatus()
                self.instance_cloud_assistant_status.append(temp_model.from_map(k))
        return self


class DescribeCloudAssistantStatusResponseBody(TeaModel):
    def __init__(self, instance_cloud_assistant_status_set=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the installation status of the Cloud Assistant client.
        self.instance_cloud_assistant_status_set = instance_cloud_assistant_status_set  # type: DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.instance_cloud_assistant_status_set:
            self.instance_cloud_assistant_status_set.validate()

    def to_map(self):
        _map = super(DescribeCloudAssistantStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_cloud_assistant_status_set is not None:
            result['InstanceCloudAssistantStatusSet'] = self.instance_cloud_assistant_status_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceCloudAssistantStatusSet') is not None:
            temp_model = DescribeCloudAssistantStatusResponseBodyInstanceCloudAssistantStatusSet()
            self.instance_cloud_assistant_status_set = temp_model.from_map(m['InstanceCloudAssistantStatusSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCloudAssistantStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCloudAssistantStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCloudAssistantStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudAssistantStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClustersRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClustersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeClustersResponseBodyClustersCluster(TeaModel):
    def __init__(self, cluster_id=None):
        self.cluster_id = cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClustersResponseBodyClustersCluster, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        return self


class DescribeClustersResponseBodyClusters(TeaModel):
    def __init__(self, cluster=None):
        self.cluster = cluster  # type: list[DescribeClustersResponseBodyClustersCluster]

    def validate(self):
        if self.cluster:
            for k in self.cluster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClustersResponseBodyClusters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cluster'] = []
        if self.cluster is not None:
            for k in self.cluster:
                result['Cluster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cluster = []
        if m.get('Cluster') is not None:
            for k in m.get('Cluster'):
                temp_model = DescribeClustersResponseBodyClustersCluster()
                self.cluster.append(temp_model.from_map(k))
        return self


class DescribeClustersResponseBody(TeaModel):
    def __init__(self, clusters=None, request_id=None):
        self.clusters = clusters  # type: DescribeClustersResponseBodyClusters
        self.request_id = request_id  # type: str

    def validate(self):
        if self.clusters:
            self.clusters.validate()

    def to_map(self):
        _map = super(DescribeClustersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.clusters is not None:
            result['Clusters'] = self.clusters.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Clusters') is not None:
            temp_model = DescribeClustersResponseBodyClusters()
            self.clusters = temp_model.from_map(m['Clusters'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClustersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClustersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClustersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClustersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCommandsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the command. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the command. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommandsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCommandsRequest(TeaModel):
    def __init__(self, command_id=None, content_encoding=None, description=None, latest=None, name=None,
                 owner_account=None, owner_id=None, page_number=None, page_size=None, provider=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None, type=None):
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The encoding mode of the `CommandContent` and `Output` response parameters. Valid values:
        # 
        # *   PlainText: returns the original command content and command output.
        # *   Base64: returns the Base64-encoded command content and command output.
        # 
        # Default value: Base64.
        self.content_encoding = content_encoding  # type: str
        # >  This parameter is deprecated and does not take effect.
        self.description = description  # type: str
        # Specifies whether to query only the latest version of common commands if common commands are queried. This parameter does not affect the query for private commands. Valid values:
        # 
        # *   true: queries only the latest version of common commands.
        # *   false: queries all versions of common commands.
        # 
        # Default value: false.
        self.latest = latest  # type: bool
        # The name of the command. Partial command names are not supported.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return per page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The provider of the common command. Take note of the following items:
        # 
        # *   If you do not specify this parameter, all the commands that you created are queried.
        # 
        # *   If you set this parameter to `AlibabaCloud`, all the common commands provided by Alibaba Cloud are queried.
        # 
        # *   If you set this parameter to a specific provider, all the common commands provided by the provider are queried, such as the following ones:
        # 
        #     *   If you set `Provider` to AlibabaCloud.ECS.GuestOS, all the common commands provided by `AlibabaCloud.ECS.GuestOS` are queried.
        #     *   If you set `Provider` to AlibabaCloud.ECS.GuestOSDiagnose, all the common commands provided by `AlibabaCloud.ECS.GuestOSDiagnose` are queried.
        self.provider = provider  # type: str
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.tag = tag  # type: list[DescribeCommandsRequestTag]
        # The command type. Valid values:
        # 
        # *   RunBatScript: batch command, applicable to Windows instances
        # *   RunPowerShellScript: PowerShell command, applicable to Windows instances
        # *   RunShellScript: shell command, applicable to Linux instances
        self.type = type  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommandsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.description is not None:
            result['Description'] = self.description
        if self.latest is not None:
            result['Latest'] = self.latest
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Latest') is not None:
            self.latest = m.get('Latest')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeCommandsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinitionPossibleValues(TeaModel):
    def __init__(self, possible_value=None):
        self.possible_value = possible_value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinitionPossibleValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.possible_value is not None:
            result['PossibleValue'] = self.possible_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PossibleValue') is not None:
            self.possible_value = m.get('PossibleValue')
        return self


class DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinition(TeaModel):
    def __init__(self, default_value=None, description=None, parameter_name=None, possible_values=None,
                 required=None):
        # The default value of the custom parameter.
        self.default_value = default_value  # type: str
        # The description of the custom parameter.
        self.description = description  # type: str
        # The name of the custom parameter.
        self.parameter_name = parameter_name  # type: str
        # The valid values of the custom enumeration parameter.
        self.possible_values = possible_values  # type: DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinitionPossibleValues
        # Indicates whether the custom parameter is required. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        self.required = required  # type: bool

    def validate(self):
        if self.possible_values:
            self.possible_values.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinition, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.description is not None:
            result['Description'] = self.description
        if self.parameter_name is not None:
            result['ParameterName'] = self.parameter_name
        if self.possible_values is not None:
            result['PossibleValues'] = self.possible_values.to_map()
        if self.required is not None:
            result['Required'] = self.required
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ParameterName') is not None:
            self.parameter_name = m.get('ParameterName')
        if m.get('PossibleValues') is not None:
            temp_model = DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinitionPossibleValues()
            self.possible_values = temp_model.from_map(m['PossibleValues'])
        if m.get('Required') is not None:
            self.required = m.get('Required')
        return self


class DescribeCommandsResponseBodyCommandsCommandParameterDefinitions(TeaModel):
    def __init__(self, parameter_definition=None):
        self.parameter_definition = parameter_definition  # type: list[DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinition]

    def validate(self):
        if self.parameter_definition:
            for k in self.parameter_definition:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandParameterDefinitions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ParameterDefinition'] = []
        if self.parameter_definition is not None:
            for k in self.parameter_definition:
                result['ParameterDefinition'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.parameter_definition = []
        if m.get('ParameterDefinition') is not None:
            for k in m.get('ParameterDefinition'):
                temp_model = DescribeCommandsResponseBodyCommandsCommandParameterDefinitionsParameterDefinition()
                self.parameter_definition.append(temp_model.from_map(k))
        return self


class DescribeCommandsResponseBodyCommandsCommandParameterNames(TeaModel):
    def __init__(self, parameter_name=None):
        self.parameter_name = parameter_name  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandParameterNames, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.parameter_name is not None:
            result['ParameterName'] = self.parameter_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ParameterName') is not None:
            self.parameter_name = m.get('ParameterName')
        return self


class DescribeCommandsResponseBodyCommandsCommandTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the command.
        self.tag_key = tag_key  # type: str
        # The tag value of the command.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeCommandsResponseBodyCommandsCommandTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeCommandsResponseBodyCommandsCommandTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommandTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeCommandsResponseBodyCommandsCommandTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeCommandsResponseBodyCommandsCommand(TeaModel):
    def __init__(self, category=None, command_content=None, command_id=None, creation_time=None, description=None,
                 enable_parameter=None, invoke_times=None, latest=None, name=None, parameter_definitions=None, parameter_names=None,
                 provider=None, tags=None, timeout=None, type=None, version=None, working_dir=None):
        # The category of the common command.
        self.category = category  # type: str
        # The Base64-encoded command content.
        self.command_content = command_content  # type: str
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The time when the command was created.
        self.creation_time = creation_time  # type: str
        # The description of the command.
        self.description = description  # type: str
        # Indicates whether the custom parameter feature was enabled for the command.
        self.enable_parameter = enable_parameter  # type: bool
        # The number of tasks created by using the command.
        self.invoke_times = invoke_times  # type: int
        # Indicates whether the common command is of the latest version. If multiple common commands from the same provider (`Provider`) belong to the same category and have the same name, these commands are of different versions of the same command. This parameter is not returned for the Cloud Assistant commands that you created.
        self.latest = latest  # type: bool
        # The name of the command.
        self.name = name  # type: str
        # Details about the custom parameters.
        self.parameter_definitions = parameter_definitions  # type: DescribeCommandsResponseBodyCommandsCommandParameterDefinitions
        # A list of custom parameter names that are parsed from the command content specified when the command was being created. If the custom parameter feature is not enabled, an empty list is returned.
        self.parameter_names = parameter_names  # type: DescribeCommandsResponseBodyCommandsCommandParameterNames
        # The provider of the common command.
        self.provider = provider  # type: str
        # The list of tags added to the command.
        self.tags = tags  # type: DescribeCommandsResponseBodyCommandsCommandTags
        # The timeout period.
        self.timeout = timeout  # type: long
        # The type of the command.
        self.type = type  # type: str
        # The version of the common command. If multiple common commands from the same provider (`Provider`) belong to the same category and have the same name, these commands are of different versions of the same command. This parameter is not returned for the Cloud Assistant commands that you created.
        self.version = version  # type: int
        # The working directory of the command on the Elastic Compute Service (ECS) instance.
        self.working_dir = working_dir  # type: str

    def validate(self):
        if self.parameter_definitions:
            self.parameter_definitions.validate()
        if self.parameter_names:
            self.parameter_names.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommandsCommand, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_parameter is not None:
            result['EnableParameter'] = self.enable_parameter
        if self.invoke_times is not None:
            result['InvokeTimes'] = self.invoke_times
        if self.latest is not None:
            result['Latest'] = self.latest
        if self.name is not None:
            result['Name'] = self.name
        if self.parameter_definitions is not None:
            result['ParameterDefinitions'] = self.parameter_definitions.to_map()
        if self.parameter_names is not None:
            result['ParameterNames'] = self.parameter_names.to_map()
        if self.provider is not None:
            result['Provider'] = self.provider
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        if self.version is not None:
            result['Version'] = self.version
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableParameter') is not None:
            self.enable_parameter = m.get('EnableParameter')
        if m.get('InvokeTimes') is not None:
            self.invoke_times = m.get('InvokeTimes')
        if m.get('Latest') is not None:
            self.latest = m.get('Latest')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ParameterDefinitions') is not None:
            temp_model = DescribeCommandsResponseBodyCommandsCommandParameterDefinitions()
            self.parameter_definitions = temp_model.from_map(m['ParameterDefinitions'])
        if m.get('ParameterNames') is not None:
            temp_model = DescribeCommandsResponseBodyCommandsCommandParameterNames()
            self.parameter_names = temp_model.from_map(m['ParameterNames'])
        if m.get('Provider') is not None:
            self.provider = m.get('Provider')
        if m.get('Tags') is not None:
            temp_model = DescribeCommandsResponseBodyCommandsCommandTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class DescribeCommandsResponseBodyCommands(TeaModel):
    def __init__(self, command=None):
        self.command = command  # type: list[DescribeCommandsResponseBodyCommandsCommand]

    def validate(self):
        if self.command:
            for k in self.command:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBodyCommands, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Command'] = []
        if self.command is not None:
            for k in self.command:
                result['Command'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.command = []
        if m.get('Command') is not None:
            for k in m.get('Command'):
                temp_model = DescribeCommandsResponseBodyCommandsCommand()
                self.command.append(temp_model.from_map(k))
        return self


class DescribeCommandsResponseBody(TeaModel):
    def __init__(self, commands=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the commands.
        self.commands = commands  # type: DescribeCommandsResponseBodyCommands
        # The number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of commands.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.commands:
            self.commands.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commands is not None:
            result['Commands'] = self.commands.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Commands') is not None:
            temp_model = DescribeCommandsResponseBodyCommands()
            self.commands = temp_model.from_map(m['Commands'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCommandsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCommandsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCommandsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCommandsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDedicatedHostAutoRenewRequest(TeaModel):
    def __init__(self, dedicated_host_ids=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of the dedicated hosts. You can specify up to 100 subscription dedicated host IDs. Separate multiple IDs with commas (,).
        self.dedicated_host_ids = dedicated_host_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostAutoRenewRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostIds') is not None:
            self.dedicated_host_ids = m.get('DedicatedHostIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute(TeaModel):
    def __init__(self, auto_renew_enabled=None, auto_renew_with_ecs=None, dedicated_host_id=None, duration=None,
                 period_unit=None, renewal_status=None):
        # Indicates whether the subscription dedicated host is automatically renewed. Valid values:
        # 
        # *   true: The dedicated host is automatically renewed.
        # *   false: The dedicated host is not automatically renewed.
        self.auto_renew_enabled = auto_renew_enabled  # type: bool
        # Indicates whether the subscription dedicated host is automatically renewed along with the subscription Elastic Compute Service (ECS) instances hosted on it if the new expiration time of the renewed instances is later than the expiration time of the dedicated host. Valid values:
        # 
        # *   AutoRenewWithEcs: The subscription dedicated host is automatically renewed along with the subscription ECS instances hosted on it.
        # *   StopRenewWithEcs: The subscription dedicated host is not automatically renewed along with the subscription ECS instances hosted on it.
        self.auto_renew_with_ecs = auto_renew_with_ecs  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The auto-renewal period.
        self.duration = duration  # type: int
        # The unit of the auto-renewal period. Valid values:
        # 
        # *   Week
        # *   Month
        self.period_unit = period_unit  # type: str
        # Indicates whether the subscription dedicated host is automatically renewed. Valid values:
        # 
        # *   AutoRenewal: The dedicated host is automatically renewed.
        # *   Normal: The dedicated host is not automatically renewed, and you will receive notifications for renewal.
        # *   NotRenewal: The dedicated host is not renewed, and no expiration notification is sent. Notifications for renewal are automatically sent three days before the dedicated host expires. You can change the value of this parameter from NotRenewal to Normal for the dedicated host and manually renew it by calling the [RenewDedicatedHosts](~~93287~~) operation. Alternatively, you can set this parameter to AutoRenewal to configure the dedicated host to be automatically renewed.
        self.renewal_status = renewal_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew_enabled is not None:
            result['AutoRenewEnabled'] = self.auto_renew_enabled
        if self.auto_renew_with_ecs is not None:
            result['AutoRenewWithEcs'] = self.auto_renew_with_ecs
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenewEnabled') is not None:
            self.auto_renew_enabled = m.get('AutoRenewEnabled')
        if m.get('AutoRenewWithEcs') is not None:
            self.auto_renew_with_ecs = m.get('AutoRenewWithEcs')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        return self


class DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes(TeaModel):
    def __init__(self, dedicated_host_renew_attribute=None):
        self.dedicated_host_renew_attribute = dedicated_host_renew_attribute  # type: list[DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute]

    def validate(self):
        if self.dedicated_host_renew_attribute:
            for k in self.dedicated_host_renew_attribute:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DedicatedHostRenewAttribute'] = []
        if self.dedicated_host_renew_attribute is not None:
            for k in self.dedicated_host_renew_attribute:
                result['DedicatedHostRenewAttribute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dedicated_host_renew_attribute = []
        if m.get('DedicatedHostRenewAttribute') is not None:
            for k in m.get('DedicatedHostRenewAttribute'):
                temp_model = DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributesDedicatedHostRenewAttribute()
                self.dedicated_host_renew_attribute.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostAutoRenewResponseBody(TeaModel):
    def __init__(self, dedicated_host_renew_attributes=None, request_id=None):
        # Details about the auto-renewal attributes of the dedicated hosts.
        self.dedicated_host_renew_attributes = dedicated_host_renew_attributes  # type: DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.dedicated_host_renew_attributes:
            self.dedicated_host_renew_attributes.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostAutoRenewResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_renew_attributes is not None:
            result['DedicatedHostRenewAttributes'] = self.dedicated_host_renew_attributes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostRenewAttributes') is not None:
            temp_model = DescribeDedicatedHostAutoRenewResponseBodyDedicatedHostRenewAttributes()
            self.dedicated_host_renew_attributes = temp_model.from_map(m['DedicatedHostRenewAttributes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDedicatedHostAutoRenewResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDedicatedHostAutoRenewResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostAutoRenewResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDedicatedHostAutoRenewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDedicatedHostClustersRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the dedicated host cluster. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the dedicated host cluster. Valid values of N: 1 to 20. The tag value cannot be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDedicatedHostClustersRequest(TeaModel):
    def __init__(self, dedicated_host_cluster_ids=None, dedicated_host_cluster_name=None, lock_reason=None,
                 owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, status=None, tag=None, zone_id=None):
        # The IDs of dedicated host clusters. The value can be a JSON array that consists of up to 100 dedicated host cluster IDs in the format of `["dc-xxxxxxxxx", "dc-yyyyyyyyy", ... "dc-zzzzzzzzz"]`. Separate the IDs with commas (,).
        self.dedicated_host_cluster_ids = dedicated_host_cluster_ids  # type: str
        # The name of the dedicated host cluster.
        self.dedicated_host_cluster_name = dedicated_host_cluster_name  # type: str
        # >  This parameter is unavailable for use.
        self.lock_reason = lock_reason  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the dedicated host cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the dedicated host cluster belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # >  This parameter is unavailable for use.
        self.status = status  # type: str
        # The list of the tags.
        self.tag = tag  # type: list[DescribeDedicatedHostClustersRequestTag]
        # The zone ID of the dedicated host cluster. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_ids is not None:
            result['DedicatedHostClusterIds'] = self.dedicated_host_cluster_ids
        if self.dedicated_host_cluster_name is not None:
            result['DedicatedHostClusterName'] = self.dedicated_host_cluster_name
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterIds') is not None:
            self.dedicated_host_cluster_ids = m.get('DedicatedHostClusterIds')
        if m.get('DedicatedHostClusterName') is not None:
            self.dedicated_host_cluster_name = m.get('DedicatedHostClusterName')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDedicatedHostClustersRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType(TeaModel):
    def __init__(self, available_instance_capacity=None, instance_type=None):
        # The available capacity of the ECS instance type.
        self.available_instance_capacity = available_instance_capacity  # type: int
        # The ECS instance type.
        self.instance_type = instance_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_instance_capacity is not None:
            result['AvailableInstanceCapacity'] = self.available_instance_capacity
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableInstanceCapacity') is not None:
            self.available_instance_capacity = m.get('AvailableInstanceCapacity')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes(TeaModel):
    def __init__(self, available_instance_type=None):
        self.available_instance_type = available_instance_type  # type: list[DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType]

    def validate(self):
        if self.available_instance_type:
            for k in self.available_instance_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableInstanceType'] = []
        if self.available_instance_type is not None:
            for k in self.available_instance_type:
                result['AvailableInstanceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_instance_type = []
        if m.get('AvailableInstanceType') is not None:
            for k in m.get('AvailableInstanceType'):
                temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypesAvailableInstanceType()
                self.available_instance_type.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity(TeaModel):
    def __init__(self, available_disk=None, data_disk_category=None, total_disk=None):
        # The available capacity of the local disk. Unit: GiB.
        self.available_disk = available_disk  # type: int
        # The category of the data disk. Valid values:
        # 
        # - cloud: basic disk
        # - cloud_efficiency: ultra disk
        # - cloud_ssd: standard SSD
        # - ephemeral_ssd: local SSD
        # - cloud_essd: enhanced SSD (ESSD)
        self.data_disk_category = data_disk_category  # type: str
        # The total capacity of the local disk. Unit: GiB.
        self.total_disk = total_disk  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_disk is not None:
            result['AvailableDisk'] = self.available_disk
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.total_disk is not None:
            result['TotalDisk'] = self.total_disk
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableDisk') is not None:
            self.available_disk = m.get('AvailableDisk')
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('TotalDisk') is not None:
            self.total_disk = m.get('TotalDisk')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities(TeaModel):
    def __init__(self, local_storage_capacity=None):
        self.local_storage_capacity = local_storage_capacity  # type: list[DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity]

    def validate(self):
        if self.local_storage_capacity:
            for k in self.local_storage_capacity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LocalStorageCapacity'] = []
        if self.local_storage_capacity is not None:
            for k in self.local_storage_capacity:
                result['LocalStorageCapacity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.local_storage_capacity = []
        if m.get('LocalStorageCapacity') is not None:
            for k in m.get('LocalStorageCapacity'):
                temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacitiesLocalStorageCapacity()
                self.local_storage_capacity.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity(TeaModel):
    def __init__(self, available_instance_types=None, available_memory=None, available_vcpus=None,
                 local_storage_capacities=None, total_memory=None, total_vcpus=None):
        # The available capacity of the Elastic Compute Service (ECS) instance types in the dedicated host cluster.
        self.available_instance_types = available_instance_types  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes
        # The size of available memory. Unit: GiB.
        self.available_memory = available_memory  # type: int
        # The number of available vCPUs.
        self.available_vcpus = available_vcpus  # type: int
        # The local storage capacity.
        self.local_storage_capacities = local_storage_capacities  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities
        # The total memory size. Unit: GiB.
        self.total_memory = total_memory  # type: int
        # The total number of vCPUs.
        self.total_vcpus = total_vcpus  # type: int

    def validate(self):
        if self.available_instance_types:
            self.available_instance_types.validate()
        if self.local_storage_capacities:
            self.local_storage_capacities.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_instance_types is not None:
            result['AvailableInstanceTypes'] = self.available_instance_types.to_map()
        if self.available_memory is not None:
            result['AvailableMemory'] = self.available_memory
        if self.available_vcpus is not None:
            result['AvailableVcpus'] = self.available_vcpus
        if self.local_storage_capacities is not None:
            result['LocalStorageCapacities'] = self.local_storage_capacities.to_map()
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.total_vcpus is not None:
            result['TotalVcpus'] = self.total_vcpus
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableInstanceTypes') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityAvailableInstanceTypes()
            self.available_instance_types = temp_model.from_map(m['AvailableInstanceTypes'])
        if m.get('AvailableMemory') is not None:
            self.available_memory = m.get('AvailableMemory')
        if m.get('AvailableVcpus') is not None:
            self.available_vcpus = m.get('AvailableVcpus')
        if m.get('LocalStorageCapacities') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacityLocalStorageCapacities()
            self.local_storage_capacities = temp_model.from_map(m['LocalStorageCapacities'])
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('TotalVcpus') is not None:
            self.total_vcpus = m.get('TotalVcpus')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds(TeaModel):
    def __init__(self, dedicated_host_id=None):
        self.dedicated_host_id = dedicated_host_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the dedicated host cluster.
        self.tag_key = tag_key  # type: str
        # The tag value of the dedicated host cluster.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster(TeaModel):
    def __init__(self, dedicated_host_cluster_capacity=None, dedicated_host_cluster_id=None,
                 dedicated_host_cluster_name=None, dedicated_host_ids=None, description=None, region_id=None, resource_group_id=None, tags=None,
                 zone_id=None):
        # The capacity of the dedicated host cluster.
        self.dedicated_host_cluster_capacity = dedicated_host_cluster_capacity  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The name of the dedicated host cluster.
        self.dedicated_host_cluster_name = dedicated_host_cluster_name  # type: str
        # The IDs of dedicated hosts in the dedicated host cluster.
        self.dedicated_host_ids = dedicated_host_ids  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds
        # The description of the dedicated host cluster.
        self.description = description  # type: str
        # The region ID of the dedicated host cluster.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the dedicated host cluster belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The tags of the dedicated host cluster.
        self.tags = tags  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags
        # The zone ID of the dedicated host cluster.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.dedicated_host_cluster_capacity:
            self.dedicated_host_cluster_capacity.validate()
        if self.dedicated_host_ids:
            self.dedicated_host_ids.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_capacity is not None:
            result['DedicatedHostClusterCapacity'] = self.dedicated_host_cluster_capacity.to_map()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_cluster_name is not None:
            result['DedicatedHostClusterName'] = self.dedicated_host_cluster_name
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterCapacity') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostClusterCapacity()
            self.dedicated_host_cluster_capacity = temp_model.from_map(m['DedicatedHostClusterCapacity'])
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostClusterName') is not None:
            self.dedicated_host_cluster_name = m.get('DedicatedHostClusterName')
        if m.get('DedicatedHostIds') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterDedicatedHostIds()
            self.dedicated_host_ids = temp_model.from_map(m['DedicatedHostIds'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostClusterTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters(TeaModel):
    def __init__(self, dedicated_host_cluster=None):
        self.dedicated_host_cluster = dedicated_host_cluster  # type: list[DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster]

    def validate(self):
        if self.dedicated_host_cluster:
            for k in self.dedicated_host_cluster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DedicatedHostCluster'] = []
        if self.dedicated_host_cluster is not None:
            for k in self.dedicated_host_cluster:
                result['DedicatedHostCluster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dedicated_host_cluster = []
        if m.get('DedicatedHostCluster') is not None:
            for k in m.get('DedicatedHostCluster'):
                temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClustersDedicatedHostCluster()
                self.dedicated_host_cluster.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostClustersResponseBody(TeaModel):
    def __init__(self, dedicated_host_clusters=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the dedicated host clusters.
        self.dedicated_host_clusters = dedicated_host_clusters  # type: DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of dedicated host clusters.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.dedicated_host_clusters:
            self.dedicated_host_clusters.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_clusters is not None:
            result['DedicatedHostClusters'] = self.dedicated_host_clusters.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusters') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBodyDedicatedHostClusters()
            self.dedicated_host_clusters = temp_model.from_map(m['DedicatedHostClusters'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDedicatedHostClustersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDedicatedHostClustersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostClustersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDedicatedHostClustersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDedicatedHostTypesRequest(TeaModel):
    def __init__(self, dedicated_host_type=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, supported_instance_type_family=None):
        # The dedicated host type. For more information, see [Dedicated host types](~~68564~~).
        self.dedicated_host_type = dedicated_host_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ECS instance family supported by the dedicated host type.
        self.supported_instance_type_family = supported_instance_type_family  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.supported_instance_type_family is not None:
            result['SupportedInstanceTypeFamily'] = self.supported_instance_type_family
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SupportedInstanceTypeFamily') is not None:
            self.supported_instance_type_family = m.get('SupportedInstanceTypeFamily')
        return self


class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies(TeaModel):
    def __init__(self, supported_instance_type_family=None):
        self.supported_instance_type_family = supported_instance_type_family  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_type_family is not None:
            result['SupportedInstanceTypeFamily'] = self.supported_instance_type_family
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedInstanceTypeFamily') is not None:
            self.supported_instance_type_family = m.get('SupportedInstanceTypeFamily')
        return self


class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList(TeaModel):
    def __init__(self, supported_instance_types_list=None):
        self.supported_instance_types_list = supported_instance_types_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_types_list is not None:
            result['SupportedInstanceTypesList'] = self.supported_instance_types_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedInstanceTypesList') is not None:
            self.supported_instance_types_list = m.get('SupportedInstanceTypesList')
        return self


class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType(TeaModel):
    def __init__(self, cores=None, cpu_over_commit_ratio_range=None, dedicated_host_type=None, gpuspec=None,
                 local_storage_amount=None, local_storage_capacity=None, local_storage_category=None, memory_size=None,
                 physical_gpus=None, sockets=None, support_cpu_over_commit_ratio=None, supported_instance_type_families=None,
                 supported_instance_types_list=None, total_vcpus=None, total_vgpus=None):
        # The number of cores in a single physical CPU.
        self.cores = cores  # type: int
        # The supported CPU overcommit ratio range.
        self.cpu_over_commit_ratio_range = cpu_over_commit_ratio_range  # type: str
        # The type of the dedicated host. You can submit a ticket to request more dedicated host types.
        self.dedicated_host_type = dedicated_host_type  # type: str
        # The GPU model.
        self.gpuspec = gpuspec  # type: str
        # The number of local disks on a dedicated host.
        self.local_storage_amount = local_storage_amount  # type: int
        # The capacity of a local disk. Unit: GiB.
        self.local_storage_capacity = local_storage_capacity  # type: long
        # The category of the local disks.
        self.local_storage_category = local_storage_category  # type: str
        # The size of the memory. Unit: GiB.
        self.memory_size = memory_size  # type: float
        # The number of physical GPUs.
        self.physical_gpus = physical_gpus  # type: int
        # The number of physical CPUs.
        self.sockets = sockets  # type: int
        # Indicates whether the CPU overcommit ratio setting is supported.
        self.support_cpu_over_commit_ratio = support_cpu_over_commit_ratio  # type: bool
        # The ECS instance families supported by the dedicated host.
        self.supported_instance_type_families = supported_instance_type_families  # type: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies
        # The ECS instance types supported by the dedicated host.
        self.supported_instance_types_list = supported_instance_types_list  # type: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList
        # The total number of vCPUs.
        self.total_vcpus = total_vcpus  # type: int
        # The total number of vGPUs.
        self.total_vgpus = total_vgpus  # type: int

    def validate(self):
        if self.supported_instance_type_families:
            self.supported_instance_type_families.validate()
        if self.supported_instance_types_list:
            self.supported_instance_types_list.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.cpu_over_commit_ratio_range is not None:
            result['CpuOverCommitRatioRange'] = self.cpu_over_commit_ratio_range
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.gpuspec is not None:
            result['GPUSpec'] = self.gpuspec
        if self.local_storage_amount is not None:
            result['LocalStorageAmount'] = self.local_storage_amount
        if self.local_storage_capacity is not None:
            result['LocalStorageCapacity'] = self.local_storage_capacity
        if self.local_storage_category is not None:
            result['LocalStorageCategory'] = self.local_storage_category
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        if self.physical_gpus is not None:
            result['PhysicalGpus'] = self.physical_gpus
        if self.sockets is not None:
            result['Sockets'] = self.sockets
        if self.support_cpu_over_commit_ratio is not None:
            result['SupportCpuOverCommitRatio'] = self.support_cpu_over_commit_ratio
        if self.supported_instance_type_families is not None:
            result['SupportedInstanceTypeFamilies'] = self.supported_instance_type_families.to_map()
        if self.supported_instance_types_list is not None:
            result['SupportedInstanceTypesList'] = self.supported_instance_types_list.to_map()
        if self.total_vcpus is not None:
            result['TotalVcpus'] = self.total_vcpus
        if self.total_vgpus is not None:
            result['TotalVgpus'] = self.total_vgpus
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('CpuOverCommitRatioRange') is not None:
            self.cpu_over_commit_ratio_range = m.get('CpuOverCommitRatioRange')
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('GPUSpec') is not None:
            self.gpuspec = m.get('GPUSpec')
        if m.get('LocalStorageAmount') is not None:
            self.local_storage_amount = m.get('LocalStorageAmount')
        if m.get('LocalStorageCapacity') is not None:
            self.local_storage_capacity = m.get('LocalStorageCapacity')
        if m.get('LocalStorageCategory') is not None:
            self.local_storage_category = m.get('LocalStorageCategory')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        if m.get('PhysicalGpus') is not None:
            self.physical_gpus = m.get('PhysicalGpus')
        if m.get('Sockets') is not None:
            self.sockets = m.get('Sockets')
        if m.get('SupportCpuOverCommitRatio') is not None:
            self.support_cpu_over_commit_ratio = m.get('SupportCpuOverCommitRatio')
        if m.get('SupportedInstanceTypeFamilies') is not None:
            temp_model = DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypeFamilies()
            self.supported_instance_type_families = temp_model.from_map(m['SupportedInstanceTypeFamilies'])
        if m.get('SupportedInstanceTypesList') is not None:
            temp_model = DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostTypeSupportedInstanceTypesList()
            self.supported_instance_types_list = temp_model.from_map(m['SupportedInstanceTypesList'])
        if m.get('TotalVcpus') is not None:
            self.total_vcpus = m.get('TotalVcpus')
        if m.get('TotalVgpus') is not None:
            self.total_vgpus = m.get('TotalVgpus')
        return self


class DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes(TeaModel):
    def __init__(self, dedicated_host_type=None):
        self.dedicated_host_type = dedicated_host_type  # type: list[DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType]

    def validate(self):
        if self.dedicated_host_type:
            for k in self.dedicated_host_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DedicatedHostType'] = []
        if self.dedicated_host_type is not None:
            for k in self.dedicated_host_type:
                result['DedicatedHostType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dedicated_host_type = []
        if m.get('DedicatedHostType') is not None:
            for k in m.get('DedicatedHostType'):
                temp_model = DescribeDedicatedHostTypesResponseBodyDedicatedHostTypesDedicatedHostType()
                self.dedicated_host_type.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostTypesResponseBody(TeaModel):
    def __init__(self, dedicated_host_types=None, request_id=None):
        # The information about the dedicated host type.
        self.dedicated_host_types = dedicated_host_types  # type: DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.dedicated_host_types:
            self.dedicated_host_types.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_types is not None:
            result['DedicatedHostTypes'] = self.dedicated_host_types.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostTypes') is not None:
            temp_model = DescribeDedicatedHostTypesResponseBodyDedicatedHostTypes()
            self.dedicated_host_types = temp_model.from_map(m['DedicatedHostTypes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDedicatedHostTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDedicatedHostTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDedicatedHostTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDedicatedHostsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the dedicated host. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the dedicated host. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDedicatedHostsRequest(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None, dedicated_host_ids=None, dedicated_host_name=None,
                 dedicated_host_type=None, lock_reason=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None, status=None,
                 tag=None, zone_id=None):
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The IDs of dedicated hosts. You can specify up to 100 dedicated host IDs in a single request. Separate the IDs with commas (,).
        self.dedicated_host_ids = dedicated_host_ids  # type: str
        # The name of the dedicated host.
        self.dedicated_host_name = dedicated_host_name  # type: str
        # The type of the dedicated host. You can call the [DescribeDedicatedHostTypes](~~134240~~) operation to obtain the most recent list of dedicated host types.
        self.dedicated_host_type = dedicated_host_type  # type: str
        # The reason why the dedicated host is locked. Valid values:
        # 
        # *   financial: The dedicated host is locked due to overdue payments.
        # *   security: The dedicated host is locked due to security reasons.
        self.lock_reason = lock_reason  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the dedicated host belongs. When this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The service state of the dedicated host. Valid values:
        # 
        # *   Available: The dedicated host is running normally.
        # *   UnderAssessment: The dedicated host is at risk, which may cause issues to ECS instances on the dedicated host.
        # *   PermanentFailure: The dedicated host has permanent failures and is unusable.
        # *   TempUnavailable: The dedicated host is temporarily unusable.
        # *   Redeploying: The dedicated host is being restored.
        # 
        # Default value: Available.
        self.status = status  # type: str
        # 标签列表。
        self.tag = tag  # type: list[DescribeDedicatedHostsRequestTag]
        # The zone ID of the dedicated host. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostIds') is not None:
            self.dedicated_host_ids = m.get('DedicatedHostIds')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDedicatedHostsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions(TeaModel):
    def __init__(self, managed_private_space_id=None):
        self.managed_private_space_id = managed_private_space_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.managed_private_space_id is not None:
            result['ManagedPrivateSpaceId'] = self.managed_private_space_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ManagedPrivateSpaceId') is not None:
            self.managed_private_space_id = m.get('ManagedPrivateSpaceId')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity(TeaModel):
    def __init__(self, available_local_storage=None, available_memory=None, available_vcpus=None,
                 available_vgpus=None, local_storage_category=None, total_local_storage=None, total_memory=None, total_vcpus=None,
                 total_vgpus=None):
        # The amount of available space on the local disks. Unit: GiB.
        self.available_local_storage = available_local_storage  # type: int
        # The amount of available memory space. Unit: GiB.
        self.available_memory = available_memory  # type: float
        # The number of available vCPUs.
        self.available_vcpus = available_vcpus  # type: int
        # The number of available vGPUs.
        self.available_vgpus = available_vgpus  # type: int
        # The category of the local disks.
        self.local_storage_category = local_storage_category  # type: str
        # The total capacity of the local disks. Unit: GiB.
        self.total_local_storage = total_local_storage  # type: int
        # The total capacity of the memory. Unit: GiB.
        self.total_memory = total_memory  # type: float
        # The total number of vCPUs.
        self.total_vcpus = total_vcpus  # type: int
        # The total number of vGPUs.
        self.total_vgpus = total_vgpus  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_local_storage is not None:
            result['AvailableLocalStorage'] = self.available_local_storage
        if self.available_memory is not None:
            result['AvailableMemory'] = self.available_memory
        if self.available_vcpus is not None:
            result['AvailableVcpus'] = self.available_vcpus
        if self.available_vgpus is not None:
            result['AvailableVgpus'] = self.available_vgpus
        if self.local_storage_category is not None:
            result['LocalStorageCategory'] = self.local_storage_category
        if self.total_local_storage is not None:
            result['TotalLocalStorage'] = self.total_local_storage
        if self.total_memory is not None:
            result['TotalMemory'] = self.total_memory
        if self.total_vcpus is not None:
            result['TotalVcpus'] = self.total_vcpus
        if self.total_vgpus is not None:
            result['TotalVgpus'] = self.total_vgpus
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableLocalStorage') is not None:
            self.available_local_storage = m.get('AvailableLocalStorage')
        if m.get('AvailableMemory') is not None:
            self.available_memory = m.get('AvailableMemory')
        if m.get('AvailableVcpus') is not None:
            self.available_vcpus = m.get('AvailableVcpus')
        if m.get('AvailableVgpus') is not None:
            self.available_vgpus = m.get('AvailableVgpus')
        if m.get('LocalStorageCategory') is not None:
            self.local_storage_category = m.get('LocalStorageCategory')
        if m.get('TotalLocalStorage') is not None:
            self.total_local_storage = m.get('TotalLocalStorage')
        if m.get('TotalMemory') is not None:
            self.total_memory = m.get('TotalMemory')
        if m.get('TotalVcpus') is not None:
            self.total_vcpus = m.get('TotalVcpus')
        if m.get('TotalVgpus') is not None:
            self.total_vgpus = m.get('TotalVgpus')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo(TeaModel):
    def __init__(self, serial_number=None):
        # This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.serial_number = serial_number  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance(TeaModel):
    def __init__(self, instance_id=None, instance_type=None):
        # The ID of the ECS instance created on the dedicated host.
        self.instance_id = instance_id  # type: str
        # The instance type of the ECS instance created on the dedicated host.
        self.instance_type = instance_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance]

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes(TeaModel):
    def __init__(self, slb_udp_timeout=None, udp_timeout=None):
        # The timeout period of the UDP session that was established between Server Load Balancer (SLB) and the dedicated host. Unit: seconds. Valid value: 60.
        self.slb_udp_timeout = slb_udp_timeout  # type: int
        # The timeout period of the UDP session that was established between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid value: 60.
        self.udp_timeout = udp_timeout  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slb_udp_timeout is not None:
            result['SlbUdpTimeout'] = self.slb_udp_timeout
        if self.udp_timeout is not None:
            result['UdpTimeout'] = self.udp_timeout
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SlbUdpTimeout') is not None:
            self.slb_udp_timeout = m.get('SlbUdpTimeout')
        if m.get('UdpTimeout') is not None:
            self.udp_timeout = m.get('UdpTimeout')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock(TeaModel):
    def __init__(self, lock_reason=None):
        # The reason why the dedicated host was locked. Valid values:
        # 
        # - financial: The dedicated host was locked due to overdue payments.
        # - security: The dedicated host was locked due to security reasons.
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks(TeaModel):
    def __init__(self, operation_lock=None):
        self.operation_lock = operation_lock  # type: list[DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock]

    def validate(self):
        if self.operation_lock:
            for k in self.operation_lock:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLock'] = []
        if self.operation_lock is not None:
            for k in self.operation_lock:
                result['OperationLock'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_lock = []
        if m.get('OperationLock') is not None:
            for k in m.get('OperationLock'):
                temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocksOperationLock()
                self.operation_lock.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies(TeaModel):
    def __init__(self, supported_custom_instance_type_family=None):
        self.supported_custom_instance_type_family = supported_custom_instance_type_family  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_custom_instance_type_family is not None:
            result['SupportedCustomInstanceTypeFamily'] = self.supported_custom_instance_type_family
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedCustomInstanceTypeFamily') is not None:
            self.supported_custom_instance_type_family = m.get('SupportedCustomInstanceTypeFamily')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies(TeaModel):
    def __init__(self, supported_instance_type_family=None):
        self.supported_instance_type_family = supported_instance_type_family  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_type_family is not None:
            result['SupportedInstanceTypeFamily'] = self.supported_instance_type_family
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedInstanceTypeFamily') is not None:
            self.supported_instance_type_family = m.get('SupportedInstanceTypeFamily')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList(TeaModel):
    def __init__(self, supported_instance_types_list=None):
        self.supported_instance_types_list = supported_instance_types_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_types_list is not None:
            result['SupportedInstanceTypesList'] = self.supported_instance_types_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedInstanceTypesList') is not None:
            self.supported_instance_types_list = m.get('SupportedInstanceTypesList')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the dedicated host.
        self.tag_key = tag_key  # type: str
        # The tag value of the dedicated host.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost(TeaModel):
    def __init__(self, scheduler_options=None, action_on_maintenance=None, auto_placement=None,
                 auto_release_time=None, capacity=None, charge_type=None, cores=None, cpu_over_commit_ratio=None, creation_time=None,
                 dedicated_host_cluster_id=None, dedicated_host_id=None, dedicated_host_name=None, dedicated_host_type=None,
                 description=None, expired_time=None, gpuspec=None, host_detail_info=None, instances=None, machine_id=None,
                 network_attributes=None, operation_locks=None, physical_gpus=None, region_id=None, resource_group_id=None,
                 sale_cycle=None, sockets=None, status=None, supported_custom_instance_type_families=None,
                 supported_instance_type_families=None, supported_instance_types_list=None, tags=None, zone_id=None):
        self.scheduler_options = scheduler_options  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions
        # The policy used to migrate the instances deployed on the dedicated host when the dedicated host fails. Valid values:
        # 
        # *   Migrate: The instances are migrated to another physical server. Instances that are not in the Stopped state when the dedicated host fails are restarted after migration.
        # *   Stop: The instances are stopped. If the dedicated host cannot be repaired, the instances are migrated to another physical server and restarted.
        # 
        # If the dedicated host has cloud disks attached, the default value is Migrate. If the dedicated host has local disks attached, the default value is Stop.
        self.action_on_maintenance = action_on_maintenance  # type: str
        # Indicates whether the dedicated host was added to the resource pool for automatic deployment. Valid values:
        # 
        # *   on: The dedicated host was added to the resource pool for automatic deployment.
        # *   off: The dedicated host was not added to the resource pool for automatic deployment.
        # 
        # For more information about automatic deployment, see the "[Automatic deployment](~~118938~~)" section in the Functions and features topic.
        self.auto_placement = auto_placement  # type: str
        # The automatic release time of the dedicated host. The time follows the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.
        self.auto_release_time = auto_release_time  # type: str
        # The performance specifications of the dedicated host.
        self.capacity = capacity  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity
        # The billing method of the dedicated host.
        self.charge_type = charge_type  # type: str
        # The number of cores in a single CPU.
        self.cores = cores  # type: int
        # The CPU overcommit ratio.
        self.cpu_over_commit_ratio = cpu_over_commit_ratio  # type: float
        # The time when the dedicated host was created. The time follows the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The ID of the dedicated host cluster to which the dedicated host belongs.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The name of the dedicated host.
        self.dedicated_host_name = dedicated_host_name  # type: str
        # The type of the dedicated host.
        self.dedicated_host_type = dedicated_host_type  # type: str
        # The description of the dedicated host.
        self.description = description  # type: str
        # The expiration time of the subscription dedicated host. The time follows the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mmZ` format. The time is displayed in UTC.
        self.expired_time = expired_time  # type: str
        # The GPU model.
        self.gpuspec = gpuspec  # type: str
        # This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.host_detail_info = host_detail_info  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo
        # Details about the ECS instances that were created on the dedicated host.
        self.instances = instances  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances
        # The machine code of the dedicated host.
        self.machine_id = machine_id  # type: str
        # The network attributes of the dedicated host.
        self.network_attributes = network_attributes  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes
        # The reasons why the resources of the dedicated host were locked.
        self.operation_locks = operation_locks  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks
        # The number of physical GPUs.
        self.physical_gpus = physical_gpus  # type: int
        # The region ID of the dedicated host.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the dedicated host belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The unit of the subscription period. Valid values:
        # 
        # *   Month
        # *   Year
        self.sale_cycle = sale_cycle  # type: str
        # The number of physical CPUs.
        self.sockets = sockets  # type: int
        # The service state of the dedicated host. Valid values:
        # 
        # *   Available: The dedicated host is running normally.
        # *   UnderAssessment: The dedicated host is at risk, which may cause issues to ECS instances on the dedicated host.
        # *   PermanentFailure: The dedicated host has permanent failures and is unusable.
        self.status = status  # type: str
        # The custom ECS instance families supported by the dedicated host.
        self.supported_custom_instance_type_families = supported_custom_instance_type_families  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies
        # The ECS instance families supported by the dedicated host.
        self.supported_instance_type_families = supported_instance_type_families  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies
        # The ECS instance types supported by the dedicated host.
        self.supported_instance_types_list = supported_instance_types_list  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList
        # The tags of the dedicated host.
        self.tags = tags  # type: DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags
        # The zone ID of the dedicated host.
        self.zone_id = zone_id  # type: str

    def validate(self):
        self.validate_required(self.scheduler_options, 'scheduler_options')
        if self.scheduler_options:
            self.scheduler_options.validate()
        if self.capacity:
            self.capacity.validate()
        if self.host_detail_info:
            self.host_detail_info.validate()
        if self.instances:
            self.instances.validate()
        if self.network_attributes:
            self.network_attributes.validate()
        if self.operation_locks:
            self.operation_locks.validate()
        if self.supported_custom_instance_type_families:
            self.supported_custom_instance_type_families.validate()
        if self.supported_instance_type_families:
            self.supported_instance_type_families.validate()
        if self.supported_instance_types_list:
            self.supported_instance_types_list.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.scheduler_options is not None:
            result['SchedulerOptions'] = self.scheduler_options.to_map()
        if self.action_on_maintenance is not None:
            result['ActionOnMaintenance'] = self.action_on_maintenance
        if self.auto_placement is not None:
            result['AutoPlacement'] = self.auto_placement
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.capacity is not None:
            result['Capacity'] = self.capacity.to_map()
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.cpu_over_commit_ratio is not None:
            result['CpuOverCommitRatio'] = self.cpu_over_commit_ratio
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.description is not None:
            result['Description'] = self.description
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.gpuspec is not None:
            result['GPUSpec'] = self.gpuspec
        if self.host_detail_info is not None:
            result['HostDetailInfo'] = self.host_detail_info.to_map()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.machine_id is not None:
            result['MachineId'] = self.machine_id
        if self.network_attributes is not None:
            result['NetworkAttributes'] = self.network_attributes.to_map()
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.physical_gpus is not None:
            result['PhysicalGpus'] = self.physical_gpus
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sale_cycle is not None:
            result['SaleCycle'] = self.sale_cycle
        if self.sockets is not None:
            result['Sockets'] = self.sockets
        if self.status is not None:
            result['Status'] = self.status
        if self.supported_custom_instance_type_families is not None:
            result['SupportedCustomInstanceTypeFamilies'] = self.supported_custom_instance_type_families.to_map()
        if self.supported_instance_type_families is not None:
            result['SupportedInstanceTypeFamilies'] = self.supported_instance_type_families.to_map()
        if self.supported_instance_types_list is not None:
            result['SupportedInstanceTypesList'] = self.supported_instance_types_list.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SchedulerOptions') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSchedulerOptions()
            self.scheduler_options = temp_model.from_map(m['SchedulerOptions'])
        if m.get('ActionOnMaintenance') is not None:
            self.action_on_maintenance = m.get('ActionOnMaintenance')
        if m.get('AutoPlacement') is not None:
            self.auto_placement = m.get('AutoPlacement')
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('Capacity') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostCapacity()
            self.capacity = temp_model.from_map(m['Capacity'])
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('CpuOverCommitRatio') is not None:
            self.cpu_over_commit_ratio = m.get('CpuOverCommitRatio')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('GPUSpec') is not None:
            self.gpuspec = m.get('GPUSpec')
        if m.get('HostDetailInfo') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostHostDetailInfo()
            self.host_detail_info = temp_model.from_map(m['HostDetailInfo'])
        if m.get('Instances') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('MachineId') is not None:
            self.machine_id = m.get('MachineId')
        if m.get('NetworkAttributes') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostNetworkAttributes()
            self.network_attributes = temp_model.from_map(m['NetworkAttributes'])
        if m.get('OperationLocks') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('PhysicalGpus') is not None:
            self.physical_gpus = m.get('PhysicalGpus')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SaleCycle') is not None:
            self.sale_cycle = m.get('SaleCycle')
        if m.get('Sockets') is not None:
            self.sockets = m.get('Sockets')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SupportedCustomInstanceTypeFamilies') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedCustomInstanceTypeFamilies()
            self.supported_custom_instance_type_families = temp_model.from_map(m['SupportedCustomInstanceTypeFamilies'])
        if m.get('SupportedInstanceTypeFamilies') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypeFamilies()
            self.supported_instance_type_families = temp_model.from_map(m['SupportedInstanceTypeFamilies'])
        if m.get('SupportedInstanceTypesList') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostSupportedInstanceTypesList()
            self.supported_instance_types_list = temp_model.from_map(m['SupportedInstanceTypesList'])
        if m.get('Tags') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHostTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDedicatedHostsResponseBodyDedicatedHosts(TeaModel):
    def __init__(self, dedicated_host=None):
        self.dedicated_host = dedicated_host  # type: list[DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost]

    def validate(self):
        if self.dedicated_host:
            for k in self.dedicated_host:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBodyDedicatedHosts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DedicatedHost'] = []
        if self.dedicated_host is not None:
            for k in self.dedicated_host:
                result['DedicatedHost'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.dedicated_host = []
        if m.get('DedicatedHost') is not None:
            for k in m.get('DedicatedHost'):
                temp_model = DescribeDedicatedHostsResponseBodyDedicatedHostsDedicatedHost()
                self.dedicated_host.append(temp_model.from_map(k))
        return self


class DescribeDedicatedHostsResponseBody(TeaModel):
    def __init__(self, dedicated_hosts=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the dedicated hosts.
        self.dedicated_hosts = dedicated_hosts  # type: DescribeDedicatedHostsResponseBodyDedicatedHosts
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of dedicated hosts.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.dedicated_hosts:
            self.dedicated_hosts.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_hosts is not None:
            result['DedicatedHosts'] = self.dedicated_hosts.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHosts') is not None:
            temp_model = DescribeDedicatedHostsResponseBodyDedicatedHosts()
            self.dedicated_hosts = temp_model.from_map(m['DedicatedHosts'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDedicatedHostsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDedicatedHostsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDedicatedHostsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDedicatedHostsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDemandsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag.
        self.key = key  # type: str
        # The value of the tag.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDemandsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDemandsRequest(TeaModel):
    def __init__(self, demand_id=None, demand_status=None, demand_type=None, dry_run=None,
                 instance_charge_type=None, instance_type=None, instance_type_family=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None, zone_id=None):
        # The ID of the filing ticket. If this parameter is specified, other optional request parameters are ignored.
        self.demand_id = demand_id  # type: str
        # The status of the filing ticket or resource usage. Valid values:
        # 
        # *   Creating: The filing ticket is being created.
        # *   Active: The filed resources are being supplied.
        # *   Expired: The filing ticket expires.
        # *   Finished: The filed resources are consumed.
        # *   Refused: The filing request is denied. For reasons why the request is denied, see the `Comment` response parameter.
        # *   Cancelled: The filing request is canceled.
        self.demand_status = demand_status  # type: list[str]
        # The source of the filed instance. Default value: System. Valid values:
        # 
        # *   Custom: filed on your own.
        # *   System: filed by Alibaba Cloud.
        self.demand_type = demand_type  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: sends a check request, without querying the status of the filing ticket. The system checks whether your AccessKey pair is valid, whether RAM users are authorized, and whether the required parameters are set. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: sends an API request. If the request succeeds, a 2XX HTTP status code is returned and the status of the filing ticket is queried.
        self.dry_run = dry_run  # type: bool
        # The billing method of the instance. Valid values:
        # 
        # *   PostPaid: pay-as-you-go
        # *   PrePaid: subscription
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type of the filed instance.
        self.instance_type = instance_type  # type: str
        # The instance family of the filed instance.
        self.instance_type_family = instance_type_family  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[DescribeDemandsRequestTag]
        # The zone ID. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDemandsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demand_id is not None:
            result['DemandId'] = self.demand_id
        if self.demand_status is not None:
            result['DemandStatus'] = self.demand_status
        if self.demand_type is not None:
            result['DemandType'] = self.demand_type
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DemandId') is not None:
            self.demand_id = m.get('DemandId')
        if m.get('DemandStatus') is not None:
            self.demand_status = m.get('DemandStatus')
        if m.get('DemandType') is not None:
            self.demand_type = m.get('DemandType')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDemandsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo(TeaModel):
    def __init__(self, amount=None, supply_end_time=None, supply_start_time=None, supply_status=None):
        # The number of delivered instances.
        self.amount = amount  # type: int
        # The end time when the filed resources are delivered and available. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.supply_end_time = supply_end_time  # type: str
        # The start time when the filed resources are delivered and available. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.supply_start_time = supply_start_time  # type: str
        # The delivery status of the filed resource. Valid values:
        # 
        # *   Delivered: The filed resource is delivered.
        # *   Delivering: The filed resource is being delivered.
        self.supply_status = supply_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.supply_end_time is not None:
            result['SupplyEndTime'] = self.supply_end_time
        if self.supply_start_time is not None:
            result['SupplyStartTime'] = self.supply_start_time
        if self.supply_status is not None:
            result['SupplyStatus'] = self.supply_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('SupplyEndTime') is not None:
            self.supply_end_time = m.get('SupplyEndTime')
        if m.get('SupplyStartTime') is not None:
            self.supply_start_time = m.get('SupplyStartTime')
        if m.get('SupplyStatus') is not None:
            self.supply_status = m.get('SupplyStatus')
        return self


class DescribeDemandsResponseBodyDemandsDemandSupplyInfos(TeaModel):
    def __init__(self, supply_info=None):
        self.supply_info = supply_info  # type: list[DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo]

    def validate(self):
        if self.supply_info:
            for k in self.supply_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDemandsResponseBodyDemandsDemandSupplyInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupplyInfo'] = []
        if self.supply_info is not None:
            for k in self.supply_info:
                result['SupplyInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.supply_info = []
        if m.get('SupplyInfo') is not None:
            for k in m.get('SupplyInfo'):
                temp_model = DescribeDemandsResponseBodyDemandsDemandSupplyInfosSupplyInfo()
                self.supply_info.append(temp_model.from_map(k))
        return self


class DescribeDemandsResponseBodyDemandsDemand(TeaModel):
    def __init__(self, available_amount=None, comment=None, delivering_amount=None, demand_description=None,
                 demand_id=None, demand_name=None, demand_status=None, demand_time=None, end_time=None,
                 instance_charge_type=None, instance_type=None, instance_type_family=None, period=None, period_unit=None,
                 start_time=None, supply_infos=None, total_amount=None, used_amount=None, zone_id=None):
        # The number of instances available for the filed resources.
        self.available_amount = available_amount  # type: int
        # The feedback on the denied request for filing resources.
        self.comment = comment  # type: str
        # The number of instances to be delivered in the filed resources.
        self.delivering_amount = delivering_amount  # type: int
        # The description of the filing ticket.
        self.demand_description = demand_description  # type: str
        # The ID of the filing ticket.
        self.demand_id = demand_id  # type: str
        # The name of the filing ticket.
        self.demand_name = demand_name  # type: str
        # The status of the filing ticket or resource usage. Valid values:
        # 
        # *   Creating: The filing ticket is being created.
        # *   Active: The filed resources are being supplied.
        # *   Expired: The filing ticket expires.
        # *   Finished: The filed resources are consumed.
        # *   Refused: The filing request is denied. For reasons why the request is denied, see the `Comment` response parameter.
        # *   Cancelled: The filing request is canceled. After the filing request is canceled, the delivery status of the resources becomes invalid.
        self.demand_status = demand_status  # type: str
        # The time when the filing ticket was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.demand_time = demand_time  # type: str
        # The expected end time for the purchase of the filed resources. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time  # type: str
        # The billing method of the filed resources. Valid values:
        # 
        # *   Prepaid: subscription
        # *   Postpaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type of the filed instance.
        self.instance_type = instance_type  # type: str
        # The instance family of the filed instance.
        self.instance_type_family = instance_type_family  # type: str
        # The usage duration of the filed resource.
        self.period = period  # type: int
        # The unit of the usage duration of the filed resource. Valid values:
        # 
        # *   Hour
        # *   Day
        # *   Month
        self.period_unit = period_unit  # type: str
        # The expected start time for the purchase of the filed resources. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time  # type: str
        # Details about the delivery status of the filed resources.
        self.supply_infos = supply_infos  # type: DescribeDemandsResponseBodyDemandsDemandSupplyInfos
        # The amount of total instances.
        self.total_amount = total_amount  # type: int
        # The amount of instances that have been used.
        self.used_amount = used_amount  # type: int
        # The ID of the zone for which to query resources.
        # 
        # This parameter is empty by default. When this parameter is empty, the system returns resources that match the other criteria in all zones within the region specified by `RegionId`.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.supply_infos:
            self.supply_infos.validate()

    def to_map(self):
        _map = super(DescribeDemandsResponseBodyDemandsDemand, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_amount is not None:
            result['AvailableAmount'] = self.available_amount
        if self.comment is not None:
            result['Comment'] = self.comment
        if self.delivering_amount is not None:
            result['DeliveringAmount'] = self.delivering_amount
        if self.demand_description is not None:
            result['DemandDescription'] = self.demand_description
        if self.demand_id is not None:
            result['DemandId'] = self.demand_id
        if self.demand_name is not None:
            result['DemandName'] = self.demand_name
        if self.demand_status is not None:
            result['DemandStatus'] = self.demand_status
        if self.demand_time is not None:
            result['DemandTime'] = self.demand_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.supply_infos is not None:
            result['SupplyInfos'] = self.supply_infos.to_map()
        if self.total_amount is not None:
            result['TotalAmount'] = self.total_amount
        if self.used_amount is not None:
            result['UsedAmount'] = self.used_amount
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableAmount') is not None:
            self.available_amount = m.get('AvailableAmount')
        if m.get('Comment') is not None:
            self.comment = m.get('Comment')
        if m.get('DeliveringAmount') is not None:
            self.delivering_amount = m.get('DeliveringAmount')
        if m.get('DemandDescription') is not None:
            self.demand_description = m.get('DemandDescription')
        if m.get('DemandId') is not None:
            self.demand_id = m.get('DemandId')
        if m.get('DemandName') is not None:
            self.demand_name = m.get('DemandName')
        if m.get('DemandStatus') is not None:
            self.demand_status = m.get('DemandStatus')
        if m.get('DemandTime') is not None:
            self.demand_time = m.get('DemandTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SupplyInfos') is not None:
            temp_model = DescribeDemandsResponseBodyDemandsDemandSupplyInfos()
            self.supply_infos = temp_model.from_map(m['SupplyInfos'])
        if m.get('TotalAmount') is not None:
            self.total_amount = m.get('TotalAmount')
        if m.get('UsedAmount') is not None:
            self.used_amount = m.get('UsedAmount')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDemandsResponseBodyDemands(TeaModel):
    def __init__(self, demand=None):
        self.demand = demand  # type: list[DescribeDemandsResponseBodyDemandsDemand]

    def validate(self):
        if self.demand:
            for k in self.demand:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDemandsResponseBodyDemands, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Demand'] = []
        if self.demand is not None:
            for k in self.demand:
                result['Demand'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.demand = []
        if m.get('Demand') is not None:
            for k in m.get('Demand'):
                temp_model = DescribeDemandsResponseBodyDemandsDemand()
                self.demand.append(temp_model.from_map(k))
        return self


class DescribeDemandsResponseBody(TeaModel):
    def __init__(self, demands=None, page_number=None, page_size=None, region_id=None, request_id=None,
                 total_count=None):
        # Details about the filing tickets whose regions meet the filter condition.
        self.demands = demands  # type: DescribeDemandsResponseBodyDemands
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The region ID.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of queried filing tickets.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.demands:
            self.demands.validate()

    def to_map(self):
        _map = super(DescribeDemandsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.demands is not None:
            result['Demands'] = self.demands.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Demands') is not None:
            temp_model = DescribeDemandsResponseBodyDemands()
            self.demands = temp_model.from_map(m['Demands'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDemandsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDemandsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDemandsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDemandsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDeploymentSetSupportedInstanceTypeFamilyRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the deployment set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDeploymentSetSupportedInstanceTypeFamilyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody(TeaModel):
    def __init__(self, instance_type_families=None, request_id=None):
        # The instance families that support deployment sets.
        self.instance_type_families = instance_type_families  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type_families is not None:
            result['InstanceTypeFamilies'] = self.instance_type_families
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceTypeFamilies') is not None:
            self.instance_type_families = m.get('InstanceTypeFamilies')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDeploymentSetSupportedInstanceTypeFamilyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetSupportedInstanceTypeFamilyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDeploymentSetsRequest(TeaModel):
    def __init__(self, deployment_set_ids=None, deployment_set_name=None, domain=None, granularity=None,
                 network_type=None, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, strategy=None):
        # The IDs of deployment sets. The value can be a JSON array that consists of up to 100 deployment set IDs in the format of `["ds-xxxxxxxxx", "ds-yyyyyyyyy", … "ds-zzzzzzzzz"]`. Separate multiple deployment set IDs with commas (,).
        self.deployment_set_ids = deployment_set_ids  # type: str
        # The name of the deployment set. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.deployment_set_name = deployment_set_name  # type: str
        # > The parameter is deprecated.
        self.domain = domain  # type: str
        # > The parameter is deprecated.
        self.granularity = granularity  # type: str
        # > The parameter is deprecated.
        self.network_type = network_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the deployment set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The deployment strategy. Valid values:
        # 
        # *   Availability: high availability strategy.
        # *   AvailabilityGroup: high availability group strategy.
        self.strategy = strategy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDeploymentSetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_set_ids is not None:
            result['DeploymentSetIds'] = self.deployment_set_ids
        if self.deployment_set_name is not None:
            result['DeploymentSetName'] = self.deployment_set_name
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.granularity is not None:
            result['Granularity'] = self.granularity
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeploymentSetIds') is not None:
            self.deployment_set_ids = m.get('DeploymentSetIds')
        if m.get('DeploymentSetName') is not None:
            self.deployment_set_name = m.get('DeploymentSetName')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Granularity') is not None:
            self.granularity = m.get('Granularity')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        return self


class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacitiesCapacity(TeaModel):
    def __init__(self, available_amount=None, used_amount=None, zone_id=None):
        # The number of ECS instances that can be added to the deployment set within the zone.
        self.available_amount = available_amount  # type: int
        # The number of ECS instances that belong to the zone in the deployment set.
        self.used_amount = used_amount  # type: int
        # The ID of the zone. Only the zone IDs of existing ECS instances in the deployment set are returned.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacitiesCapacity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_amount is not None:
            result['AvailableAmount'] = self.available_amount
        if self.used_amount is not None:
            result['UsedAmount'] = self.used_amount
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableAmount') is not None:
            self.available_amount = m.get('AvailableAmount')
        if m.get('UsedAmount') is not None:
            self.used_amount = m.get('UsedAmount')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacities(TeaModel):
    def __init__(self, capacity=None):
        self.capacity = capacity  # type: list[DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacitiesCapacity]

    def validate(self):
        if self.capacity:
            for k in self.capacity:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacities, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Capacity'] = []
        if self.capacity is not None:
            for k in self.capacity:
                result['Capacity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.capacity = []
        if m.get('Capacity') is not None:
            for k in m.get('Capacity'):
                temp_model = DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacitiesCapacity()
                self.capacity.append(temp_model.from_map(k))
        return self


class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds(TeaModel):
    def __init__(self, instance_id=None):
        self.instance_id = instance_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet(TeaModel):
    def __init__(self, capacities=None, creation_time=None, deployment_set_description=None,
                 deployment_set_id=None, deployment_set_name=None, deployment_strategy=None, domain=None, granularity=None,
                 group_count=None, instance_amount=None, instance_ids=None, strategy=None):
        # Details of the capacities of the deployment set. This parameter is valid only when the deployment set contains Elastic Compute Service (ECS) instances. The value contains the capacities of the deployment set in different zones.
        self.capacities = capacities  # type: DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacities
        # The time when the deployment set was created.
        self.creation_time = creation_time  # type: str
        # The description of the deployment set.
        self.deployment_set_description = deployment_set_description  # type: str
        # The ID of the deployment set.
        self.deployment_set_id = deployment_set_id  # type: str
        # The name of the deployment set.
        self.deployment_set_name = deployment_set_name  # type: str
        # The deployment strategy. The value of this response parameter is that of the `Strategy` request parameter.
        self.deployment_strategy = deployment_strategy  # type: str
        # The deployment domain.
        self.domain = domain  # type: str
        # The deployment granularity.
        self.granularity = granularity  # type: str
        # The number of deployment set groups in the deployment set.
        # 
        # >  This parameter is valid only when the Strategy request parameter is set to AvailabilityGroup.
        self.group_count = group_count  # type: int
        # The number of instances in the deployment set.
        self.instance_amount = instance_amount  # type: int
        # The IDs of the instances in the deployment set.
        self.instance_ids = instance_ids  # type: DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds
        # The deployment strategy.
        self.strategy = strategy  # type: str

    def validate(self):
        if self.capacities:
            self.capacities.validate()
        if self.instance_ids:
            self.instance_ids.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacities is not None:
            result['Capacities'] = self.capacities.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.deployment_set_description is not None:
            result['DeploymentSetDescription'] = self.deployment_set_description
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.deployment_set_name is not None:
            result['DeploymentSetName'] = self.deployment_set_name
        if self.deployment_strategy is not None:
            result['DeploymentStrategy'] = self.deployment_strategy
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.granularity is not None:
            result['Granularity'] = self.granularity
        if self.group_count is not None:
            result['GroupCount'] = self.group_count
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids.to_map()
        if self.strategy is not None:
            result['Strategy'] = self.strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Capacities') is not None:
            temp_model = DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetCapacities()
            self.capacities = temp_model.from_map(m['Capacities'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeploymentSetDescription') is not None:
            self.deployment_set_description = m.get('DeploymentSetDescription')
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('DeploymentSetName') is not None:
            self.deployment_set_name = m.get('DeploymentSetName')
        if m.get('DeploymentStrategy') is not None:
            self.deployment_strategy = m.get('DeploymentStrategy')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Granularity') is not None:
            self.granularity = m.get('Granularity')
        if m.get('GroupCount') is not None:
            self.group_count = m.get('GroupCount')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceIds') is not None:
            temp_model = DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSetInstanceIds()
            self.instance_ids = temp_model.from_map(m['InstanceIds'])
        if m.get('Strategy') is not None:
            self.strategy = m.get('Strategy')
        return self


class DescribeDeploymentSetsResponseBodyDeploymentSets(TeaModel):
    def __init__(self, deployment_set=None):
        self.deployment_set = deployment_set  # type: list[DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet]

    def validate(self):
        if self.deployment_set:
            for k in self.deployment_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBodyDeploymentSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DeploymentSet'] = []
        if self.deployment_set is not None:
            for k in self.deployment_set:
                result['DeploymentSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.deployment_set = []
        if m.get('DeploymentSet') is not None:
            for k in m.get('DeploymentSet'):
                temp_model = DescribeDeploymentSetsResponseBodyDeploymentSetsDeploymentSet()
                self.deployment_set.append(temp_model.from_map(k))
        return self


class DescribeDeploymentSetsResponseBody(TeaModel):
    def __init__(self, deployment_sets=None, page_number=None, page_size=None, region_id=None, request_id=None,
                 total_count=None):
        # Details about the deployment sets.
        self.deployment_sets = deployment_sets  # type: DescribeDeploymentSetsResponseBodyDeploymentSets
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The region ID of the deployment set.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of deployment sets returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.deployment_sets:
            self.deployment_sets.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_sets is not None:
            result['DeploymentSets'] = self.deployment_sets.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeploymentSets') is not None:
            temp_model = DescribeDeploymentSetsResponseBodyDeploymentSets()
            self.deployment_sets = temp_model.from_map(m['DeploymentSets'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDeploymentSetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDeploymentSetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDeploymentSetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDeploymentSetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiagnosticMetricSetsRequest(TeaModel):
    def __init__(self, max_results=None, metric_set_ids=None, next_token=None, region_id=None, resource_type=None,
                 type=None):
        # The maximum number of entries to return on each page. Maximum value: 100.
        # 
        # Default value:
        # 
        # *   If this parameter is left empty, the default value is 10.
        # *   If this parameter is set to a value greater than 100, the default value is 100.
        self.max_results = max_results  # type: int
        self.metric_set_ids = metric_set_ids  # type: list[str]
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeDiagnosticMetricSets operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        # The region ID of the diagnostic metric set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The resource type supported by the diagnostic metric set.
        self.resource_type = resource_type  # type: str
        # The type of the diagnostic metric set. Valid values:
        # 
        # *   User: user-defined diagnostic metric set
        # *   Common: common diagnostic metric set
        # 
        # Default value: user.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticMetricSetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.metric_set_ids is not None:
            result['MetricSetIds'] = self.metric_set_ids
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MetricSetIds') is not None:
            self.metric_set_ids = m.get('MetricSetIds')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDiagnosticMetricSetsResponseBodyMetricSets(TeaModel):
    def __init__(self, description=None, metric_ids=None, metric_set_id=None, metric_set_name=None,
                 resource_type=None, type=None):
        # The description of the diagnostic metric set.
        self.description = description  # type: str
        # The IDs of the diagnostic metrics.
        self.metric_ids = metric_ids  # type: list[str]
        # The ID of the diagnostic metric set.
        self.metric_set_id = metric_set_id  # type: str
        # The name of the diagnostic metric set.
        self.metric_set_name = metric_set_name  # type: str
        # The resource type supported by the diagnostic metric set.
        self.resource_type = resource_type  # type: str
        # The type of the diagnostic metric set. Valid values:
        # 
        # *   User: user-defined diagnostic metric set
        # *   Common: common diagnostic metric set
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticMetricSetsResponseBodyMetricSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.metric_ids is not None:
            result['MetricIds'] = self.metric_ids
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.metric_set_name is not None:
            result['MetricSetName'] = self.metric_set_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MetricIds') is not None:
            self.metric_ids = m.get('MetricIds')
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('MetricSetName') is not None:
            self.metric_set_name = m.get('MetricSetName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeDiagnosticMetricSetsResponseBody(TeaModel):
    def __init__(self, metric_sets=None, next_token=None, request_id=None):
        self.metric_sets = metric_sets  # type: list[DescribeDiagnosticMetricSetsResponseBodyMetricSets]
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.metric_sets:
            for k in self.metric_sets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticMetricSetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricSets'] = []
        if self.metric_sets is not None:
            for k in self.metric_sets:
                result['MetricSets'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_sets = []
        if m.get('MetricSets') is not None:
            for k in m.get('MetricSets'):
                temp_model = DescribeDiagnosticMetricSetsResponseBodyMetricSets()
                self.metric_sets.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDiagnosticMetricSetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDiagnosticMetricSetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticMetricSetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiagnosticMetricSetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiagnosticMetricsRequest(TeaModel):
    def __init__(self, max_results=None, metric_ids=None, next_token=None, region_id=None, resource_type=None):
        # The maximum number of entries to return on each page. Maximum value: 100.
        # 
        # Default value:
        # 
        # *   If this parameter is left empty, the default value is 10.
        # *   If this parameter is set to a value greater than 100, the default value is 100.
        self.max_results = max_results  # type: int
        # The IDs of diagnostic metrics.
        self.metric_ids = metric_ids  # type: list[str]
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeDiagnosticMetrics operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        # The region ID of the diagnostic metric. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The resource type supported by the diagnostic metric.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticMetricsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.metric_ids is not None:
            result['MetricIds'] = self.metric_ids
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MetricIds') is not None:
            self.metric_ids = m.get('MetricIds')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeDiagnosticMetricsResponseBodyMetrics(TeaModel):
    def __init__(self, description=None, guest_metric=None, metric_category=None, metric_id=None, metric_name=None,
                 resource_type=None, supported_operating_system=None):
        # The description of the diagnostic metric.
        self.description = description  # type: str
        # Indicates whether the diagnostic metric needs to be assessed by running a Cloud Assistant command in a guest operating system.
        self.guest_metric = guest_metric  # type: bool
        # The category of the diagnostic metric.
        self.metric_category = metric_category  # type: str
        # The ID of the diagnostic metric.
        self.metric_id = metric_id  # type: str
        # The name of the diagnostic metric.
        self.metric_name = metric_name  # type: str
        # The resource type supported by the diagnostic metric.
        self.resource_type = resource_type  # type: str
        # The operating system type supported by the diagnostic metric. Valid values:
        # 
        # *   Windows
        # *   Linux
        # *   All: both Windows and Linux
        self.supported_operating_system = supported_operating_system  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticMetricsResponseBodyMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.guest_metric is not None:
            result['GuestMetric'] = self.guest_metric
        if self.metric_category is not None:
            result['MetricCategory'] = self.metric_category
        if self.metric_id is not None:
            result['MetricId'] = self.metric_id
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.supported_operating_system is not None:
            result['SupportedOperatingSystem'] = self.supported_operating_system
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GuestMetric') is not None:
            self.guest_metric = m.get('GuestMetric')
        if m.get('MetricCategory') is not None:
            self.metric_category = m.get('MetricCategory')
        if m.get('MetricId') is not None:
            self.metric_id = m.get('MetricId')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('SupportedOperatingSystem') is not None:
            self.supported_operating_system = m.get('SupportedOperatingSystem')
        return self


class DescribeDiagnosticMetricsResponseBody(TeaModel):
    def __init__(self, metrics=None, next_token=None, request_id=None):
        # The list of diagnostic metrics.
        self.metrics = metrics  # type: list[DescribeDiagnosticMetricsResponseBodyMetrics]
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticMetricsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeDiagnosticMetricsResponseBodyMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDiagnosticMetricsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDiagnosticMetricsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticMetricsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiagnosticMetricsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiagnosticReportAttributesRequest(TeaModel):
    def __init__(self, region_id=None, report_id=None):
        # The region ID of the diagnostic report. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the diagnostic report.
        self.report_id = report_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        return self


class DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssuesIssue(TeaModel):
    def __init__(self, additional=None, issue_id=None, occurrence_time=None, severity=None):
        # The additional data about the diagnosed issue. The value is a JSON string.
        self.additional = additional  # type: str
        # The ID of the diagnosed issue, which is the unique identifier of the issue.
        self.issue_id = issue_id  # type: str
        # The time when the diagnosed issue occurred.
        self.occurrence_time = occurrence_time  # type: str
        # The severity level of the diagnosed issue. Valid values:
        # 
        # *   Info: Diagnostic information was recorded and may be related to exceptions.
        # *   Warn: Diagnostic information was recorded and may indicate potential exceptions.
        # *   Critical: Critical exceptions were detected.
        self.severity = severity  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssuesIssue, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional is not None:
            result['Additional'] = self.additional
        if self.issue_id is not None:
            result['IssueId'] = self.issue_id
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Additional') is not None:
            self.additional = m.get('Additional')
        if m.get('IssueId') is not None:
            self.issue_id = m.get('IssueId')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssues(TeaModel):
    def __init__(self, issue=None):
        self.issue = issue  # type: list[DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssuesIssue]

    def validate(self):
        if self.issue:
            for k in self.issue:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Issue'] = []
        if self.issue is not None:
            for k in self.issue:
                result['Issue'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.issue = []
        if m.get('Issue') is not None:
            for k in m.get('Issue'):
                temp_model = DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssuesIssue()
                self.issue.append(temp_model.from_map(k))
        return self


class DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResult(TeaModel):
    def __init__(self, issues=None, metric_category=None, metric_id=None, severity=None, status=None):
        # Details about the diagnosed issues.
        self.issues = issues  # type: DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssues
        # The category of the diagnostic metric.
        self.metric_category = metric_category  # type: str
        # The ID of the diagnostic metric.
        self.metric_id = metric_id  # type: str
        # The severity level of the diagnostic metric. Valid values:
        # 
        # *   Unknown: The diagnostic has not started, failed to run, or exited unexpectedly without a diagnosis.
        # *   Normal: No exceptions were detected.
        # *   Info: Diagnostic information was recorded and may be related to exceptions.
        # *   NotSupport: The version of the guest operating system does support diagnosing the metric.
        # *   Warn: Diagnostic information was recorded and may indicate potential exceptions.
        # *   Critical: Critical exceptions were detected.
        self.severity = severity  # type: str
        # The state of the diagnostic metric. Valid values:
        # 
        # *   InProgress: The diagnostic is in progress.
        # *   Finished: The diagnostic is complete.
        # *   Failed: The diagnostic failed.
        self.status = status  # type: str

    def validate(self):
        if self.issues:
            self.issues.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.issues is not None:
            result['Issues'] = self.issues.to_map()
        if self.metric_category is not None:
            result['MetricCategory'] = self.metric_category
        if self.metric_id is not None:
            result['MetricId'] = self.metric_id
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Issues') is not None:
            temp_model = DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResultIssues()
            self.issues = temp_model.from_map(m['Issues'])
        if m.get('MetricCategory') is not None:
            self.metric_category = m.get('MetricCategory')
        if m.get('MetricId') is not None:
            self.metric_id = m.get('MetricId')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDiagnosticReportAttributesResponseBodyMetricResults(TeaModel):
    def __init__(self, metric_result=None):
        self.metric_result = metric_result  # type: list[DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResult]

    def validate(self):
        if self.metric_result:
            for k in self.metric_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponseBodyMetricResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricResult'] = []
        if self.metric_result is not None:
            for k in self.metric_result:
                result['MetricResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_result = []
        if m.get('MetricResult') is not None:
            for k in m.get('MetricResult'):
                temp_model = DescribeDiagnosticReportAttributesResponseBodyMetricResultsMetricResult()
                self.metric_result.append(temp_model.from_map(k))
        return self


class DescribeDiagnosticReportAttributesResponseBody(TeaModel):
    def __init__(self, attributes=None, creation_time=None, end_time=None, finished_time=None, metric_results=None,
                 metric_set_id=None, report_id=None, request_id=None, resource_id=None, resource_type=None, severity=None,
                 start_time=None, status=None):
        # The extended attributes of the diagnostic report.
        self.attributes = attributes  # type: str
        # The time when the diagnostic report was created.
        self.creation_time = creation_time  # type: str
        # The end of the reporting period of the diagnostic report. The value is the EndTime value that was passed in when you called the [CreateDiagnosticReport](~~442490~~) operation to create the diagnostic report.
        self.end_time = end_time  # type: str
        # The time when the diagnostic report was complete.
        self.finished_time = finished_time  # type: str
        # The results of all diagnostic metrics in the diagnostic metric set.
        self.metric_results = metric_results  # type: DescribeDiagnosticReportAttributesResponseBodyMetricResults
        # The ID of the diagnostic metric set.
        self.metric_set_id = metric_set_id  # type: str
        # The ID of the diagnostic report, which is the unique identifier of the report.
        self.report_id = report_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The type of the resource. The ResourceType parameter can only be set to instance, which indicates that only instances are supported.
        self.resource_type = resource_type  # type: str
        # The severity level of the diagnostic report. The value of this parameter is determined by the highest severity level of all diagnostic metrics. Valid values:
        # 
        # *   Unknown: The diagnostic has not started, failed to run, or exited unexpectedly without a diagnosis.
        # *   Normal: No exceptions were detected.
        # *   Info: Diagnostic information was recorded and may be related to exceptions.
        # *   Warn: Diagnostic information was recorded and may indicate potential exceptions.
        # *   Critical: Critical exceptions were detected.
        self.severity = severity  # type: str
        # The beginning of the reporting period of the diagnostic report. The value is the StartTime value that was passed in when you called the [CreateDiagnosticReport](~~442490~~) operation to create the diagnostic report.
        self.start_time = start_time  # type: str
        # The state of the diagnostic report. Valid values:
        # 
        # *   InProgress: The diagnostic is in progress.
        # *   Finished: The diagnostic is complete.
        # *   Failed: The diagnostic failed.
        self.status = status  # type: str

    def validate(self):
        if self.metric_results:
            self.metric_results.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attributes is not None:
            result['Attributes'] = self.attributes
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.metric_results is not None:
            result['MetricResults'] = self.metric_results.to_map()
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Attributes') is not None:
            self.attributes = m.get('Attributes')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('MetricResults') is not None:
            temp_model = DescribeDiagnosticReportAttributesResponseBodyMetricResults()
            self.metric_results = temp_model.from_map(m['MetricResults'])
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDiagnosticReportAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDiagnosticReportAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiagnosticReportAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiagnosticReportsRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, region_id=None, report_ids=None, resource_ids=None,
                 severity=None, status=None):
        # The maximum number of entries to return on each page. Maximum value: 100.
        # 
        # Default value:
        # 
        # *   If this parameter is left empty, the default value is 10.
        # *   If this parameter is set to a value greater than 100, the default value is 100.
        self.max_results = max_results  # type: int
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeDiagnosticReports operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        # The region ID of the diagnostic report. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The IDs of diagnostic reports. You can specify up to 100 report IDs.
        self.report_ids = report_ids  # type: list[str]
        # The IDs of resources. You can specify up to 100 resource IDs.
        self.resource_ids = resource_ids  # type: list[str]
        # The severity level of the diagnostic report. Valid values:
        # 
        # * Unknown: The diagnostic has not started, failed to run, or exited unexpectedly without a diagnosis.
        # * Normal: No exceptions are detected.
        # * Info: Diagnostic information is recorded and may be related to exceptions.
        # * Warn: Diagnostic information is recorded and may indicate exceptions.
        # * Critical: Critical exceptions are detected.
        self.severity = severity  # type: str
        # The state of the diagnostic report. Valid values:
        # 
        # *   InProgress: The diagnostic is in progress.
        # *   Failed: The diagnostic failed.
        # *   Finished: The diagnostic is complete.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticReportsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.report_ids is not None:
            result['ReportIds'] = self.report_ids
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReportIds') is not None:
            self.report_ids = m.get('ReportIds')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue(TeaModel):
    def __init__(self, issue_id=None, metric_category=None, metric_id=None, severity=None):
        # The unique ID of the diagnosed issue.
        self.issue_id = issue_id  # type: str
        # The category of the diagnostic metric.
        self.metric_category = metric_category  # type: str
        # The ID of the diagnostic metric.
        self.metric_id = metric_id  # type: str
        # The severity level of the diagnostic metric. Valid values:
        # 
        # *   Info: Diagnostic information was recorded and may be related to exceptions.
        # *   Warn: Diagnostic information was recorded and may indicate exceptions.
        # *   Critical: Critical exceptions were detected.
        self.severity = severity  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.issue_id is not None:
            result['IssueId'] = self.issue_id
        if self.metric_category is not None:
            result['MetricCategory'] = self.metric_category
        if self.metric_id is not None:
            result['MetricId'] = self.metric_id
        if self.severity is not None:
            result['Severity'] = self.severity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IssueId') is not None:
            self.issue_id = m.get('IssueId')
        if m.get('MetricCategory') is not None:
            self.metric_category = m.get('MetricCategory')
        if m.get('MetricId') is not None:
            self.metric_id = m.get('MetricId')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        return self


class DescribeDiagnosticReportsResponseBodyReportsReportIssues(TeaModel):
    def __init__(self, issue=None):
        self.issue = issue  # type: list[DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue]

    def validate(self):
        if self.issue:
            for k in self.issue:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponseBodyReportsReportIssues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Issue'] = []
        if self.issue is not None:
            for k in self.issue:
                result['Issue'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.issue = []
        if m.get('Issue') is not None:
            for k in m.get('Issue'):
                temp_model = DescribeDiagnosticReportsResponseBodyReportsReportIssuesIssue()
                self.issue.append(temp_model.from_map(k))
        return self


class DescribeDiagnosticReportsResponseBodyReportsReport(TeaModel):
    def __init__(self, creation_time=None, end_time=None, finished_time=None, issues=None, metric_set_id=None,
                 report_id=None, resource_id=None, resource_type=None, severity=None, start_time=None, status=None):
        # The time when the diagnostic report was created.
        self.creation_time = creation_time  # type: str
        # The end of the reporting period of the diagnostic report. The value is the EndTime value that was passed in when you called the [CreateDiagnosticReport](~~442490~~) operation to create the diagnostic report.
        self.end_time = end_time  # type: str
        # The time when the diagnostic was complete.
        self.finished_time = finished_time  # type: str
        # The list of issues.
        self.issues = issues  # type: DescribeDiagnosticReportsResponseBodyReportsReportIssues
        # The ID of the diagnostic metric set.
        self.metric_set_id = metric_set_id  # type: str
        # The ID of the diagnostic report.
        self.report_id = report_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The type of the resource.
        self.resource_type = resource_type  # type: str
        # The severity level of the diagnostic report. Valid values:
        # 
        # *   Unknown: The diagnostic has not started, failed to run, or exited unexpectedly without a diagnosis.
        # *   Normal: No exceptions were detected.
        # *   Info: Diagnostic information was recorded and may be related to exceptions.
        # *   Warn: Diagnostic information was recorded and may indicate exceptions.
        # *   Critical: Critical exceptions were detected.
        self.severity = severity  # type: str
        # The beginning of the reporting period of the diagnostic report. The value is the StartTime value that was passed in when you called the [CreateDiagnosticReport](~~442490~~) operation to create the diagnostic report.
        self.start_time = start_time  # type: str
        # The state of the diagnostic report.
        self.status = status  # type: str

    def validate(self):
        if self.issues:
            self.issues.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponseBodyReportsReport, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.issues is not None:
            result['Issues'] = self.issues.to_map()
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.report_id is not None:
            result['ReportId'] = self.report_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('Issues') is not None:
            temp_model = DescribeDiagnosticReportsResponseBodyReportsReportIssues()
            self.issues = temp_model.from_map(m['Issues'])
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('ReportId') is not None:
            self.report_id = m.get('ReportId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDiagnosticReportsResponseBodyReports(TeaModel):
    def __init__(self, report=None):
        self.report = report  # type: list[DescribeDiagnosticReportsResponseBodyReportsReport]

    def validate(self):
        if self.report:
            for k in self.report:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponseBodyReports, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Report'] = []
        if self.report is not None:
            for k in self.report:
                result['Report'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.report = []
        if m.get('Report') is not None:
            for k in m.get('Report'):
                temp_model = DescribeDiagnosticReportsResponseBodyReportsReport()
                self.report.append(temp_model.from_map(k))
        return self


class DescribeDiagnosticReportsResponseBody(TeaModel):
    def __init__(self, next_token=None, reports=None, request_id=None):
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The list of reports.
        self.reports = reports  # type: DescribeDiagnosticReportsResponseBodyReports
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.reports:
            self.reports.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.reports is not None:
            result['Reports'] = self.reports.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Reports') is not None:
            temp_model = DescribeDiagnosticReportsResponseBodyReports()
            self.reports = temp_model.from_map(m['Reports'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDiagnosticReportsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDiagnosticReportsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDiagnosticReportsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiagnosticReportsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDiskMonitorDataRequest(TeaModel):
    def __init__(self, disk_id=None, end_time=None, owner_account=None, owner_id=None, period=None,
                 resource_owner_account=None, resource_owner_id=None, start_time=None):
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The end of the time range in which you want to query the monitoring data. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The interval at which to retrieve the monitoring data. Unit: seconds. Valid values:
        # 
        # *   60
        # *   600
        # *   3600
        # 
        # Default value: 60.
        self.period = period  # type: int
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start of the time range in which you want to query the monitoring data. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiskMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData(TeaModel):
    def __init__(self, bpsread=None, bpstotal=None, bpswrite=None, disk_id=None, iopsread=None, iopstotal=None,
                 iopswrite=None, latency_read=None, latency_write=None, time_stamp=None):
        # The read bandwidth of the system disk. Unit: byte/s.
        self.bpsread = bpsread  # type: int
        # The total read and write bandwidth of the system disk. Unit: byte/s.
        self.bpstotal = bpstotal  # type: int
        # The write bandwidth of the system disk. Unit: byte/s.
        self.bpswrite = bpswrite  # type: int
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The number of read I/O operations per second on the system disk.
        self.iopsread = iopsread  # type: int
        # The total number of read and write I/O operations per second on the system disk.
        self.iopstotal = iopstotal  # type: int
        # The number of write I/O operations per second on the system disk.
        self.iopswrite = iopswrite  # type: int
        # The read latency of the disk. Unit: microseconds.
        self.latency_read = latency_read  # type: int
        # The write latency of the disk. Unit: microseconds.
        self.latency_write = latency_write  # type: int
        # The timestamp of the monitoring data. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bpsread is not None:
            result['BPSRead'] = self.bpsread
        if self.bpstotal is not None:
            result['BPSTotal'] = self.bpstotal
        if self.bpswrite is not None:
            result['BPSWrite'] = self.bpswrite
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.iopsread is not None:
            result['IOPSRead'] = self.iopsread
        if self.iopstotal is not None:
            result['IOPSTotal'] = self.iopstotal
        if self.iopswrite is not None:
            result['IOPSWrite'] = self.iopswrite
        if self.latency_read is not None:
            result['LatencyRead'] = self.latency_read
        if self.latency_write is not None:
            result['LatencyWrite'] = self.latency_write
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BPSRead') is not None:
            self.bpsread = m.get('BPSRead')
        if m.get('BPSTotal') is not None:
            self.bpstotal = m.get('BPSTotal')
        if m.get('BPSWrite') is not None:
            self.bpswrite = m.get('BPSWrite')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('IOPSRead') is not None:
            self.iopsread = m.get('IOPSRead')
        if m.get('IOPSTotal') is not None:
            self.iopstotal = m.get('IOPSTotal')
        if m.get('IOPSWrite') is not None:
            self.iopswrite = m.get('IOPSWrite')
        if m.get('LatencyRead') is not None:
            self.latency_read = m.get('LatencyRead')
        if m.get('LatencyWrite') is not None:
            self.latency_write = m.get('LatencyWrite')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeDiskMonitorDataResponseBodyMonitorData(TeaModel):
    def __init__(self, disk_monitor_data=None):
        self.disk_monitor_data = disk_monitor_data  # type: list[DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData]

    def validate(self):
        if self.disk_monitor_data:
            for k in self.disk_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDiskMonitorDataResponseBodyMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskMonitorData'] = []
        if self.disk_monitor_data is not None:
            for k in self.disk_monitor_data:
                result['DiskMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk_monitor_data = []
        if m.get('DiskMonitorData') is not None:
            for k in m.get('DiskMonitorData'):
                temp_model = DescribeDiskMonitorDataResponseBodyMonitorDataDiskMonitorData()
                self.disk_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeDiskMonitorDataResponseBody(TeaModel):
    def __init__(self, monitor_data=None, request_id=None, total_count=None):
        # Details about the monitoring data of the disk.
        self.monitor_data = monitor_data  # type: DescribeDiskMonitorDataResponseBodyMonitorData
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of returned monitoring data entries.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super(DescribeDiskMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MonitorData') is not None:
            temp_model = DescribeDiskMonitorDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDiskMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDiskMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDiskMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDiskMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDisksRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of filter 1 used to query resources. Set the value to `CreationStartTime`. You can specify a time by setting both `Filter.1.Key` and `Filter.1.Value` to query resources that were created after the time.
        self.key = key  # type: str
        # The value of filter 1 used to query resources. Set the value to a time. If you specify this parameter, you must also specify the `Filter.1.Key` parameter. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDisksRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the disk. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the disk. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDisksRequest(TeaModel):
    def __init__(self, filter=None, additional_attributes=None, auto_snapshot_policy_id=None, category=None,
                 delete_auto_snapshot=None, delete_with_instance=None, disk_charge_type=None, disk_ids=None, disk_name=None,
                 disk_type=None, dry_run=None, enable_auto_snapshot=None, enable_automated_snapshot_policy=None,
                 enable_shared=None, encrypted=None, instance_id=None, kmskey_id=None, lock_reason=None, max_results=None,
                 multi_attach=None, next_token=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 portable=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 snapshot_id=None, status=None, tag=None, zone_id=None):
        self.filter = filter  # type: list[DescribeDisksRequestFilter]
        # The values of attributes.
        self.additional_attributes = additional_attributes  # type: list[str]
        # The ID of the automatic snapshot policy that is applied to the cloud disk.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The category of the disk. Valid values:
        # 
        # * all: all disk categories
        # * cloud: basic disk
        # * cloud_efficiency: ultra disk
        # * cloud_ssd: standard SSD
        # * cloud_essd: enhanced SSD (ESSD)
        # * local\_ssd_pro: I/O-intensive local disk
        # * local\_hdd_pro: throughput-intensive local disk
        # * ephemeral: retired local disk
        # * ephemeral_ssd: retired local SSD
        # 
        # Default value: all.
        self.category = category  # type: str
        # Specifies whether to delete the automatic snapshots of the cloud disk when the disk is released.
        # 
        # *   true: The automatic snapshots of the cloud disk are deleted when the disk is released.
        # *   false: The automatic snapshots of the cloud disk are not deleted when the disk is released.
        # 
        # Default value: false.
        self.delete_auto_snapshot = delete_auto_snapshot  # type: bool
        # Specifies whether to release the cloud disk when its associated instance is released. Valid values:
        # 
        # *   true: The cloud disk is released when its associated instance is released.
        # *   false: The cloud disk is not released but is retained as a pay-as-you-go data disk when its associated instance is released.
        # 
        # Default value: false.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The billing method of the disk. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.disk_charge_type = disk_charge_type  # type: str
        # The IDs of disks. The value is a JSON array that consists of up to 100 disk IDs. Separate the disk IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        # The name of the disk.
        self.disk_name = disk_name  # type: str
        # The type of the disk. Valid values:
        # 
        # *   all: system disk and data disk
        # *   system: system disk
        # *   data: data disk
        # 
        # Default value: all.
        self.disk_type = disk_type  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned, and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether the automatic snapshot policy feature is enabled for the cloud disk.
        # 
        # *   true: The automatic snapshot policy feature is enabled for the cloud disk.
        # *   false: The automatic snapshot policy feature is not enabled for the cloud disk.
        # 
        # >  By default, the automatic snapshot policy feature is enabled for created cloud disks. You only need to apply an automatic snapshot policy to a cloud disk before you can use the automatic snapshot policy.
        self.enable_auto_snapshot = enable_auto_snapshot  # type: bool
        # Specifies whether an automatic snapshot policy is applied to the cloud disk.
        # 
        # *   true: An automatic snapshot policy is applied to the cloud disk.
        # *   false: No automatic snapshot policy is applied to the cloud disk.
        # 
        # Default value: false.
        self.enable_automated_snapshot_policy = enable_automated_snapshot_policy  # type: bool
        # Specifies whether the disk is a Shared Block Storage device.
        self.enable_shared = enable_shared  # type: bool
        # Specifies whether to query only encrypted cloud disks.
        # 
        # *   true: queries only encrypted cloud disks.
        # *   false: does not query encrypted cloud disks.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the instance to which the disk is attached.
        self.instance_id = instance_id  # type: str
        # The ID of the Key Management Service (KMS) key used by the cloud disk.
        self.kmskey_id = kmskey_id  # type: str
        # The reason why the disk is locked. Valid values:
        # 
        # *   financial: The disk is locked due to overdue payments.
        # *   security: The disk is locked due to security reasons.
        # *   recycling: The preemptible instance is locked and pending release.
        # *   dedicatedhostfinancial: The instance is locked due to overdue payments for the dedicated host.
        self.lock_reason = lock_reason  # type: str
        # The maximum number of entries to return on each page. Valid values: 1 to 500.
        # 
        # Default value:
        # 
        # *   If this parameter is not specified or is set to a value smaller than 10, the default value is 10.
        # *   If this parameter is set to a value greater than 500, the default value is 500.
        self.max_results = max_results  # type: int
        # Specifies whether the multi-attach feature is enabled for the disk. Valid values:
        # 
        # *   Disabled: The multi-attach feature is not enabled for the disk.
        # *   Enabled: The multi-attach feature is enabled for the disk.
        # *   LegacyShared: Shared Block Storage devices are queried.
        # 
        # The multi-attach feature is in invitational preview. To use this feature, [submit a ticket](https://workorder-intl.console.aliyun.com/console.htm#/ticket/list).
        self.multi_attach = multi_attach  # type: str
        # The query token. Set the value to the `NextToken` value returned in the last call to the Describedisks operation.
        # 
        # For more information about how to check the responses returned by this operation, see the preceding "Description" section.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Page start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # Specifies whether the disk is removable. Valid values:
        # 
        # *   true: The disk is removable. A removable disk can independently exist and can be attached to or detached from an instance within the same zone.
        # *   false: The disk is not removable. A disk that is not removable cannot independently exist or be attached to or detached from an instance within the same zone.
        # 
        # The `Portable` attribute of the following disks is `false`, and these disks share the same lifecycle with their associated instances:
        # 
        # *   Local disks
        # *   Local SSDs
        # *   Subscription data disks
        self.portable = portable  # type: bool
        # The region ID of the disk. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the disk belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot that was used to create the cloud disk.
        self.snapshot_id = snapshot_id  # type: str
        # The state of the cloud disk. For more information, see [Disk states](~~25689~~). Valid values:
        # 
        # * In_use
        # * Available
        # * Attaching
        # * Detaching
        # * Creating
        # * ReIniting
        # * All
        # 
        # Default value: All.
        self.status = status  # type: str
        # The tags.
        self.tag = tag  # type: list[DescribeDisksRequestTag]
        # The zone ID of the disk.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.additional_attributes is not None:
            result['AdditionalAttributes'] = self.additional_attributes
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_auto_snapshot is not None:
            result['DeleteAutoSnapshot'] = self.delete_auto_snapshot
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.disk_charge_type is not None:
            result['DiskChargeType'] = self.disk_charge_type
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.enable_auto_snapshot is not None:
            result['EnableAutoSnapshot'] = self.enable_auto_snapshot
        if self.enable_automated_snapshot_policy is not None:
            result['EnableAutomatedSnapshotPolicy'] = self.enable_automated_snapshot_policy
        if self.enable_shared is not None:
            result['EnableShared'] = self.enable_shared
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.multi_attach is not None:
            result['MultiAttach'] = self.multi_attach
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.portable is not None:
            result['Portable'] = self.portable
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeDisksRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('AdditionalAttributes') is not None:
            self.additional_attributes = m.get('AdditionalAttributes')
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteAutoSnapshot') is not None:
            self.delete_auto_snapshot = m.get('DeleteAutoSnapshot')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('DiskChargeType') is not None:
            self.disk_charge_type = m.get('DiskChargeType')
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EnableAutoSnapshot') is not None:
            self.enable_auto_snapshot = m.get('EnableAutoSnapshot')
        if m.get('EnableAutomatedSnapshotPolicy') is not None:
            self.enable_automated_snapshot_policy = m.get('EnableAutomatedSnapshotPolicy')
        if m.get('EnableShared') is not None:
            self.enable_shared = m.get('EnableShared')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MultiAttach') is not None:
            self.multi_attach = m.get('MultiAttach')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Portable') is not None:
            self.portable = m.get('Portable')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDisksRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDisksResponseBodyDisksDiskAttachmentsAttachment(TeaModel):
    def __init__(self, attached_time=None, device=None, instance_id=None):
        # The time when the disk was attached. The time is displayed in UTC.
        self.attached_time = attached_time  # type: str
        # The device name of the disk.
        self.device = device  # type: str
        # The ID of the instance to which the disk was attached.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskAttachmentsAttachment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attached_time is not None:
            result['AttachedTime'] = self.attached_time
        if self.device is not None:
            result['Device'] = self.device
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachedTime') is not None:
            self.attached_time = m.get('AttachedTime')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeDisksResponseBodyDisksDiskAttachments(TeaModel):
    def __init__(self, attachment=None):
        self.attachment = attachment  # type: list[DescribeDisksResponseBodyDisksDiskAttachmentsAttachment]

    def validate(self):
        if self.attachment:
            for k in self.attachment:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskAttachments, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Attachment'] = []
        if self.attachment is not None:
            for k in self.attachment:
                result['Attachment'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.attachment = []
        if m.get('Attachment') is not None:
            for k in m.get('Attachment'):
                temp_model = DescribeDisksResponseBodyDisksDiskAttachmentsAttachment()
                self.attachment.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance(TeaModel):
    def __init__(self, attached_time=None, device=None, instance_id=None):
        # The time when the cloud disk was attached. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.attached_time = attached_time  # type: str
        # The mount point of the disk.
        self.device = device  # type: str
        # The ID of the instance to which the disk is attached.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attached_time is not None:
            result['AttachedTime'] = self.attached_time
        if self.device is not None:
            result['Device'] = self.device
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachedTime') is not None:
            self.attached_time = m.get('AttachedTime')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeDisksResponseBodyDisksDiskMountInstances(TeaModel):
    def __init__(self, mount_instance=None):
        self.mount_instance = mount_instance  # type: list[DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance]

    def validate(self):
        if self.mount_instance:
            for k in self.mount_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskMountInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MountInstance'] = []
        if self.mount_instance is not None:
            for k in self.mount_instance:
                result['MountInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.mount_instance = []
        if m.get('MountInstance') is not None:
            for k in m.get('MountInstance'):
                temp_model = DescribeDisksResponseBodyDisksDiskMountInstancesMountInstance()
                self.mount_instance.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock(TeaModel):
    def __init__(self, lock_reason=None):
        # The security reason why the disk was locked.
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeDisksResponseBodyDisksDiskOperationLocks(TeaModel):
    def __init__(self, operation_lock=None):
        self.operation_lock = operation_lock  # type: list[DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock]

    def validate(self):
        if self.operation_lock:
            for k in self.operation_lock:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLock'] = []
        if self.operation_lock is not None:
            for k in self.operation_lock:
                result['OperationLock'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_lock = []
        if m.get('OperationLock') is not None:
            for k in m.get('OperationLock'):
                temp_model = DescribeDisksResponseBodyDisksDiskOperationLocksOperationLock()
                self.operation_lock.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBodyDisksDiskTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the disk.
        self.tag_key = tag_key  # type: str
        # The tag value of the disk.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeDisksResponseBodyDisksDiskTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeDisksResponseBodyDisksDiskTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDiskTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDisksResponseBodyDisksDiskTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBodyDisksDisk(TeaModel):
    def __init__(self, attached_time=None, attachments=None, auto_snapshot_policy_id=None, bdf_id=None,
                 bursting_enabled=None, category=None, creation_time=None, delete_auto_snapshot=None, delete_with_instance=None,
                 description=None, detached_time=None, device=None, disk_charge_type=None, disk_id=None, disk_name=None,
                 enable_auto_snapshot=None, enable_automated_snapshot_policy=None, encrypted=None, expired_time=None, iops=None,
                 iopsread=None, iopswrite=None, image_id=None, instance_id=None, kmskey_id=None, mount_instance_num=None,
                 mount_instances=None, multi_attach=None, operation_locks=None, performance_level=None, portable=None,
                 product_code=None, provisioned_iops=None, region_id=None, resource_group_id=None, serial_number=None, size=None,
                 source_snapshot_id=None, status=None, storage_cluster_id=None, storage_set_id=None,
                 storage_set_partition_number=None, tags=None, throughput=None, type=None, zone_id=None):
        # The time when the cloud disk was last attached. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mmZ format. The time is displayed in UTC.
        self.attached_time = attached_time  # type: str
        # The attachment information of the cloud disk. The value is an array that consists of the `Attachment` values. This value is not returned when you query Shared Block Storage devices.
        self.attachments = attachments  # type: DescribeDisksResponseBodyDisksDiskAttachments
        # The ID of the automatic snapshot policy that is applied to the cloud disk.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # This parameter is in invitational preview and is unavailable for general users.
        self.bdf_id = bdf_id  # type: str
        # This parameter is unavailable.
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of the disk. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # *   local_ssd_pro: I/O-intensive local disk
        # *   local_hdd_pro: throughput-intensive local disk
        # *   ephemeral: retired local disk
        # *   ephemeral_ssd: retired local SSD
        self.category = category  # type: str
        # The time when the disk was created.
        self.creation_time = creation_time  # type: str
        # Indicates whether the automatic snapshots of the cloud disk are deleted when the disk is released. Valid values:
        # 
        # *   true: The automatic snapshots of the cloud disk are deleted when the disk is released.
        # *   false: The automatic snapshots of the cloud disk are retained when the disk is released.
        # 
        # Snapshots that are created by calling the [CreateSnapshot](~~25524~~) operation or by using the Elastic Compute Service (ECS) console are retained and not affected by this parameter.
        self.delete_auto_snapshot = delete_auto_snapshot  # type: bool
        # Indicates whether the cloud disk is released when its associated instance is released. Valid values:
        # 
        # *   true: The cloud disk is released when its associated instance is released.
        # *   false: The cloud disk is retained when its associated instance is released.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of the disk.
        self.description = description  # type: str
        # The time when the cloud disk was last detached.
        self.detached_time = detached_time  # type: str
        # The device name of the disk on its associated instance. Example: /dev/xvdb. Take note of the following items:
        # 
        # *   This parameter has a value only when the `Status` value is `In_use`.
        # *   This parameter is empty for cloud disks that have the multi-attach feature enabled. You can query the attachment information of the disk based on the `Attachment` values.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The billing method of the disk. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.disk_charge_type = disk_charge_type  # type: str
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The name of the disk.
        self.disk_name = disk_name  # type: str
        # Indicates whether the automatic snapshot policy feature is enabled for the cloud disk.
        self.enable_auto_snapshot = enable_auto_snapshot  # type: bool
        # Indicates whether an automatic snapshot policy was applied to the cloud disk.
        self.enable_automated_snapshot_policy = enable_automated_snapshot_policy  # type: bool
        # Indicates whether the cloud disk was encrypted.
        self.encrypted = encrypted  # type: bool
        # The time when the subscription cloud disk expires.
        self.expired_time = expired_time  # type: str
        # The maximum number of IOPS.
        self.iops = iops  # type: int
        # The maximum number of read operations per second.
        self.iopsread = iopsread  # type: int
        # The maximum number of write operations per second.
        self.iopswrite = iopswrite  # type: int
        # The ID of the image that was used to create the instance. This parameter is empty unless the cloud disk was created from an image. The value of this parameter remains unchanged throughout the lifecycle of the cloud disk.
        self.image_id = image_id  # type: str
        # The ID of the instance to which the disk was attached. Take note of the following items:
        # 
        # *   This parameter has a value only when the `Status` value is `In_use`.
        # *   This parameter is empty for cloud disks that have the multi-attach feature enabled. You can query the attachment information of the disk based on the `Attachment` values.
        self.instance_id = instance_id  # type: str
        # The ID of the KMS key that is used by the cloud disk.
        self.kmskey_id = kmskey_id  # type: str
        # The number of instances to which the Shared Block Storage device is attached.
        self.mount_instance_num = mount_instance_num  # type: int
        # The attachment information of the Shared Block Storage device.
        self.mount_instances = mount_instances  # type: DescribeDisksResponseBodyDisksDiskMountInstances
        # Indicates whether the multi-attach feature was enabled for the cloud disk.
        self.multi_attach = multi_attach  # type: str
        # The reasons why the disk was locked.
        self.operation_locks = operation_locks  # type: DescribeDisksResponseBodyDisksDiskOperationLocks
        # The performance level of the ESSD. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        self.performance_level = performance_level  # type: str
        # Indicates whether the disk is removable.
        self.portable = portable  # type: bool
        # The product code in Alibaba Cloud Marketplace.
        self.product_code = product_code  # type: str
        # This parameter is unavailable.
        self.provisioned_iops = provisioned_iops  # type: long
        # The region ID of the disk.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the disk belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The serial number of the disk.
        self.serial_number = serial_number  # type: str
        # The size of the disk. Unit: GiB.
        self.size = size  # type: int
        # The ID of the snapshot that was used to create the cloud disk.
        # 
        # This parameter is empty unless the cloud disk was created from a snapshot. The value of this parameter remains unchanged throughout the lifecycle of the cloud disk.
        self.source_snapshot_id = source_snapshot_id  # type: str
        # The state of the cloud disk. Valid values:
        # 
        # *   In_use
        # *   Available
        # *   Attaching
        # *   Detaching
        # *   Creating
        # *   ReIniting
        self.status = status  # type: str
        # The ID of the dedicated block storage cluster to which the cloud disk belongs. If your cloud disk belongs to the public block storage cluster, an empty value is returned.
        self.storage_cluster_id = storage_cluster_id  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The maximum number of partitions in the storage set.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # The tags of the disk.
        self.tags = tags  # type: DescribeDisksResponseBodyDisksDiskTags
        # The amount of data transferred per second. Unit: MB/s.
        self.throughput = throughput  # type: int
        # The type of the disk. Valid values:
        # 
        # *   system: system disk
        # *   data: data disk
        self.type = type  # type: str
        # The zone ID of the disk.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.attachments:
            self.attachments.validate()
        if self.mount_instances:
            self.mount_instances.validate()
        if self.operation_locks:
            self.operation_locks.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisksDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attached_time is not None:
            result['AttachedTime'] = self.attached_time
        if self.attachments is not None:
            result['Attachments'] = self.attachments.to_map()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bdf_id is not None:
            result['BdfId'] = self.bdf_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.delete_auto_snapshot is not None:
            result['DeleteAutoSnapshot'] = self.delete_auto_snapshot
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.detached_time is not None:
            result['DetachedTime'] = self.detached_time
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_charge_type is not None:
            result['DiskChargeType'] = self.disk_charge_type
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.enable_auto_snapshot is not None:
            result['EnableAutoSnapshot'] = self.enable_auto_snapshot
        if self.enable_automated_snapshot_policy is not None:
            result['EnableAutomatedSnapshotPolicy'] = self.enable_automated_snapshot_policy
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.iops is not None:
            result['IOPS'] = self.iops
        if self.iopsread is not None:
            result['IOPSRead'] = self.iopsread
        if self.iopswrite is not None:
            result['IOPSWrite'] = self.iopswrite
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.mount_instance_num is not None:
            result['MountInstanceNum'] = self.mount_instance_num
        if self.mount_instances is not None:
            result['MountInstances'] = self.mount_instances.to_map()
        if self.multi_attach is not None:
            result['MultiAttach'] = self.multi_attach
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.portable is not None:
            result['Portable'] = self.portable
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.size is not None:
            result['Size'] = self.size
        if self.source_snapshot_id is not None:
            result['SourceSnapshotId'] = self.source_snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.throughput is not None:
            result['Throughput'] = self.throughput
        if self.type is not None:
            result['Type'] = self.type
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachedTime') is not None:
            self.attached_time = m.get('AttachedTime')
        if m.get('Attachments') is not None:
            temp_model = DescribeDisksResponseBodyDisksDiskAttachments()
            self.attachments = temp_model.from_map(m['Attachments'])
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BdfId') is not None:
            self.bdf_id = m.get('BdfId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeleteAutoSnapshot') is not None:
            self.delete_auto_snapshot = m.get('DeleteAutoSnapshot')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DetachedTime') is not None:
            self.detached_time = m.get('DetachedTime')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskChargeType') is not None:
            self.disk_charge_type = m.get('DiskChargeType')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('EnableAutoSnapshot') is not None:
            self.enable_auto_snapshot = m.get('EnableAutoSnapshot')
        if m.get('EnableAutomatedSnapshotPolicy') is not None:
            self.enable_automated_snapshot_policy = m.get('EnableAutomatedSnapshotPolicy')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('IOPS') is not None:
            self.iops = m.get('IOPS')
        if m.get('IOPSRead') is not None:
            self.iopsread = m.get('IOPSRead')
        if m.get('IOPSWrite') is not None:
            self.iopswrite = m.get('IOPSWrite')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('MountInstanceNum') is not None:
            self.mount_instance_num = m.get('MountInstanceNum')
        if m.get('MountInstances') is not None:
            temp_model = DescribeDisksResponseBodyDisksDiskMountInstances()
            self.mount_instances = temp_model.from_map(m['MountInstances'])
        if m.get('MultiAttach') is not None:
            self.multi_attach = m.get('MultiAttach')
        if m.get('OperationLocks') is not None:
            temp_model = DescribeDisksResponseBodyDisksDiskOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Portable') is not None:
            self.portable = m.get('Portable')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SourceSnapshotId') is not None:
            self.source_snapshot_id = m.get('SourceSnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        if m.get('Tags') is not None:
            temp_model = DescribeDisksResponseBodyDisksDiskTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Throughput') is not None:
            self.throughput = m.get('Throughput')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeDisksResponseBodyDisks(TeaModel):
    def __init__(self, disk=None):
        self.disk = disk  # type: list[DescribeDisksResponseBodyDisksDisk]

    def validate(self):
        if self.disk:
            for k in self.disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBodyDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Disk'] = []
        if self.disk is not None:
            for k in self.disk:
                result['Disk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk = []
        if m.get('Disk') is not None:
            for k in m.get('Disk'):
                temp_model = DescribeDisksResponseBodyDisksDisk()
                self.disk.append(temp_model.from_map(k))
        return self


class DescribeDisksResponseBody(TeaModel):
    def __init__(self, disks=None, next_token=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the disks.
        self.disks = disks  # type: DescribeDisksResponseBodyDisks
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.disks:
            self.disks.validate()

    def to_map(self):
        _map = super(DescribeDisksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disks is not None:
            result['Disks'] = self.disks.to_map()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Disks') is not None:
            temp_model = DescribeDisksResponseBodyDisks()
            self.disks = temp_model.from_map(m['Disks'])
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDisksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDisksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDisksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDisksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDisksFullStatusRequestEventTime(TeaModel):
    def __init__(self, end=None, start=None):
        # The end of the time range in which to query occurred events.
        # 
        # The time follows the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is specified in UTC.
        self.end = end  # type: str
        # The start of the time range in which to query occurred events.
        # 
        # The time follows the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time specified in UTC.
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksFullStatusRequestEventTime, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeDisksFullStatusRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N added to the EBS device. A key-value pair consists of a key specified by the Tag.N.Key parameter and a value specified by the `Tag.N.Value` parameter. The two parameters are associated with each other. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added are returned. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added are returned.
        self.key = key  # type: str
        # The value of tag N added to the EBS device. A key-value pair consists of a key specified by the `Tag.N.Key` parameter and a value specified by the Tag.N.Value parameter. The two parameters are associated with each other. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksFullStatusRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDisksFullStatusRequest(TeaModel):
    def __init__(self, event_time=None, disk_id=None, event_id=None, event_type=None, health_status=None,
                 owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, status=None, tag=None):
        self.event_time = event_time  # type: DescribeDisksFullStatusRequestEventTime
        # The ID of EBS device N. Valid values of N: 1 to 100.
        self.disk_id = disk_id  # type: list[str]
        # The ID of the event. Valid values of N: 1 to 100.
        self.event_id = event_id  # type: list[str]
        # The event type. Valid values:
        # 
        # *   Degraded: The performance of the EBS device is degraded.
        # *   SeverelyDegraded: The performance of the EBS device is severely degraded.
        # *   Stalled: The performance of the EBS device is severely affected.
        # *   ErrorDetected: The local disk is damaged.
        self.event_type = event_type  # type: str
        # The health status of the EBS device. Valid values:
        # 
        # *   Impaired: The EBS device is damaged.
        # *   Warning: The performance of the EBS device may be degraded.
        # *   Initializing: The disk is being initialized.
        # *   InsufficientData: The status cannot be determined due to insufficient data.
        # *   NotApplicable: The EBS device cannot be used.
        self.health_status = health_status  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. The value must be a positive integer.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the EBS device. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the EBS device belongs. When you use this property to query resources, the number of resources that are contained in the specified resource group cannot exceed 1,000.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The lifecycle status of the EBS device. For more information, see [Disk status](~~25689~~). Valid values:
        # 
        # *   In_use: The disk is in use.
        # *   Available: The disk can be attached.
        # *   Attaching: The disk is being attached.
        # *   Detaching: The disk is being detached.
        # *   Creating: The disk is being created.
        # *   ReIniting: The disk is being initialized.
        self.status = status  # type: str
        # The tags of the instance.
        self.tag = tag  # type: list[DescribeDisksFullStatusRequestTag]

    def validate(self):
        if self.event_time:
            self.event_time.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_time is not None:
            result['EventTime'] = self.event_time.to_map()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventTime') is not None:
            temp_model = DescribeDisksFullStatusRequestEventTime()
            self.event_time = temp_model.from_map(m['EventTime'])
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDisksFullStatusRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the event type.
        self.code = code  # type: int
        # The name of the event type. Valid values:
        # 
        # *   Degraded: The performance of the EBS device was degraded.
        # *   SeverelyDegraded: The performance of the EBS device was severely degraded.
        # *   Stalled: The performance of the EBS device was severely affected.
        # *   ErrorDetected: The local disk was damaged.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType(TeaModel):
    def __init__(self, event_end_time=None, event_id=None, event_time=None, event_type=None, impact_level=None):
        # The time when the event ended.
        self.event_end_time = event_end_time  # type: str
        # The ID of the event.
        self.event_id = event_id  # type: str
        # The time when the event occurred.
        self.event_time = event_time  # type: str
        # The type of the event.
        self.event_type = event_type  # type: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType
        # The impact level of the event.
        self.impact_level = impact_level  # type: str

    def validate(self):
        if self.event_type:
            self.event_type.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_end_time is not None:
            result['EventEndTime'] = self.event_end_time
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        if self.event_type is not None:
            result['EventType'] = self.event_type.to_map()
        if self.impact_level is not None:
            result['ImpactLevel'] = self.impact_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventEndTime') is not None:
            self.event_end_time = m.get('EventEndTime')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        if m.get('EventType') is not None:
            temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventTypeEventType()
            self.event_type = temp_model.from_map(m['EventType'])
        if m.get('ImpactLevel') is not None:
            self.impact_level = m.get('ImpactLevel')
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet(TeaModel):
    def __init__(self, disk_event_type=None):
        self.disk_event_type = disk_event_type  # type: list[DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType]

    def validate(self):
        if self.disk_event_type:
            for k in self.disk_event_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskEventType'] = []
        if self.disk_event_type is not None:
            for k in self.disk_event_type:
                result['DiskEventType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk_event_type = []
        if m.get('DiskEventType') is not None:
            for k in m.get('DiskEventType'):
                temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSetDiskEventType()
                self.disk_event_type.append(temp_model.from_map(k))
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the health status of the EBS device.
        self.code = code  # type: int
        # The name of the health status of the EBS device.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the lifecycle status of the EBS device.
        self.code = code  # type: int
        # The name of the lifecycle status of the EBS device.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType(TeaModel):
    def __init__(self, device=None, disk_event_set=None, disk_id=None, health_status=None, instance_id=None,
                 status=None):
        # The name of the EBS device that is attached to an instance. Example: /dev/xvdb.
        # 
        # This parameter has a value only when the value of `Status` is `In_use`.
        # 
        # > This parameter will be deprecated in the future. To ensure future compatibility, we recommend that you do not use this parameter.
        self.device = device  # type: str
        # The events about the EBS device.
        self.disk_event_set = disk_event_set  # type: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet
        # The ID of EBS device N.
        self.disk_id = disk_id  # type: str
        # The health status of the EBS device.
        self.health_status = health_status  # type: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus
        # The ID of the instance that you query.
        self.instance_id = instance_id  # type: str
        # The lifecycle status of the EBS device.
        self.status = status  # type: DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus

    def validate(self):
        if self.disk_event_set:
            self.disk_event_set.validate()
        if self.health_status:
            self.health_status.validate()
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_event_set is not None:
            result['DiskEventSet'] = self.disk_event_set.to_map()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskEventSet') is not None:
            temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeDiskEventSet()
            self.disk_event_set = temp_model.from_map(m['DiskEventSet'])
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('HealthStatus') is not None:
            temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeHealthStatus()
            self.health_status = temp_model.from_map(m['HealthStatus'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusTypeStatus()
            self.status = temp_model.from_map(m['Status'])
        return self


class DescribeDisksFullStatusResponseBodyDiskFullStatusSet(TeaModel):
    def __init__(self, disk_full_status_type=None):
        self.disk_full_status_type = disk_full_status_type  # type: list[DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType]

    def validate(self):
        if self.disk_full_status_type:
            for k in self.disk_full_status_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBodyDiskFullStatusSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskFullStatusType'] = []
        if self.disk_full_status_type is not None:
            for k in self.disk_full_status_type:
                result['DiskFullStatusType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk_full_status_type = []
        if m.get('DiskFullStatusType') is not None:
            for k in m.get('DiskFullStatusType'):
                temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSetDiskFullStatusType()
                self.disk_full_status_type.append(temp_model.from_map(k))
        return self


class DescribeDisksFullStatusResponseBody(TeaModel):
    def __init__(self, disk_full_status_set=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # The collection of full status information of the EBS devices.
        self.disk_full_status_set = disk_full_status_set  # type: DescribeDisksFullStatusResponseBodyDiskFullStatusSet
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of EBS devices for which full status information is returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.disk_full_status_set:
            self.disk_full_status_set.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_full_status_set is not None:
            result['DiskFullStatusSet'] = self.disk_full_status_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskFullStatusSet') is not None:
            temp_model = DescribeDisksFullStatusResponseBodyDiskFullStatusSet()
            self.disk_full_status_set = temp_model.from_map(m['DiskFullStatusSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDisksFullStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDisksFullStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDisksFullStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDisksFullStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEipAddressesRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEipAddressesRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeEipAddressesRequest(TeaModel):
    def __init__(self, filter=None, allocation_id=None, associated_instance_id=None, associated_instance_type=None,
                 charge_type=None, eip_address=None, isp=None, lock_reason=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 status=None):
        self.filter = filter  # type: list[DescribeEipAddressesRequestFilter]
        self.allocation_id = allocation_id  # type: str
        self.associated_instance_id = associated_instance_id  # type: str
        self.associated_instance_type = associated_instance_type  # type: str
        self.charge_type = charge_type  # type: str
        self.eip_address = eip_address  # type: str
        self.isp = isp  # type: str
        self.lock_reason = lock_reason  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.status = status  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.associated_instance_id is not None:
            result['AssociatedInstanceId'] = self.associated_instance_id
        if self.associated_instance_type is not None:
            result['AssociatedInstanceType'] = self.associated_instance_type
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeEipAddressesRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('AssociatedInstanceId') is not None:
            self.associated_instance_id = m.get('AssociatedInstanceId')
        if m.get('AssociatedInstanceType') is not None:
            self.associated_instance_type = m.get('AssociatedInstanceType')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('EipAddress') is not None:
            self.eip_address = m.get('EipAddress')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason(TeaModel):
    def __init__(self, lock_reason=None):
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks(TeaModel):
    def __init__(self, lock_reason=None):
        self.lock_reason = lock_reason  # type: list[DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason]

    def validate(self):
        if self.lock_reason:
            for k in self.lock_reason:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LockReason'] = []
        if self.lock_reason is not None:
            for k in self.lock_reason:
                result['LockReason'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.lock_reason = []
        if m.get('LockReason') is not None:
            for k in m.get('LockReason'):
                temp_model = DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocksLockReason()
                self.lock_reason.append(temp_model.from_map(k))
        return self


class DescribeEipAddressesResponseBodyEipAddressesEipAddress(TeaModel):
    def __init__(self, allocation_id=None, allocation_time=None, bandwidth=None, charge_type=None,
                 eip_bandwidth=None, expired_time=None, instance_id=None, instance_type=None, internet_charge_type=None,
                 ip_address=None, operation_locks=None, region_id=None, status=None):
        self.allocation_id = allocation_id  # type: str
        self.allocation_time = allocation_time  # type: str
        self.bandwidth = bandwidth  # type: str
        self.charge_type = charge_type  # type: str
        self.eip_bandwidth = eip_bandwidth  # type: str
        self.expired_time = expired_time  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_type = instance_type  # type: str
        self.internet_charge_type = internet_charge_type  # type: str
        self.ip_address = ip_address  # type: str
        self.operation_locks = operation_locks  # type: DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks
        self.region_id = region_id  # type: str
        self.status = status  # type: str

    def validate(self):
        if self.operation_locks:
            self.operation_locks.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesResponseBodyEipAddressesEipAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.allocation_time is not None:
            result['AllocationTime'] = self.allocation_time
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.eip_bandwidth is not None:
            result['EipBandwidth'] = self.eip_bandwidth
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('AllocationTime') is not None:
            self.allocation_time = m.get('AllocationTime')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('EipBandwidth') is not None:
            self.eip_bandwidth = m.get('EipBandwidth')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('OperationLocks') is not None:
            temp_model = DescribeEipAddressesResponseBodyEipAddressesEipAddressOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeEipAddressesResponseBodyEipAddresses(TeaModel):
    def __init__(self, eip_address=None):
        self.eip_address = eip_address  # type: list[DescribeEipAddressesResponseBodyEipAddressesEipAddress]

    def validate(self):
        if self.eip_address:
            for k in self.eip_address:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesResponseBodyEipAddresses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EipAddress'] = []
        if self.eip_address is not None:
            for k in self.eip_address:
                result['EipAddress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.eip_address = []
        if m.get('EipAddress') is not None:
            for k in m.get('EipAddress'):
                temp_model = DescribeEipAddressesResponseBodyEipAddressesEipAddress()
                self.eip_address.append(temp_model.from_map(k))
        return self


class DescribeEipAddressesResponseBody(TeaModel):
    def __init__(self, eip_addresses=None, page_number=None, page_size=None, request_id=None, total_count=None):
        self.eip_addresses = eip_addresses  # type: DescribeEipAddressesResponseBodyEipAddresses
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.eip_addresses:
            self.eip_addresses.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_addresses is not None:
            result['EipAddresses'] = self.eip_addresses.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EipAddresses') is not None:
            temp_model = DescribeEipAddressesResponseBodyEipAddresses()
            self.eip_addresses = temp_model.from_map(m['EipAddresses'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEipAddressesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEipAddressesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEipAddressesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEipAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEipMonitorDataRequest(TeaModel):
    def __init__(self, allocation_id=None, end_time=None, owner_account=None, owner_id=None, period=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, start_time=None):
        self.allocation_id = allocation_id  # type: str
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.period = period  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEipMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData(TeaModel):
    def __init__(self, eip_bandwidth=None, eip_flow=None, eip_packets=None, eip_rx=None, eip_tx=None,
                 time_stamp=None):
        self.eip_bandwidth = eip_bandwidth  # type: int
        self.eip_flow = eip_flow  # type: int
        self.eip_packets = eip_packets  # type: int
        self.eip_rx = eip_rx  # type: int
        self.eip_tx = eip_tx  # type: int
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_bandwidth is not None:
            result['EipBandwidth'] = self.eip_bandwidth
        if self.eip_flow is not None:
            result['EipFlow'] = self.eip_flow
        if self.eip_packets is not None:
            result['EipPackets'] = self.eip_packets
        if self.eip_rx is not None:
            result['EipRX'] = self.eip_rx
        if self.eip_tx is not None:
            result['EipTX'] = self.eip_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EipBandwidth') is not None:
            self.eip_bandwidth = m.get('EipBandwidth')
        if m.get('EipFlow') is not None:
            self.eip_flow = m.get('EipFlow')
        if m.get('EipPackets') is not None:
            self.eip_packets = m.get('EipPackets')
        if m.get('EipRX') is not None:
            self.eip_rx = m.get('EipRX')
        if m.get('EipTX') is not None:
            self.eip_tx = m.get('EipTX')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeEipMonitorDataResponseBodyEipMonitorDatas(TeaModel):
    def __init__(self, eip_monitor_data=None):
        self.eip_monitor_data = eip_monitor_data  # type: list[DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData]

    def validate(self):
        if self.eip_monitor_data:
            for k in self.eip_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEipMonitorDataResponseBodyEipMonitorDatas, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EipMonitorData'] = []
        if self.eip_monitor_data is not None:
            for k in self.eip_monitor_data:
                result['EipMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.eip_monitor_data = []
        if m.get('EipMonitorData') is not None:
            for k in m.get('EipMonitorData'):
                temp_model = DescribeEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData()
                self.eip_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeEipMonitorDataResponseBody(TeaModel):
    def __init__(self, eip_monitor_datas=None, request_id=None):
        self.eip_monitor_datas = eip_monitor_datas  # type: DescribeEipMonitorDataResponseBodyEipMonitorDatas
        self.request_id = request_id  # type: str

    def validate(self):
        if self.eip_monitor_datas:
            self.eip_monitor_datas.validate()

    def to_map(self):
        _map = super(DescribeEipMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_monitor_datas is not None:
            result['EipMonitorDatas'] = self.eip_monitor_datas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EipMonitorDatas') is not None:
            temp_model = DescribeEipMonitorDataResponseBodyEipMonitorDatas()
            self.eip_monitor_datas = temp_model.from_map(m['EipMonitorDatas'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeEipMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEipMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEipMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEipMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None):
        # The ID of the elasticity assurance.
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class DescribeElasticityAssuranceInstancesRequest(TeaModel):
    def __init__(self, private_pool_options=None, max_results=None, next_token=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token used to start the next query. Set the value to the NextToken value obtained from the response to the previous request.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the elasticity assurance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = DescribeElasticityAssuranceInstancesRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet(TeaModel):
    def __init__(self, instance_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem(TeaModel):
    def __init__(self, instance_id_set=None):
        self.instance_id_set = instance_id_set  # type: list[DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet]

    def validate(self):
        if self.instance_id_set:
            for k in self.instance_id_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceIdSet'] = []
        if self.instance_id_set is not None:
            for k in self.instance_id_set:
                result['InstanceIdSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_id_set = []
        if m.get('InstanceIdSet') is not None:
            for k in m.get('InstanceIdSet'):
                temp_model = DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItemInstanceIdSet()
                self.instance_id_set.append(temp_model.from_map(k))
        return self


class DescribeElasticityAssuranceInstancesResponseBody(TeaModel):
    def __init__(self, elasticity_assurance_item=None, max_results=None, next_token=None, request_id=None,
                 total_count=None):
        # Details about the instances that were created by using the elasticity assurance.
        self.elasticity_assurance_item = elasticity_assurance_item  # type: DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem
        # The number of entries returned per page.
        self.max_results = max_results  # type: int
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.elasticity_assurance_item:
            self.elasticity_assurance_item.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.elasticity_assurance_item is not None:
            result['ElasticityAssuranceItem'] = self.elasticity_assurance_item.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ElasticityAssuranceItem') is not None:
            temp_model = DescribeElasticityAssuranceInstancesResponseBodyElasticityAssuranceItem()
            self.elasticity_assurance_item = temp_model.from_map(m['ElasticityAssuranceItem'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeElasticityAssuranceInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeElasticityAssuranceInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssuranceInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeElasticityAssuranceInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeElasticityAssurancesRequestPrivatePoolOptions(TeaModel):
    def __init__(self, ids=None):
        # The IDs of elasticity assurances. The value can be a JSON array that consists of up to 100 elasticity assurance IDs. Separate the IDs with commas (,).
        self.ids = ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssurancesRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        return self


class DescribeElasticityAssurancesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the elasticity assurance. You can specify multiple tag keys to query.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag of the elasticity assurance.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssurancesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeElasticityAssurancesRequest(TeaModel):
    def __init__(self, private_pool_options=None, instance_charge_type=None, instance_type=None, max_results=None,
                 next_token=None, owner_account=None, owner_id=None, platform=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, status=None, tag=None, zone_id=None):
        self.private_pool_options = private_pool_options  # type: DescribeElasticityAssurancesRequestPrivatePoolOptions
        # The billing method of the instances to be created by using the elasticity assurance. Set the value to PostPaid. Only pay-as-you-go instances can be created by using elasticity assurances.  
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type to which the elasticity assurance applies.
        self.instance_type = instance_type  # type: str
        # The maximum number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token used to start the next query. Set the value to the NextToken value obtained from the response to the previous request.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # >  This parameter is deprecated.
        self.platform = platform  # type: str
        # The region ID of the elasticity assurance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the elasticity assurance belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The state of the elasticity assurance. Valid values:
        # 
        # - All: All states.
        # - Preparing: The elasticity assurance is being prepared.
        # - Prepared: The elasticity assurance is to take effect.
        # - Active: The elasticity assurance is in effect.
        # - Released: The elasticity assurance is released.
        # 
        # Default value: Active.
        self.status = status  # type: str
        # The tags that you want to query resources. You can specify a maximum of 20 tags.
        self.tag = tag  # type: list[DescribeElasticityAssurancesRequestTag]
        # The zone ID of the elasticity assurance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = DescribeElasticityAssurancesRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeElasticityAssurancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource(TeaModel):
    def __init__(self, instance_type=None, total_amount=None, used_amount=None, zone_id=None):
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The total number of instances for which capacity of an instance type is reserved.
        self.total_amount = total_amount  # type: int
        # The number of instances that have used the elasticity assurance.
        self.used_amount = used_amount  # type: int
        # The zone ID.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.total_amount is not None:
            result['TotalAmount'] = self.total_amount
        if self.used_amount is not None:
            result['UsedAmount'] = self.used_amount
        if self.zone_id is not None:
            result['zoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('TotalAmount') is not None:
            self.total_amount = m.get('TotalAmount')
        if m.get('UsedAmount') is not None:
            self.used_amount = m.get('UsedAmount')
        if m.get('zoneId') is not None:
            self.zone_id = m.get('zoneId')
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources(TeaModel):
    def __init__(self, allocated_resource=None):
        self.allocated_resource = allocated_resource  # type: list[DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource]

    def validate(self):
        if self.allocated_resource:
            for k in self.allocated_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllocatedResource'] = []
        if self.allocated_resource is not None:
            for k in self.allocated_resource:
                result['AllocatedResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.allocated_resource = []
        if m.get('AllocatedResource') is not None:
            for k in m.get('AllocatedResource'):
                temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResourcesAllocatedResource()
                self.allocated_resource.append(temp_model.from_map(k))
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the elasticity assurance.
        self.tag_key = tag_key  # type: str
        # The tag value of the elasticity assurance.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem(TeaModel):
    def __init__(self, allocated_resources=None, description=None, end_time=None, instance_charge_type=None,
                 latest_start_time=None, private_pool_options_id=None, private_pool_options_match_criteria=None,
                 private_pool_options_name=None, region_id=None, resource_group_id=None, start_time=None, start_time_type=None, status=None,
                 tags=None, total_assurance_times=None, used_assurance_times=None):
        # Details about the allocated resources.
        self.allocated_resources = allocated_resources  # type: DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources
        # The description of the elasticity assurance.
        self.description = description  # type: str
        # The time when the elasticity assurance expires.
        self.end_time = end_time  # type: str
        # The billing method of the instances to be created by using the elasticity assurance. Set the value to PostPaid. Only pay-as-you-go instances can be created by using elasticity assurances.
        self.instance_charge_type = instance_charge_type  # type: str
        # >  This parameter is unavailable.
        self.latest_start_time = latest_start_time  # type: str
        # The ID of the elasticity assurance.
        self.private_pool_options_id = private_pool_options_id  # type: str
        # The type of the private pool associated with the elasticity assurance. Valid values:
        # 
        # - Open: open private pool
        # - Target: targeted private pool
        self.private_pool_options_match_criteria = private_pool_options_match_criteria  # type: str
        # The name of the elasticity assurance.
        self.private_pool_options_name = private_pool_options_name  # type: str
        # The region ID of the elasticity assurance.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the elasticity assurance belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The time when the elasticity assurance takes effect.
        self.start_time = start_time  # type: str
        # Indicates when the elasticity assurance takes effect. Valid values:
        # 
        # - Now: The elasticity assurance takes effect as soon as it is created.
        # - Later: The elasticity assurance takes effect at the specified time.
        self.start_time_type = start_time_type  # type: str
        # The state of the elasticity assurance. Valid values:
        # 
        # - Preparing: The elasticity assurance is being prepared.
        # - Prepared: The elasticity assurance is to take effect.
        # - Active: The elasticity assurance is in effect.
        # - Released: The elasticity assurance is released.
        self.status = status  # type: str
        # The tags of the elasticity assurance.
        self.tags = tags  # type: DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags
        # The total number of times that the elasticity assurance has been applied.
        self.total_assurance_times = total_assurance_times  # type: str
        # >  This parameter is unavailable.
        self.used_assurance_times = used_assurance_times  # type: int

    def validate(self):
        if self.allocated_resources:
            self.allocated_resources.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocated_resources is not None:
            result['AllocatedResources'] = self.allocated_resources.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.latest_start_time is not None:
            result['LatestStartTime'] = self.latest_start_time
        if self.private_pool_options_id is not None:
            result['PrivatePoolOptionsId'] = self.private_pool_options_id
        if self.private_pool_options_match_criteria is not None:
            result['PrivatePoolOptionsMatchCriteria'] = self.private_pool_options_match_criteria
        if self.private_pool_options_name is not None:
            result['PrivatePoolOptionsName'] = self.private_pool_options_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.start_time_type is not None:
            result['StartTimeType'] = self.start_time_type
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.total_assurance_times is not None:
            result['TotalAssuranceTimes'] = self.total_assurance_times
        if self.used_assurance_times is not None:
            result['UsedAssuranceTimes'] = self.used_assurance_times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocatedResources') is not None:
            temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemAllocatedResources()
            self.allocated_resources = temp_model.from_map(m['AllocatedResources'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('LatestStartTime') is not None:
            self.latest_start_time = m.get('LatestStartTime')
        if m.get('PrivatePoolOptionsId') is not None:
            self.private_pool_options_id = m.get('PrivatePoolOptionsId')
        if m.get('PrivatePoolOptionsMatchCriteria') is not None:
            self.private_pool_options_match_criteria = m.get('PrivatePoolOptionsMatchCriteria')
        if m.get('PrivatePoolOptionsName') is not None:
            self.private_pool_options_name = m.get('PrivatePoolOptionsName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StartTimeType') is not None:
            self.start_time_type = m.get('StartTimeType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItemTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TotalAssuranceTimes') is not None:
            self.total_assurance_times = m.get('TotalAssuranceTimes')
        if m.get('UsedAssuranceTimes') is not None:
            self.used_assurance_times = m.get('UsedAssuranceTimes')
        return self


class DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet(TeaModel):
    def __init__(self, elasticity_assurance_item=None):
        self.elasticity_assurance_item = elasticity_assurance_item  # type: list[DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem]

    def validate(self):
        if self.elasticity_assurance_item:
            for k in self.elasticity_assurance_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ElasticityAssuranceItem'] = []
        if self.elasticity_assurance_item is not None:
            for k in self.elasticity_assurance_item:
                result['ElasticityAssuranceItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.elasticity_assurance_item = []
        if m.get('ElasticityAssuranceItem') is not None:
            for k in m.get('ElasticityAssuranceItem'):
                temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSetElasticityAssuranceItem()
                self.elasticity_assurance_item.append(temp_model.from_map(k))
        return self


class DescribeElasticityAssurancesResponseBody(TeaModel):
    def __init__(self, elasticity_assurance_set=None, max_results=None, next_token=None, request_id=None,
                 total_count=None):
        # Details about the elasticity assurances.
        self.elasticity_assurance_set = elasticity_assurance_set  # type: DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet
        # The number of entries returned per page.
        self.max_results = max_results  # type: int
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.elasticity_assurance_set:
            self.elasticity_assurance_set.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.elasticity_assurance_set is not None:
            result['ElasticityAssuranceSet'] = self.elasticity_assurance_set.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ElasticityAssuranceSet') is not None:
            temp_model = DescribeElasticityAssurancesResponseBodyElasticityAssuranceSet()
            self.elasticity_assurance_set = temp_model.from_map(m['ElasticityAssuranceSet'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeElasticityAssurancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeElasticityAssurancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeElasticityAssurancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeElasticityAssurancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEniMonitorDataRequest(TeaModel):
    def __init__(self, end_time=None, eni_id=None, instance_id=None, owner_account=None, owner_id=None, period=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, start_time=None):
        # The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.end_time = end_time  # type: str
        # The ID of the secondary ENI. By default, all secondary ENIs that are bound to the specified instance are queried.
        self.eni_id = eni_id  # type: str
        # The ID of the instance to which the secondary ENI is bound.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The interval at which to retrieve monitored data. Unit: seconds. Valid values:
        # 
        # *   60
        # *   600
        # *   3600
        # 
        # Default value: 60.
        self.period = period  # type: int
        # The region ID of the secondary ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEniMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.eni_id is not None:
            result['EniId'] = self.eni_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EniId') is not None:
            self.eni_id = m.get('EniId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData(TeaModel):
    def __init__(self, drop_packet_rx=None, drop_packet_tx=None, eni_id=None, intranet_rx=None, intranet_tx=None,
                 packet_rx=None, packet_tx=None, time_stamp=None):
        # The number of dropped packets received by the secondary ENI over the internal network.
        self.drop_packet_rx = drop_packet_rx  # type: str
        # The number of dropped packets sent by the secondary ENI over the internal network.
        self.drop_packet_tx = drop_packet_tx  # type: str
        # The ID of the secondary ENI.
        self.eni_id = eni_id  # type: str
        # The average rate of data traffic received by the secondary ENI over the internal network. Unit: Kbit/s.
        self.intranet_rx = intranet_rx  # type: str
        # The average rate of data traffic sent by the secondary ENI over the internal network. Unit: Kbit/s.
        self.intranet_tx = intranet_tx  # type: str
        # The number of packets received by the secondary ENI over the internal network.
        self.packet_rx = packet_rx  # type: str
        # The number of packets sent by the secondary ENI over the internal network.
        self.packet_tx = packet_tx  # type: str
        # The timestamp of the monitored data. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.drop_packet_rx is not None:
            result['DropPacketRx'] = self.drop_packet_rx
        if self.drop_packet_tx is not None:
            result['DropPacketTx'] = self.drop_packet_tx
        if self.eni_id is not None:
            result['EniId'] = self.eni_id
        if self.intranet_rx is not None:
            result['IntranetRx'] = self.intranet_rx
        if self.intranet_tx is not None:
            result['IntranetTx'] = self.intranet_tx
        if self.packet_rx is not None:
            result['PacketRx'] = self.packet_rx
        if self.packet_tx is not None:
            result['PacketTx'] = self.packet_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DropPacketRx') is not None:
            self.drop_packet_rx = m.get('DropPacketRx')
        if m.get('DropPacketTx') is not None:
            self.drop_packet_tx = m.get('DropPacketTx')
        if m.get('EniId') is not None:
            self.eni_id = m.get('EniId')
        if m.get('IntranetRx') is not None:
            self.intranet_rx = m.get('IntranetRx')
        if m.get('IntranetTx') is not None:
            self.intranet_tx = m.get('IntranetTx')
        if m.get('PacketRx') is not None:
            self.packet_rx = m.get('PacketRx')
        if m.get('PacketTx') is not None:
            self.packet_tx = m.get('PacketTx')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeEniMonitorDataResponseBodyMonitorData(TeaModel):
    def __init__(self, eni_monitor_data=None):
        self.eni_monitor_data = eni_monitor_data  # type: list[DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData]

    def validate(self):
        if self.eni_monitor_data:
            for k in self.eni_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEniMonitorDataResponseBodyMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EniMonitorData'] = []
        if self.eni_monitor_data is not None:
            for k in self.eni_monitor_data:
                result['EniMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.eni_monitor_data = []
        if m.get('EniMonitorData') is not None:
            for k in m.get('EniMonitorData'):
                temp_model = DescribeEniMonitorDataResponseBodyMonitorDataEniMonitorData()
                self.eni_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeEniMonitorDataResponseBody(TeaModel):
    def __init__(self, monitor_data=None, request_id=None, total_count=None):
        # Details about the monitored data of the ENI.
        self.monitor_data = monitor_data  # type: DescribeEniMonitorDataResponseBodyMonitorData
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of returned entries.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super(DescribeEniMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MonitorData') is not None:
            temp_model = DescribeEniMonitorDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeEniMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEniMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEniMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEniMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeForwardTableEntriesRequest(TeaModel):
    def __init__(self, forward_entry_id=None, forward_table_id=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.forward_entry_id = forward_entry_id  # type: str
        self.forward_table_id = forward_table_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeForwardTableEntriesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry(TeaModel):
    def __init__(self, external_ip=None, external_port=None, forward_entry_id=None, forward_table_id=None,
                 internal_ip=None, internal_port=None, ip_protocol=None, status=None):
        self.external_ip = external_ip  # type: str
        self.external_port = external_port  # type: str
        self.forward_entry_id = forward_entry_id  # type: str
        self.forward_table_id = forward_table_id  # type: str
        self.internal_ip = internal_ip  # type: str
        self.internal_port = internal_port  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeForwardTableEntriesResponseBodyForwardTableEntries(TeaModel):
    def __init__(self, forward_table_entry=None):
        self.forward_table_entry = forward_table_entry  # type: list[DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry]

    def validate(self):
        if self.forward_table_entry:
            for k in self.forward_table_entry:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeForwardTableEntriesResponseBodyForwardTableEntries, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ForwardTableEntry'] = []
        if self.forward_table_entry is not None:
            for k in self.forward_table_entry:
                result['ForwardTableEntry'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.forward_table_entry = []
        if m.get('ForwardTableEntry') is not None:
            for k in m.get('ForwardTableEntry'):
                temp_model = DescribeForwardTableEntriesResponseBodyForwardTableEntriesForwardTableEntry()
                self.forward_table_entry.append(temp_model.from_map(k))
        return self


class DescribeForwardTableEntriesResponseBody(TeaModel):
    def __init__(self, forward_table_entries=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        self.forward_table_entries = forward_table_entries  # type: DescribeForwardTableEntriesResponseBodyForwardTableEntries
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.forward_table_entries:
            self.forward_table_entries.validate()

    def to_map(self):
        _map = super(DescribeForwardTableEntriesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_table_entries is not None:
            result['ForwardTableEntries'] = self.forward_table_entries.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardTableEntries') is not None:
            temp_model = DescribeForwardTableEntriesResponseBodyForwardTableEntries()
            self.forward_table_entries = temp_model.from_map(m['ForwardTableEntries'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeForwardTableEntriesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeForwardTableEntriesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeForwardTableEntriesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeForwardTableEntriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHaVipsRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHaVipsRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeHaVipsRequest(TeaModel):
    def __init__(self, filter=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.filter = filter  # type: list[DescribeHaVipsRequestFilter]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHaVipsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeHaVipsRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses(TeaModel):
    def __init__(self, associated_eip_addresse=None):
        self.associated_eip_addresse = associated_eip_addresse  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_eip_addresse is not None:
            result['associatedEipAddresse'] = self.associated_eip_addresse
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('associatedEipAddresse') is not None:
            self.associated_eip_addresse = m.get('associatedEipAddresse')
        return self


class DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances(TeaModel):
    def __init__(self, associated_instance=None):
        self.associated_instance = associated_instance  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_instance is not None:
            result['associatedInstance'] = self.associated_instance
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('associatedInstance') is not None:
            self.associated_instance = m.get('associatedInstance')
        return self


class DescribeHaVipsResponseBodyHaVipsHaVip(TeaModel):
    def __init__(self, associated_eip_addresses=None, associated_instances=None, create_time=None,
                 description=None, ha_vip_id=None, ip_address=None, master_instance_id=None, region_id=None, status=None,
                 v_switch_id=None, vpc_id=None):
        self.associated_eip_addresses = associated_eip_addresses  # type: DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses
        self.associated_instances = associated_instances  # type: DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.ha_vip_id = ha_vip_id  # type: str
        self.ip_address = ip_address  # type: str
        self.master_instance_id = master_instance_id  # type: str
        self.region_id = region_id  # type: str
        self.status = status  # type: str
        self.v_switch_id = v_switch_id  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.associated_eip_addresses:
            self.associated_eip_addresses.validate()
        if self.associated_instances:
            self.associated_instances.validate()

    def to_map(self):
        _map = super(DescribeHaVipsResponseBodyHaVipsHaVip, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_eip_addresses is not None:
            result['AssociatedEipAddresses'] = self.associated_eip_addresses.to_map()
        if self.associated_instances is not None:
            result['AssociatedInstances'] = self.associated_instances.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.master_instance_id is not None:
            result['MasterInstanceId'] = self.master_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssociatedEipAddresses') is not None:
            temp_model = DescribeHaVipsResponseBodyHaVipsHaVipAssociatedEipAddresses()
            self.associated_eip_addresses = temp_model.from_map(m['AssociatedEipAddresses'])
        if m.get('AssociatedInstances') is not None:
            temp_model = DescribeHaVipsResponseBodyHaVipsHaVipAssociatedInstances()
            self.associated_instances = temp_model.from_map(m['AssociatedInstances'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('MasterInstanceId') is not None:
            self.master_instance_id = m.get('MasterInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeHaVipsResponseBodyHaVips(TeaModel):
    def __init__(self, ha_vip=None):
        self.ha_vip = ha_vip  # type: list[DescribeHaVipsResponseBodyHaVipsHaVip]

    def validate(self):
        if self.ha_vip:
            for k in self.ha_vip:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHaVipsResponseBodyHaVips, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HaVip'] = []
        if self.ha_vip is not None:
            for k in self.ha_vip:
                result['HaVip'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ha_vip = []
        if m.get('HaVip') is not None:
            for k in m.get('HaVip'):
                temp_model = DescribeHaVipsResponseBodyHaVipsHaVip()
                self.ha_vip.append(temp_model.from_map(k))
        return self


class DescribeHaVipsResponseBody(TeaModel):
    def __init__(self, ha_vips=None, page_number=None, page_size=None, request_id=None, total_count=None):
        self.ha_vips = ha_vips  # type: DescribeHaVipsResponseBodyHaVips
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.ha_vips:
            self.ha_vips.validate()

    def to_map(self):
        _map = super(DescribeHaVipsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ha_vips is not None:
            result['HaVips'] = self.ha_vips.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HaVips') is not None:
            temp_model = DescribeHaVipsResponseBodyHaVips()
            self.ha_vips = temp_model.from_map(m['HaVips'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeHaVipsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHaVipsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHaVipsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHaVipsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHpcClustersRequest(TeaModel):
    def __init__(self, client_token=None, hpc_cluster_ids=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The IDs of HPC clusters. The value is a JSON array that consists of up to 100 HPC cluster IDs. Separate the HPC cluster IDs with commas (,).
        self.hpc_cluster_ids = hpc_cluster_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the HPC cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHpcClustersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.hpc_cluster_ids is not None:
            result['HpcClusterIds'] = self.hpc_cluster_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('HpcClusterIds') is not None:
            self.hpc_cluster_ids = m.get('HpcClusterIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeHpcClustersResponseBodyHpcClustersHpcCluster(TeaModel):
    def __init__(self, description=None, hpc_cluster_id=None, name=None):
        # The description of the HPC cluster.
        self.description = description  # type: str
        # The ID of the HPC cluster.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # The name of the HPC cluster.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHpcClustersResponseBodyHpcClustersHpcCluster, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeHpcClustersResponseBodyHpcClusters(TeaModel):
    def __init__(self, hpc_cluster=None):
        self.hpc_cluster = hpc_cluster  # type: list[DescribeHpcClustersResponseBodyHpcClustersHpcCluster]

    def validate(self):
        if self.hpc_cluster:
            for k in self.hpc_cluster:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHpcClustersResponseBodyHpcClusters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['HpcCluster'] = []
        if self.hpc_cluster is not None:
            for k in self.hpc_cluster:
                result['HpcCluster'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.hpc_cluster = []
        if m.get('HpcCluster') is not None:
            for k in m.get('HpcCluster'):
                temp_model = DescribeHpcClustersResponseBodyHpcClustersHpcCluster()
                self.hpc_cluster.append(temp_model.from_map(k))
        return self


class DescribeHpcClustersResponseBody(TeaModel):
    def __init__(self, hpc_clusters=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the HPC clusters.
        self.hpc_clusters = hpc_clusters  # type: DescribeHpcClustersResponseBodyHpcClusters
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of HPC clusters queried.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.hpc_clusters:
            self.hpc_clusters.validate()

    def to_map(self):
        _map = super(DescribeHpcClustersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.hpc_clusters is not None:
            result['HpcClusters'] = self.hpc_clusters.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HpcClusters') is not None:
            temp_model = DescribeHpcClustersResponseBodyHpcClusters()
            self.hpc_clusters = temp_model.from_map(m['HpcClusters'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeHpcClustersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHpcClustersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHpcClustersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHpcClustersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageComponentsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the image component. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N of the image component. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageComponentsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageComponentsRequest(TeaModel):
    def __init__(self, image_component_id=None, max_results=None, name=None, next_token=None, owner=None,
                 owner_account=None, owner_id=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, tag=None):
        # The IDs of the image components. You can specify up to 20 image components.
        self.image_component_id = image_component_id  # type: list[str]
        # The maximum number of entries to return on each page. Valid values: 1 to 500.
        # 
        # Default value: 50.
        self.max_results = max_results  # type: int
        # The name of the image component. You must specify an exact name to search for the image component.
        self.name = name  # type: str
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeImageComponents operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        # The type of the image component. Valid values:
        # 
        # *   SELF: the custom component that you created.
        # *   ALIYUN: the system component provided by Alibaba Cloud.
        self.owner = owner  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image component. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags
        self.tag = tag  # type: list[DescribeImageComponentsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_component_id is not None:
            result['ImageComponentId'] = self.image_component_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.name is not None:
            result['Name'] = self.name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageComponentId') is not None:
            self.image_component_id = m.get('ImageComponentId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImageComponentsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the image component.
        self.tag_key = tag_key  # type: str
        # The tag value of the image component.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImageComponentsResponseBodyImageComponentImageComponentSetTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImageComponentsResponseBodyImageComponentImageComponentSet(TeaModel):
    def __init__(self, component_type=None, content=None, creation_time=None, description=None,
                 image_component_id=None, name=None, owner=None, resource_group_id=None, system_type=None, tags=None):
        # The type of the image component.
        self.component_type = component_type  # type: str
        # The content of the image component.
        self.content = content  # type: str
        # The time when the image component was created.
        self.creation_time = creation_time  # type: str
        # The description of the image component.
        self.description = description  # type: str
        # The ID of the image component.
        self.image_component_id = image_component_id  # type: str
        # The name of the image component.
        self.name = name  # type: str
        # The type of the image component. Valid values:
        # 
        # *   SELF: the custom component that you created.
        # *   ALIYUN: the system component provided by Alibaba Cloud.
        self.owner = owner  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The operating system type supported by the image component.
        self.system_type = system_type  # type: str
        # The tags of the image component.
        self.tags = tags  # type: DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsResponseBodyImageComponentImageComponentSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.component_type is not None:
            result['ComponentType'] = self.component_type
        if self.content is not None:
            result['Content'] = self.content
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.image_component_id is not None:
            result['ImageComponentId'] = self.image_component_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner is not None:
            result['Owner'] = self.owner
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.system_type is not None:
            result['SystemType'] = self.system_type
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComponentType') is not None:
            self.component_type = m.get('ComponentType')
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageComponentId') is not None:
            self.image_component_id = m.get('ImageComponentId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Owner') is not None:
            self.owner = m.get('Owner')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SystemType') is not None:
            self.system_type = m.get('SystemType')
        if m.get('Tags') is not None:
            temp_model = DescribeImageComponentsResponseBodyImageComponentImageComponentSetTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeImageComponentsResponseBodyImageComponent(TeaModel):
    def __init__(self, image_component_set=None):
        self.image_component_set = image_component_set  # type: list[DescribeImageComponentsResponseBodyImageComponentImageComponentSet]

    def validate(self):
        if self.image_component_set:
            for k in self.image_component_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsResponseBodyImageComponent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageComponentSet'] = []
        if self.image_component_set is not None:
            for k in self.image_component_set:
                result['ImageComponentSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_component_set = []
        if m.get('ImageComponentSet') is not None:
            for k in m.get('ImageComponentSet'):
                temp_model = DescribeImageComponentsResponseBodyImageComponentImageComponentSet()
                self.image_component_set.append(temp_model.from_map(k))
        return self


class DescribeImageComponentsResponseBody(TeaModel):
    def __init__(self, image_component=None, max_results=None, next_token=None, request_id=None, total_count=None):
        # Details about the image components.
        self.image_component = image_component  # type: DescribeImageComponentsResponseBodyImageComponent
        # The maximum number of entries returned per page.
        self.max_results = max_results  # type: int
        # The query token returned in this call. For information about how to use this return value, see the "Description" section in this topic.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of image components returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.image_component:
            self.image_component.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_component is not None:
            result['ImageComponent'] = self.image_component.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageComponent') is not None:
            temp_model = DescribeImageComponentsResponseBodyImageComponent()
            self.image_component = temp_model.from_map(m['ImageComponent'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageComponentsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageComponentsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageComponentsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageComponentsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageFromFamilyRequest(TeaModel):
    def __init__(self, image_family=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The name of the image family. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with http://, https://, acs:, or aliyun.
        self.image_family = image_family  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFromFamilyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping(TeaModel):
    def __init__(self, device=None, format=None, import_ossbucket=None, import_ossobject=None, size=None,
                 snapshot_id=None, type=None):
        # The device name of the disk. Example: /dev/xvdb.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The format of the image.
        self.format = format  # type: str
        # The OSS bucket that contains the imported image file.
        self.import_ossbucket = import_ossbucket  # type: str
        # The OSS object corresponding to the imported image file.
        self.import_ossobject = import_ossobject  # type: str
        # The size of the disk. Unit: GiB.
        self.size = size  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The type of the image.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.format is not None:
            result['Format'] = self.format
        if self.import_ossbucket is not None:
            result['ImportOSSBucket'] = self.import_ossbucket
        if self.import_ossobject is not None:
            result['ImportOSSObject'] = self.import_ossobject
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('ImportOSSBucket') is not None:
            self.import_ossbucket = m.get('ImportOSSBucket')
        if m.get('ImportOSSObject') is not None:
            self.import_ossobject = m.get('ImportOSSObject')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings(TeaModel):
    def __init__(self, disk_device_mapping=None):
        self.disk_device_mapping = disk_device_mapping  # type: list[DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping]

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = DescribeImageFromFamilyResponseBodyImageDiskDeviceMappingsDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        return self


class DescribeImageFromFamilyResponseBodyImageTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the image.
        self.tag_key = tag_key  # type: str
        # The tag value of the image.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBodyImageTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeImageFromFamilyResponseBodyImageTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeImageFromFamilyResponseBodyImageTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBodyImageTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImageFromFamilyResponseBodyImageTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImageFromFamilyResponseBodyImage(TeaModel):
    def __init__(self, architecture=None, creation_time=None, description=None, disk_device_mappings=None,
                 image_family=None, image_id=None, image_name=None, image_owner_alias=None, image_version=None, is_copied=None,
                 is_self_shared=None, is_subscribed=None, is_support_cloudinit=None, is_support_io_optimized=None, osname=None,
                 ostype=None, platform=None, product_code=None, progress=None, size=None, status=None, tags=None, usage=None):
        # The image architecture. Valid values:
        # 
        # *   i386
        # *   x86\_64
        self.architecture = architecture  # type: str
        # The time when the image was created.
        self.creation_time = creation_time  # type: str
        # The description of the image.
        self.description = description  # type: str
        # The mappings between the disks and snapshots under the image.
        self.disk_device_mappings = disk_device_mappings  # type: DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings
        # The name of the image family.
        self.image_family = image_family  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The name of the image.
        self.image_name = image_name  # type: str
        # The alias of the image owner. Valid values:
        # 
        # - system: public images provided by Alibaba Cloud
        # - self: your custom images
        # - others: shared images from other Alibaba Cloud accounts
        # - marketplace: Alibaba Cloud Marketplace images
        self.image_owner_alias = image_owner_alias  # type: str
        # The version of the image.
        self.image_version = image_version  # type: str
        # Indicates whether the image is a copy of another image.
        self.is_copied = is_copied  # type: bool
        # Indicates whether the image has been shared to other Alibaba Cloud accounts.
        self.is_self_shared = is_self_shared  # type: str
        # Indicates whether you have subscribed to the image corresponding to the specified product code.
        self.is_subscribed = is_subscribed  # type: bool
        # Indicates whether the image supports cloud-init.
        self.is_support_cloudinit = is_support_cloudinit  # type: bool
        # Indicates whether the image can be used on I/O optimized instances.
        self.is_support_io_optimized = is_support_io_optimized  # type: bool
        # The name of the operating system.
        self.osname = osname  # type: str
        # The type of the operating system. Valid values:
        # 
        # - windows
        # - linux
        self.ostype = ostype  # type: str
        # The platform of the operating system.
        self.platform = platform  # type: str
        # The product code of the Alibaba Cloud Marketplace image.
        self.product_code = product_code  # type: str
        # The image creation progress. Unit: percent (%).
        self.progress = progress  # type: str
        # The size of the image. Unit: GiB.
        self.size = size  # type: int
        # The status of the image. Valid values:
        # 
        # - UnAvailable: The image is unavailable.
        # - Available: The image is available.
        # - Creating: The image is being created.
        # - CreateFailed: The image failed to be created.
        self.status = status  # type: str
        # An array that consists of Tag data.
        self.tags = tags  # type: DescribeImageFromFamilyResponseBodyImageTags
        # Indicates whether the image has been used to create ECS instances. Valid values:
        # 
        # - instance: The image has been used to create one or more ECS instances.
        # - none: The image has not been used to create ECS instances.
        self.usage = usage  # type: str

    def validate(self):
        if self.disk_device_mappings:
            self.disk_device_mappings.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBodyImage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_device_mappings is not None:
            result['DiskDeviceMappings'] = self.disk_device_mappings.to_map()
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.image_version is not None:
            result['ImageVersion'] = self.image_version
        if self.is_copied is not None:
            result['IsCopied'] = self.is_copied
        if self.is_self_shared is not None:
            result['IsSelfShared'] = self.is_self_shared
        if self.is_subscribed is not None:
            result['IsSubscribed'] = self.is_subscribed
        if self.is_support_cloudinit is not None:
            result['IsSupportCloudinit'] = self.is_support_cloudinit
        if self.is_support_io_optimized is not None:
            result['IsSupportIoOptimized'] = self.is_support_io_optimized
        if self.osname is not None:
            result['OSName'] = self.osname
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskDeviceMappings') is not None:
            temp_model = DescribeImageFromFamilyResponseBodyImageDiskDeviceMappings()
            self.disk_device_mappings = temp_model.from_map(m['DiskDeviceMappings'])
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('ImageVersion') is not None:
            self.image_version = m.get('ImageVersion')
        if m.get('IsCopied') is not None:
            self.is_copied = m.get('IsCopied')
        if m.get('IsSelfShared') is not None:
            self.is_self_shared = m.get('IsSelfShared')
        if m.get('IsSubscribed') is not None:
            self.is_subscribed = m.get('IsSubscribed')
        if m.get('IsSupportCloudinit') is not None:
            self.is_support_cloudinit = m.get('IsSupportCloudinit')
        if m.get('IsSupportIoOptimized') is not None:
            self.is_support_io_optimized = m.get('IsSupportIoOptimized')
        if m.get('OSName') is not None:
            self.osname = m.get('OSName')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeImageFromFamilyResponseBodyImageTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class DescribeImageFromFamilyResponseBody(TeaModel):
    def __init__(self, image=None, request_id=None):
        # The image information.
        self.image = image  # type: DescribeImageFromFamilyResponseBodyImage
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.image:
            self.image.validate()

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image is not None:
            result['Image'] = self.image.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Image') is not None:
            temp_model = DescribeImageFromFamilyResponseBodyImage()
            self.image = temp_model.from_map(m['Image'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageFromFamilyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageFromFamilyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageFromFamilyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageFromFamilyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagePipelineExecutionsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # > This parameter is deprecated.
        self.key = key  # type: str
        # > This parameter is deprecated.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImagePipelineExecutionsRequest(TeaModel):
    def __init__(self, execution_id=None, image_pipeline_id=None, max_results=None, next_token=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 status=None, tag=None):
        # The ID of the image build task.
        self.execution_id = execution_id  # type: str
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        # The maximum number of entries to return on each page. Valid values: 1 to 500.
        # 
        # Default value: 50.
        self.max_results = max_results  # type: int
        # The query token. Set the value to the `NextToken` value that was returned when you last called the DescribeImagePipelineExecutions operation. Leave this parameter empty when you call this operation for the first time.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image build task. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The status of the image build task. You can specify multiple values at the same time. Separate the values with commas (,). Example format: `BUILDING,DISTRIBUTING`. Valid values: 
        # 
        # - BUILDING: The image is being built.
        # - DISTRIBUTING: The image is being distributed.
        # - RELEASING: The image is being recycled.
        # - SUCCESS: The image is built.
        # - FAILED: The image fails to be built.
        # - CANCELLING: The image build task is being canceled.
        # - CANCELLED: The image build task is canceled.
        # 
        # >  You cannot query the image build tasks in all status by leaving this parameter empty.
        self.status = status  # type: str
        # > This parameter is deprecated.
        self.tag = tag  # type: list[DescribeImagePipelineExecutionsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execution_id is not None:
            result['ExecutionId'] = self.execution_id
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecutionId') is not None:
            self.execution_id = m.get('ExecutionId')
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagePipelineExecutionsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The key of the tag.
        self.tag_key = tag_key  # type: str
        # The value of the tag.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet(TeaModel):
    def __init__(self, creation_time=None, execution_id=None, image_id=None, image_pipeline_id=None, message=None,
                 modified_time=None, resource_group_id=None, status=None, tags=None):
        # The time when the image build task was created.
        self.creation_time = creation_time  # type: str
        # The ID of the image build task.
        self.execution_id = execution_id  # type: str
        # The ID of the image to be created by using the image build task.
        self.image_id = image_id  # type: str
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        # The execution result of the image build task.
        self.message = message  # type: str
        # The last time when the image build task was updated.
        self.modified_time = modified_time  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The status of the image build task. Valid values:
        # 
        # *   BUILDING: The image was being built.
        # *   DISTRIBUTING: The image was being distributed.
        # *   RELEASING: The image was being recycled.
        # *   SUCCESS: The image was built.
        # *   FAILED: The image failed to be built.
        # *   CANCELLING: The image build task was being canceled.
        # *   CANCELLED: The image build task was cancelled.
        self.status = status  # type: str
        # The list of tag key-value pairs.
        self.tags = tags  # type: DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.execution_id is not None:
            result['ExecutionId'] = self.execution_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.message is not None:
            result['Message'] = self.message
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ExecutionId') is not None:
            self.execution_id = m.get('ExecutionId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSetTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution(TeaModel):
    def __init__(self, image_pipeline_execution_set=None):
        self.image_pipeline_execution_set = image_pipeline_execution_set  # type: list[DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet]

    def validate(self):
        if self.image_pipeline_execution_set:
            for k in self.image_pipeline_execution_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImagePipelineExecutionSet'] = []
        if self.image_pipeline_execution_set is not None:
            for k in self.image_pipeline_execution_set:
                result['ImagePipelineExecutionSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_pipeline_execution_set = []
        if m.get('ImagePipelineExecutionSet') is not None:
            for k in m.get('ImagePipelineExecutionSet'):
                temp_model = DescribeImagePipelineExecutionsResponseBodyImagePipelineExecutionImagePipelineExecutionSet()
                self.image_pipeline_execution_set.append(temp_model.from_map(k))
        return self


class DescribeImagePipelineExecutionsResponseBody(TeaModel):
    def __init__(self, image_pipeline_execution=None, max_results=None, next_token=None, request_id=None,
                 total_count=None):
        # Details of the image build task.
        self.image_pipeline_execution = image_pipeline_execution  # type: DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution
        # The maximum number of entries returned per page.
        self.max_results = max_results  # type: int
        # The query token returned in this call. For information about how to use this return value, see the Description section in this topic.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of returned image components.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.image_pipeline_execution:
            self.image_pipeline_execution.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_pipeline_execution is not None:
            result['ImagePipelineExecution'] = self.image_pipeline_execution.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImagePipelineExecution') is not None:
            temp_model = DescribeImagePipelineExecutionsResponseBodyImagePipelineExecution()
            self.image_pipeline_execution = temp_model.from_map(m['ImagePipelineExecution'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImagePipelineExecutionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImagePipelineExecutionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImagePipelineExecutionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagePipelineExecutionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagePipelinesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the image template. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N of the image template. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelinesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImagePipelinesRequest(TeaModel):
    def __init__(self, image_pipeline_id=None, max_results=None, name=None, next_token=None, owner_account=None,
                 owner_id=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None):
        # The IDs of the image templates. You can specify at most 20 IDs.
        self.image_pipeline_id = image_pipeline_id  # type: list[str]
        # The maximum number of entries to return on each page. Valid values: 1 to 500.
        # 
        # Default value: 50.
        self.max_results = max_results  # type: int
        # The name of the image template.
        self.name = name  # type: str
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeImagePipelines operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # > Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.tag = tag  # type: list[DescribeImagePipelinesRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.name is not None:
            result['Name'] = self.name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagePipelinesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts(TeaModel):
    def __init__(self, add_account=None):
        self.add_account = add_account  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_account is not None:
            result['AddAccount'] = self.add_account
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddAccount') is not None:
            self.add_account = m.get('AddAccount')
        return self


class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the image template.
        self.tag_key = tag_key  # type: str
        # The tag value of the image template.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds(TeaModel):
    def __init__(self, to_region_id=None):
        self.to_region_id = to_region_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.to_region_id is not None:
            result['ToRegionId'] = self.to_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ToRegionId') is not None:
            self.to_region_id = m.get('ToRegionId')
        return self


class DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet(TeaModel):
    def __init__(self, add_accounts=None, base_image=None, base_image_type=None, build_content=None,
                 creation_time=None, delete_instance_on_failure=None, description=None, image_name=None, image_pipeline_id=None,
                 instance_type=None, internet_max_bandwidth_out=None, name=None, resource_group_id=None, system_disk_size=None,
                 tags=None, to_region_ids=None, v_switch_id=None):
        # The IDs of Alibaba Cloud accounts to which to share the created image.
        self.add_accounts = add_accounts  # type: DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts
        # The source image.
        # 
        # *   When `BaseImageType` is set to IMAGE, the value of this parameter is the ID of a custom image.
        # *   When `BaseImageType` is set to IMAGE_FAMILY, the value of this parameter is the name of an image family.
        self.base_image = base_image  # type: str
        # The type of the source image. Valid values:
        # 
        # *   IMAGE: custom image
        # *   IMAGE_FAMILY: image family
        self.base_image_type = base_image_type  # type: str
        # The content of the image template.
        self.build_content = build_content  # type: str
        # The time when the image template was created.
        self.creation_time = creation_time  # type: str
        # Indicates whether to release the intermediate instance when the image fails to be created.
        self.delete_instance_on_failure = delete_instance_on_failure  # type: bool
        # The description of the image template.
        self.description = description  # type: str
        # The name prefix of the created image.
        self.image_name = image_name  # type: str
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        # The instance type of the intermediate instance.
        self.instance_type = instance_type  # type: str
        # The size of the outbound public bandwidth for the intermediate instance. Unit: Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # The name of the image template.
        self.name = name  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The system disk size of the intermediate instance. Unit: GiB.
        self.system_disk_size = system_disk_size  # type: int
        # The tags of the image template.
        self.tags = tags  # type: DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags
        # The IDs of regions to which to distribute the created image.
        self.to_region_ids = to_region_ids  # type: DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        if self.add_accounts:
            self.add_accounts.validate()
        if self.tags:
            self.tags.validate()
        if self.to_region_ids:
            self.to_region_ids.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_accounts is not None:
            result['AddAccounts'] = self.add_accounts.to_map()
        if self.base_image is not None:
            result['BaseImage'] = self.base_image
        if self.base_image_type is not None:
            result['BaseImageType'] = self.base_image_type
        if self.build_content is not None:
            result['BuildContent'] = self.build_content
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.delete_instance_on_failure is not None:
            result['DeleteInstanceOnFailure'] = self.delete_instance_on_failure
        if self.description is not None:
            result['Description'] = self.description
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.name is not None:
            result['Name'] = self.name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.to_region_ids is not None:
            result['ToRegionIds'] = self.to_region_ids.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddAccounts') is not None:
            temp_model = DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetAddAccounts()
            self.add_accounts = temp_model.from_map(m['AddAccounts'])
        if m.get('BaseImage') is not None:
            self.base_image = m.get('BaseImage')
        if m.get('BaseImageType') is not None:
            self.base_image_type = m.get('BaseImageType')
        if m.get('BuildContent') is not None:
            self.build_content = m.get('BuildContent')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeleteInstanceOnFailure') is not None:
            self.delete_instance_on_failure = m.get('DeleteInstanceOnFailure')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        if m.get('Tags') is not None:
            temp_model = DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('ToRegionIds') is not None:
            temp_model = DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSetToRegionIds()
            self.to_region_ids = temp_model.from_map(m['ToRegionIds'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeImagePipelinesResponseBodyImagePipeline(TeaModel):
    def __init__(self, image_pipeline_set=None):
        self.image_pipeline_set = image_pipeline_set  # type: list[DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet]

    def validate(self):
        if self.image_pipeline_set:
            for k in self.image_pipeline_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBodyImagePipeline, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImagePipelineSet'] = []
        if self.image_pipeline_set is not None:
            for k in self.image_pipeline_set:
                result['ImagePipelineSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_pipeline_set = []
        if m.get('ImagePipelineSet') is not None:
            for k in m.get('ImagePipelineSet'):
                temp_model = DescribeImagePipelinesResponseBodyImagePipelineImagePipelineSet()
                self.image_pipeline_set.append(temp_model.from_map(k))
        return self


class DescribeImagePipelinesResponseBody(TeaModel):
    def __init__(self, image_pipeline=None, max_results=None, next_token=None, request_id=None, total_count=None):
        # Details of the image templates.
        self.image_pipeline = image_pipeline  # type: DescribeImagePipelinesResponseBodyImagePipeline
        # The maximum number of entries returned per page.
        self.max_results = max_results  # type: int
        # The query token returned in this call. For information about how to use this return value, see the "Description" section in this topic.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of image templates returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.image_pipeline:
            self.image_pipeline.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_pipeline is not None:
            result['ImagePipeline'] = self.image_pipeline.to_map()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImagePipeline') is not None:
            temp_model = DescribeImagePipelinesResponseBodyImagePipeline()
            self.image_pipeline = temp_model.from_map(m['ImagePipeline'])
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImagePipelinesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImagePipelinesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImagePipelinesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagePipelinesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSharePermissionRequest(TeaModel):
    def __init__(self, image_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10
        self.page_size = page_size  # type: int
        # The region ID of the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSharePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeImageSharePermissionResponseBodyAccountsAccount(TeaModel):
    def __init__(self, aliyun_id=None):
        # The ID of the Alibaba Cloud account.
        self.aliyun_id = aliyun_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponseBodyAccountsAccount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_id is not None:
            result['AliyunId'] = self.aliyun_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliyunId') is not None:
            self.aliyun_id = m.get('AliyunId')
        return self


class DescribeImageSharePermissionResponseBodyAccounts(TeaModel):
    def __init__(self, account=None):
        self.account = account  # type: list[DescribeImageSharePermissionResponseBodyAccountsAccount]

    def validate(self):
        if self.account:
            for k in self.account:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponseBodyAccounts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Account'] = []
        if self.account is not None:
            for k in self.account:
                result['Account'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.account = []
        if m.get('Account') is not None:
            for k in m.get('Account'):
                temp_model = DescribeImageSharePermissionResponseBodyAccountsAccount()
                self.account.append(temp_model.from_map(k))
        return self


class DescribeImageSharePermissionResponseBodyShareGroupsShareGroup(TeaModel):
    def __init__(self, group=None):
        # The shared group.
        self.group = group  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponseBodyShareGroupsShareGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['Group'] = self.group
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Group') is not None:
            self.group = m.get('Group')
        return self


class DescribeImageSharePermissionResponseBodyShareGroups(TeaModel):
    def __init__(self, share_group=None):
        self.share_group = share_group  # type: list[DescribeImageSharePermissionResponseBodyShareGroupsShareGroup]

    def validate(self):
        if self.share_group:
            for k in self.share_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponseBodyShareGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ShareGroup'] = []
        if self.share_group is not None:
            for k in self.share_group:
                result['ShareGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.share_group = []
        if m.get('ShareGroup') is not None:
            for k in m.get('ShareGroup'):
                temp_model = DescribeImageSharePermissionResponseBodyShareGroupsShareGroup()
                self.share_group.append(temp_model.from_map(k))
        return self


class DescribeImageSharePermissionResponseBody(TeaModel):
    def __init__(self, accounts=None, image_id=None, page_number=None, page_size=None, region_id=None,
                 request_id=None, share_groups=None, total_count=None):
        # The Alibaba Cloud accounts.
        self.accounts = accounts  # type: DescribeImageSharePermissionResponseBodyAccounts
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The region ID of the image.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The shared groups.
        self.share_groups = share_groups  # type: DescribeImageSharePermissionResponseBodyShareGroups
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.accounts:
            self.accounts.validate()
        if self.share_groups:
            self.share_groups.validate()

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accounts is not None:
            result['Accounts'] = self.accounts.to_map()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.share_groups is not None:
            result['ShareGroups'] = self.share_groups.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Accounts') is not None:
            temp_model = DescribeImageSharePermissionResponseBodyAccounts()
            self.accounts = temp_model.from_map(m['Accounts'])
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ShareGroups') is not None:
            temp_model = DescribeImageSharePermissionResponseBodyShareGroups()
            self.share_groups = temp_model.from_map(m['ShareGroups'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageSharePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageSharePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageSharePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSharePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageSupportInstanceTypesRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of filter. Only the image ID can be used to filter instance types. Valid values:
        # 
        # * imagId: image ID
        # * filter: image ID
        self.key = key  # type: str
        # The value of filter.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImageSupportInstanceTypesRequest(TeaModel):
    def __init__(self, action_type=None, filter=None, image_id=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The scenario in which the instance type is used. Default value: CreateEcs. Valid values:
        # 
        # *   CreateEcs: instance creation
        # *   Upgrade: instance type upgrade
        # *   Downgrade: instance type downgrade
        # *   RenewDowngrade: renewal and configuration downgrade
        self.action_type = action_type  # type: str
        # The list of filters to querying resources.
        self.filter = filter  # type: list[DescribeImageSupportInstanceTypesRequestFilter]
        # The ID of the image.
        self.image_id = image_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeImageSupportInstanceTypesRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType(TeaModel):
    def __init__(self, cpu_core_count=None, instance_type_family=None, instance_type_id=None, memory_size=None):
        # The number of vCPUs of the instance type.
        self.cpu_core_count = cpu_core_count  # type: int
        # The instance family.
        self.instance_type_family = instance_type_family  # type: str
        # The ID of the instance type.
        self.instance_type_id = instance_type_id  # type: str
        # The memory size of the instance type. Unit: GiB.
        self.memory_size = memory_size  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_core_count is not None:
            result['CpuCoreCount'] = self.cpu_core_count
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.instance_type_id is not None:
            result['InstanceTypeId'] = self.instance_type_id
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuCoreCount') is not None:
            self.cpu_core_count = m.get('CpuCoreCount')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InstanceTypeId') is not None:
            self.instance_type_id = m.get('InstanceTypeId')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        return self


class DescribeImageSupportInstanceTypesResponseBodyInstanceTypes(TeaModel):
    def __init__(self, instance_type=None):
        self.instance_type = instance_type  # type: list[DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType]

    def validate(self):
        if self.instance_type:
            for k in self.instance_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesResponseBodyInstanceTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceType'] = []
        if self.instance_type is not None:
            for k in self.instance_type:
                result['InstanceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_type = []
        if m.get('InstanceType') is not None:
            for k in m.get('InstanceType'):
                temp_model = DescribeImageSupportInstanceTypesResponseBodyInstanceTypesInstanceType()
                self.instance_type.append(temp_model.from_map(k))
        return self


class DescribeImageSupportInstanceTypesResponseBody(TeaModel):
    def __init__(self, image_id=None, instance_types=None, region_id=None, request_id=None):
        # The ID of the image.
        self.image_id = image_id  # type: str
        # Details about the instance types that are supported by the image.
        self.instance_types = instance_types  # type: DescribeImageSupportInstanceTypesResponseBodyInstanceTypes
        # The region ID of the image.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_types:
            self.instance_types.validate()

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceTypes') is not None:
            temp_model = DescribeImageSupportInstanceTypesResponseBodyInstanceTypes()
            self.instance_types = temp_model.from_map(m['InstanceTypes'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImageSupportInstanceTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageSupportInstanceTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageSupportInstanceTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageSupportInstanceTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagesRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of filter N used to query resources. Valid values:
        # 
        # *   If you set this parameter to `CreationStartTime`, you can query the resources that were created after the point in time specified by the `Filter.N.Value` value.
        # *   If you set this parameter to `CreationEndTime`, you can query the resources that were created before the point in time specified by the `Filter.N.Value` value.
        self.key = key  # type: str
        # The value of filter N used to query resources. When you specify this parameter, you must also specify the `Filter.N.Key` parameter. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImagesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the image.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag of the image.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImagesRequest(TeaModel):
    def __init__(self, action_type=None, architecture=None, dry_run=None, filter=None, image_family=None,
                 image_id=None, image_name=None, image_owner_alias=None, image_owner_id=None, instance_type=None,
                 is_public=None, is_support_cloudinit=None, is_support_io_optimized=None, ostype=None, owner_account=None,
                 owner_id=None, page_number=None, page_size=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, show_expired=None, snapshot_id=None, status=None, tag=None,
                 usage=None):
        # The scenario in which to use the image. Default value: CreateEcs. Valid values:
        # 
        # *   CreateEcs: instance creation
        # *   ChangeOS: replacement of the system disk or operating system
        self.action_type = action_type  # type: str
        # The image architecture. Valid values:
        # 
        # *   i386
        # *   x86\_64
        # *   arm64
        self.architecture = architecture  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether RAM users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned, and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # The filters that used to query resources.
        self.filter = filter  # type: list[DescribeImagesRequestFilter]
        # The name of the image family. You can set this parameter to query images of the specified image family.
        # 
        # This parameter is empty by default.
        self.image_family = image_family  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The name of the image.
        self.image_name = image_name  # type: str
        # The source of the image. Valid values:
        # 
        # *   system: public images provided by Alibaba Cloud.
        # 
        # *   self: your custom images.
        # 
        # *   others: shared images from other Alibaba Cloud accounts or community images published by other Alibaba Cloud accounts. Take note of the following items:
        # 
        #     *   To query community images, you must set IsPublic to true.
        #     *   To query shared images, you must set IsPublic to false or leave the IsPublic parameter empty.
        # 
        # *   marketplace: Alibaba Cloud Marketplace images. If Alibaba Cloud Marketplace images are returned in the response, you can use the images without subscription. You must pay attention to the billing details of Alibaba Cloud Marketplace images.
        # 
        # This parameter is empty by default, which indicates that your custom images, public images provided by Alibaba Cloud, shared images from other Alibaba Cloud accounts, and community images published by other Alibaba Cloud accounts are queried.
        self.image_owner_alias = image_owner_alias  # type: str
        # The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query shared images or community images.
        self.image_owner_id = image_owner_id  # type: long
        # The instance type for which the image can be used.
        self.instance_type = instance_type  # type: str
        # Specifies whether to query published community images. Valid values:
        # 
        # *   true: queries published community images. When you set this parameter to true, you must set ImageOwnerAlias to others.
        # *   false: queries other image types than community images. The specific image types to be queried are determined by the ImageOwnerAlias value.
        # 
        # Default value: false.
        self.is_public = is_public  # type: bool
        # Specifies whether the image supports cloud-init.
        self.is_support_cloudinit = is_support_cloudinit  # type: bool
        # Specifies whether the image can be used on I/O optimized instances.
        self.is_support_io_optimized = is_support_io_optimized  # type: bool
        # The operating system type of the image. Valid values:
        # 
        # *   windows
        # *   linux
        self.ostype = ostype  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the custom image belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether the subscription image has expired.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.show_expired = show_expired  # type: bool
        # The ID of the snapshot used to create the custom image.
        self.snapshot_id = snapshot_id  # type: str
        # The state of the image. Default value: Available. Valid values:
        # 
        # * Creating: The image is being created.
        # * Waiting: The image is waiting to be processed.
        # * Available: The image is available.
        # * UnAvailable: The image is unavailable.
        # * CreateFailed: The image cannot be created.
        # * Deprecated: The image is discontinued.
        # 
        # You can specify multiple values. Separate the values with commas (,).
        self.status = status  # type: str
        # The tags that used to query resources. You can specify up to 20 tags.
        self.tag = tag  # type: list[DescribeImagesRequestTag]
        # Specifies whether the image is running on an Elastic Compute Service (ECS) instance. Valid values:
        # 
        # *   instance: The image is already in use and running on an ECS instance.
        # *   none: The image is not in use.
        self.usage = usage  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_type is not None:
            result['ActionType'] = self.action_type
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.image_owner_id is not None:
            result['ImageOwnerId'] = self.image_owner_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.is_public is not None:
            result['IsPublic'] = self.is_public
        if self.is_support_cloudinit is not None:
            result['IsSupportCloudinit'] = self.is_support_cloudinit
        if self.is_support_io_optimized is not None:
            result['IsSupportIoOptimized'] = self.is_support_io_optimized
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.show_expired is not None:
            result['ShowExpired'] = self.show_expired
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionType') is not None:
            self.action_type = m.get('ActionType')
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeImagesRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('ImageOwnerId') is not None:
            self.image_owner_id = m.get('ImageOwnerId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IsPublic') is not None:
            self.is_public = m.get('IsPublic')
        if m.get('IsSupportCloudinit') is not None:
            self.is_support_cloudinit = m.get('IsSupportCloudinit')
        if m.get('IsSupportIoOptimized') is not None:
            self.is_support_io_optimized = m.get('IsSupportIoOptimized')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ShowExpired') is not None:
            self.show_expired = m.get('ShowExpired')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class DescribeImagesResponseBodyImagesImageDetectionOptionsItemsItem(TeaModel):
    def __init__(self, name=None, risk_code=None, risk_level=None, value=None):
        # The name of the check item.
        self.name = name  # type: str
        # The risk that the check item may have.
        self.risk_code = risk_code  # type: str
        # Indicates the severity of the risk that the check item of the imported custom image has. If the check item is at risk, this parameter is returned. If the check item is not at risk, this parameter is not returned.  
        # 
        # Valid values:
        # 
        # - High: The check item has a high risk, which may affect instance startup. We strongly recommended that you handle the risk.
        # - Medium: The check item has a medium risk, which may affect the startup performance or configurations of the instance. We recommend that you handle the risk.
        self.risk_level = risk_level  # type: str
        # The result of the check item.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageDetectionOptionsItemsItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.risk_code is not None:
            result['RiskCode'] = self.risk_code
        if self.risk_level is not None:
            result['RiskLevel'] = self.risk_level
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RiskCode') is not None:
            self.risk_code = m.get('RiskCode')
        if m.get('RiskLevel') is not None:
            self.risk_level = m.get('RiskLevel')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeImagesResponseBodyImagesImageDetectionOptionsItems(TeaModel):
    def __init__(self, item=None):
        self.item = item  # type: list[DescribeImagesResponseBodyImagesImageDetectionOptionsItemsItem]

    def validate(self):
        if self.item:
            for k in self.item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageDetectionOptionsItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Item'] = []
        if self.item is not None:
            for k in self.item:
                result['Item'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.item = []
        if m.get('Item') is not None:
            for k in m.get('Item'):
                temp_model = DescribeImagesResponseBodyImagesImageDetectionOptionsItemsItem()
                self.item.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBodyImagesImageDetectionOptions(TeaModel):
    def __init__(self, items=None, status=None):
        # The check items.
        self.items = items  # type: DescribeImagesResponseBodyImagesImageDetectionOptionsItems
        # The state of the image check task. Valid values:
        # 
        # - Processing: The image check task is in progress.
        # - Finished: The image check task is completed.
        self.status = status  # type: str

    def validate(self):
        if self.items:
            self.items.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageDetectionOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.items is not None:
            result['Items'] = self.items.to_map()
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Items') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageDetectionOptionsItems()
            self.items = temp_model.from_map(m['Items'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping(TeaModel):
    def __init__(self, device=None, format=None, import_ossbucket=None, import_ossobject=None, progress=None,
                 remain_time=None, size=None, snapshot_id=None, type=None):
        # The device name of the disk. Example: /dev/xvdb.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure compatibility.
        self.device = device  # type: str
        # The format of the image.
        self.format = format  # type: str
        # The Object Storage Service (OSS) bucket that contains the imported image file.
        self.import_ossbucket = import_ossbucket  # type: str
        # The OSS object that corresponds to the imported image file.
        self.import_ossobject = import_ossobject  # type: str
        # The progress of an image copy task.
        self.progress = progress  # type: str
        # The amount of remaining time required for an image copy task. Unit: seconds.
        self.remain_time = remain_time  # type: int
        # The size of the disk.
        self.size = size  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The type of the image.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.format is not None:
            result['Format'] = self.format
        if self.import_ossbucket is not None:
            result['ImportOSSBucket'] = self.import_ossbucket
        if self.import_ossobject is not None:
            result['ImportOSSObject'] = self.import_ossobject
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.remain_time is not None:
            result['RemainTime'] = self.remain_time
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('ImportOSSBucket') is not None:
            self.import_ossbucket = m.get('ImportOSSBucket')
        if m.get('ImportOSSObject') is not None:
            self.import_ossobject = m.get('ImportOSSObject')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RemainTime') is not None:
            self.remain_time = m.get('RemainTime')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeImagesResponseBodyImagesImageDiskDeviceMappings(TeaModel):
    def __init__(self, disk_device_mapping=None):
        self.disk_device_mapping = disk_device_mapping  # type: list[DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping]

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageDiskDeviceMappings, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = DescribeImagesResponseBodyImagesImageDiskDeviceMappingsDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBodyImagesImageFeatures(TeaModel):
    def __init__(self, nvme_support=None):
        # Indicates whether the image supports Non-Volatile Memory Express (NVMe). Valid values:
        # 
        # - supported: The image supports NVMe. Instances created from this image support the NVMe protocol.
        # - unsupported: The image does not support NVMe. Instances created from this image do not support the NVMe protocol.
        self.nvme_support = nvme_support  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageFeatures, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nvme_support is not None:
            result['NvmeSupport'] = self.nvme_support
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NvmeSupport') is not None:
            self.nvme_support = m.get('NvmeSupport')
        return self


class DescribeImagesResponseBodyImagesImageTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the image.
        self.tag_key = tag_key  # type: str
        # The tag value of the image.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeImagesResponseBodyImagesImageTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeImagesResponseBodyImagesImageTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImageTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeImagesResponseBodyImagesImageTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBodyImagesImage(TeaModel):
    def __init__(self, architecture=None, boot_mode=None, creation_time=None, description=None,
                 detection_options=None, disk_device_mappings=None, features=None, image_family=None, image_id=None, image_name=None,
                 image_owner_alias=None, image_owner_id=None, image_version=None, is_copied=None, is_public=None, is_self_shared=None,
                 is_subscribed=None, is_support_cloudinit=None, is_support_io_optimized=None, login_as_non_root_supported=None,
                 osname=None, osname_en=None, ostype=None, platform=None, product_code=None, progress=None,
                 resource_group_id=None, size=None, status=None, supplier_name=None, tags=None, usage=None):
        # The image architecture. Valid values:
        # 
        # *   i386
        # *   x86\_64
        # *   arm64
        self.architecture = architecture  # type: str
        # The boot mode of the custom image. Valid values:
        # 
        # *   BIOS
        # *   UEFI
        # 
        # >  You must know which boot modes the specified image supports. When you use this parameter to change the boot mode of the image, specify a boot mode supported by the image to ensure that instances which use this image can start normally.
        self.boot_mode = boot_mode  # type: str
        # The time when the image was created.
        self.creation_time = creation_time  # type: str
        # The description of the image.
        self.description = description  # type: str
        # Details about the check performed on the image.
        self.detection_options = detection_options  # type: DescribeImagesResponseBodyImagesImageDetectionOptions
        # The mappings between disks and snapshots in the image.
        self.disk_device_mappings = disk_device_mappings  # type: DescribeImagesResponseBodyImagesImageDiskDeviceMappings
        # The attributes of the image.
        self.features = features  # type: DescribeImagesResponseBodyImagesImageFeatures
        # The name of the image family.
        self.image_family = image_family  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The name of the image.
        self.image_name = image_name  # type: str
        # The source of the image. Valid values:
        # 
        # *   system: public images provided by Alibaba Cloud.
        # *   self: your custom images.
        # *   others: shared images from other Alibaba Cloud accounts or community images published by other Alibaba Cloud accounts.
        # *   marketplace: Alibaba Cloud Marketplace images.
        self.image_owner_alias = image_owner_alias  # type: str
        # The ID of the Alibaba Cloud account to which the image belongs. This parameter takes effect only when you query shared images or community images.
        self.image_owner_id = image_owner_id  # type: long
        # The version of the image.
        self.image_version = image_version  # type: str
        # Indicates whether the image is a copy of another image.
        self.is_copied = is_copied  # type: bool
        # Indicates whether the image is publicly available. Publicly available images include public images provided by Alibaba Cloud and custom images published as community images. Valid values: 
        # 
        # - true: The image is publicly available.
        # - false: The image is not publicly available.
        self.is_public = is_public  # type: bool
        # Indicates whether the custom image was shared to other Alibaba Cloud accounts.
        self.is_self_shared = is_self_shared  # type: str
        # Indicates whether you have subscribed to the image that corresponds to the specified product code.
        self.is_subscribed = is_subscribed  # type: bool
        # Indicates whether the image supports cloud-init.
        self.is_support_cloudinit = is_support_cloudinit  # type: bool
        # Indicates whether the image can be used on I/O optimized instances.
        self.is_support_io_optimized = is_support_io_optimized  # type: bool
        # Indicates whether the image supports logons of non-root users. Valid values:
        # 
        # - true: The image supports logons of non-root users.
        # - false: The image does not support logons of non-root users.
        self.login_as_non_root_supported = login_as_non_root_supported  # type: bool
        # The Chinese name of the operating system.
        self.osname = osname  # type: str
        # The English name of the operating system.
        self.osname_en = osname_en  # type: str
        # The type of the operating system. Valid values:
        # 
        # *   windows
        # *   linux
        self.ostype = ostype  # type: str
        # The operating system.
        self.platform = platform  # type: str
        # The product code of the Alibaba Cloud Marketplace image.
        self.product_code = product_code  # type: str
        # The image creation progress. Unit: percent (%).
        self.progress = progress  # type: str
        # The ID of the resource group to which the image belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The size of the image. Unit: GiB.
        self.size = size  # type: int
        # The state of the image. Valid values:
        # 
        # *   UnAvailable: The image is unavailable.
        # *   Available: The image is available.
        # *   Creating: The image is being created.
        # *   CreateFailed: The image cannot be created.
        self.status = status  # type: str
        # The name of the supplier that certified the community image.
        self.supplier_name = supplier_name  # type: str
        # The tags of the image.
        self.tags = tags  # type: DescribeImagesResponseBodyImagesImageTags
        # Indicates whether the image has been used to create ECS instances. Valid values:
        # 
        # *   instance: The image has been used to create one or more ECS instances.
        # *   none: The image has not been used to create ECS instances.
        self.usage = usage  # type: str

    def validate(self):
        if self.detection_options:
            self.detection_options.validate()
        if self.disk_device_mappings:
            self.disk_device_mappings.validate()
        if self.features:
            self.features.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImagesImage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.boot_mode is not None:
            result['BootMode'] = self.boot_mode
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.detection_options is not None:
            result['DetectionOptions'] = self.detection_options.to_map()
        if self.disk_device_mappings is not None:
            result['DiskDeviceMappings'] = self.disk_device_mappings.to_map()
        if self.features is not None:
            result['Features'] = self.features.to_map()
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.image_owner_id is not None:
            result['ImageOwnerId'] = self.image_owner_id
        if self.image_version is not None:
            result['ImageVersion'] = self.image_version
        if self.is_copied is not None:
            result['IsCopied'] = self.is_copied
        if self.is_public is not None:
            result['IsPublic'] = self.is_public
        if self.is_self_shared is not None:
            result['IsSelfShared'] = self.is_self_shared
        if self.is_subscribed is not None:
            result['IsSubscribed'] = self.is_subscribed
        if self.is_support_cloudinit is not None:
            result['IsSupportCloudinit'] = self.is_support_cloudinit
        if self.is_support_io_optimized is not None:
            result['IsSupportIoOptimized'] = self.is_support_io_optimized
        if self.login_as_non_root_supported is not None:
            result['LoginAsNonRootSupported'] = self.login_as_non_root_supported
        if self.osname is not None:
            result['OSName'] = self.osname
        if self.osname_en is not None:
            result['OSNameEn'] = self.osname_en
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.supplier_name is not None:
            result['SupplierName'] = self.supplier_name
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('BootMode') is not None:
            self.boot_mode = m.get('BootMode')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DetectionOptions') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageDetectionOptions()
            self.detection_options = temp_model.from_map(m['DetectionOptions'])
        if m.get('DiskDeviceMappings') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageDiskDeviceMappings()
            self.disk_device_mappings = temp_model.from_map(m['DiskDeviceMappings'])
        if m.get('Features') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageFeatures()
            self.features = temp_model.from_map(m['Features'])
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('ImageOwnerId') is not None:
            self.image_owner_id = m.get('ImageOwnerId')
        if m.get('ImageVersion') is not None:
            self.image_version = m.get('ImageVersion')
        if m.get('IsCopied') is not None:
            self.is_copied = m.get('IsCopied')
        if m.get('IsPublic') is not None:
            self.is_public = m.get('IsPublic')
        if m.get('IsSelfShared') is not None:
            self.is_self_shared = m.get('IsSelfShared')
        if m.get('IsSubscribed') is not None:
            self.is_subscribed = m.get('IsSubscribed')
        if m.get('IsSupportCloudinit') is not None:
            self.is_support_cloudinit = m.get('IsSupportCloudinit')
        if m.get('IsSupportIoOptimized') is not None:
            self.is_support_io_optimized = m.get('IsSupportIoOptimized')
        if m.get('LoginAsNonRootSupported') is not None:
            self.login_as_non_root_supported = m.get('LoginAsNonRootSupported')
        if m.get('OSName') is not None:
            self.osname = m.get('OSName')
        if m.get('OSNameEn') is not None:
            self.osname_en = m.get('OSNameEn')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SupplierName') is not None:
            self.supplier_name = m.get('SupplierName')
        if m.get('Tags') is not None:
            temp_model = DescribeImagesResponseBodyImagesImageTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class DescribeImagesResponseBodyImages(TeaModel):
    def __init__(self, image=None):
        self.image = image  # type: list[DescribeImagesResponseBodyImagesImage]

    def validate(self):
        if self.image:
            for k in self.image:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Image'] = []
        if self.image is not None:
            for k in self.image:
                result['Image'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image = []
        if m.get('Image') is not None:
            for k in m.get('Image'):
                temp_model = DescribeImagesResponseBodyImagesImage()
                self.image.append(temp_model.from_map(k))
        return self


class DescribeImagesResponseBody(TeaModel):
    def __init__(self, images=None, page_number=None, page_size=None, region_id=None, request_id=None,
                 total_count=None):
        # Details about the images.
        self.images = images  # type: DescribeImagesResponseBodyImages
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The region ID of the image.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of images.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.images:
            self.images.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.images is not None:
            result['Images'] = self.images.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Images') is not None:
            temp_model = DescribeImagesResponseBodyImages()
            self.images = temp_model.from_map(m['Images'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAttachmentAttributesRequest(TeaModel):
    def __init__(self, instance_ids=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. The value can be a JSON array that consists of up to 100 instance IDs. Separate the IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the elasticity assurance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttachmentAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance(TeaModel):
    def __init__(self, instance_id=None, private_pool_options_id=None, private_pool_options_match_criteria=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the private pool. When the value of `PrivatePoolOptionsMatchCriteria` is `Open`, the value of PrivatePoolOptionsId is the ID of a private pool that is automatically matched to the instance.
        self.private_pool_options_id = private_pool_options_id  # type: str
        # The match mode of the private pool. Valid values:
        # 
        # *   Open: open private pool. Instances automatically match an open private pool.
        # *   Target: specified private pool. Instances match a specified private pool.
        # *   None: no private pool. Instances do not use private pools.
        self.private_pool_options_match_criteria = private_pool_options_match_criteria  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.private_pool_options_id is not None:
            result['PrivatePoolOptionsId'] = self.private_pool_options_id
        if self.private_pool_options_match_criteria is not None:
            result['PrivatePoolOptionsMatchCriteria'] = self.private_pool_options_match_criteria
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PrivatePoolOptionsId') is not None:
            self.private_pool_options_id = m.get('PrivatePoolOptionsId')
        if m.get('PrivatePoolOptionsMatchCriteria') is not None:
            self.private_pool_options_match_criteria = m.get('PrivatePoolOptionsMatchCriteria')
        return self


class DescribeInstanceAttachmentAttributesResponseBodyInstances(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance]

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttachmentAttributesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeInstanceAttachmentAttributesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeInstanceAttachmentAttributesResponseBody(TeaModel):
    def __init__(self, instances=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the private pools that the instances match.
        self.instances = instances  # type: DescribeInstanceAttachmentAttributesResponseBodyInstances
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttachmentAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = DescribeInstanceAttachmentAttributesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceAttachmentAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceAttachmentAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttachmentAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAttachmentAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAttributeRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceAttributeResponseBodyDedicatedHostAttribute(TeaModel):
    def __init__(self, dedicated_host_id=None, dedicated_host_name=None):
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The name of the dedicated host.
        self.dedicated_host_name = dedicated_host_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyDedicatedHostAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        return self


class DescribeInstanceAttributeResponseBodyEipAddress(TeaModel):
    def __init__(self, allocation_id=None, bandwidth=None, internet_charge_type=None, ip_address=None):
        # The ID of the EIP.
        self.allocation_id = allocation_id  # type: str
        # The maximum public bandwidth of the EIP. Unit: Mbit/s.
        self.bandwidth = bandwidth  # type: int
        # The billing method for network usage. Valid values:
        # 
        # - PayByBandwidth: pay-by-bandwidth
        # - PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The EIP of the instance.
        self.ip_address = ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyEipAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstanceAttributeResponseBodyInnerIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyInnerIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstanceAttributeResponseBodyOperationLocksLockReason(TeaModel):
    def __init__(self, lock_reason=None):
        # The reason why the instance was locked. Valid values:
        # 
        # - financial: The instance was locked due to overdue payments.
        # - security: The instance was locked due to security reasons.
        # - recycling: The preemptible instance was locked and pending release.
        # - dedicatedhostfinancial: The instance was locked due to overdue payments for the dedicated host.
        # - refunded: The instance was locked because a refund was made for the instance.
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyOperationLocksLockReason, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeInstanceAttributeResponseBodyOperationLocks(TeaModel):
    def __init__(self, lock_reason=None):
        self.lock_reason = lock_reason  # type: list[DescribeInstanceAttributeResponseBodyOperationLocksLockReason]

    def validate(self):
        if self.lock_reason:
            for k in self.lock_reason:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LockReason'] = []
        if self.lock_reason is not None:
            for k in self.lock_reason:
                result['LockReason'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.lock_reason = []
        if m.get('LockReason') is not None:
            for k in m.get('LockReason'):
                temp_model = DescribeInstanceAttributeResponseBodyOperationLocksLockReason()
                self.lock_reason.append(temp_model.from_map(k))
        return self


class DescribeInstanceAttributeResponseBodyPublicIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyPublicIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstanceAttributeResponseBodySecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodySecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstanceAttributeResponseBodyVpcAttributes(TeaModel):
    def __init__(self, nat_ip_address=None, private_ip_address=None, v_switch_id=None, vpc_id=None):
        # The Network Address Translation (NAT) IP address of the instance. It is used by ECS instances in different VPCs for communication.
        self.nat_ip_address = nat_ip_address  # type: str
        # The private IP address of the instance.
        self.private_ip_address = private_ip_address  # type: DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the VPC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.private_ip_address:
            self.private_ip_address.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBodyVpcAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_ip_address is not None:
            result['NatIpAddress'] = self.nat_ip_address
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NatIpAddress') is not None:
            self.nat_ip_address = m.get('NatIpAddress')
        if m.get('PrivateIpAddress') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyVpcAttributesPrivateIpAddress()
            self.private_ip_address = temp_model.from_map(m['PrivateIpAddress'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeInstanceAttributeResponseBody(TeaModel):
    def __init__(self, cluster_id=None, cpu=None, creation_time=None, credit_specification=None,
                 dedicated_host_attribute=None, description=None, eip_address=None, expired_time=None, host_name=None, image_id=None,
                 inner_ip_address=None, instance_charge_type=None, instance_id=None, instance_name=None, instance_network_type=None,
                 instance_type=None, internet_charge_type=None, internet_max_bandwidth_in=None, internet_max_bandwidth_out=None,
                 io_optimized=None, memory=None, operation_locks=None, public_ip_address=None, region_id=None, request_id=None,
                 security_group_ids=None, serial_number=None, status=None, stopped_mode=None, vlan_id=None, vpc_attributes=None,
                 zone_id=None):
        # The ID of the cluster to which the instance belongs. 
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.cluster_id = cluster_id  # type: str
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://icms.alibaba-inc.com/content/ecs/api?l=1&m=277&n=10049).
        self.creation_time = creation_time  # type: str
        # The performance mode of the burstable instance. Valid values:
        # 
        # - Standard: standard mode. For more information, see the "Standard mode" section in [Overview](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/burstable-instance-types-overview#section-svb-w9d-dju).
        # - Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Overview](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/burstable-instance-types-overview#section-svb-w9d-dju).
        self.credit_specification = credit_specification  # type: str
        # Details about the dedicated host. It is an array that consists of the DedicatedHostClusterId, DedicatedHostId, and DedicatedHostName parameters.
        self.dedicated_host_attribute = dedicated_host_attribute  # type: DescribeInstanceAttributeResponseBodyDedicatedHostAttribute
        # The description of the instance.
        self.description = description  # type: str
        # Details about the elastic IP address (EIP) associated with the instance.
        self.eip_address = eip_address  # type: DescribeInstanceAttributeResponseBodyEipAddress
        # The time when the instance expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://icms.alibaba-inc.com/content/ecs/api?l=1&m=277&n=10049).
        self.expired_time = expired_time  # type: str
        # The hostname of the instance.
        self.host_name = host_name  # type: str
        # The ID of the image that the instance is running.
        self.image_id = image_id  # type: str
        # The internal IP address of the instance located in the classic network.
        self.inner_ip_address = inner_ip_address  # type: DescribeInstanceAttributeResponseBodyInnerIpAddress
        # The billing method of the instance. Valid values:
        # 
        # - PrePaid: subscription
        # - PostPaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The ID of instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The network type of the instance. Valid values: 
        # 
        # - classic
        # - vpc
        self.instance_network_type = instance_network_type  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage. Valid values:
        # 
        # - PayByBandwidth: pay-by-bandwidth
        # - PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Indicates whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # The memory size of the instance. Unit: MiB.
        self.memory = memory  # type: int
        # The reason why the instance was locked. Valid values:
        # 
        # - financial: The instance was locked due to overdue payments.
        # - security: The instance was locked due to security reasons.
        # - recycling: The preemptible instance was locked and pending release.
        # - dedicatedhostfinancial: The instance was locked due to overdue payments for the dedicated host.
        # - refunded: The instance was locked because a refund was made for the instance.
        self.operation_locks = operation_locks  # type: DescribeInstanceAttributeResponseBodyOperationLocks
        # The public IP address of the instance.
        self.public_ip_address = public_ip_address  # type: DescribeInstanceAttributeResponseBodyPublicIpAddress
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The IDs of the security groups to which the instance belongs.
        self.security_group_ids = security_group_ids  # type: DescribeInstanceAttributeResponseBodySecurityGroupIds
        # The serial number of the instance.
        self.serial_number = serial_number  # type: str
        # The state of the instance. Valid values:
        # 
        # - Pending: The instance is being created.
        # - Running: The instance is running.
        # - Starting: The instance is being started.
        # - Stopping: The instance is being stopped.
        # - Stopped: The instance is stopped.
        self.status = status  # type: str
        # Indicates whether the instance continues to be billed after it is stopped. Valid values:
        # 
        # - KeepCharging: standard mode. Billing of the instance continues after the instance is stopped, and resources are retained for the instance.
        # - StopCharging: economical mode. Billing of some resources of the instance stops after the instance is stopped. When the instance is stopped, its resources such as vCPUs, memory, and public IP address are released. You may be unable to restart the instance if some types of resources are out of stock in the current region.
        # - Not-applicable: Economical mode is not applicable to the instance.
        self.stopped_mode = stopped_mode  # type: str
        # The virtual LAN (VLAN) ID of the instance. 
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.vlan_id = vlan_id  # type: str
        # The virtual private cloud (VPC) attributes of the instance.
        self.vpc_attributes = vpc_attributes  # type: DescribeInstanceAttributeResponseBodyVpcAttributes
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.dedicated_host_attribute:
            self.dedicated_host_attribute.validate()
        if self.eip_address:
            self.eip_address.validate()
        if self.inner_ip_address:
            self.inner_ip_address.validate()
        if self.operation_locks:
            self.operation_locks.validate()
        if self.public_ip_address:
            self.public_ip_address.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.vpc_attributes:
            self.vpc_attributes.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        if self.dedicated_host_attribute is not None:
            result['DedicatedHostAttribute'] = self.dedicated_host_attribute.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address.to_map()
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.inner_ip_address is not None:
            result['InnerIpAddress'] = self.inner_ip_address.to_map()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_network_type is not None:
            result['InstanceNetworkType'] = self.instance_network_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.status is not None:
            result['Status'] = self.status
        if self.stopped_mode is not None:
            result['StoppedMode'] = self.stopped_mode
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        if self.vpc_attributes is not None:
            result['VpcAttributes'] = self.vpc_attributes.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        if m.get('DedicatedHostAttribute') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyDedicatedHostAttribute()
            self.dedicated_host_attribute = temp_model.from_map(m['DedicatedHostAttribute'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EipAddress') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyEipAddress()
            self.eip_address = temp_model.from_map(m['EipAddress'])
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InnerIpAddress') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyInnerIpAddress()
            self.inner_ip_address = temp_model.from_map(m['InnerIpAddress'])
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceNetworkType') is not None:
            self.instance_network_type = m.get('InstanceNetworkType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('OperationLocks') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('PublicIpAddress') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyPublicIpAddress()
            self.public_ip_address = temp_model.from_map(m['PublicIpAddress'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeInstanceAttributeResponseBodySecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StoppedMode') is not None:
            self.stopped_mode = m.get('StoppedMode')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        if m.get('VpcAttributes') is not None:
            temp_model = DescribeInstanceAttributeResponseBodyVpcAttributes()
            self.vpc_attributes = temp_model.from_map(m['VpcAttributes'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeInstanceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, renewal_status=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. You can specify a maximum of 100 subscription instance IDs in a single requets. Separate the instance IDs with commas (,).
        # 
        # > The `InstanceId` and `RenewalStatus` parameters cannot be empty at the same time.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        # The auto-renewal state of the instance. Valid values:
        # 
        # *   AutoRenewal: Auto-renewal is enabled for the instance.
        # *   Normal: Auto-renewal is disabled for the instance.
        # *   NotRenewal: The instance is not to be renewed. The system sends no more expiration reminders, but sends only a non-renewal reminder three days before the expiration date. For an instance that is not to be renewed, you can call the [ModifyInstanceAutoRenewAttribute](~~52843~~) operation to change its auto-renewal state to `Normal`. Then, you can manually renew the instance or enable auto-renewal for the instance.
        self.renewal_status = renewal_status  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAutoRenewAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute(TeaModel):
    def __init__(self, auto_renew_enabled=None, duration=None, instance_id=None, period_unit=None,
                 renewal_status=None):
        # Indicates whether auto-renewal was enabled.
        self.auto_renew_enabled = auto_renew_enabled  # type: bool
        # The auto-renewal duration.
        self.duration = duration  # type: int
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The unit of the auto-renewal duration.
        self.period_unit = period_unit  # type: str
        # The auto-renewal state of the instance. Valid values:
        # 
        # *   AutoRenewal: Auto-renewal is enabled for the instance.
        # *   Normal: Auto-renewal is disabled for the instance.
        # *   NotRenewal: The instance is not to be renewed. The system sends no more expiration reminders, but sends only a non-renewal reminder three days before the expiration date. For an instance that is not to be renewed, you can call the [ModifyInstanceAutoRenewAttribute](~~52843~~) operation to change its auto-renewal state to `Normal`. Then, you can manually renew the instance or enable auto-renewal for the instance.
        self.renewal_status = renewal_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew_enabled is not None:
            result['AutoRenewEnabled'] = self.auto_renew_enabled
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenewEnabled') is not None:
            self.auto_renew_enabled = m.get('AutoRenewEnabled')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        return self


class DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes(TeaModel):
    def __init__(self, instance_renew_attribute=None):
        self.instance_renew_attribute = instance_renew_attribute  # type: list[DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute]

    def validate(self):
        if self.instance_renew_attribute:
            for k in self.instance_renew_attribute:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceRenewAttribute'] = []
        if self.instance_renew_attribute is not None:
            for k in self.instance_renew_attribute:
                result['InstanceRenewAttribute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_renew_attribute = []
        if m.get('InstanceRenewAttribute') is not None:
            for k in m.get('InstanceRenewAttribute'):
                temp_model = DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributesInstanceRenewAttribute()
                self.instance_renew_attribute.append(temp_model.from_map(k))
        return self


class DescribeInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(self, instance_renew_attributes=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the renewal attributes of instances.
        self.instance_renew_attributes = instance_renew_attributes  # type: DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instance_renew_attributes:
            self.instance_renew_attributes.validate()

    def to_map(self):
        _map = super(DescribeInstanceAutoRenewAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_renew_attributes is not None:
            result['InstanceRenewAttributes'] = self.instance_renew_attributes.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceRenewAttributes') is not None:
            temp_model = DescribeInstanceAutoRenewAttributeResponseBodyInstanceRenewAttributes()
            self.instance_renew_attributes = temp_model.from_map(m['InstanceRenewAttributes'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceAutoRenewAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceAutoRenewAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceHistoryEventsRequestEventPublishTime(TeaModel):
    def __init__(self, end=None, start=None):
        # The end of the time range in which to query published system events. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end = end  # type: str
        # The beginning of the time range in which to query published system events. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsRequestEventPublishTime, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeInstanceHistoryEventsRequestNotBefore(TeaModel):
    def __init__(self, end=None, start=None):
        # The end time of the scheduled execution period for the system event. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end = end  # type: str
        # The start time of the scheduled execution period for the system event. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsRequestNotBefore, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeInstanceHistoryEventsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of a tag that you want to attach to the specified resource.
        self.key = key  # type: str
        # The value of the tag that you want to attach to the specified resource.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInstanceHistoryEventsRequest(TeaModel):
    def __init__(self, event_publish_time=None, not_before=None, event_cycle_status=None, event_id=None,
                 event_type=None, impact_level=None, instance_event_cycle_status=None, instance_event_type=None,
                 instance_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_group_id=None, resource_id=None, resource_owner_account=None, resource_owner_id=None, resource_type=None,
                 tag=None):
        self.event_publish_time = event_publish_time  # type: DescribeInstanceHistoryEventsRequestEventPublishTime
        self.not_before = not_before  # type: DescribeInstanceHistoryEventsRequestNotBefore
        # The lifecycle state of the system event. This parameter is valid only when the InstanceEventCycleStatus.N parameter is not specified. Valid values:
        # 
        # *   Scheduled
        # *   Avoided
        # *   Executing
        # *   Executed
        # *   Canceled
        # *   Failed
        # *   Inquiring
        self.event_cycle_status = event_cycle_status  # type: str
        # The ID of system event N. Valid values of N: 1 to 100. You can specify multiple event IDs by repeatedly listing this parameter.
        self.event_id = event_id  # type: list[str]
        # The type of the system event. This parameter is valid only when the InstanceEventType.N parameter is not specified. Valid values:
        # 
        # *   SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
        # *   SystemMaintenance.Redeploy: The instance is redeployed due to system maintenance.
        # *   SystemFailure.Reboot: The instance is restarted due to a system failure.
        # *   SystemFailure.Redeploy: The instance is redeployed due to a system failure.
        # *   SystemFailure.Delete: The instance is released due to an instance creation failure.
        # *   InstanceFailure.Reboot: The instance is restarted due to an instance failure.
        # *   InstanceExpiration.Stop: The instance is stopped due to subscription expiration.
        # *   InstanceExpiration.Delete: The instance is released due to subscription expiration.
        # *   AccountUnbalanced.Stop: The pay-as-you-go instance is stopped due to an overdue payment.
        # *   AccountUnbalanced.Delete: The pay-as-you-go instance is released due to an overdue payment.
        # 
        # > For more information, see [Overview](~~66574~~). The values of this parameter are applicable to only instance system events, but not to disk system events.
        self.event_type = event_type  # type: str
        # > This parameter is unavailable.
        self.impact_level = impact_level  # type: str
        # The lifecycle state of system event N. Valid values of N: 1 to 7. You can specify multiple states by repeatedly listing this parameter. Valid values:
        # 
        # *   Scheduled
        # *   Avoided
        # *   Executing
        # *   Executed
        # *   Canceled
        # *   Failed
        # *   Inquiring
        self.instance_event_cycle_status = instance_event_cycle_status  # type: list[str]
        # The type of system event N. Valid values of N: 1 to 30. You can specify multiple types by repeatedly listing this parameter. Valid values:
        # 
        # *   SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
        # *   SystemMaintenance.Redeploy: The instance is redeployed due to system maintenance.
        # *   SystemFailure.Reboot: The instance is restarted due to a system failure.
        # *   SystemFailure.Redeploy: The instance is redeployed due to a system failure.
        # *   SystemFailure.Delete: The instance is released due to an instance creation failure.
        # *   InstanceFailure.Reboot: The instance is restarted due to an instance failure.
        # *   InstanceExpiration.Stop: The instance is stopped due to subscription expiration.
        # *   InstanceExpiration.Delete: The instance is released due to subscription expiration.
        # *   AccountUnbalanced.Stop: The pay-as-you-go instance is stopped due to an overdue payment.
        # *   AccountUnbalanced.Delete: The pay-as-you-go instance is released due to an overdue payment.
        # 
        # > For more information, see [Overview](~~66574~~). The values of this parameter are applicable to only instance system events, but not to disk system events.
        self.instance_event_type = instance_event_type  # type: list[str]
        # The ID of the instance. If this parameter is not specified, the system events of all instances within the specified region are queried.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. The value must be a positive integer.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the resource belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of resource N. Valid values of N: 1 to 100. You can specify multiple resource IDs by repeatedly listing this parameter. Valid values:
        # 
        # *   When the `ResourceType` parameter is set to instance, the ResourceId.N parameter specifies the ID of instance N.
        # *   When the `ResourceType` parameter is set to ddh, the ResourceId.N parameter specifies the ID of dedicated host N.
        # *   When the `ResourceType` parameter is set to managedhost, the ResourceId.N parameter specifies the ID of physical machine N in a smart hosting pool.
        # 
        # If this parameter is not specified, the system events of all resources of the resource type specified by `ResourceType` within the region specified by `RegionId` are queried.
        # 
        # > We recommend that you use the `ResourceId.N` parameter to specify one or more resource IDs. If you specify both the ` ResourceId.N  `and `InstanceId` parameters, the `ResourceId.N` parameter takes precedence by default.
        self.resource_id = resource_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance.
        # *   ddh: dedicated host.
        # *   managehost: physical machine in a smart hosting pool.
        # 
        # Default value: instance.
        self.resource_type = resource_type  # type: str
        # The tags that are supported by system events.
        self.tag = tag  # type: list[DescribeInstanceHistoryEventsRequestTag]

    def validate(self):
        if self.event_publish_time:
            self.event_publish_time.validate()
        if self.not_before:
            self.not_before.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_publish_time is not None:
            result['EventPublishTime'] = self.event_publish_time.to_map()
        if self.not_before is not None:
            result['NotBefore'] = self.not_before.to_map()
        if self.event_cycle_status is not None:
            result['EventCycleStatus'] = self.event_cycle_status
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.impact_level is not None:
            result['ImpactLevel'] = self.impact_level
        if self.instance_event_cycle_status is not None:
            result['InstanceEventCycleStatus'] = self.instance_event_cycle_status
        if self.instance_event_type is not None:
            result['InstanceEventType'] = self.instance_event_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventPublishTime') is not None:
            temp_model = DescribeInstanceHistoryEventsRequestEventPublishTime()
            self.event_publish_time = temp_model.from_map(m['EventPublishTime'])
        if m.get('NotBefore') is not None:
            temp_model = DescribeInstanceHistoryEventsRequestNotBefore()
            self.not_before = temp_model.from_map(m['NotBefore'])
        if m.get('EventCycleStatus') is not None:
            self.event_cycle_status = m.get('EventCycleStatus')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('ImpactLevel') is not None:
            self.impact_level = m.get('ImpactLevel')
        if m.get('InstanceEventCycleStatus') is not None:
            self.instance_event_cycle_status = m.get('InstanceEventCycleStatus')
        if m.get('InstanceEventType') is not None:
            self.instance_event_type = m.get('InstanceEventType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInstanceHistoryEventsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The state code of the system event.
        self.code = code  # type: int
        # The state name of the system event.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the system event type.
        self.code = code  # type: int
        # The name of the system event type.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk(TeaModel):
    def __init__(self, creation_time=None, device_category=None, device_size=None, device_type=None,
                 release_time=None):
        # The time when the disk was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The category of the cloud disk or local disk. Valid values:
        # 
        # *   cloud: basic disk.
        # *   cloud_efficiency: ultra disk.
        # *   cloud_ssd: standard SSD.
        # *   cloud_essd: enhanced SSD (ESSD).
        # *   local_ssd_pro: I/O-intensive local disk.
        # *   local_hdd_pro: throughput-intensive local disk.
        # *   ephemeral: retired local disk.
        # *   ephemeral_ssd: retired local SSD.
        self.device_category = device_category  # type: str
        # The size of the disk. Unit: GiB.
        self.device_size = device_size  # type: str
        # The type of the disk. Valid values:
        # 
        # *   system: system disk.
        # *   data: data disk.
        self.device_type = device_type  # type: str
        # The time when the disk was released. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.release_time = release_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.device_category is not None:
            result['DeviceCategory'] = self.device_category
        if self.device_size is not None:
            result['DeviceSize'] = self.device_size
        if self.device_type is not None:
            result['DeviceType'] = self.device_type
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeviceCategory') is not None:
            self.device_category = m.get('DeviceCategory')
        if m.get('DeviceSize') is not None:
            self.device_size = m.get('DeviceSize')
        if m.get('DeviceType') is not None:
            self.device_type = m.get('DeviceType')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks(TeaModel):
    def __init__(self, inactive_disk=None):
        self.inactive_disk = inactive_disk  # type: list[DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk]

    def validate(self):
        if self.inactive_disk:
            for k in self.inactive_disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InactiveDisk'] = []
        if self.inactive_disk is not None:
            for k in self.inactive_disk:
                result['InactiveDisk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.inactive_disk = []
        if m.get('InactiveDisk') is not None:
            for k in m.get('InactiveDisk'):
                temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk()
                self.inactive_disk.append(temp_model.from_map(k))
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeMigrationOptions(TeaModel):
    def __init__(self, migration_option=None):
        self.migration_option = migration_option  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeMigrationOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.migration_option is not None:
            result['MigrationOption'] = self.migration_option
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MigrationOption') is not None:
            self.migration_option = m.get('MigrationOption')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute(TeaModel):
    def __init__(self, device=None, disk_id=None, host_id=None, host_type=None, inactive_disks=None,
                 migration_options=None, online_repair_policy=None, rack=None):
        # The device name of the local disk.
        self.device = device  # type: str
        # The ID of the local disk.
        self.disk_id = disk_id  # type: str
        # The ID of the host.
        self.host_id = host_id  # type: str
        # The type of the host. Valid values:
        # 
        # *   ddh: dedicated host.
        # *   managehost: physical machine in a smart hosting pool.
        self.host_type = host_type  # type: str
        # Details about the inactive cloud disks or local disks that have been released and must be removed.
        self.inactive_disks = inactive_disks  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks
        # The migration solution of the instance. Valid value: MigrationOptions. Instances can be migrated only by using migration plans.
        self.migration_options = migration_options  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeMigrationOptions
        # The online repair policy of the damaged disk. Valid value: IsolateOnly, which indicates that damaged disks are isolated but not repaired.
        self.online_repair_policy = online_repair_policy  # type: str
        # The rack number of the cloud box.
        self.rack = rack  # type: str

    def validate(self):
        if self.inactive_disks:
            self.inactive_disks.validate()
        if self.migration_options:
            self.migration_options.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.host_id is not None:
            result['HostId'] = self.host_id
        if self.host_type is not None:
            result['HostType'] = self.host_type
        if self.inactive_disks is not None:
            result['InactiveDisks'] = self.inactive_disks.to_map()
        if self.migration_options is not None:
            result['MigrationOptions'] = self.migration_options.to_map()
        if self.online_repair_policy is not None:
            result['OnlineRepairPolicy'] = self.online_repair_policy
        if self.rack is not None:
            result['Rack'] = self.rack
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('HostId') is not None:
            self.host_id = m.get('HostId')
        if m.get('HostType') is not None:
            self.host_type = m.get('HostType')
        if m.get('InactiveDisks') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeInactiveDisks()
            self.inactive_disks = temp_model.from_map(m['InactiveDisks'])
        if m.get('MigrationOptions') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttributeMigrationOptions()
            self.migration_options = temp_model.from_map(m['MigrationOptions'])
        if m.get('OnlineRepairPolicy') is not None:
            self.online_repair_policy = m.get('OnlineRepairPolicy')
        if m.get('Rack') is not None:
            self.rack = m.get('Rack')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType(TeaModel):
    def __init__(self, event_cycle_status=None, event_finish_time=None, event_id=None, event_publish_time=None,
                 event_type=None, extended_attribute=None, impact_level=None, instance_id=None, not_before=None, reason=None,
                 resource_type=None):
        # The lifecycle state of the system event.
        self.event_cycle_status = event_cycle_status  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus
        # The time when the system event ended. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.event_finish_time = event_finish_time  # type: str
        # The ID of the system event.
        self.event_id = event_id  # type: str
        # The time when the system event was published. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.event_publish_time = event_publish_time  # type: str
        # The type of the system event.
        self.event_type = event_type  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType
        # The extended attribute of the system event.
        self.extended_attribute = extended_attribute  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute
        # The impact level of the system event.
        self.impact_level = impact_level  # type: str
        # The ID of the instance that you query.
        self.instance_id = instance_id  # type: str
        # The scheduled start time of the system event. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.not_before = not_before  # type: str
        # The reason why the system event was scheduled.
        self.reason = reason  # type: str
        # The type of a resource. Valid values:
        # 
        # *   instance: ECS instance.
        # *   ddh: dedicated host.
        # *   managehost: physical machine in a smart hosting pool.
        self.resource_type = resource_type  # type: str

    def validate(self):
        if self.event_cycle_status:
            self.event_cycle_status.validate()
        if self.event_type:
            self.event_type.validate()
        if self.extended_attribute:
            self.extended_attribute.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_cycle_status is not None:
            result['EventCycleStatus'] = self.event_cycle_status.to_map()
        if self.event_finish_time is not None:
            result['EventFinishTime'] = self.event_finish_time
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_publish_time is not None:
            result['EventPublishTime'] = self.event_publish_time
        if self.event_type is not None:
            result['EventType'] = self.event_type.to_map()
        if self.extended_attribute is not None:
            result['ExtendedAttribute'] = self.extended_attribute.to_map()
        if self.impact_level is not None:
            result['ImpactLevel'] = self.impact_level
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.not_before is not None:
            result['NotBefore'] = self.not_before
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventCycleStatus') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventCycleStatus()
            self.event_cycle_status = temp_model.from_map(m['EventCycleStatus'])
        if m.get('EventFinishTime') is not None:
            self.event_finish_time = m.get('EventFinishTime')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventPublishTime') is not None:
            self.event_publish_time = m.get('EventPublishTime')
        if m.get('EventType') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeEventType()
            self.event_type = temp_model.from_map(m['EventType'])
        if m.get('ExtendedAttribute') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventTypeExtendedAttribute()
            self.extended_attribute = temp_model.from_map(m['ExtendedAttribute'])
        if m.get('ImpactLevel') is not None:
            self.impact_level = m.get('ImpactLevel')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NotBefore') is not None:
            self.not_before = m.get('NotBefore')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet(TeaModel):
    def __init__(self, instance_system_event_type=None):
        self.instance_system_event_type = instance_system_event_type  # type: list[DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType]

    def validate(self):
        if self.instance_system_event_type:
            for k in self.instance_system_event_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceSystemEventType'] = []
        if self.instance_system_event_type is not None:
            for k in self.instance_system_event_type:
                result['InstanceSystemEventType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_system_event_type = []
        if m.get('InstanceSystemEventType') is not None:
            for k in m.get('InstanceSystemEventType'):
                temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSetInstanceSystemEventType()
                self.instance_system_event_type.append(temp_model.from_map(k))
        return self


class DescribeInstanceHistoryEventsResponseBody(TeaModel):
    def __init__(self, instance_system_event_set=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the instance system events.
        self.instance_system_event_set = instance_system_event_set  # type: DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances that were queried.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instance_system_event_set:
            self.instance_system_event_set.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_system_event_set is not None:
            result['InstanceSystemEventSet'] = self.instance_system_event_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceSystemEventSet') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBodyInstanceSystemEventSet()
            self.instance_system_event_set = temp_model.from_map(m['InstanceSystemEventSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceHistoryEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceHistoryEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceHistoryEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceHistoryEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceMaintenanceAttributesRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of the instances. You can enter up to 100 instance IDs.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues(TeaModel):
    def __init__(self, supported_value=None):
        self.supported_value = supported_value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_value is not None:
            result['SupportedValue'] = self.supported_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedValue') is not None:
            self.supported_value = m.get('SupportedValue')
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance(TeaModel):
    def __init__(self, default_value=None, supported_values=None, value=None):
        # The default maintenance action.
        self.default_value = default_value  # type: str
        # The list of the supported maintenance actions.
        self.supported_values = supported_values  # type: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues
        # The current maintenance action. Valid values:
        # 
        # *   Stop: The instance goes down.
        # *   AutoRecover: The instance is automatically recovered.
        # *   AutoRedeploy: Failover is performed on the instance, which may damage the data disks.
        self.value = value  # type: str

    def validate(self):
        if self.supported_values:
            self.supported_values.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_value is not None:
            result['DefaultValue'] = self.default_value
        if self.supported_values is not None:
            result['SupportedValues'] = self.supported_values.to_map()
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultValue') is not None:
            self.default_value = m.get('DefaultValue')
        if m.get('SupportedValues') is not None:
            temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenanceSupportedValues()
            self.supported_values = temp_model.from_map(m['SupportedValues'])
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow(TeaModel):
    def __init__(self, end_time=None, start_time=None):
        # The end time of the maintenance window.
        self.end_time = end_time  # type: str
        # The start time of the maintenance window.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows(TeaModel):
    def __init__(self, maintenance_window=None):
        self.maintenance_window = maintenance_window  # type: list[DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow]

    def validate(self):
        if self.maintenance_window:
            for k in self.maintenance_window:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MaintenanceWindow'] = []
        if self.maintenance_window is not None:
            for k in self.maintenance_window:
                result['MaintenanceWindow'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.maintenance_window = []
        if m.get('MaintenanceWindow') is not None:
            for k in m.get('MaintenanceWindow'):
                temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindowsMaintenanceWindow()
                self.maintenance_window.append(temp_model.from_map(k))
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute(TeaModel):
    def __init__(self, action_on_maintenance=None, instance_id=None, maintenance_windows=None,
                 notify_on_maintenance=None):
        # The attributes of the maintenance action of the instance.
        self.action_on_maintenance = action_on_maintenance  # type: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Details about the maintenance window.
        self.maintenance_windows = maintenance_windows  # type: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows
        # Indicates whether an event notification was sent before instance shutdown.
        self.notify_on_maintenance = notify_on_maintenance  # type: bool

    def validate(self):
        if self.action_on_maintenance:
            self.action_on_maintenance.validate()
        if self.maintenance_windows:
            self.maintenance_windows.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_on_maintenance is not None:
            result['ActionOnMaintenance'] = self.action_on_maintenance.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.maintenance_windows is not None:
            result['MaintenanceWindows'] = self.maintenance_windows.to_map()
        if self.notify_on_maintenance is not None:
            result['NotifyOnMaintenance'] = self.notify_on_maintenance
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionOnMaintenance') is not None:
            temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeActionOnMaintenance()
            self.action_on_maintenance = temp_model.from_map(m['ActionOnMaintenance'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaintenanceWindows') is not None:
            temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttributeMaintenanceWindows()
            self.maintenance_windows = temp_model.from_map(m['MaintenanceWindows'])
        if m.get('NotifyOnMaintenance') is not None:
            self.notify_on_maintenance = m.get('NotifyOnMaintenance')
        return self


class DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes(TeaModel):
    def __init__(self, maintenance_attribute=None):
        self.maintenance_attribute = maintenance_attribute  # type: list[DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute]

    def validate(self):
        if self.maintenance_attribute:
            for k in self.maintenance_attribute:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MaintenanceAttribute'] = []
        if self.maintenance_attribute is not None:
            for k in self.maintenance_attribute:
                result['MaintenanceAttribute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.maintenance_attribute = []
        if m.get('MaintenanceAttribute') is not None:
            for k in m.get('MaintenanceAttribute'):
                temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributesMaintenanceAttribute()
                self.maintenance_attribute.append(temp_model.from_map(k))
        return self


class DescribeInstanceMaintenanceAttributesResponseBody(TeaModel):
    def __init__(self, maintenance_attributes=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the maintenance attributes.
        self.maintenance_attributes = maintenance_attributes  # type: DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of queried maintenance attributes.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.maintenance_attributes:
            self.maintenance_attributes.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.maintenance_attributes is not None:
            result['MaintenanceAttributes'] = self.maintenance_attributes.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaintenanceAttributes') is not None:
            temp_model = DescribeInstanceMaintenanceAttributesResponseBodyMaintenanceAttributes()
            self.maintenance_attributes = temp_model.from_map(m['MaintenanceAttributes'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceMaintenanceAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceMaintenanceAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceMaintenanceAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceMaintenanceAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceModificationPriceRequestSystemDisk(TeaModel):
    def __init__(self, category=None):
        # The category of the system disk. You must specify this parameter only when you upgrade a non-I/O optimized instance of a retired instance type to an I/O optimized instance of an available instance type. For more information about instance types, see [Instance families](~~25378~~) and [Retired instance types](~~55263~~).
        # 
        # Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # 
        # This parameter is empty by default.
        self.category = category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class DescribeInstanceModificationPriceRequestDataDisk(TeaModel):
    def __init__(self, category=None, performance_level=None, size=None):
        # The category of data disk. You can specify this parameter if you want to query the pricing information about newly attached subscription data disks. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # *   cloud: basic disk
        # 
        # This parameter is empty by default.
        # 
        # >  When you call the DescribeInstanceModificationPrice operation, you must specify at least one of the following parameters: `InstanceType` and `DataDisk.N.*`.
        self.category = category  # type: str
        # The performance level of data disk N that is an enhanced SSD (ESSD). The N value must be the same as that in `DataDisk.N.Category` when DataDisk.N.Category is set to cloud_essd. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # Default value: PL1.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # The capacity of data disk. Unit: GiB. Valid values:
        # 
        # *   Valid values when Category is set to cloud_efficiency: 20 to 32768.
        # *   Valid values when Category is set to cloud_ssd: 20 to 32768.
        # *   Valid values when Category is set to cloud_essd: depend on the `DataDisk.N.PerformanceLevel` value.
        #     *   Valid values when PerformanceLevel is set to PL0: 40 to 32768.
        #     *   Valid values when PerformanceLevel is set to PL1: 20 to 32768.
        #     *   Valid values when PerformanceLevel is set to PL2: 461 to 32768.
        #     *   Valid values when PerformanceLevel is set to PL3: 1261 to 32768.
        # *   Valid values when Category is set to cloud: 5 to 2000.
        # 
        # The default value is the minimum capacity allowed for the specified data disk category.
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribeInstanceModificationPriceRequest(TeaModel):
    def __init__(self, system_disk=None, data_disk=None, instance_id=None, instance_type=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.system_disk = system_disk  # type: DescribeInstanceModificationPriceRequestSystemDisk
        # The list of data disk. The list size can up to 16.
        self.data_disk = data_disk  # type: list[DescribeInstanceModificationPriceRequestDataDisk]
        # The ID of the instance for which you want to query pricing information for a configuration upgrade.
        self.instance_id = instance_id  # type: str
        # The new instance type. We recommend that you call the [DescribeResourcesModification](~~66187~~) operation to query the instance types available for configuration upgrades in a specified zone.
        # 
        # >  When you call the DescribeInstanceModificationPrice operation, you must specify at least one of the following parameters: `InstanceType` and `DataDisk.N.*`.
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = DescribeInstanceModificationPriceRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribeInstanceModificationPriceRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceModificationPriceResponseBodyPriceInfoPrice(TeaModel):
    def __init__(self, currency=None, discount_price=None, original_price=None, trade_price=None):
        # The currency unit. 
        # 
        # Alibaba Cloud China site (aliyun.com): CNY. 
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # The discount.
        self.discount_price = discount_price  # type: float
        # The original price.
        self.original_price = original_price  # type: float
        # The transaction price, which is equal to the original price minus the discount.
        self.trade_price = trade_price  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponseBodyPriceInfoPrice, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule(TeaModel):
    def __init__(self, description=None, rule_id=None):
        # The description of the promotion rule.
        self.description = description  # type: str
        # The ID of the promotion rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeInstanceModificationPriceResponseBodyPriceInfoRules(TeaModel):
    def __init__(self, rule=None):
        self.rule = rule  # type: list[DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule]

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponseBodyPriceInfoRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = DescribeInstanceModificationPriceResponseBodyPriceInfoRulesRule()
                self.rule.append(temp_model.from_map(k))
        return self


class DescribeInstanceModificationPriceResponseBodyPriceInfo(TeaModel):
    def __init__(self, price=None, rules=None):
        # The price.
        self.price = price  # type: DescribeInstanceModificationPriceResponseBodyPriceInfoPrice
        # Details about the promotion rules.
        self.rules = rules  # type: DescribeInstanceModificationPriceResponseBodyPriceInfoRules

    def validate(self):
        if self.price:
            self.price.validate()
        if self.rules:
            self.rules.validate()

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponseBodyPriceInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price is not None:
            result['Price'] = self.price.to_map()
        if self.rules is not None:
            result['Rules'] = self.rules.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Price') is not None:
            temp_model = DescribeInstanceModificationPriceResponseBodyPriceInfoPrice()
            self.price = temp_model.from_map(m['Price'])
        if m.get('Rules') is not None:
            temp_model = DescribeInstanceModificationPriceResponseBodyPriceInfoRules()
            self.rules = temp_model.from_map(m['Rules'])
        return self


class DescribeInstanceModificationPriceResponseBody(TeaModel):
    def __init__(self, price_info=None, request_id=None):
        # Details about the prices and discount rules.
        self.price_info = price_info  # type: DescribeInstanceModificationPriceResponseBodyPriceInfo
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.price_info:
            self.price_info.validate()

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price_info is not None:
            result['PriceInfo'] = self.price_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PriceInfo') is not None:
            temp_model = DescribeInstanceModificationPriceResponseBodyPriceInfo()
            self.price_info = temp_model.from_map(m['PriceInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceModificationPriceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceModificationPriceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceModificationPriceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceModificationPriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceMonitorDataRequest(TeaModel):
    def __init__(self, end_time=None, instance_id=None, owner_account=None, owner_id=None, period=None,
                 resource_owner_account=None, resource_owner_id=None, start_time=None):
        # The end of the time range to query. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. If the value of seconds (`ss`) is not `00`, the time is rounded up to the next minute.
        self.end_time = end_time  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The interval at which to retrieve monitored data. Unit: seconds. Valid values:
        # 
        # *   60
        # *   600
        # *   3600
        # 
        # Default value: 60.
        self.period = period  # type: int
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (`ss`) is not `00`, the time is rounded up to the next minute.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData(TeaModel):
    def __init__(self, bpsread=None, bpswrite=None, cpu=None, cpuadvance_credit_balance=None,
                 cpucredit_balance=None, cpucredit_usage=None, cpunotpaid_surplus_credit_usage=None, iopsread=None, iopswrite=None,
                 instance_id=None, internet_bandwidth=None, internet_rx=None, internet_tx=None, intranet_bandwidth=None,
                 intranet_rx=None, intranet_tx=None, time_stamp=None):
        # The read bandwidth of the disks (system disk and data disks). Unit: Byte/s.
        self.bpsread = bpsread  # type: int
        # The write bandwidth of the disks (system disk and data disks). Unit: Byte/s.
        self.bpswrite = bpswrite  # type: int
        # The vCPU utilization of the instance. Unit: percent (%).
        self.cpu = cpu  # type: int
        # The overdrawn CPU credits of the burstable instance.
        self.cpuadvance_credit_balance = cpuadvance_credit_balance  # type: float
        # The total CPU credits of the burstable instance.
        self.cpucredit_balance = cpucredit_balance  # type: float
        # The number of CPU credits consumed by the burstable instance.
        self.cpucredit_usage = cpucredit_usage  # type: float
        # The unpaid excess credits.
        self.cpunotpaid_surplus_credit_usage = cpunotpaid_surplus_credit_usage  # type: float
        # The number of read I/O operations per second on the disks (system disk and data disks).
        self.iopsread = iopsread  # type: int
        # The number of write I/O operations per second on the disks (system disk and data disks).
        self.iopswrite = iopswrite  # type: int
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The public bandwidth of the instance. Unit: Kbit/s.
        self.internet_bandwidth = internet_bandwidth  # type: int
        # The public data traffic received by the instance during the period specified by the `Period` parameter, which starts from the time specified by the `TimeStamp` parameter. Unit: Kbit/s.
        self.internet_rx = internet_rx  # type: int
        # The public data traffic sent by the instance during the period specified by the `Period` parameter, which starts from the time specified by the `TimeStamp` parameter. Unit: Kbit/s.
        self.internet_tx = internet_tx  # type: int
        # The internal bandwidth of the instance. Unit: Kbit/s.
        self.intranet_bandwidth = intranet_bandwidth  # type: int
        # The internal data traffic received by the instance during the period specified by the `Period` parameter, which starts from the time specified by the `TimeStamp` parameter. Unit: Kbit/s.
        self.intranet_rx = intranet_rx  # type: int
        # The internal data traffic sent by the instance during the period specified by the `Period` parameter, which starts from the time specified by the `TimeStamp` parameter. Unit: Kbit/s.
        self.intranet_tx = intranet_tx  # type: int
        # The timestamp of the monitoring data.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bpsread is not None:
            result['BPSRead'] = self.bpsread
        if self.bpswrite is not None:
            result['BPSWrite'] = self.bpswrite
        if self.cpu is not None:
            result['CPU'] = self.cpu
        if self.cpuadvance_credit_balance is not None:
            result['CPUAdvanceCreditBalance'] = self.cpuadvance_credit_balance
        if self.cpucredit_balance is not None:
            result['CPUCreditBalance'] = self.cpucredit_balance
        if self.cpucredit_usage is not None:
            result['CPUCreditUsage'] = self.cpucredit_usage
        if self.cpunotpaid_surplus_credit_usage is not None:
            result['CPUNotpaidSurplusCreditUsage'] = self.cpunotpaid_surplus_credit_usage
        if self.iopsread is not None:
            result['IOPSRead'] = self.iopsread
        if self.iopswrite is not None:
            result['IOPSWrite'] = self.iopswrite
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.internet_bandwidth is not None:
            result['InternetBandwidth'] = self.internet_bandwidth
        if self.internet_rx is not None:
            result['InternetRX'] = self.internet_rx
        if self.internet_tx is not None:
            result['InternetTX'] = self.internet_tx
        if self.intranet_bandwidth is not None:
            result['IntranetBandwidth'] = self.intranet_bandwidth
        if self.intranet_rx is not None:
            result['IntranetRX'] = self.intranet_rx
        if self.intranet_tx is not None:
            result['IntranetTX'] = self.intranet_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BPSRead') is not None:
            self.bpsread = m.get('BPSRead')
        if m.get('BPSWrite') is not None:
            self.bpswrite = m.get('BPSWrite')
        if m.get('CPU') is not None:
            self.cpu = m.get('CPU')
        if m.get('CPUAdvanceCreditBalance') is not None:
            self.cpuadvance_credit_balance = m.get('CPUAdvanceCreditBalance')
        if m.get('CPUCreditBalance') is not None:
            self.cpucredit_balance = m.get('CPUCreditBalance')
        if m.get('CPUCreditUsage') is not None:
            self.cpucredit_usage = m.get('CPUCreditUsage')
        if m.get('CPUNotpaidSurplusCreditUsage') is not None:
            self.cpunotpaid_surplus_credit_usage = m.get('CPUNotpaidSurplusCreditUsage')
        if m.get('IOPSRead') is not None:
            self.iopsread = m.get('IOPSRead')
        if m.get('IOPSWrite') is not None:
            self.iopswrite = m.get('IOPSWrite')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InternetBandwidth') is not None:
            self.internet_bandwidth = m.get('InternetBandwidth')
        if m.get('InternetRX') is not None:
            self.internet_rx = m.get('InternetRX')
        if m.get('InternetTX') is not None:
            self.internet_tx = m.get('InternetTX')
        if m.get('IntranetBandwidth') is not None:
            self.intranet_bandwidth = m.get('IntranetBandwidth')
        if m.get('IntranetRX') is not None:
            self.intranet_rx = m.get('IntranetRX')
        if m.get('IntranetTX') is not None:
            self.intranet_tx = m.get('IntranetTX')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeInstanceMonitorDataResponseBodyMonitorData(TeaModel):
    def __init__(self, instance_monitor_data=None):
        self.instance_monitor_data = instance_monitor_data  # type: list[DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData]

    def validate(self):
        if self.instance_monitor_data:
            for k in self.instance_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceMonitorDataResponseBodyMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceMonitorData'] = []
        if self.instance_monitor_data is not None:
            for k in self.instance_monitor_data:
                result['InstanceMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_monitor_data = []
        if m.get('InstanceMonitorData') is not None:
            for k in m.get('InstanceMonitorData'):
                temp_model = DescribeInstanceMonitorDataResponseBodyMonitorDataInstanceMonitorData()
                self.instance_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeInstanceMonitorDataResponseBody(TeaModel):
    def __init__(self, monitor_data=None, request_id=None):
        # The monitoring data about the instance.
        self.monitor_data = monitor_data  # type: DescribeInstanceMonitorDataResponseBodyMonitorData
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super(DescribeInstanceMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MonitorData') is not None:
            temp_model = DescribeInstanceMonitorDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceRamRoleRequest(TeaModel):
    def __init__(self, instance_ids=None, owner_id=None, page_number=None, page_size=None, ram_role_name=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. You can specify up to 100 instance IDs in a single request. You must specify at least one of the `InstanceIds` and `RamRoleName` parameters.
        self.instance_ids = instance_ids  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The name of the instance RAM role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created. You must specify at least one of the `InstanceIds` and `RamRoleName` parameters.
        self.ram_role_name = ram_role_name  # type: str
        # The region ID of the instance RAM role. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceRamRoleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet(TeaModel):
    def __init__(self, instance_id=None, ram_role_name=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance RAM role.
        self.ram_role_name = ram_role_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        return self


class DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets(TeaModel):
    def __init__(self, instance_ram_role_set=None):
        self.instance_ram_role_set = instance_ram_role_set  # type: list[DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet]

    def validate(self):
        if self.instance_ram_role_set:
            for k in self.instance_ram_role_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceRamRoleSet'] = []
        if self.instance_ram_role_set is not None:
            for k in self.instance_ram_role_set:
                result['InstanceRamRoleSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_ram_role_set = []
        if m.get('InstanceRamRoleSet') is not None:
            for k in m.get('InstanceRamRoleSet'):
                temp_model = DescribeInstanceRamRoleResponseBodyInstanceRamRoleSetsInstanceRamRoleSet()
                self.instance_ram_role_set.append(temp_model.from_map(k))
        return self


class DescribeInstanceRamRoleResponseBody(TeaModel):
    def __init__(self, instance_ram_role_sets=None, region_id=None, request_id=None, total_count=None):
        # Details about the instance RAM roles.
        self.instance_ram_role_sets = instance_ram_role_sets  # type: DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets
        # The region ID of the instance RAM role.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instance RAM roles returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instance_ram_role_sets:
            self.instance_ram_role_sets.validate()

    def to_map(self):
        _map = super(DescribeInstanceRamRoleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ram_role_sets is not None:
            result['InstanceRamRoleSets'] = self.instance_ram_role_sets.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceRamRoleSets') is not None:
            temp_model = DescribeInstanceRamRoleResponseBodyInstanceRamRoleSets()
            self.instance_ram_role_sets = temp_model.from_map(m['InstanceRamRoleSets'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceRamRoleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceRamRoleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceRamRoleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceRamRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceStatusRequest(TeaModel):
    def __init__(self, cluster_id=None, instance_id=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None, zone_id=None):
        # The cluster ID of the instance.
        self.cluster_id = cluster_id  # type: str
        # The IDs of the instances.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The zone ID of the instance. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus(TeaModel):
    def __init__(self, instance_id=None, status=None):
        # The ID of instance.
        self.instance_id = instance_id  # type: str
        # The state of the instance. Valid values:
        # 
        # * Pending: The instance is being created.
        # * Running: The instance is running.
        # * Starting: The instance is being started.
        # * Stopping: The instance is being stopped.
        # * Stopped: The instance is stopped.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeInstanceStatusResponseBodyInstanceStatuses(TeaModel):
    def __init__(self, instance_status=None):
        self.instance_status = instance_status  # type: list[DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus]

    def validate(self):
        if self.instance_status:
            for k in self.instance_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceStatusResponseBodyInstanceStatuses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceStatus'] = []
        if self.instance_status is not None:
            for k in self.instance_status:
                result['InstanceStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_status = []
        if m.get('InstanceStatus') is not None:
            for k in m.get('InstanceStatus'):
                temp_model = DescribeInstanceStatusResponseBodyInstanceStatusesInstanceStatus()
                self.instance_status.append(temp_model.from_map(k))
        return self


class DescribeInstanceStatusResponseBody(TeaModel):
    def __init__(self, instance_statuses=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # The status information of the instances.
        self.instance_statuses = instance_statuses  # type: DescribeInstanceStatusResponseBodyInstanceStatuses
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instance_statuses:
            self.instance_statuses.validate()

    def to_map(self):
        _map = super(DescribeInstanceStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_statuses is not None:
            result['InstanceStatuses'] = self.instance_statuses.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceStatuses') is not None:
            temp_model = DescribeInstanceStatusResponseBodyInstanceStatuses()
            self.instance_statuses = temp_model.from_map(m['InstanceStatuses'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstanceStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTopologyRequest(TeaModel):
    def __init__(self, instance_ids=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The IDs of one or more ECS instances. You can specify a maximum of 100 instance IDs.
        self.instance_ids = instance_ids  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ECS instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceTopologyResponseBodyTopologysTopology(TeaModel):
    def __init__(self, host_id=None, instance_id=None):
        # The ID of the host where the ECS instance is deployed. This parameter is encrypted and cannot match the ID of the instance. However, if the values of this parameter for different ECS instances are the same, the ECS instances are deployed on the same host.
        self.host_id = host_id  # type: str
        # The ID of the ECS instance.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyTopologysTopology, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_id is not None:
            result['HostId'] = self.host_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HostId') is not None:
            self.host_id = m.get('HostId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class DescribeInstanceTopologyResponseBodyTopologys(TeaModel):
    def __init__(self, topology=None):
        self.topology = topology  # type: list[DescribeInstanceTopologyResponseBodyTopologysTopology]

    def validate(self):
        if self.topology:
            for k in self.topology:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBodyTopologys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Topology'] = []
        if self.topology is not None:
            for k in self.topology:
                result['Topology'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.topology = []
        if m.get('Topology') is not None:
            for k in m.get('Topology'):
                temp_model = DescribeInstanceTopologyResponseBodyTopologysTopology()
                self.topology.append(temp_model.from_map(k))
        return self


class DescribeInstanceTopologyResponseBody(TeaModel):
    def __init__(self, request_id=None, topologys=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the topology.
        self.topologys = topologys  # type: DescribeInstanceTopologyResponseBodyTopologys

    def validate(self):
        if self.topologys:
            self.topologys.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.topologys is not None:
            result['Topologys'] = self.topologys.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Topologys') is not None:
            temp_model = DescribeInstanceTopologyResponseBodyTopologys()
            self.topologys = temp_model.from_map(m['Topologys'])
        return self


class DescribeInstanceTopologyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTopologyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTopologyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTopologyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTypeFamiliesRequest(TeaModel):
    def __init__(self, generation=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The generation of the instance family. For more information, see [Instance families](~~25378~~). Valid values:
        # 
        # *   ecs-1: Generation I, which consists of the earliest and cost-effective instance types
        # *   ecs-2: Generation II, which provides upgraded software and hardware and higher performance than Generation I
        # *   ecs-3: Generation III, which consists of high-performance instance families and is suitable for different business scenarios
        # *   ecs-4: Generation IV, which consists of enterprise-level instance families (such as g5, c5, and r5), Bare Metal Instance families (such as ebmc5s, ebmg5s, and ebmr5s), and burstable instance families (such as t5) that can meet a wide variety of business requirements with lower latency
        # *   ecs-5: Generation V, which consists of enterprise-level instance families (such as g6, c6, and r6), Bare Metal Instance families (such as ebmg6, ebmg6e, and ebmc6), and storage enhanced instance families (such as g6e) and delivers quick response and higher performance
        # *   ecs-6: Generation VI, which consists of enterprise-level instance families (such as hfc7, hfg7, and hfr7) and Bare Metal Instance families (such as ebmhfg7) and is in invitational preview
        self.generation = generation  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTypeFamiliesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generation is not None:
            result['Generation'] = self.generation
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Generation') is not None:
            self.generation = m.get('Generation')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily(TeaModel):
    def __init__(self, generation=None, instance_type_family_id=None):
        # The generation of the instance family.
        self.generation = generation  # type: str
        # The ID of the instance family.
        self.instance_type_family_id = instance_type_family_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.generation is not None:
            result['Generation'] = self.generation
        if self.instance_type_family_id is not None:
            result['InstanceTypeFamilyId'] = self.instance_type_family_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Generation') is not None:
            self.generation = m.get('Generation')
        if m.get('InstanceTypeFamilyId') is not None:
            self.instance_type_family_id = m.get('InstanceTypeFamilyId')
        return self


class DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies(TeaModel):
    def __init__(self, instance_type_family=None):
        self.instance_type_family = instance_type_family  # type: list[DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily]

    def validate(self):
        if self.instance_type_family:
            for k in self.instance_type_family:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceTypeFamily'] = []
        if self.instance_type_family is not None:
            for k in self.instance_type_family:
                result['InstanceTypeFamily'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_type_family = []
        if m.get('InstanceTypeFamily') is not None:
            for k in m.get('InstanceTypeFamily'):
                temp_model = DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamiliesInstanceTypeFamily()
                self.instance_type_family.append(temp_model.from_map(k))
        return self


class DescribeInstanceTypeFamiliesResponseBody(TeaModel):
    def __init__(self, instance_type_families=None, request_id=None):
        # Details about instance families.
        self.instance_type_families = instance_type_families  # type: DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_type_families:
            self.instance_type_families.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypeFamiliesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type_families is not None:
            result['InstanceTypeFamilies'] = self.instance_type_families.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceTypeFamilies') is not None:
            temp_model = DescribeInstanceTypeFamiliesResponseBodyInstanceTypeFamilies()
            self.instance_type_families = temp_model.from_map(m['InstanceTypeFamilies'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceTypeFamiliesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTypeFamiliesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypeFamiliesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTypeFamiliesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceTypesRequest(TeaModel):
    def __init__(self, cpu_architecture=None, gpuspec=None, instance_category=None, instance_family_level=None,
                 instance_type_family=None, instance_types=None, local_storage_category=None, max_results=None,
                 maximum_cpu_core_count=None, maximum_cpu_speed_frequency=None, maximum_cpu_turbo_frequency=None, maximum_gpuamount=None,
                 maximum_memory_size=None, minimum_baseline_credit=None, minimum_cpu_core_count=None,
                 minimum_cpu_speed_frequency=None, minimum_cpu_turbo_frequency=None, minimum_disk_quantity=None,
                 minimum_eni_ipv_6address_quantity=None, minimum_eni_private_ip_address_quantity=None, minimum_eni_quantity=None,
                 minimum_eri_quantity=None, minimum_gpuamount=None, minimum_initial_credit=None, minimum_instance_bandwidth_rx=None,
                 minimum_instance_bandwidth_tx=None, minimum_instance_pps_rx=None, minimum_instance_pps_tx=None,
                 minimum_local_storage_amount=None, minimum_local_storage_capacity=None, minimum_memory_size=None,
                 minimum_primary_eni_queue_number=None, minimum_queue_pair_number=None, minimum_secondary_eni_queue_number=None, next_token=None,
                 nvme_support=None, owner_account=None, owner_id=None, physical_processor_model=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The CPU architecture. Valid values:
        # 
        # *   X86
        # *   ARM
        self.cpu_architecture = cpu_architecture  # type: str
        # The GPU model.
        # 
        # > Fuzzy match is supported. For example, if an instance type provides NVIDIA V100 GPUs and you set this parameter to NVIDIA, information about the instance type is queried.
        self.gpuspec = gpuspec  # type: str
        # The category of the instance type. Valid values:
        # 
        # *   General-purpose: general-purpose instance type
        # *   Compute-optimized: compute-optimized instance type
        # *   Memory-optimized: memory-optimized instance type
        # *   Big data: big data instance type
        # *   Local SSDs: instance type with local SSDs
        # *   High Clock Speed: instance type with high clock speeds
        # *   Enhanced: enhanced instance type
        # *   Shared: shared instance type
        # *   Compute-optimized with GPU: GPU-accelerated compute-optimized instance type
        # *   Visual Compute-optimized: visual compute-optimized instance type
        # *   Heterogeneous Service: heterogeneous service instance type
        # *   Compute-optimized with FPGA: FPGA-accelerated compute-optimized instance type
        # *   Compute-optimized with NPU: NPU-accelerated compute-optimized instance type
        # *   ECS Bare Metal: ECS Bare Metal Instance type
        # *   Super Computing Cluster: Super Computing Cluster (SCC) instance type
        self.instance_category = instance_category  # type: str
        # The level of the instance family. Valid values:
        # 
        # *   EntryLevel: entry level (shared)
        # *   EnterpriseLevel: enterprise level
        # *   CreditEntryLevel: credit-based entry level
        self.instance_family_level = instance_family_level  # type: str
        # The instance family to which the instance type belongs. For information about the valid values of this parameter, see [DescribeInstanceTypeFamilies](~~25621~~).
        # 
        # For more information about instance families, see [Instance families](~~25378~~).
        self.instance_type_family = instance_type_family  # type: str
        # Instance type N. Valid values of N: 1 to 10. If this parameter is empty, information about all instance types is queried.
        self.instance_types = instance_types  # type: list[str]
        # The category of local disks. For more information, see [Local disks](~~63138#section_n2w\_8yc\_5u1~~). Valid values:
        # 
        # *   local_hdd_pro: local Serial Advanced Technology Attachment (SATA) HDDs, which are used by d1ne or d1 instances
        # *   local_ssd_pro: local Non-Volatile Memory Express (NVMe) SSDs, which are used by i2, i2g, i1, ga1, or gn5 instances
        self.local_storage_category = local_storage_category  # type: str
        # The maximum number of entries to return on each page. Maximum value: 1600.
        # 
        # Default value: 1600.
        self.max_results = max_results  # type: long
        # The maximum number of vCPUs. The value must be a positive integer.
        # 
        # > If an instance type has more vCPUs than the specified value, information about the instance type is not queried.
        self.maximum_cpu_core_count = maximum_cpu_core_count  # type: int
        # The maximum clock speed.
        # 
        # > If an instance type uses processors that have a higher clock speed than the specified value, information about the instance type is not queried.
        self.maximum_cpu_speed_frequency = maximum_cpu_speed_frequency  # type: float
        # The maximum turbo frequency.
        # 
        # > If an instance type uses processors that deliver a higher turbo frequency than the specified value, information about the instance type is not queried.
        self.maximum_cpu_turbo_frequency = maximum_cpu_turbo_frequency  # type: float
        # The maximum number of GPUs. The value must be a positive integer.
        # 
        # > If an instance type provides more GPUs than the specified value, information about the instance type is not queried.
        self.maximum_gpuamount = maximum_gpuamount  # type: int
        # The maximum memory size. Unit: GiB.
        # 
        # > If the memory size of an instance type is larger than the specified value, information about the instance type is not queried.
        self.maximum_memory_size = maximum_memory_size  # type: float
        # The minimum baseline CPU performance (overall baseline performance of all vCPUs) per t5 or t6 burstable instance.
        # 
        # > If a t5 or t6 instance type provides baseline CPU performance that is lower than the specified value, information about the instance type is not queried.
        self.minimum_baseline_credit = minimum_baseline_credit  # type: int
        # The minimum number of vCPUs. The value must be a positive integer.
        # 
        # > If an instance type has fewer vCPUs than the specified value, information about the instance type is not queried.
        self.minimum_cpu_core_count = minimum_cpu_core_count  # type: int
        # The minimum clock speed.
        # 
        # > If an instance type uses processors that have a lower clock speed than the specified value, information about the instance type is not queried.
        self.minimum_cpu_speed_frequency = minimum_cpu_speed_frequency  # type: float
        # The minimum turbo frequency.
        # 
        # > If an instance type uses processors that deliver a lower turbo frequency than the specified value, information about the instance type is not queried.
        self.minimum_cpu_turbo_frequency = minimum_cpu_turbo_frequency  # type: float
        # The minimum number of cloud disks.
        # 
        # > If an instance type supports fewer cloud disks than the specified value, information about the instance type is not queried.
        self.minimum_disk_quantity = minimum_disk_quantity  # type: int
        # The minimum number of IPv6 addresses per ENI.
        # 
        # > If an instance type supports fewer IPv6 addresses per ENI than the specified value, information about the instance type is not queried.
        self.minimum_eni_ipv_6address_quantity = minimum_eni_ipv_6address_quantity  # type: int
        # The minimum number of IPv4 addresses per ENI.
        # 
        # > If an instance type supports fewer IPv4 addresses per ENI than the specified value, information about the instance type is not queried.
        self.minimum_eni_private_ip_address_quantity = minimum_eni_private_ip_address_quantity  # type: int
        # The minimum number of elastic network interfaces (ENIs).
        # 
        # > If an instance type supports fewer ENIs than the specified value, information about the instance type is not queried.
        self.minimum_eni_quantity = minimum_eni_quantity  # type: int
        # The minimum number of ERIs.
        # 
        # > If an instance type supports fewer ERIs than the specified value, information about the instance type is not queried.
        self.minimum_eri_quantity = minimum_eri_quantity  # type: int
        # The minimum number of GPUs. The value must be a positive integer.
        # 
        # > If an instance type provides fewer GPUs than the specified value, information about the instance type is not queried.
        self.minimum_gpuamount = minimum_gpuamount  # type: int
        # The minimum initial CPU credits per t5 or t6 burstable instance.
        # 
        # > If a t5 or t6 instance type provides less initial vCPU credits than the specified value, information about the instance type is not queried.
        self.minimum_initial_credit = minimum_initial_credit  # type: int
        # The minimum inbound internal bandwidth. Unit: Kbit/s.
        # 
        # > If an instance type provides an inbound internal bandwidth that is lower than the specified value, information about the instance type is not queried.
        self.minimum_instance_bandwidth_rx = minimum_instance_bandwidth_rx  # type: int
        # The minimum outbound internal bandwidth. Unit: Kbit/s.
        # 
        # > If an instance type provides an outbound internal bandwidth that is lower than the specified value, information about the instance type is not queried.
        self.minimum_instance_bandwidth_tx = minimum_instance_bandwidth_tx  # type: int
        # The minimum inbound packet forwarding rate over the internal network. Unit: pps.
        # 
        # > If an instance type provides an inbound packet forwarding rate over the internal network that is lower than the specified value, information about the instance type is not queried.
        self.minimum_instance_pps_rx = minimum_instance_pps_rx  # type: long
        # The minimum outbound packet forwarding rate over the internal network. Unit: pps.
        # 
        # > If an instance type provides an outbound packet forwarding rate over the internal network that is lower than the specified value, information about the instance type is not queried.
        self.minimum_instance_pps_tx = minimum_instance_pps_tx  # type: long
        # The minimum number of local disks.
        # 
        # > If an instance type supports fewer local disks than the specified value, information about the instance type is not queried.
        self.minimum_local_storage_amount = minimum_local_storage_amount  # type: int
        # The capacity of each local disk. Unit: GiB.
        self.minimum_local_storage_capacity = minimum_local_storage_capacity  # type: long
        # The minimum memory size. Unit: GiB.
        # 
        # > If the memory size of an instance type is smaller than the specified value, information about the instance type is not queried.
        self.minimum_memory_size = minimum_memory_size  # type: float
        # The minimum default number of queues per primary network interface controller (NIC).
        # 
        # > If an instance type supports fewer queues per primary NIC than the specified value, information about the instance type is not queried.
        self.minimum_primary_eni_queue_number = minimum_primary_eni_queue_number  # type: int
        # The minimum number of queue pair (QP) queues per elastic RDMA interface (ERI).
        # 
        # > If an instance type supports fewer QP queues per ERI than the specified value, information about the instance type is not queried.
        self.minimum_queue_pair_number = minimum_queue_pair_number  # type: int
        # The minimum default number of queues per secondary NIC.
        # 
        # > If an instance type supports fewer queues per secondary NIC than the specified value, information about the instance type is not queried.
        self.minimum_secondary_eni_queue_number = minimum_secondary_eni_queue_number  # type: int
        # The query token. Set the value to the NextToken value returned in the previous call to the DescribeInstanceTypes operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        # Specifies whether cloud disks can be attached by using the NVMe protocol. Valid values:
        # 
        # *   required: Cloud disks can be attached by using the NVMe protocol.
        # *   unsupported: Cloud disk cannot be attached by using the NVMe protocol.
        self.nvme_support = nvme_support  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The CPU model.
        # 
        # > Fuzzy match is supported. For example, if an instance type uses Intel Xeon (Ice Lake) Platinum 8369B processors and you set this parameter to Intel, information about the instance type is queried.
        self.physical_processor_model = physical_processor_model  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTypesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_architecture is not None:
            result['CpuArchitecture'] = self.cpu_architecture
        if self.gpuspec is not None:
            result['GPUSpec'] = self.gpuspec
        if self.instance_category is not None:
            result['InstanceCategory'] = self.instance_category
        if self.instance_family_level is not None:
            result['InstanceFamilyLevel'] = self.instance_family_level
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.local_storage_category is not None:
            result['LocalStorageCategory'] = self.local_storage_category
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.maximum_cpu_core_count is not None:
            result['MaximumCpuCoreCount'] = self.maximum_cpu_core_count
        if self.maximum_cpu_speed_frequency is not None:
            result['MaximumCpuSpeedFrequency'] = self.maximum_cpu_speed_frequency
        if self.maximum_cpu_turbo_frequency is not None:
            result['MaximumCpuTurboFrequency'] = self.maximum_cpu_turbo_frequency
        if self.maximum_gpuamount is not None:
            result['MaximumGPUAmount'] = self.maximum_gpuamount
        if self.maximum_memory_size is not None:
            result['MaximumMemorySize'] = self.maximum_memory_size
        if self.minimum_baseline_credit is not None:
            result['MinimumBaselineCredit'] = self.minimum_baseline_credit
        if self.minimum_cpu_core_count is not None:
            result['MinimumCpuCoreCount'] = self.minimum_cpu_core_count
        if self.minimum_cpu_speed_frequency is not None:
            result['MinimumCpuSpeedFrequency'] = self.minimum_cpu_speed_frequency
        if self.minimum_cpu_turbo_frequency is not None:
            result['MinimumCpuTurboFrequency'] = self.minimum_cpu_turbo_frequency
        if self.minimum_disk_quantity is not None:
            result['MinimumDiskQuantity'] = self.minimum_disk_quantity
        if self.minimum_eni_ipv_6address_quantity is not None:
            result['MinimumEniIpv6AddressQuantity'] = self.minimum_eni_ipv_6address_quantity
        if self.minimum_eni_private_ip_address_quantity is not None:
            result['MinimumEniPrivateIpAddressQuantity'] = self.minimum_eni_private_ip_address_quantity
        if self.minimum_eni_quantity is not None:
            result['MinimumEniQuantity'] = self.minimum_eni_quantity
        if self.minimum_eri_quantity is not None:
            result['MinimumEriQuantity'] = self.minimum_eri_quantity
        if self.minimum_gpuamount is not None:
            result['MinimumGPUAmount'] = self.minimum_gpuamount
        if self.minimum_initial_credit is not None:
            result['MinimumInitialCredit'] = self.minimum_initial_credit
        if self.minimum_instance_bandwidth_rx is not None:
            result['MinimumInstanceBandwidthRx'] = self.minimum_instance_bandwidth_rx
        if self.minimum_instance_bandwidth_tx is not None:
            result['MinimumInstanceBandwidthTx'] = self.minimum_instance_bandwidth_tx
        if self.minimum_instance_pps_rx is not None:
            result['MinimumInstancePpsRx'] = self.minimum_instance_pps_rx
        if self.minimum_instance_pps_tx is not None:
            result['MinimumInstancePpsTx'] = self.minimum_instance_pps_tx
        if self.minimum_local_storage_amount is not None:
            result['MinimumLocalStorageAmount'] = self.minimum_local_storage_amount
        if self.minimum_local_storage_capacity is not None:
            result['MinimumLocalStorageCapacity'] = self.minimum_local_storage_capacity
        if self.minimum_memory_size is not None:
            result['MinimumMemorySize'] = self.minimum_memory_size
        if self.minimum_primary_eni_queue_number is not None:
            result['MinimumPrimaryEniQueueNumber'] = self.minimum_primary_eni_queue_number
        if self.minimum_queue_pair_number is not None:
            result['MinimumQueuePairNumber'] = self.minimum_queue_pair_number
        if self.minimum_secondary_eni_queue_number is not None:
            result['MinimumSecondaryEniQueueNumber'] = self.minimum_secondary_eni_queue_number
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.nvme_support is not None:
            result['NvmeSupport'] = self.nvme_support
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.physical_processor_model is not None:
            result['PhysicalProcessorModel'] = self.physical_processor_model
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuArchitecture') is not None:
            self.cpu_architecture = m.get('CpuArchitecture')
        if m.get('GPUSpec') is not None:
            self.gpuspec = m.get('GPUSpec')
        if m.get('InstanceCategory') is not None:
            self.instance_category = m.get('InstanceCategory')
        if m.get('InstanceFamilyLevel') is not None:
            self.instance_family_level = m.get('InstanceFamilyLevel')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('LocalStorageCategory') is not None:
            self.local_storage_category = m.get('LocalStorageCategory')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MaximumCpuCoreCount') is not None:
            self.maximum_cpu_core_count = m.get('MaximumCpuCoreCount')
        if m.get('MaximumCpuSpeedFrequency') is not None:
            self.maximum_cpu_speed_frequency = m.get('MaximumCpuSpeedFrequency')
        if m.get('MaximumCpuTurboFrequency') is not None:
            self.maximum_cpu_turbo_frequency = m.get('MaximumCpuTurboFrequency')
        if m.get('MaximumGPUAmount') is not None:
            self.maximum_gpuamount = m.get('MaximumGPUAmount')
        if m.get('MaximumMemorySize') is not None:
            self.maximum_memory_size = m.get('MaximumMemorySize')
        if m.get('MinimumBaselineCredit') is not None:
            self.minimum_baseline_credit = m.get('MinimumBaselineCredit')
        if m.get('MinimumCpuCoreCount') is not None:
            self.minimum_cpu_core_count = m.get('MinimumCpuCoreCount')
        if m.get('MinimumCpuSpeedFrequency') is not None:
            self.minimum_cpu_speed_frequency = m.get('MinimumCpuSpeedFrequency')
        if m.get('MinimumCpuTurboFrequency') is not None:
            self.minimum_cpu_turbo_frequency = m.get('MinimumCpuTurboFrequency')
        if m.get('MinimumDiskQuantity') is not None:
            self.minimum_disk_quantity = m.get('MinimumDiskQuantity')
        if m.get('MinimumEniIpv6AddressQuantity') is not None:
            self.minimum_eni_ipv_6address_quantity = m.get('MinimumEniIpv6AddressQuantity')
        if m.get('MinimumEniPrivateIpAddressQuantity') is not None:
            self.minimum_eni_private_ip_address_quantity = m.get('MinimumEniPrivateIpAddressQuantity')
        if m.get('MinimumEniQuantity') is not None:
            self.minimum_eni_quantity = m.get('MinimumEniQuantity')
        if m.get('MinimumEriQuantity') is not None:
            self.minimum_eri_quantity = m.get('MinimumEriQuantity')
        if m.get('MinimumGPUAmount') is not None:
            self.minimum_gpuamount = m.get('MinimumGPUAmount')
        if m.get('MinimumInitialCredit') is not None:
            self.minimum_initial_credit = m.get('MinimumInitialCredit')
        if m.get('MinimumInstanceBandwidthRx') is not None:
            self.minimum_instance_bandwidth_rx = m.get('MinimumInstanceBandwidthRx')
        if m.get('MinimumInstanceBandwidthTx') is not None:
            self.minimum_instance_bandwidth_tx = m.get('MinimumInstanceBandwidthTx')
        if m.get('MinimumInstancePpsRx') is not None:
            self.minimum_instance_pps_rx = m.get('MinimumInstancePpsRx')
        if m.get('MinimumInstancePpsTx') is not None:
            self.minimum_instance_pps_tx = m.get('MinimumInstancePpsTx')
        if m.get('MinimumLocalStorageAmount') is not None:
            self.minimum_local_storage_amount = m.get('MinimumLocalStorageAmount')
        if m.get('MinimumLocalStorageCapacity') is not None:
            self.minimum_local_storage_capacity = m.get('MinimumLocalStorageCapacity')
        if m.get('MinimumMemorySize') is not None:
            self.minimum_memory_size = m.get('MinimumMemorySize')
        if m.get('MinimumPrimaryEniQueueNumber') is not None:
            self.minimum_primary_eni_queue_number = m.get('MinimumPrimaryEniQueueNumber')
        if m.get('MinimumQueuePairNumber') is not None:
            self.minimum_queue_pair_number = m.get('MinimumQueuePairNumber')
        if m.get('MinimumSecondaryEniQueueNumber') is not None:
            self.minimum_secondary_eni_queue_number = m.get('MinimumSecondaryEniQueueNumber')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('NvmeSupport') is not None:
            self.nvme_support = m.get('NvmeSupport')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PhysicalProcessorModel') is not None:
            self.physical_processor_model = m.get('PhysicalProcessorModel')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCardsNetworkCardInfo(TeaModel):
    def __init__(self, network_card_index=None):
        # The index of the NIC.
        self.network_card_index = network_card_index  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCardsNetworkCardInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_card_index is not None:
            result['NetworkCardIndex'] = self.network_card_index
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkCardIndex') is not None:
            self.network_card_index = m.get('NetworkCardIndex')
        return self


class DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCards(TeaModel):
    def __init__(self, network_card_info=None):
        self.network_card_info = network_card_info  # type: list[DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCardsNetworkCardInfo]

    def validate(self):
        if self.network_card_info:
            for k in self.network_card_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCards, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkCardInfo'] = []
        if self.network_card_info is not None:
            for k in self.network_card_info:
                result['NetworkCardInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_card_info = []
        if m.get('NetworkCardInfo') is not None:
            for k in m.get('NetworkCardInfo'):
                temp_model = DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCardsNetworkCardInfo()
                self.network_card_info.append(temp_model.from_map(k))
        return self


class DescribeInstanceTypesResponseBodyInstanceTypesInstanceType(TeaModel):
    def __init__(self, baseline_credit=None, cpu_architecture=None, cpu_core_count=None, cpu_speed_frequency=None,
                 cpu_turbo_frequency=None, disk_quantity=None, eni_ipv_6address_quantity=None, eni_private_ip_address_quantity=None,
                 eni_quantity=None, eni_total_quantity=None, eni_trunk_supported=None, eri_quantity=None, gpuamount=None,
                 gpumemory_size=None, gpuspec=None, initial_credit=None, instance_bandwidth_rx=None, instance_bandwidth_tx=None,
                 instance_category=None, instance_family_level=None, instance_pps_rx=None, instance_pps_tx=None,
                 instance_type_family=None, instance_type_id=None, local_storage_amount=None, local_storage_capacity=None,
                 local_storage_category=None, maximum_queue_number_per_eni=None, memory_size=None, network_card_quantity=None,
                 network_cards=None, network_encryption_support=None, nvme_support=None, physical_processor_model=None,
                 primary_eni_queue_number=None, queue_pair_number=None, secondary_eni_queue_number=None, total_eni_queue_quantity=None):
        # The baseline CPU performance (overall baseline performance of all vCPUs) per t5 or t6 burstable instance.
        self.baseline_credit = baseline_credit  # type: int
        # The CPU architecture. Valid values:
        # 
        # *   X86
        # *   ARM
        self.cpu_architecture = cpu_architecture  # type: str
        # The number of vCPUs.
        self.cpu_core_count = cpu_core_count  # type: int
        # The CPU base frequency. Unit: GHz.
        self.cpu_speed_frequency = cpu_speed_frequency  # type: float
        # The CPU turbo frequency. Unit: GHz.
        self.cpu_turbo_frequency = cpu_turbo_frequency  # type: float
        # The maximum number of cloud disks.
        self.disk_quantity = disk_quantity  # type: int
        # The maximum number of IPv6 addresses per ENI.
        self.eni_ipv_6address_quantity = eni_ipv_6address_quantity  # type: int
        # The maximum number of IPv4 addresses per ENI.
        self.eni_private_ip_address_quantity = eni_private_ip_address_quantity  # type: int
        # The maximum number of ENIs.
        self.eni_quantity = eni_quantity  # type: int
        # The maximum number of NICs, including the primary NIC, ENIs, and trunk NICs.
        # 
        # > This parameter is in invitational preview and is unavailable to general users.
        self.eni_total_quantity = eni_total_quantity  # type: int
        # Indicates whether NICs on instances of the instance type support trunking.
        # 
        # > This parameter is in invitational preview and is unavailable to general users.
        self.eni_trunk_supported = eni_trunk_supported  # type: bool
        # The number of ERIs.
        # 
        # > This parameter is in invitational preview and is unavailable to general users.
        self.eri_quantity = eri_quantity  # type: int
        # The number of GPUs.
        self.gpuamount = gpuamount  # type: int
        # The amount of GPU memory per GPU. Unit: GiB.
        self.gpumemory_size = gpumemory_size  # type: float
        # The GPU model.
        self.gpuspec = gpuspec  # type: str
        # The initial vCPU credits per t5 or t6 burstable instance.
        self.initial_credit = initial_credit  # type: int
        # The maximum inbound internal bandwidth. Unit: Kbit/s.
        self.instance_bandwidth_rx = instance_bandwidth_rx  # type: int
        # The maximum outbound internal bandwidth. Unit: Kbit/s.
        self.instance_bandwidth_tx = instance_bandwidth_tx  # type: int
        # The category of the instance type. Valid values:
        # 
        # *   General-purpose: general-purpose instance type
        # *   Compute-optimized: compute-optimized instance type
        # *   Memory-optimized: memory-optimized instance type
        # *   Big data: big data instance type
        # *   Local SSDs: instance type with local SSDs
        # *   High Clock Speed: instance type with high clock speeds
        # *   Enhanced: enhanced instance type
        # *   Shared: shared instance type
        # *   Compute-optimized with GPU: GPU-accelerated compute-optimized instance type
        # *   Visual Compute-optimized: visual compute-optimized instance type
        # *   Heterogeneous Service: heterogeneous service instance type
        # *   Compute-optimized with FPGA: FPGA-accelerated compute-optimized instance type
        # *   Compute-optimized with NPU: NPU-accelerated compute-optimized instance type
        # *   ECS Bare Metal: ECS Bare Metal Instance type
        # *   Super Computing Cluster: SCC instance type
        self.instance_category = instance_category  # type: str
        # The level of the instance family. Valid values:
        # 
        # *   EntryLevel: entry level (shared).
        # *   EnterpriseLevel: enterprise level.
        # *   CreditEntryLevel: credit-based entry level. For more information, see [Overview](~~59977~~).
        self.instance_family_level = instance_family_level  # type: str
        # The inbound packet forwarding rate over the internal network. Unit: pps.
        self.instance_pps_rx = instance_pps_rx  # type: long
        # The outbound packet forwarding rate over the internal network. Unit: pps.
        self.instance_pps_tx = instance_pps_tx  # type: long
        # The instance family.
        self.instance_type_family = instance_type_family  # type: str
        # The ID of the instance type.
        self.instance_type_id = instance_type_id  # type: str
        # The number of local disks.
        self.local_storage_amount = local_storage_amount  # type: int
        # The capacity of each local disk. Unit: GiB.
        self.local_storage_capacity = local_storage_capacity  # type: long
        # The category of local disks. For more information, see [Local disks](~~63138~~). Valid values:
        # 
        # *   local_hdd_pro: local SATA HDDs, which are used by d1ne or d1 instances
        # *   local_ssd_pro: local NVMe SSDs, which are used by i2, i2g, i1, ga1, or gn5 instances
        self.local_storage_category = local_storage_category  # type: str
        # The maximum number of queues per ENI (including primary ENI and secondary ENI).
        self.maximum_queue_number_per_eni = maximum_queue_number_per_eni  # type: int
        # The memory size. Unit: GiB.
        self.memory_size = memory_size  # type: float
        # The number of NICs.
        self.network_card_quantity = network_card_quantity  # type: int
        # Details about NICs.
        self.network_cards = network_cards  # type: DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCards
        # Indicates whether to allow network traffic transmitted over virtual private clouds (VPCs) to be encrypted. Valid values:
        # 
        # *   true: allows network traffic transmitted over VPCs to be encrypted.
        # *   false: does not allow network traffic transmitted over VPCs to be encrypted.
        self.network_encryption_support = network_encryption_support  # type: bool
        # Indicates whether cloud disks can be attached by using the NVMe protocol. Valid values:
        # 
        # *   required: Cloud disks can be attached by using the NVMe protocol.
        # *   unsupported: Cloud disk cannot be attached by using the NVMe protocol.
        self.nvme_support = nvme_support  # type: str
        # The CPU model.
        self.physical_processor_model = physical_processor_model  # type: str
        # The default number of queues per primary NIC.
        self.primary_eni_queue_number = primary_eni_queue_number  # type: int
        # The maximum number of QP queues per ERI.
        self.queue_pair_number = queue_pair_number  # type: int
        # The default number of queues per secondary ENI.
        self.secondary_eni_queue_number = secondary_eni_queue_number  # type: int
        # The maximum number of queues on ENIs that the instance type supports.
        self.total_eni_queue_quantity = total_eni_queue_quantity  # type: int

    def validate(self):
        if self.network_cards:
            self.network_cards.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypesResponseBodyInstanceTypesInstanceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.baseline_credit is not None:
            result['BaselineCredit'] = self.baseline_credit
        if self.cpu_architecture is not None:
            result['CpuArchitecture'] = self.cpu_architecture
        if self.cpu_core_count is not None:
            result['CpuCoreCount'] = self.cpu_core_count
        if self.cpu_speed_frequency is not None:
            result['CpuSpeedFrequency'] = self.cpu_speed_frequency
        if self.cpu_turbo_frequency is not None:
            result['CpuTurboFrequency'] = self.cpu_turbo_frequency
        if self.disk_quantity is not None:
            result['DiskQuantity'] = self.disk_quantity
        if self.eni_ipv_6address_quantity is not None:
            result['EniIpv6AddressQuantity'] = self.eni_ipv_6address_quantity
        if self.eni_private_ip_address_quantity is not None:
            result['EniPrivateIpAddressQuantity'] = self.eni_private_ip_address_quantity
        if self.eni_quantity is not None:
            result['EniQuantity'] = self.eni_quantity
        if self.eni_total_quantity is not None:
            result['EniTotalQuantity'] = self.eni_total_quantity
        if self.eni_trunk_supported is not None:
            result['EniTrunkSupported'] = self.eni_trunk_supported
        if self.eri_quantity is not None:
            result['EriQuantity'] = self.eri_quantity
        if self.gpuamount is not None:
            result['GPUAmount'] = self.gpuamount
        if self.gpumemory_size is not None:
            result['GPUMemorySize'] = self.gpumemory_size
        if self.gpuspec is not None:
            result['GPUSpec'] = self.gpuspec
        if self.initial_credit is not None:
            result['InitialCredit'] = self.initial_credit
        if self.instance_bandwidth_rx is not None:
            result['InstanceBandwidthRx'] = self.instance_bandwidth_rx
        if self.instance_bandwidth_tx is not None:
            result['InstanceBandwidthTx'] = self.instance_bandwidth_tx
        if self.instance_category is not None:
            result['InstanceCategory'] = self.instance_category
        if self.instance_family_level is not None:
            result['InstanceFamilyLevel'] = self.instance_family_level
        if self.instance_pps_rx is not None:
            result['InstancePpsRx'] = self.instance_pps_rx
        if self.instance_pps_tx is not None:
            result['InstancePpsTx'] = self.instance_pps_tx
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.instance_type_id is not None:
            result['InstanceTypeId'] = self.instance_type_id
        if self.local_storage_amount is not None:
            result['LocalStorageAmount'] = self.local_storage_amount
        if self.local_storage_capacity is not None:
            result['LocalStorageCapacity'] = self.local_storage_capacity
        if self.local_storage_category is not None:
            result['LocalStorageCategory'] = self.local_storage_category
        if self.maximum_queue_number_per_eni is not None:
            result['MaximumQueueNumberPerEni'] = self.maximum_queue_number_per_eni
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        if self.network_card_quantity is not None:
            result['NetworkCardQuantity'] = self.network_card_quantity
        if self.network_cards is not None:
            result['NetworkCards'] = self.network_cards.to_map()
        if self.network_encryption_support is not None:
            result['NetworkEncryptionSupport'] = self.network_encryption_support
        if self.nvme_support is not None:
            result['NvmeSupport'] = self.nvme_support
        if self.physical_processor_model is not None:
            result['PhysicalProcessorModel'] = self.physical_processor_model
        if self.primary_eni_queue_number is not None:
            result['PrimaryEniQueueNumber'] = self.primary_eni_queue_number
        if self.queue_pair_number is not None:
            result['QueuePairNumber'] = self.queue_pair_number
        if self.secondary_eni_queue_number is not None:
            result['SecondaryEniQueueNumber'] = self.secondary_eni_queue_number
        if self.total_eni_queue_quantity is not None:
            result['TotalEniQueueQuantity'] = self.total_eni_queue_quantity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BaselineCredit') is not None:
            self.baseline_credit = m.get('BaselineCredit')
        if m.get('CpuArchitecture') is not None:
            self.cpu_architecture = m.get('CpuArchitecture')
        if m.get('CpuCoreCount') is not None:
            self.cpu_core_count = m.get('CpuCoreCount')
        if m.get('CpuSpeedFrequency') is not None:
            self.cpu_speed_frequency = m.get('CpuSpeedFrequency')
        if m.get('CpuTurboFrequency') is not None:
            self.cpu_turbo_frequency = m.get('CpuTurboFrequency')
        if m.get('DiskQuantity') is not None:
            self.disk_quantity = m.get('DiskQuantity')
        if m.get('EniIpv6AddressQuantity') is not None:
            self.eni_ipv_6address_quantity = m.get('EniIpv6AddressQuantity')
        if m.get('EniPrivateIpAddressQuantity') is not None:
            self.eni_private_ip_address_quantity = m.get('EniPrivateIpAddressQuantity')
        if m.get('EniQuantity') is not None:
            self.eni_quantity = m.get('EniQuantity')
        if m.get('EniTotalQuantity') is not None:
            self.eni_total_quantity = m.get('EniTotalQuantity')
        if m.get('EniTrunkSupported') is not None:
            self.eni_trunk_supported = m.get('EniTrunkSupported')
        if m.get('EriQuantity') is not None:
            self.eri_quantity = m.get('EriQuantity')
        if m.get('GPUAmount') is not None:
            self.gpuamount = m.get('GPUAmount')
        if m.get('GPUMemorySize') is not None:
            self.gpumemory_size = m.get('GPUMemorySize')
        if m.get('GPUSpec') is not None:
            self.gpuspec = m.get('GPUSpec')
        if m.get('InitialCredit') is not None:
            self.initial_credit = m.get('InitialCredit')
        if m.get('InstanceBandwidthRx') is not None:
            self.instance_bandwidth_rx = m.get('InstanceBandwidthRx')
        if m.get('InstanceBandwidthTx') is not None:
            self.instance_bandwidth_tx = m.get('InstanceBandwidthTx')
        if m.get('InstanceCategory') is not None:
            self.instance_category = m.get('InstanceCategory')
        if m.get('InstanceFamilyLevel') is not None:
            self.instance_family_level = m.get('InstanceFamilyLevel')
        if m.get('InstancePpsRx') is not None:
            self.instance_pps_rx = m.get('InstancePpsRx')
        if m.get('InstancePpsTx') is not None:
            self.instance_pps_tx = m.get('InstancePpsTx')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InstanceTypeId') is not None:
            self.instance_type_id = m.get('InstanceTypeId')
        if m.get('LocalStorageAmount') is not None:
            self.local_storage_amount = m.get('LocalStorageAmount')
        if m.get('LocalStorageCapacity') is not None:
            self.local_storage_capacity = m.get('LocalStorageCapacity')
        if m.get('LocalStorageCategory') is not None:
            self.local_storage_category = m.get('LocalStorageCategory')
        if m.get('MaximumQueueNumberPerEni') is not None:
            self.maximum_queue_number_per_eni = m.get('MaximumQueueNumberPerEni')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        if m.get('NetworkCardQuantity') is not None:
            self.network_card_quantity = m.get('NetworkCardQuantity')
        if m.get('NetworkCards') is not None:
            temp_model = DescribeInstanceTypesResponseBodyInstanceTypesInstanceTypeNetworkCards()
            self.network_cards = temp_model.from_map(m['NetworkCards'])
        if m.get('NetworkEncryptionSupport') is not None:
            self.network_encryption_support = m.get('NetworkEncryptionSupport')
        if m.get('NvmeSupport') is not None:
            self.nvme_support = m.get('NvmeSupport')
        if m.get('PhysicalProcessorModel') is not None:
            self.physical_processor_model = m.get('PhysicalProcessorModel')
        if m.get('PrimaryEniQueueNumber') is not None:
            self.primary_eni_queue_number = m.get('PrimaryEniQueueNumber')
        if m.get('QueuePairNumber') is not None:
            self.queue_pair_number = m.get('QueuePairNumber')
        if m.get('SecondaryEniQueueNumber') is not None:
            self.secondary_eni_queue_number = m.get('SecondaryEniQueueNumber')
        if m.get('TotalEniQueueQuantity') is not None:
            self.total_eni_queue_quantity = m.get('TotalEniQueueQuantity')
        return self


class DescribeInstanceTypesResponseBodyInstanceTypes(TeaModel):
    def __init__(self, instance_type=None):
        self.instance_type = instance_type  # type: list[DescribeInstanceTypesResponseBodyInstanceTypesInstanceType]

    def validate(self):
        if self.instance_type:
            for k in self.instance_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypesResponseBodyInstanceTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceType'] = []
        if self.instance_type is not None:
            for k in self.instance_type:
                result['InstanceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_type = []
        if m.get('InstanceType') is not None:
            for k in m.get('InstanceType'):
                temp_model = DescribeInstanceTypesResponseBodyInstanceTypesInstanceType()
                self.instance_type.append(temp_model.from_map(k))
        return self


class DescribeInstanceTypesResponseBody(TeaModel):
    def __init__(self, instance_types=None, next_token=None, request_id=None):
        # Details about the instance types.
        self.instance_types = instance_types  # type: DescribeInstanceTypesResponseBodyInstanceTypes
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_types:
            self.instance_types.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types.to_map()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceTypes') is not None:
            temp_model = DescribeInstanceTypesResponseBodyInstanceTypes()
            self.instance_types = temp_model.from_map(m['InstanceTypes'])
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInstanceTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceVncPasswdRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceVncPasswdRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceVncPasswdResponseBody(TeaModel):
    def __init__(self, request_id=None, vnc_passwd=None):
        self.request_id = request_id  # type: str
        self.vnc_passwd = vnc_passwd  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceVncPasswdResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vnc_passwd is not None:
            result['VncPasswd'] = self.vnc_passwd
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VncPasswd') is not None:
            self.vnc_passwd = m.get('VncPasswd')
        return self


class DescribeInstanceVncPasswdResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceVncPasswdResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceVncPasswdResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceVncPasswdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstanceVncUrlRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceVncUrlRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeInstanceVncUrlResponseBody(TeaModel):
    def __init__(self, request_id=None, vnc_url=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The URL of the VNC management terminal.
        self.vnc_url = vnc_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstanceVncUrlResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.vnc_url is not None:
            result['VncUrl'] = self.vnc_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('VncUrl') is not None:
            self.vnc_url = m.get('VncUrl')
        return self


class DescribeInstanceVncUrlResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstanceVncUrlResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstanceVncUrlResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstanceVncUrlResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstancesRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of filter 1 used to query resources. Set the value to `CreationStartTime`. You can specify a time by setting both `Filter.1.Key` and `Filter.1.Value` to query resources that were created after the time.
        self.key = key  # type: str
        # The value of filter 1 used to query resources. Set the value to a time. If you specify this parameter, you must also specify the `Filter.1.Key` parameter. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInstancesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the instance. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the instance. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInstancesRequest(TeaModel):
    def __init__(self, filter=None, additional_attributes=None, device_available=None, dry_run=None,
                 eip_addresses=None, hpc_cluster_id=None, http_endpoint=None, http_put_response_hop_limit=None, http_tokens=None,
                 image_id=None, inner_ip_addresses=None, instance_charge_type=None, instance_ids=None, instance_name=None,
                 instance_network_type=None, instance_type=None, instance_type_family=None, internet_charge_type=None, io_optimized=None,
                 ipv_6address=None, key_pair_name=None, lock_reason=None, max_results=None, need_sale_cycle=None,
                 next_token=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 private_ip_addresses=None, public_ip_addresses=None, rdma_ip_addresses=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, security_group_id=None, status=None, tag=None, v_switch_id=None,
                 vpc_id=None, zone_id=None):
        self.filter = filter  # type: list[DescribeInstancesRequestFilter]
        # The value of attribute N. Valid values of N: 1 to 20.
        self.additional_attributes = additional_attributes  # type: list[str]
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.device_available = device_available  # type: bool
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether RAM users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned and the request is made.
        self.dry_run = dry_run  # type: bool
        # The elastic IP addresses (EIPs) of instances. This parameter is valid when InstanceNetworkType is set to vpc. The value can be a JSON array that consists of up to 100 IP addresses. Separate the IP addresses with commas (,).
        self.eip_addresses = eip_addresses  # type: str
        # The ID of the High Performance Computing (HPC) cluster to which the instance belongs.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # Specifies whether the access channel is enabled for instance metadata. Valid values:
        # 
        # *   enabled
        # *   disabled
        # 
        # Default value: enabled.
        # 
        # >  For more information about instance metadata, see [Overview of ECS instance metadata](~~49122~~).
        self.http_endpoint = http_endpoint  # type: str
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.http_put_response_hop_limit = http_put_response_hop_limit  # type: int
        # Specifies whether the security hardening mode (IMDSv2) is forcefully used to access instance metadata. Valid values:
        # 
        # *   optional: The security hardening mode (IMDSv2) is not forcefully used.
        # *   required: The security hardening mode (IMDSv2) is forcefully used. After you set this parameter to required, you cannot access instance metadata in normal mode.
        # 
        # Default value: optional.
        # 
        # >  For more information about modes of accessing instance metadata, see [Access mode of instance metadata](~~150575~~).
        self.http_tokens = http_tokens  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The internal IP addresses of instances located in the classic network. This parameter is valid when InstanceNetworkType is set to classic. The value can be a JSON array that consists of up to 100 IP addresses. Separate the IP addresses with commas (,).
        self.inner_ip_addresses = inner_ip_addresses  # type: str
        # The billing method of the instance. Valid values:
        # 
        # *   PostPaid: pay-as-you-go
        # *   PrePaid: subscription
        self.instance_charge_type = instance_charge_type  # type: str
        # The IDs of instances. The value can be a JSON array that consists of up to 100 instance IDs. Separate the IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # The name of the instance. Fuzzy search with the asterisk (\*) wildcard characters is supported.
        self.instance_name = instance_name  # type: str
        # The network type of the instance. Valid values:
        # 
        # *   classic: classic network
        # *   vpc: VPC
        self.instance_network_type = instance_network_type  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The instance family of the instance.
        self.instance_type_family = instance_type_family  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidth values are used as upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instances, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # Specifies whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: bool
        # IPv6 address N of the elastic network interface (ENI). You can specify multiple IPv6 addresses. Valid values of N: 1 to 100.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The name of the SSH key pair bound to the instance.
        self.key_pair_name = key_pair_name  # type: str
        # The reason why the instance is locked. Valid values:
        # 
        # *   financial: The instance is locked due to overdue payments.
        # *   security: The instance is locked due to security reasons.
        # *   recycling: The preemptible instance is locked and pending release.
        # *   dedicatedhostfinancial: The instance is locked due to overdue payments for the dedicated host.
        # *   refunded: The instance is locked because a refund is made for the instance.
        self.lock_reason = lock_reason  # type: str
        # The maximum number of entries to return on each page. Maximum value: 100.
        # 
        # Default value:
        # 
        # *   If this parameter is not specified or is set to a value smaller than 10, the default value is 10.
        # *   If this parameter is set to a value greater than 100, the default value is 100.
        self.max_results = max_results  # type: int
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.need_sale_cycle = need_sale_cycle  # type: bool
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeInstances operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The private IP addresses of instances located in VPCs. This parameter is valid when InstanceNetworkType is set to vpc. The value can be a JSON array that consists of up to 100 IP addresses. Separate the IP addresses with commas (,).
        self.private_ip_addresses = private_ip_addresses  # type: str
        # The public IP addresses of instances. The value can be a JSON array that consists of up to 100 IP addresses. Separate the IP addresses with commas (,).
        self.public_ip_addresses = public_ip_addresses  # type: str
        # The Remote Direct Memory Access (RDMA) IP address of the HPC instance.
        self.rdma_ip_addresses = rdma_ip_addresses  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the instance belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group to which the instance belongs.
        self.security_group_id = security_group_id  # type: str
        # The state of the instance. Valid values:
        # 
        # *   Pending: The instance is being created.
        # *   Running: The instance is running.
        # *   Starting: The instance is being started.
        # *   Stopping: The instance is being stopped.
        # *   Stopped: The instance is stopped.
        self.status = status  # type: str
        # The tags.
        self.tag = tag  # type: list[DescribeInstancesRequestTag]
        # The ID of the vSwitch to which the instance is connected.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the virtual private cloud (VPC) to which the instance belongs.
        self.vpc_id = vpc_id  # type: str
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.additional_attributes is not None:
            result['AdditionalAttributes'] = self.additional_attributes
        if self.device_available is not None:
            result['DeviceAvailable'] = self.device_available
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.eip_addresses is not None:
            result['EipAddresses'] = self.eip_addresses
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.http_endpoint is not None:
            result['HttpEndpoint'] = self.http_endpoint
        if self.http_put_response_hop_limit is not None:
            result['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit
        if self.http_tokens is not None:
            result['HttpTokens'] = self.http_tokens
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.inner_ip_addresses is not None:
            result['InnerIpAddresses'] = self.inner_ip_addresses
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_network_type is not None:
            result['InstanceNetworkType'] = self.instance_network_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.need_sale_cycle is not None:
            result['NeedSaleCycle'] = self.need_sale_cycle
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.private_ip_addresses is not None:
            result['PrivateIpAddresses'] = self.private_ip_addresses
        if self.public_ip_addresses is not None:
            result['PublicIpAddresses'] = self.public_ip_addresses
        if self.rdma_ip_addresses is not None:
            result['RdmaIpAddresses'] = self.rdma_ip_addresses
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeInstancesRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('AdditionalAttributes') is not None:
            self.additional_attributes = m.get('AdditionalAttributes')
        if m.get('DeviceAvailable') is not None:
            self.device_available = m.get('DeviceAvailable')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('EipAddresses') is not None:
            self.eip_addresses = m.get('EipAddresses')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('HttpEndpoint') is not None:
            self.http_endpoint = m.get('HttpEndpoint')
        if m.get('HttpPutResponseHopLimit') is not None:
            self.http_put_response_hop_limit = m.get('HttpPutResponseHopLimit')
        if m.get('HttpTokens') is not None:
            self.http_tokens = m.get('HttpTokens')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InnerIpAddresses') is not None:
            self.inner_ip_addresses = m.get('InnerIpAddresses')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceNetworkType') is not None:
            self.instance_network_type = m.get('InstanceNetworkType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NeedSaleCycle') is not None:
            self.need_sale_cycle = m.get('NeedSaleCycle')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PrivateIpAddresses') is not None:
            self.private_ip_addresses = m.get('PrivateIpAddresses')
        if m.get('PublicIpAddresses') is not None:
            self.public_ip_addresses = m.get('PublicIpAddresses')
        if m.get('RdmaIpAddresses') is not None:
            self.rdma_ip_addresses = m.get('RdmaIpAddresses')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeInstancesResponseBodyInstancesInstanceCpuOptions(TeaModel):
    def __init__(self, core_count=None, numa=None, threads_per_core=None):
        # The number of physical CPU cores.
        self.core_count = core_count  # type: int
        # The number of threads allocated. Valid value: 2.
        self.numa = numa  # type: str
        # The number of threads per CPU core.
        self.threads_per_core = threads_per_core  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceCpuOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.core_count is not None:
            result['CoreCount'] = self.core_count
        if self.numa is not None:
            result['Numa'] = self.numa
        if self.threads_per_core is not None:
            result['ThreadsPerCore'] = self.threads_per_core
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoreCount') is not None:
            self.core_count = m.get('CoreCount')
        if m.get('Numa') is not None:
            self.numa = m.get('Numa')
        if m.get('ThreadsPerCore') is not None:
            self.threads_per_core = m.get('ThreadsPerCore')
        return self


class DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None, dedicated_host_id=None, dedicated_host_name=None):
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The name of the dedicated host.
        self.dedicated_host_name = dedicated_host_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        return self


class DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute(TeaModel):
    def __init__(self, affinity=None, tenancy=None):
        # Indicates whether the instance on the dedicated host is associated with the dedicated host. Valid values: 
        # 
        # - default: The instance is not associated with the dedicated host. When the instance is started from economical mode, the instance may be automatically deployed on another dedicated host in the automatic deployment resource pool.
        # - host: The instance is associated with the dedicated host. When the instance is started from economical mode, the instance is still deployed on the original dedicated host.
        self.affinity = affinity  # type: str
        # Indicates whether the instance is hosted on a dedicated host. Valid values:
        # 
        # - default: The instance is not hosted on a dedicated host.
        # - host: The instance is hosted on a dedicated host.
        self.tenancy = tenancy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affinity is not None:
            result['Affinity'] = self.affinity
        if self.tenancy is not None:
            result['Tenancy'] = self.tenancy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Affinity') is not None:
            self.affinity = m.get('Affinity')
        if m.get('Tenancy') is not None:
            self.tenancy = m.get('Tenancy')
        return self


class DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr(TeaModel):
    def __init__(self, capacity_reservation_id=None, capacity_reservation_preference=None):
        # The ID of the capacity reservation.
        self.capacity_reservation_id = capacity_reservation_id  # type: str
        # The preference of the capacity reservation.
        self.capacity_reservation_preference = capacity_reservation_preference  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity_reservation_id is not None:
            result['CapacityReservationId'] = self.capacity_reservation_id
        if self.capacity_reservation_preference is not None:
            result['CapacityReservationPreference'] = self.capacity_reservation_preference
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CapacityReservationId') is not None:
            self.capacity_reservation_id = m.get('CapacityReservationId')
        if m.get('CapacityReservationPreference') is not None:
            self.capacity_reservation_preference = m.get('CapacityReservationPreference')
        return self


class DescribeInstancesResponseBodyInstancesInstanceEipAddress(TeaModel):
    def __init__(self, allocation_id=None, bandwidth=None, internet_charge_type=None, ip_address=None,
                 is_support_unassociate=None):
        # The ID of the EIP.
        self.allocation_id = allocation_id  # type: str
        # The maximum public bandwidth of the EIP. Unit: Mbit/s.
        self.bandwidth = bandwidth  # type: int
        # The billing method of the EIP. Valid values: 
        # 
        # - PayByBandwidth
        # - PayByTraffic
        self.internet_charge_type = internet_charge_type  # type: str
        # The EIP.
        self.ip_address = ip_address  # type: str
        # Indicates whether the EIP can be disassociated.
        self.is_support_unassociate = is_support_unassociate  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceEipAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        if self.is_support_unassociate is not None:
            result['IsSupportUnassociate'] = self.is_support_unassociate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        if m.get('IsSupportUnassociate') is not None:
            self.is_support_unassociate = m.get('IsSupportUnassociate')
        return self


class DescribeInstancesResponseBodyInstancesInstanceHibernationOptions(TeaModel):
    def __init__(self, configured=None):
        # >  This parameter is in invitational preview and is unavailable for general users.
        self.configured = configured  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceHibernationOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configured is not None:
            result['Configured'] = self.configured
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Configured') is not None:
            self.configured = m.get('Configured')
        return self


class DescribeInstancesResponseBodyInstancesInstanceImageOptions(TeaModel):
    def __init__(self, login_as_non_root=None):
        # Indicates whether the instance that uses the image supports logons of the ecs-user user. Valid values: 
        # 
        # - true: The instance that uses the image supports logons of the ecs-user user.
        # - false: The instance that uses the image does not support logons of the ecs-user user.
        self.login_as_non_root = login_as_non_root  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceImageOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.login_as_non_root is not None:
            result['LoginAsNonRoot'] = self.login_as_non_root
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LoginAsNonRoot') is not None:
            self.login_as_non_root = m.get('LoginAsNonRoot')
        return self


class DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceMetadataOptions(TeaModel):
    def __init__(self, http_endpoint=None, http_put_response_hop_limit=None, http_tokens=None):
        # Indicates whether the access channel is enabled for instance metadata. Valid values:
        # 
        # - enabled
        # - disabled
        self.http_endpoint = http_endpoint  # type: str
        # >  This parameter is unavailable.
        self.http_put_response_hop_limit = http_put_response_hop_limit  # type: int
        # Indicates whether the security hardening mode (IMDSv2) is forcefully used to access instance metadata. Valid values: 
        # 
        # - optional: The security hardening mode (IMDSv2) is not forcefully used.
        # - required: The security hardening mode (IMDSv2) is forcefully used.
        self.http_tokens = http_tokens  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceMetadataOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_endpoint is not None:
            result['HttpEndpoint'] = self.http_endpoint
        if self.http_put_response_hop_limit is not None:
            result['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit
        if self.http_tokens is not None:
            result['HttpTokens'] = self.http_tokens
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpEndpoint') is not None:
            self.http_endpoint = m.get('HttpEndpoint')
        if m.get('HttpPutResponseHopLimit') is not None:
            self.http_put_response_hop_limit = m.get('HttpPutResponseHopLimit')
        if m.get('HttpTokens') is not None:
            self.http_tokens = m.get('HttpTokens')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSetsIpv4PrefixSet(TeaModel):
    def __init__(self, ipv_4prefix=None):
        # The IPv4 prefix.
        self.ipv_4prefix = ipv_4prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSetsIpv4PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSets(TeaModel):
    def __init__(self, ipv_4prefix_set=None):
        self.ipv_4prefix_set = ipv_4prefix_set  # type: list[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSetsIpv4PrefixSet]

    def validate(self):
        if self.ipv_4prefix_set:
            for k in self.ipv_4prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4PrefixSet'] = []
        if self.ipv_4prefix_set is not None:
            for k in self.ipv_4prefix_set:
                result['Ipv4PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_4prefix_set = []
        if m.get('Ipv4PrefixSet') is not None:
            for k in m.get('Ipv4PrefixSet'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSetsIpv4PrefixSet()
                self.ipv_4prefix_set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSetsIpv6PrefixSet(TeaModel):
    def __init__(self, ipv_6prefix=None):
        # The IPv6 prefix.
        self.ipv_6prefix = ipv_6prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSetsIpv6PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSets(TeaModel):
    def __init__(self, ipv_6prefix_set=None):
        self.ipv_6prefix_set = ipv_6prefix_set  # type: list[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSetsIpv6PrefixSet]

    def validate(self):
        if self.ipv_6prefix_set:
            for k in self.ipv_6prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6PrefixSet'] = []
        if self.ipv_6prefix_set is not None:
            for k in self.ipv_6prefix_set:
                result['Ipv6PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6prefix_set = []
        if m.get('Ipv6PrefixSet') is not None:
            for k in m.get('Ipv6PrefixSet'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSetsIpv6PrefixSet()
                self.ipv_6prefix_set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set(TeaModel):
    def __init__(self, ipv_6address=None):
        # The IPv6 address assigned to the ENI.
        self.ipv_6address = ipv_6address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets(TeaModel):
    def __init__(self, ipv_6set=None):
        self.ipv_6set = ipv_6set  # type: list[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set]

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(self, primary=None, private_ip_address=None):
        # Indicates whether the IP address is the primary private IP address.
        self.primary = primary  # type: bool
        # The private IP address of the instance to which the ENI is bound.
        self.private_ip_address = private_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets(TeaModel):
    def __init__(self, private_ip_set=None):
        self.private_ip_set = private_ip_set  # type: list[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet]

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface(TeaModel):
    def __init__(self, ipv_4prefix_sets=None, ipv_6prefix_sets=None, ipv_6sets=None, mac_address=None,
                 network_interface_id=None, primary_ip_address=None, private_ip_sets=None, type=None):
        # The sets of IPv4 prefix.
        self.ipv_4prefix_sets = ipv_4prefix_sets  # type: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSets
        # The sets of IPv6 prefix.
        self.ipv_6prefix_sets = ipv_6prefix_sets  # type: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSets
        # The IPv6 addresses assigned to the ENI. This parameter has a value only when the `AdditionalAttributes.N` request parameter is set to `NETWORK_PRIMARY_ENI_IP`.
        self.ipv_6sets = ipv_6sets  # type: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets
        # The media access control (MAC) address of the ENI.
        self.mac_address = mac_address  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The primary private IP address of the ENI.
        self.primary_ip_address = primary_ip_address  # type: str
        # Details about the private IP address.
        self.private_ip_sets = private_ip_sets  # type: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets
        # The type of the ENI. Valid values:
        # 
        # *   Primary
        # *   Secondary
        self.type = type  # type: str

    def validate(self):
        if self.ipv_4prefix_sets:
            self.ipv_4prefix_sets.validate()
        if self.ipv_6prefix_sets:
            self.ipv_6prefix_sets.validate()
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix_sets is not None:
            result['Ipv4PrefixSets'] = self.ipv_4prefix_sets.to_map()
        if self.ipv_6prefix_sets is not None:
            result['Ipv6PrefixSets'] = self.ipv_6prefix_sets.to_map()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4PrefixSets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv4PrefixSets()
            self.ipv_4prefix_sets = temp_model.from_map(m['Ipv4PrefixSets'])
        if m.get('Ipv6PrefixSets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6PrefixSets()
            self.ipv_6prefix_sets = temp_model.from_map(m['Ipv6PrefixSets'])
        if m.get('Ipv6Sets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfaceIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('PrivateIpSets') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterfacePrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces(TeaModel):
    def __init__(self, network_interface=None):
        self.network_interface = network_interface  # type: list[DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface]

    def validate(self):
        if self.network_interface:
            for k in self.network_interface:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterface'] = []
        if self.network_interface is not None:
            for k in self.network_interface:
                result['NetworkInterface'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_interface = []
        if m.get('NetworkInterface') is not None:
            for k in m.get('NetworkInterface'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfacesNetworkInterface()
                self.network_interface.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason(TeaModel):
    def __init__(self, lock_msg=None, lock_reason=None):
        # The message returned when the instance was locked.
        self.lock_msg = lock_msg  # type: str
        # The reason why the instance was locked. Valid values:
        # 
        # - financial: The instance was locked due to overdue payments.
        # - security: The instance was locked due to security reasons.
        # - recycling: The preemptible instance was locked and pending release.
        # - dedicatedhostfinancial: The instance was locked due to overdue payments for the dedicated host.
        # - refunded: The instance was locked because a refund was made for the instance.
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_msg is not None:
            result['LockMsg'] = self.lock_msg
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockMsg') is not None:
            self.lock_msg = m.get('LockMsg')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeInstancesResponseBodyInstancesInstanceOperationLocks(TeaModel):
    def __init__(self, lock_reason=None):
        self.lock_reason = lock_reason  # type: list[DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason]

    def validate(self):
        if self.lock_reason:
            for k in self.lock_reason:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LockReason'] = []
        if self.lock_reason is not None:
            for k in self.lock_reason:
                result['LockReason'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.lock_reason = []
        if m.get('LockReason') is not None:
            for k in m.get('LockReason'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceOperationLocksLockReason()
                self.lock_reason.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstancePublicIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstancePublicIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeInstancesResponseBodyInstancesInstanceTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the instance.
        self.tag_key = tag_key  # type: str
        # The tag value of the instance.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeInstancesResponseBodyInstancesInstanceTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeInstancesResponseBodyInstancesInstanceTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInstancesResponseBodyInstancesInstanceTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress(TeaModel):
    def __init__(self, ip_address=None):
        self.ip_address = ip_address  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ip_address is not None:
            result['IpAddress'] = self.ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IpAddress') is not None:
            self.ip_address = m.get('IpAddress')
        return self


class DescribeInstancesResponseBodyInstancesInstanceVpcAttributes(TeaModel):
    def __init__(self, nat_ip_address=None, private_ip_address=None, v_switch_id=None, vpc_id=None):
        # The NAT IP address of the instance. It is used by ECS instances in different VPCs for communication.
        self.nat_ip_address = nat_ip_address  # type: str
        # The private IP addresses of the instance.
        self.private_ip_address = private_ip_address  # type: DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress
        # The ID of the vSwitch.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the VPC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.private_ip_address:
            self.private_ip_address.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstanceVpcAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_ip_address is not None:
            result['NatIpAddress'] = self.nat_ip_address
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NatIpAddress') is not None:
            self.nat_ip_address = m.get('NatIpAddress')
        if m.get('PrivateIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceVpcAttributesPrivateIpAddress()
            self.private_ip_address = temp_model.from_map(m['PrivateIpAddress'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeInstancesResponseBodyInstancesInstance(TeaModel):
    def __init__(self, auto_release_time=None, cluster_id=None, cpu=None, cpu_options=None, creation_time=None,
                 credit_specification=None, dedicated_host_attribute=None, dedicated_instance_attribute=None, deletion_protection=None,
                 deployment_set_group_no=None, deployment_set_id=None, description=None, device_available=None,
                 ecs_capacity_reservation_attr=None, eip_address=None, expired_time=None, gpuamount=None, gpuspec=None, hibernation_options=None,
                 host_name=None, hpc_cluster_id=None, isp=None, image_id=None, image_options=None, inner_ip_address=None,
                 instance_charge_type=None, instance_id=None, instance_name=None, instance_network_type=None, instance_type=None,
                 instance_type_family=None, internet_charge_type=None, internet_max_bandwidth_in=None, internet_max_bandwidth_out=None,
                 io_optimized=None, key_pair_name=None, local_storage_amount=None, local_storage_capacity=None, memory=None,
                 metadata_options=None, network_interfaces=None, osname=None, osname_en=None, ostype=None, operation_locks=None,
                 public_ip_address=None, rdma_ip_address=None, recyclable=None, region_id=None, resource_group_id=None,
                 sale_cycle=None, security_group_ids=None, serial_number=None, spot_duration=None, spot_price_limit=None,
                 spot_strategy=None, start_time=None, status=None, stopped_mode=None, tags=None, vlan_id=None, vpc_attributes=None,
                 zone_id=None):
        # The time when to automatically release the pay-as-you-go instance.
        self.auto_release_time = auto_release_time  # type: str
        # The ID of the cluster to which the instance belongs.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.cluster_id = cluster_id  # type: str
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # Details about the CPU options.
        self.cpu_options = cpu_options  # type: DescribeInstancesResponseBodyInstancesInstanceCpuOptions
        # The time when the instance was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. For more information, see [ISO 8601](~~25696~~).
        self.creation_time = creation_time  # type: str
        # The performance mode of the burstable instance. Valid values:
        # 
        # *   Standard: standard mode. For more information, see the "Standard mode" section in [Overview](~~59977~~).
        # *   Unlimited: unlimited mode. For more information, see the "Unlimited mode" section in [Overview](~~59977~~).
        self.credit_specification = credit_specification  # type: str
        # Details about the dedicated host. It is an array that consists of the DedicatedHostClusterId, DedicatedHostId, and DedicatedHostName parameters.
        self.dedicated_host_attribute = dedicated_host_attribute  # type: DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute
        # The attributes of the instance on the dedicated host.
        self.dedicated_instance_attribute = dedicated_instance_attribute  # type: DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute
        # The release protection attribute of the instance. This parameter indicates whether you can use the ECS console or call the DeleteInstance operation to release the instance.
        # 
        # *   true: Release protection is enabled for the instance.
        # *   false: Release protection is disabled for the instance.
        # 
        # >  This parameter is applicable only to pay-as-you-go instances. It can protect instances against manual releases, but not against automatic releases.
        self.deletion_protection = deletion_protection  # type: bool
        # The number of the deployment set group to which the instance belongs in a deployment set.
        self.deployment_set_group_no = deployment_set_group_no  # type: int
        # The ID of the deployment set in which the instance is deployed.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance.
        self.description = description  # type: str
        # Indicates whether data disks can be attached to the instance.
        self.device_available = device_available  # type: bool
        # Details about the capacity reservation related to the instance.
        self.ecs_capacity_reservation_attr = ecs_capacity_reservation_attr  # type: DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr
        # Details about the EIP associated with the instance.
        self.eip_address = eip_address  # type: DescribeInstancesResponseBodyInstancesInstanceEipAddress
        # The time when the instance expires. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. For more information, see [ISO 8601](~~25696~~).
        self.expired_time = expired_time  # type: str
        # The number of GPUs for the instance type.
        self.gpuamount = gpuamount  # type: int
        # The category of GPUs for the instance type.
        self.gpuspec = gpuspec  # type: str
        # >  This parameter is in invitational preview and is unavailable for general users.
        self.hibernation_options = hibernation_options  # type: DescribeInstancesResponseBodyInstancesInstanceHibernationOptions
        # The hostname of the instance.
        self.host_name = host_name  # type: str
        # The ID of the HPC cluster to which the instance belongs.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # >  This parameter is in invitational preview and is unavailable for general users.
        self.isp = isp  # type: str
        # The ID of the image that the instance is running.
        self.image_id = image_id  # type: str
        # Details about the image options.
        self.image_options = image_options  # type: DescribeInstancesResponseBodyInstancesInstanceImageOptions
        # The internal IP addresses of the instance located in the classic network.
        self.inner_ip_address = inner_ip_address  # type: DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The network type of the instance. Valid values:
        # 
        # *   classic
        # *   vpc
        self.instance_network_type = instance_network_type  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # The instance family of the instance.
        self.instance_type_family = instance_type_family  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Indicates whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: bool
        # The name of the key pair bound to the instance.
        self.key_pair_name = key_pair_name  # type: str
        # The number of local disks attached to the instance.
        self.local_storage_amount = local_storage_amount  # type: int
        # The capacity of local disks attached to the instance.
        self.local_storage_capacity = local_storage_capacity  # type: long
        # The memory size of the instance. Unit: MiB.
        self.memory = memory  # type: int
        # Details about the metadata options.
        self.metadata_options = metadata_options  # type: DescribeInstancesResponseBodyInstancesInstanceMetadataOptions
        # Details about the ENIs bound to the instance.
        self.network_interfaces = network_interfaces  # type: DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces
        # The name of the operating system of the instance.
        self.osname = osname  # type: str
        # The English name of the operating system of the instance.
        self.osname_en = osname_en  # type: str
        # The type of the operating system of the instance. Valid values:
        # 
        # *   windows
        # *   linux
        self.ostype = ostype  # type: str
        # The reasons why the instance was locked.
        self.operation_locks = operation_locks  # type: DescribeInstancesResponseBodyInstancesInstanceOperationLocks
        # The public IP addresses of the instance.
        self.public_ip_address = public_ip_address  # type: DescribeInstancesResponseBodyInstancesInstancePublicIpAddress
        # The RDMA IP addresses of the HPC instance.
        self.rdma_ip_address = rdma_ip_address  # type: DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress
        # Indicates whether the instance can be recycled.
        self.recyclable = recyclable  # type: bool
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the instance belongs.
        self.resource_group_id = resource_group_id  # type: str
        # >  The parameter is discontinued.
        self.sale_cycle = sale_cycle  # type: str
        # The IDs of the security groups to which the instance belongs.
        self.security_group_ids = security_group_ids  # type: DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds
        # The serial number of the instance.
        self.serial_number = serial_number  # type: str
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   A value of 0 indicates that the preemptible instance has no protection period.
        # 
        # >  This parameter is returned when the SpotStrategy parameter is set to SpotWithPriceLimit or SpotAsPriceGo.
        self.spot_duration = spot_duration  # type: int
        # The maximum hourly price of the instance. It can be accurate to three decimal places. This parameter is valid only when the SpotStrategy parameter is set to SpotWithPriceLimit.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price is automatically used as the bid price. The market price can be up to the pay-as-you-go price.
        self.spot_strategy = spot_strategy  # type: str
        # The time when the instance was last started. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC. For more information, see [ISO 8601](~~25696~~).
        self.start_time = start_time  # type: str
        # The state of the instance.
        self.status = status  # type: str
        # Indicates whether the instance continues to be billed after it is stopped. Valid values:
        # 
        # *   KeepCharging: The instance is stopped in standard mode. The billing of the instance continues after the instance is stopped, and resources are retained for the instance.
        # *   StopCharging: The instance is stopped in economical mode. The billing of some resources of the instance stops after the instance is stopped. When the instance is stopped, its resources such as vCPUs, memory, and public IP address are released. The instance may be unable to start again if some required resources are out of stock in the current region.
        # *   Not-applicable: The instance does not support economical mode.
        self.stopped_mode = stopped_mode  # type: str
        # The tags of the instance.
        self.tags = tags  # type: DescribeInstancesResponseBodyInstancesInstanceTags
        # The virtual LAN (VLAN) ID of the instance.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.vlan_id = vlan_id  # type: str
        # The VPC attributes of the instance.
        self.vpc_attributes = vpc_attributes  # type: DescribeInstancesResponseBodyInstancesInstanceVpcAttributes
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.cpu_options:
            self.cpu_options.validate()
        if self.dedicated_host_attribute:
            self.dedicated_host_attribute.validate()
        if self.dedicated_instance_attribute:
            self.dedicated_instance_attribute.validate()
        if self.ecs_capacity_reservation_attr:
            self.ecs_capacity_reservation_attr.validate()
        if self.eip_address:
            self.eip_address.validate()
        if self.hibernation_options:
            self.hibernation_options.validate()
        if self.image_options:
            self.image_options.validate()
        if self.inner_ip_address:
            self.inner_ip_address.validate()
        if self.metadata_options:
            self.metadata_options.validate()
        if self.network_interfaces:
            self.network_interfaces.validate()
        if self.operation_locks:
            self.operation_locks.validate()
        if self.public_ip_address:
            self.public_ip_address.validate()
        if self.rdma_ip_address:
            self.rdma_ip_address.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.tags:
            self.tags.validate()
        if self.vpc_attributes:
            self.vpc_attributes.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstancesInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.cluster_id is not None:
            result['ClusterId'] = self.cluster_id
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.cpu_options is not None:
            result['CpuOptions'] = self.cpu_options.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        if self.dedicated_host_attribute is not None:
            result['DedicatedHostAttribute'] = self.dedicated_host_attribute.to_map()
        if self.dedicated_instance_attribute is not None:
            result['DedicatedInstanceAttribute'] = self.dedicated_instance_attribute.to_map()
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deployment_set_group_no is not None:
            result['DeploymentSetGroupNo'] = self.deployment_set_group_no
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.device_available is not None:
            result['DeviceAvailable'] = self.device_available
        if self.ecs_capacity_reservation_attr is not None:
            result['EcsCapacityReservationAttr'] = self.ecs_capacity_reservation_attr.to_map()
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address.to_map()
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.gpuamount is not None:
            result['GPUAmount'] = self.gpuamount
        if self.gpuspec is not None:
            result['GPUSpec'] = self.gpuspec
        if self.hibernation_options is not None:
            result['HibernationOptions'] = self.hibernation_options.to_map()
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_options is not None:
            result['ImageOptions'] = self.image_options.to_map()
        if self.inner_ip_address is not None:
            result['InnerIpAddress'] = self.inner_ip_address.to_map()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_network_type is not None:
            result['InstanceNetworkType'] = self.instance_network_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.local_storage_amount is not None:
            result['LocalStorageAmount'] = self.local_storage_amount
        if self.local_storage_capacity is not None:
            result['LocalStorageCapacity'] = self.local_storage_capacity
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.metadata_options is not None:
            result['MetadataOptions'] = self.metadata_options.to_map()
        if self.network_interfaces is not None:
            result['NetworkInterfaces'] = self.network_interfaces.to_map()
        if self.osname is not None:
            result['OSName'] = self.osname
        if self.osname_en is not None:
            result['OSNameEn'] = self.osname_en
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address.to_map()
        if self.rdma_ip_address is not None:
            result['RdmaIpAddress'] = self.rdma_ip_address.to_map()
        if self.recyclable is not None:
            result['Recyclable'] = self.recyclable
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.sale_cycle is not None:
            result['SaleCycle'] = self.sale_cycle
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.stopped_mode is not None:
            result['StoppedMode'] = self.stopped_mode
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        if self.vpc_attributes is not None:
            result['VpcAttributes'] = self.vpc_attributes.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('ClusterId') is not None:
            self.cluster_id = m.get('ClusterId')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CpuOptions') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceCpuOptions()
            self.cpu_options = temp_model.from_map(m['CpuOptions'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        if m.get('DedicatedHostAttribute') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceDedicatedHostAttribute()
            self.dedicated_host_attribute = temp_model.from_map(m['DedicatedHostAttribute'])
        if m.get('DedicatedInstanceAttribute') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceDedicatedInstanceAttribute()
            self.dedicated_instance_attribute = temp_model.from_map(m['DedicatedInstanceAttribute'])
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeploymentSetGroupNo') is not None:
            self.deployment_set_group_no = m.get('DeploymentSetGroupNo')
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceAvailable') is not None:
            self.device_available = m.get('DeviceAvailable')
        if m.get('EcsCapacityReservationAttr') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceEcsCapacityReservationAttr()
            self.ecs_capacity_reservation_attr = temp_model.from_map(m['EcsCapacityReservationAttr'])
        if m.get('EipAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceEipAddress()
            self.eip_address = temp_model.from_map(m['EipAddress'])
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('GPUAmount') is not None:
            self.gpuamount = m.get('GPUAmount')
        if m.get('GPUSpec') is not None:
            self.gpuspec = m.get('GPUSpec')
        if m.get('HibernationOptions') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceHibernationOptions()
            self.hibernation_options = temp_model.from_map(m['HibernationOptions'])
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageOptions') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceImageOptions()
            self.image_options = temp_model.from_map(m['ImageOptions'])
        if m.get('InnerIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceInnerIpAddress()
            self.inner_ip_address = temp_model.from_map(m['InnerIpAddress'])
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceNetworkType') is not None:
            self.instance_network_type = m.get('InstanceNetworkType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('LocalStorageAmount') is not None:
            self.local_storage_amount = m.get('LocalStorageAmount')
        if m.get('LocalStorageCapacity') is not None:
            self.local_storage_capacity = m.get('LocalStorageCapacity')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MetadataOptions') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceMetadataOptions()
            self.metadata_options = temp_model.from_map(m['MetadataOptions'])
        if m.get('NetworkInterfaces') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceNetworkInterfaces()
            self.network_interfaces = temp_model.from_map(m['NetworkInterfaces'])
        if m.get('OSName') is not None:
            self.osname = m.get('OSName')
        if m.get('OSNameEn') is not None:
            self.osname_en = m.get('OSNameEn')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OperationLocks') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('PublicIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstancePublicIpAddress()
            self.public_ip_address = temp_model.from_map(m['PublicIpAddress'])
        if m.get('RdmaIpAddress') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceRdmaIpAddress()
            self.rdma_ip_address = temp_model.from_map(m['RdmaIpAddress'])
        if m.get('Recyclable') is not None:
            self.recyclable = m.get('Recyclable')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SaleCycle') is not None:
            self.sale_cycle = m.get('SaleCycle')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StoppedMode') is not None:
            self.stopped_mode = m.get('StoppedMode')
        if m.get('Tags') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        if m.get('VpcAttributes') is not None:
            temp_model = DescribeInstancesResponseBodyInstancesInstanceVpcAttributes()
            self.vpc_attributes = temp_model.from_map(m['VpcAttributes'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeInstancesResponseBodyInstances(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[DescribeInstancesResponseBodyInstancesInstance]

    def validate(self):
        if self.instance:
            for k in self.instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instance'] = []
        if self.instance is not None:
            for k in self.instance:
                result['Instance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance = []
        if m.get('Instance') is not None:
            for k in m.get('Instance'):
                temp_model = DescribeInstancesResponseBodyInstancesInstance()
                self.instance.append(temp_model.from_map(k))
        return self


class DescribeInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, next_token=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the instances.
        self.instances = instances  # type: DescribeInstancesResponseBodyInstances
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of instances returned.
        # 
        # >  If you specify the `MaxResults` and `NextToken` parameters to perform a paged query, the value of the `TotalCount` response parameter is invalid.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instances:
            self.instances.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instances') is not None:
            temp_model = DescribeInstancesResponseBodyInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInstancesFullStatusRequestEventPublishTime(TeaModel):
    def __init__(self, end=None, start=None):
        # The end of the period during which system events are published. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end = end  # type: str
        # The beginning of the period during which system events are published. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusRequestEventPublishTime, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeInstancesFullStatusRequestNotBefore(TeaModel):
    def __init__(self, end=None, start=None):
        # The end of the period during which O\&M tasks related to scheduled system events are executed. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end = end  # type: str
        # The beginning of the period during which O\&M tasks related to scheduled system events are executed. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start = start  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusRequestNotBefore, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeInstancesFullStatusRequest(TeaModel):
    def __init__(self, event_publish_time=None, not_before=None, event_id=None, event_type=None, health_status=None,
                 instance_event_type=None, instance_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, status=None):
        self.event_publish_time = event_publish_time  # type: DescribeInstancesFullStatusRequestEventPublishTime
        self.not_before = not_before  # type: DescribeInstancesFullStatusRequestNotBefore
        # The IDs of the event. You can specify up to 100 event IDs in a single request.
        self.event_id = event_id  # type: list[str]
        # The type of the system event. This parameter is valid only when the InstanceEventType.N parameter is not specified. Valid values:
        # 
        # *   SystemMaintenance.Reboot: The instance is restarted due to system maintenance.
        # *   SystemFailure.Reboot: The instance is restarted due to a system failure.
        # *   InstanceFailure.Reboot: The instance is restarted due to an instance failure.
        # *   InstanceExpiration.Stop: The subscription instance is stopped due to expiration.
        # *   InstanceExpiration.Delete: The subscription instance is released due to expiration.
        # *   AccountUnbalanced.Stop: The pay-as-you-go instance is stopped due to an overdue payment.
        # *   AccountUnbalanced.Delete: The pay-as-you-go instance is released due to an overdue payment.
        self.event_type = event_type  # type: str
        # The health state of the instance. Valid values:
        # 
        # *   Impaired: The instance is impaired.
        # *   Warning: The performance of the instance is degraded.
        # *   Maintaining: The instance is being maintained.
        # *   Initializing: The instance is being initialized.
        # *   InsufficientData: The state cannot be determined due to insufficient data.
        # *   NotApplicable: The state is not applicable.
        # 
        # All these values are case-sensitive.
        self.health_status = health_status  # type: str
        # The types of system events. You can specify up to 30 event types in a single request.
        self.instance_event_type = instance_event_type  # type: list[str]
        # The IDs of the instances. You can specify up to 100 instance IDs in a single request.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. The value must be a positive integer.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The lifecycle state of the instance. Valid values:
        # 
        # *   Starting: The instance is being started.
        # *   Running: The instance is running.
        # *   Stopped: The instance is stopped.
        self.status = status  # type: str

    def validate(self):
        if self.event_publish_time:
            self.event_publish_time.validate()
        if self.not_before:
            self.not_before.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_publish_time is not None:
            result['EventPublishTime'] = self.event_publish_time.to_map()
        if self.not_before is not None:
            result['NotBefore'] = self.not_before.to_map()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status
        if self.instance_event_type is not None:
            result['InstanceEventType'] = self.instance_event_type
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventPublishTime') is not None:
            temp_model = DescribeInstancesFullStatusRequestEventPublishTime()
            self.event_publish_time = temp_model.from_map(m['EventPublishTime'])
        if m.get('NotBefore') is not None:
            temp_model = DescribeInstancesFullStatusRequestNotBefore()
            self.not_before = temp_model.from_map(m['NotBefore'])
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('HealthStatus') is not None:
            self.health_status = m.get('HealthStatus')
        if m.get('InstanceEventType') is not None:
            self.instance_event_type = m.get('InstanceEventType')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the health state.
        self.code = code  # type: int
        # The name of the health state.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the event state.
        self.code = code  # type: int
        # The name of the event state.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the event type.
        self.code = code  # type: int
        # The name of the event type.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk(TeaModel):
    def __init__(self, creation_time=None, device_category=None, device_size=None, device_type=None,
                 release_time=None):
        # The time when the disk was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The category of the disk. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: enhanced SSD (ESSD)
        # *   local_ssd_pro: I/O-intensive local disk
        # *   local_hdd_pro: throughput-intensive local disk
        # *   ephemeral: retired local disk
        # *   ephemeral_ssd: retired local SSD
        self.device_category = device_category  # type: str
        # The size of the disk. Unit: GiB.
        self.device_size = device_size  # type: str
        # The type of the disk. Valid values:
        # 
        # *   system: system disk
        # *   data: data disk
        self.device_type = device_type  # type: str
        # The time when the disk was released. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.release_time = release_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.device_category is not None:
            result['DeviceCategory'] = self.device_category
        if self.device_size is not None:
            result['DeviceSize'] = self.device_size
        if self.device_type is not None:
            result['DeviceType'] = self.device_type
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeviceCategory') is not None:
            self.device_category = m.get('DeviceCategory')
        if m.get('DeviceSize') is not None:
            self.device_size = m.get('DeviceSize')
        if m.get('DeviceType') is not None:
            self.device_type = m.get('DeviceType')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks(TeaModel):
    def __init__(self, inactive_disk=None):
        self.inactive_disk = inactive_disk  # type: list[DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk]

    def validate(self):
        if self.inactive_disk:
            for k in self.inactive_disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InactiveDisk'] = []
        if self.inactive_disk is not None:
            for k in self.inactive_disk:
                result['InactiveDisk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.inactive_disk = []
        if m.get('InactiveDisk') is not None:
            for k in m.get('InactiveDisk'):
                temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisksInactiveDisk()
                self.inactive_disk.append(temp_model.from_map(k))
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute(TeaModel):
    def __init__(self, device=None, disk_id=None, inactive_disks=None):
        # The device name of the local disk.
        self.device = device  # type: str
        # The ID of the local disk.
        self.disk_id = disk_id  # type: str
        # Details about the inactive cloud disks or local disks that have been released and must be cleared.
        self.inactive_disks = inactive_disks  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks

    def validate(self):
        if self.inactive_disks:
            self.inactive_disks.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.inactive_disks is not None:
            result['InactiveDisks'] = self.inactive_disks.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InactiveDisks') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttributeInactiveDisks()
            self.inactive_disks = temp_model.from_map(m['InactiveDisks'])
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType(TeaModel):
    def __init__(self, event_cycle_status=None, event_id=None, event_publish_time=None, event_type=None,
                 extended_attribute=None, impact_level=None, not_before=None, reason=None):
        # The state of the event. Valid values:
        self.event_cycle_status = event_cycle_status  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus
        # The ID of the event.
        self.event_id = event_id  # type: str
        # The time when the event was published. The time is displayed in UTC.
        self.event_publish_time = event_publish_time  # type: str
        # The type of the event.
        self.event_type = event_type  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType
        # The extended attributes of system events generated for instances that have local disks attached.
        self.extended_attribute = extended_attribute  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute
        # The impact level of the event.
        self.impact_level = impact_level  # type: str
        # The scheduled time when to execute the O\&M task related to the event. The time is displayed in UTC.
        self.not_before = not_before  # type: str
        # The reason why the event was scheduled.
        self.reason = reason  # type: str

    def validate(self):
        if self.event_cycle_status:
            self.event_cycle_status.validate()
        if self.event_type:
            self.event_type.validate()
        if self.extended_attribute:
            self.extended_attribute.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_cycle_status is not None:
            result['EventCycleStatus'] = self.event_cycle_status.to_map()
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_publish_time is not None:
            result['EventPublishTime'] = self.event_publish_time
        if self.event_type is not None:
            result['EventType'] = self.event_type.to_map()
        if self.extended_attribute is not None:
            result['ExtendedAttribute'] = self.extended_attribute.to_map()
        if self.impact_level is not None:
            result['ImpactLevel'] = self.impact_level
        if self.not_before is not None:
            result['NotBefore'] = self.not_before
        if self.reason is not None:
            result['Reason'] = self.reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventCycleStatus') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventCycleStatus()
            self.event_cycle_status = temp_model.from_map(m['EventCycleStatus'])
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventPublishTime') is not None:
            self.event_publish_time = m.get('EventPublishTime')
        if m.get('EventType') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeEventType()
            self.event_type = temp_model.from_map(m['EventType'])
        if m.get('ExtendedAttribute') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventTypeExtendedAttribute()
            self.extended_attribute = temp_model.from_map(m['ExtendedAttribute'])
        if m.get('ImpactLevel') is not None:
            self.impact_level = m.get('ImpactLevel')
        if m.get('NotBefore') is not None:
            self.not_before = m.get('NotBefore')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet(TeaModel):
    def __init__(self, scheduled_system_event_type=None):
        self.scheduled_system_event_type = scheduled_system_event_type  # type: list[DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType]

    def validate(self):
        if self.scheduled_system_event_type:
            for k in self.scheduled_system_event_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ScheduledSystemEventType'] = []
        if self.scheduled_system_event_type is not None:
            for k in self.scheduled_system_event_type:
                result['ScheduledSystemEventType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.scheduled_system_event_type = []
        if m.get('ScheduledSystemEventType') is not None:
            for k in m.get('ScheduledSystemEventType'):
                temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSetScheduledSystemEventType()
                self.scheduled_system_event_type.append(temp_model.from_map(k))
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus(TeaModel):
    def __init__(self, code=None, name=None):
        # The code of the instance lifecycle state.
        self.code = code  # type: int
        # The name of the instance lifecycle state.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType(TeaModel):
    def __init__(self, health_status=None, instance_id=None, scheduled_system_event_set=None, status=None):
        # The health state of the instance.
        self.health_status = health_status  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # Details about the scheduled system events.
        self.scheduled_system_event_set = scheduled_system_event_set  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet
        # The lifecycle state of the instance.
        self.status = status  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus

    def validate(self):
        if self.health_status:
            self.health_status.validate()
        if self.scheduled_system_event_set:
            self.scheduled_system_event_set.validate()
        if self.status:
            self.status.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.health_status is not None:
            result['HealthStatus'] = self.health_status.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.scheduled_system_event_set is not None:
            result['ScheduledSystemEventSet'] = self.scheduled_system_event_set.to_map()
        if self.status is not None:
            result['Status'] = self.status.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HealthStatus') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeHealthStatus()
            self.health_status = temp_model.from_map(m['HealthStatus'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ScheduledSystemEventSet') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeScheduledSystemEventSet()
            self.scheduled_system_event_set = temp_model.from_map(m['ScheduledSystemEventSet'])
        if m.get('Status') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusTypeStatus()
            self.status = temp_model.from_map(m['Status'])
        return self


class DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet(TeaModel):
    def __init__(self, instance_full_status_type=None):
        self.instance_full_status_type = instance_full_status_type  # type: list[DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType]

    def validate(self):
        if self.instance_full_status_type:
            for k in self.instance_full_status_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceFullStatusType'] = []
        if self.instance_full_status_type is not None:
            for k in self.instance_full_status_type:
                result['InstanceFullStatusType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_full_status_type = []
        if m.get('InstanceFullStatusType') is not None:
            for k in m.get('InstanceFullStatusType'):
                temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSetInstanceFullStatusType()
                self.instance_full_status_type.append(temp_model.from_map(k))
        return self


class DescribeInstancesFullStatusResponseBody(TeaModel):
    def __init__(self, instance_full_status_set=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the full status information of instances.
        self.instance_full_status_set = instance_full_status_set  # type: DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.instance_full_status_set:
            self.instance_full_status_set.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_full_status_set is not None:
            result['InstanceFullStatusSet'] = self.instance_full_status_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceFullStatusSet') is not None:
            temp_model = DescribeInstancesFullStatusResponseBodyInstanceFullStatusSet()
            self.instance_full_status_set = temp_model.from_map(m['InstanceFullStatusSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInstancesFullStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInstancesFullStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInstancesFullStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInstancesFullStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInvocationResultsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the command. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the command. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationResultsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInvocationResultsRequest(TeaModel):
    def __init__(self, command_id=None, content_encoding=None, include_history=None, instance_id=None,
                 invoke_id=None, invoke_record_status=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None):
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The encoding method of the `Output` response parameter. Valid values:
        # 
        # *   PlainText: returns the original command content and command output.
        # *   Base64: returns the Base64-encoded command content and command output.
        # 
        # Default value: Base64.
        self.content_encoding = content_encoding  # type: str
        # Specifies whether to return the results of historical scheduled executions. Valid values:
        # 
        # *   true: returns the results of historical scheduled executions. When this parameter is set to true, the `InvokeId` parameter must be set to the ID of a scheduled task.
        # *   false: does not return the results of historical scheduled executions.
        # 
        # Default value: false.
        self.include_history = include_history  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the command task. You can call the [DescribeInvocations](~~64840~~) operation to query the command task IDs.
        self.invoke_id = invoke_id  # type: str
        # The state of the execution. Valid values:
        # 
        # *   Running
        # *   Finished
        # *   Failed
        # *   Stopped
        # 
        # >  To improve compatibility, we recommend that you use the `InvocationStatus` parameter instead of the InvokeRecordStatus parameter.
        self.invoke_record_status = invoke_record_status  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[DescribeInvocationResultsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.include_history is not None:
            result['IncludeHistory'] = self.include_history
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_record_status is not None:
            result['InvokeRecordStatus'] = self.invoke_record_status
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('IncludeHistory') is not None:
            self.include_history = m.get('IncludeHistory')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeRecordStatus') is not None:
            self.invoke_record_status = m.get('InvokeRecordStatus')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInvocationResultsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the command.
        self.tag_key = tag_key  # type: str
        # The tag value of the command.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult(TeaModel):
    def __init__(self, command_id=None, container_id=None, container_name=None, dropped=None, error_code=None,
                 error_info=None, exit_code=None, finished_time=None, instance_id=None, invocation_status=None, invoke_id=None,
                 invoke_record_status=None, output=None, repeats=None, start_time=None, stop_time=None, tags=None, username=None):
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The name of the container.
        self.container_name = container_name  # type: str
        # The size of truncated and discarded text when the size of text in the `Output` response parameter is larger than 24 KB.
        self.dropped = dropped  # type: int
        # The error code returned when the command cannot be sent or run. Valid values:
        # 
        # *   If this parameter is empty, the command is run normally.
        # *   InstanceNotExists: The instance does not exist or has been released.
        # *   InstanceReleased: The instance is released while the command is being run.
        # *   InstanceNotRunning: The instance is not running while the command is being run.
        # *   CommandNotApplicable: The command is not applicable to the specified instance.
        # *   AccountNotExists: The specified account does not exist.
        # *   DirectoryNotExists: The specified directory does not exist.
        # *   BadCronExpression: The specified cron expression for the execution schedule is invalid.
        # *   ClientNotRunning: The Cloud Assistant client is not running.
        # *   ClientNotResponse: The Cloud Assistant client does not respond.
        # *   ClientIsUpgrading: The Cloud Assistant client is being upgraded.
        # *   ClientNeedUpgrade: The Cloud Assistant client needs to be upgraded.
        # *   DeliveryTimeout: The request to send the command has timed out.
        # *   ExecutionTimeout: The execution has timed out.
        # *   ExecutionException: An exception has occurred while the command is being run.
        # *   ExecutionInterrupted: The execution is interrupted.
        # *   ExitCodeNonzero: The execution is complete, but the exit code is not 0.
        self.error_code = error_code  # type: str
        # The error message returned when the command cannot be sent or run. Valid values:
        # 
        # *   If this parameter is empty, the command is run normally.
        # *   the specified instance does not exists
        # *   the instance has released when create task
        # *   the instance is not running when create task
        # *   the command is not applicable
        # *   the specified account does not exists
        # *   the specified directory does not exists
        # *   the cron job expression is invalid
        # *   the aliyun service is not running on the instance
        # *   the aliyun service in the instance does not response
        # *   the aliyun service in the instance is upgrading now
        # *   the aliyun service in the instance need upgrade
        # *   the command delivery has been timeout
        # *   the command execution has been timeout
        # *   the command execution got an exception
        # *   the command execution has been interrupted
        # *   the command execution exit code is not zero
        self.error_info = error_info  # type: str
        # The exit code of the command execution.
        # 
        # *   For Linux instances, the value is the exit code of the shell command.
        # *   For Windows instances, the value is the exit code of the batch or PowerShell command.
        self.exit_code = exit_code  # type: long
        # The completion time of the execution. If an execution times out, the completion time of the execution is subject to the value of the TimedOut parameter specified in the [CreateCommand](~~64844~~) operation.
        self.finished_time = finished_time  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The execution state on a single instance. Valid values:
        # 
        # *   Pending: The command is being verified or sent.
        # 
        # *   Invalid: The specified command type or parameter is invalid.
        # 
        # *   Aborted: The command failed to be sent. To send a command to an instance, make sure that the instance is in the Running state and the command is sent to the instance within 1 minute.
        # 
        # *   Running: The command is being run on the instance.
        # 
        # *   Success:
        # 
        #     *   Command that is set to run only once: The execution is complete, and the exit code is 0.
        #     *   Command that is set to run on a schedule: The last execution succeeds, the exit code is 0, and the specified cycle ends.
        # 
        # *   Failed:
        # 
        #     *   Command that is set to run only once: The execution is complete, but the exit code is not 0.
        #     *   Command that is set to run on a schedule: The last execution is complete, the exit code is not 0, and the specified execution time is about to end.
        # 
        # *   Error: The execution cannot proceed due to an exception.
        # 
        # *   Timeout: The execution times out.
        # 
        # *   Cancelled: The execution is canceled, and the command is not run.
        # 
        # *   Stopping: The command that is running is being stopped.
        # 
        # *   Terminated: The command is terminated while it is being run.
        # 
        # *   Scheduled:
        # 
        #     *   Command that is set to run only once: The command is not applicable.
        #     *   Command that is set to run on a schedule: The command is waiting to be run.
        self.invocation_status = invocation_status  # type: str
        # The ID of the command task.
        self.invoke_id = invoke_id  # type: str
        # The state of the execution.
        self.invoke_record_status = invoke_record_status  # type: str
        # The command output.
        self.output = output  # type: str
        # The number of times that the command is run on the instance.
        # 
        # *   If the command is set to run only once on the instance, the value is 0 or 1.
        # *   If the command is set to run on a schedule on the instance, the value is the number of times that the command is run.
        self.repeats = repeats  # type: int
        # The time when the command started to be run on the instance.
        self.start_time = start_time  # type: str
        # The time when the command stopped being run on the instance. If you call the `StopInvocation` operation to manually stop the execution, the value is the time when you call the operation.
        self.stop_time = stop_time  # type: str
        # The tags of the command.
        self.tags = tags  # type: DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTags
        # The username that was used to run the command on the ECS instance.
        self.username = username  # type: str

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.dropped is not None:
            result['Dropped'] = self.dropped
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_info is not None:
            result['ErrorInfo'] = self.error_info
        if self.exit_code is not None:
            result['ExitCode'] = self.exit_code
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_record_status is not None:
            result['InvokeRecordStatus'] = self.invoke_record_status
        if self.output is not None:
            result['Output'] = self.output
        if self.repeats is not None:
            result['Repeats'] = self.repeats
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.username is not None:
            result['Username'] = self.username
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('Dropped') is not None:
            self.dropped = m.get('Dropped')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorInfo') is not None:
            self.error_info = m.get('ErrorInfo')
        if m.get('ExitCode') is not None:
            self.exit_code = m.get('ExitCode')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeRecordStatus') is not None:
            self.invoke_record_status = m.get('InvokeRecordStatus')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Repeats') is not None:
            self.repeats = m.get('Repeats')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('Tags') is not None:
            temp_model = DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResultTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Username') is not None:
            self.username = m.get('Username')
        return self


class DescribeInvocationResultsResponseBodyInvocationInvocationResults(TeaModel):
    def __init__(self, invocation_result=None):
        self.invocation_result = invocation_result  # type: list[DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult]

    def validate(self):
        if self.invocation_result:
            for k in self.invocation_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBodyInvocationInvocationResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvocationResult'] = []
        if self.invocation_result is not None:
            for k in self.invocation_result:
                result['InvocationResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invocation_result = []
        if m.get('InvocationResult') is not None:
            for k in m.get('InvocationResult'):
                temp_model = DescribeInvocationResultsResponseBodyInvocationInvocationResultsInvocationResult()
                self.invocation_result.append(temp_model.from_map(k))
        return self


class DescribeInvocationResultsResponseBodyInvocation(TeaModel):
    def __init__(self, invocation_results=None, page_number=None, page_size=None, total_count=None):
        # The execution results.
        self.invocation_results = invocation_results  # type: DescribeInvocationResultsResponseBodyInvocationInvocationResults
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The total number of the commands.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.invocation_results:
            self.invocation_results.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBodyInvocation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invocation_results is not None:
            result['InvocationResults'] = self.invocation_results.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InvocationResults') is not None:
            temp_model = DescribeInvocationResultsResponseBodyInvocationInvocationResults()
            self.invocation_results = temp_model.from_map(m['InvocationResults'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInvocationResultsResponseBody(TeaModel):
    def __init__(self, invocation=None, request_id=None):
        # Details of the execution result.
        self.invocation = invocation  # type: DescribeInvocationResultsResponseBodyInvocation
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.invocation:
            self.invocation.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invocation is not None:
            result['Invocation'] = self.invocation.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Invocation') is not None:
            temp_model = DescribeInvocationResultsResponseBodyInvocation()
            self.invocation = temp_model.from_map(m['Invocation'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInvocationResultsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInvocationResultsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInvocationResultsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInvocationResultsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInvocationsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the command task. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the command. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeInvocationsRequest(TeaModel):
    def __init__(self, command_id=None, command_name=None, command_type=None, content_encoding=None,
                 include_output=None, instance_id=None, invoke_id=None, invoke_status=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, repeat_mode=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None, timed=None):
        # The ID of the command. You can call the [DescribeCommands](~~64843~~) operation to query all available command IDs.
        self.command_id = command_id  # type: str
        # The name of the command.
        self.command_name = command_name  # type: str
        # The type of the command. If this parameter and `InstanceId` are both specified, this parameter does not take effect.
        self.command_type = command_type  # type: str
        # The encoding mode of the `CommandContent` and `Output` response parameters. Valid values:
        # 
        # *   PlainText: returns the original command content and command outputs.
        # *   Base64: returns the Base64-encoded command content and command outputs.
        # 
        # Default value: Base64.
        self.content_encoding = content_encoding  # type: str
        # Specifies whether to return the command outputs in the response.
        # 
        # *   true: The command outputs are returned. When this parameter is set to true, you must specify `InvokeId`, `InstanceId`, or both.
        # *   false: The command outputs are not returned.
        # 
        # Default value: false.
        self.include_output = include_output  # type: bool
        # The ID of the instance. When you specify this parameter, the system queries all the execution records of all the commands that run on the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the command task.
        self.invoke_id = invoke_id  # type: str
        # The overall execution state of the command. The value of this parameter depends on the execution states on all involved instances. Valid values:
        # 
        # *   Running:
        # 
        #     *   Scheduled execution: Before you manually stop the execution of the command, the overall execution state is always Running.
        #     *   One-time execution: If the execution is in progress on one or more instances, the overall execution state is Running.
        # 
        # *   Finished:
        # 
        #     *   Scheduled execution: The overall execution state can never be Finished.
        #     *   One-time execution: The execution is complete on all instances, or the execution is manually stopped on some instances and is complete on other instances.
        # 
        # *   Failed:
        # 
        #     *   Scheduled execution: The overall execution state can never be Failed.
        #     *   One-time execution: The execution fails on all instances.
        # 
        # *   PartialFailed:
        # 
        #     *   Scheduled execution: The overall execution state can never be PartialFailed.
        #     *   One-time execution: The execution fails on some instances.
        # 
        # *   Stopped: The execution is stopped.
        self.invoke_status = invoke_status  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Page start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: The command is immediately run.
        # *   Period: The command is run on a schedule.
        # *   NextRebootOnly: The command is automatically run the next time the instance starts.
        # *   EveryReboot: The command is automatically run every time the instance starts.
        # 
        # This parameter is empty by default, which indicates that commands run in all modes are queried.
        self.repeat_mode = repeat_mode  # type: str
        # The ID of the resource group. After you set this parameter, command execution results in the specified resource group are queried.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags of the command.
        self.tag = tag  # type: list[DescribeInvocationsRequestTag]
        # Specifies whether to query the commands that are to be automatically run. Valid values:
        # 
        # *   true: queries the commands that meet the following requirements: The commands are run by calling the `RunCommand` or `InvokeCommand` operation with `RepeatMode` set to `Period`, `NextRebootOnly`, or `EveryReboot`. The executions of the commands are not canceled and not complete or are not stopped and not complete.
        # 
        # *   false: queries commands that meet the following requirements:
        # 
        #     *   The commands are run by calling the `RunCommand` or `InvokeCommand` operation with `RepeatMode` set to `Once`.
        #     *   The executions of the commands are canceled, stopped, or complete.
        # 
        # Default value: false.
        self.timed = timed  # type: bool

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.command_name is not None:
            result['CommandName'] = self.command_name
        if self.command_type is not None:
            result['CommandType'] = self.command_type
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.include_output is not None:
            result['IncludeOutput'] = self.include_output
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_status is not None:
            result['InvokeStatus'] = self.invoke_status
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timed is not None:
            result['Timed'] = self.timed
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('CommandName') is not None:
            self.command_name = m.get('CommandName')
        if m.get('CommandType') is not None:
            self.command_type = m.get('CommandType')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('IncludeOutput') is not None:
            self.include_output = m.get('IncludeOutput')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeStatus') is not None:
            self.invoke_status = m.get('InvokeStatus')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInvocationsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        return self


class DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance(TeaModel):
    def __init__(self, creation_time=None, dropped=None, error_code=None, error_info=None, exit_code=None,
                 finish_time=None, instance_id=None, instance_invoke_status=None, invocation_status=None, output=None,
                 repeats=None, start_time=None, stop_time=None, timed=None, update_time=None):
        # The start time of the execution.
        self.creation_time = creation_time  # type: str
        # The size of the text that is truncated and discarded when the Output value exceeds 24 KB in size.
        self.dropped = dropped  # type: int
        # The code that indicates why the command failed to be sent or run. Valid values:
        # 
        # *   If this parameter is empty, the execution is normal.
        # *   InstanceNotExists: The instance does not exist or was released.
        # *   InstanceReleased: The instance was released while the command was being run.
        # *   InstanceNotRunning: The instance was not in the Running state while the command started to be run.
        # *   CommandNotApplicable: The command is not applicable to the specified instance.
        # *   AccountNotExists: The specified account does not exist.
        # *   DirectoryNotExists: The specified directory does not exist.
        # *   BadCronExpression: The cron expression used to specify a schedule is invalid.
        # *   ClientNotRunning: The Cloud Assistant client is not running.
        # *   ClientNotResponse: The Cloud Assistant client does not respond.
        # *   ClientIsUpgrading: The Cloud Assistant client is being upgraded.
        # *   ClientNeedUpgrade: The Cloud Assistant client needs to be upgraded.
        # *   DeliveryTimeout: The request to send the command timed out.
        # *   ExecutionTimeout: The execution timed out.
        # *   ExecutionException: An exception occurs while the command is being run.
        # *   ExecutionInterrupted: The execution was interrupted.
        # *   ExitCodeNonzero: The execution is complete, but the exit code is not 0.
        self.error_code = error_code  # type: str
        # Details about the reason why the command failed to be sent or run. Valid values:
        # 
        # *   If this parameter is empty, the execution is normal.
        # *   the specified instance does not exists
        # *   the instance has released when create task
        # *   the instance is not running when create task
        # *   the command is not applicable
        # *   the specified account does not exists
        # *   the specified directory does not exists
        # *   the cron job expression is invalid
        # *   the aliyun service is not running on the instance
        # *   the aliyun service in the instance does not response
        # *   the aliyun service in the instance is upgrading now
        # *   the aliyun service in the instance is upgrading now
        # *   the command delivery has been timeout
        # *   the command execution has been timeout
        # *   the command execution got an exception
        # *   the command execution has been interrupted
        # *   the command execution exit code is not zero
        self.error_info = error_info  # type: str
        # The exit code of the execution. Valid values:
        # 
        # *   For Linux instances, the exit code is the exit code of the shell process.
        # *   For Windows instances, the exit code is the exit code of the batch or PowerShell process.
        self.exit_code = exit_code  # type: long
        # The end time of the execution.
        self.finish_time = finish_time  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The execution state on a single instance.
        # 
        # > We recommend that you ignore this parameter and check the value of the `InvocationStatus` response parameter for the overall execution state.
        self.instance_invoke_status = instance_invoke_status  # type: str
        # The execution state on a single instance. Valid values:
        # 
        # *   Pending: The command is being verified or sent.
        # 
        # *   Invalid: The specified command type or parameter is invalid.
        # 
        # *   Aborted: The command failed to be sent. To send a command to an instance, make sure that the instance is in the Running state and that the command is sent within 1 minute.
        # 
        # *   Running: The command is being run on the instance.
        # 
        # *   Success:
        # 
        #     *   Command that is set to run only once: The execution is complete, and the exit code is 0.
        #     *   Command that is set to run on a schedule: The previous execution is complete, the exit code is 0, and the specified cycle ends.
        # 
        # *   Failed:
        # 
        #     *   Command that is set to run only once: The execution is complete, but the exit code is not 0.
        #     *   Command that is set to run on a schedule: The previous execution is complete, the exit code is not 0, and the specified cycle is about to end.
        # 
        # *   Error: The execution cannot proceed due to an exception.
        # 
        # *   Timeout: The execution times out.
        # 
        # *   Cancelled: The execution is canceled, and the command is not started.
        # 
        # *   Stopping: The command task is being stopped.
        # 
        # *   Terminated: The command task is terminated while it is being run.
        # 
        # *   Scheduled:
        # 
        #     *   Command that is set to run only once: The overall execution state can never be Scheduled.
        #     *   Command that is set to run on a schedule: The command is pending execution.
        self.invocation_status = invocation_status  # type: str
        # The output of the command.
        self.output = output  # type: str
        # The number of times that the command is run on the instance.
        # 
        # *   If the execution is a one-time execution, the value is 0 or 1.
        # *   If the execution is a scheduled execution, the value is the number of times that the command is run.
        self.repeats = repeats  # type: int
        # The time when the command started to be run on the instance.
        self.start_time = start_time  # type: str
        # The time when the command stopped being run on the instance. If you call the `StopInvocation` operation to manually stop the execution, the value is the time when you called the operation.
        self.stop_time = stop_time  # type: str
        # Indicates whether the command is to be automatically run.
        self.timed = timed  # type: bool
        # The time when the execution state was updated.
        self.update_time = update_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.dropped is not None:
            result['Dropped'] = self.dropped
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_info is not None:
            result['ErrorInfo'] = self.error_info
        if self.exit_code is not None:
            result['ExitCode'] = self.exit_code
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_invoke_status is not None:
            result['InstanceInvokeStatus'] = self.instance_invoke_status
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.output is not None:
            result['Output'] = self.output
        if self.repeats is not None:
            result['Repeats'] = self.repeats
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Dropped') is not None:
            self.dropped = m.get('Dropped')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorInfo') is not None:
            self.error_info = m.get('ErrorInfo')
        if m.get('ExitCode') is not None:
            self.exit_code = m.get('ExitCode')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceInvokeStatus') is not None:
            self.instance_invoke_status = m.get('InstanceInvokeStatus')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Repeats') is not None:
            self.repeats = m.get('Repeats')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances(TeaModel):
    def __init__(self, invoke_instance=None):
        self.invoke_instance = invoke_instance  # type: list[DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance]

    def validate(self):
        if self.invoke_instance:
            for k in self.invoke_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvokeInstance'] = []
        if self.invoke_instance is not None:
            for k in self.invoke_instance:
                result['InvokeInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invoke_instance = []
        if m.get('InvokeInstance') is not None:
            for k in m.get('InvokeInstance'):
                temp_model = DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance()
                self.invoke_instance.append(temp_model.from_map(k))
        return self


class DescribeInvocationsResponseBodyInvocationsInvocationTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the command task.
        self.tag_key = tag_key  # type: str
        # The tag value of the command task.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvocationTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeInvocationsResponseBodyInvocationsInvocationTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeInvocationsResponseBodyInvocationsInvocationTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvocationTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeInvocationsResponseBodyInvocationsInvocationTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeInvocationsResponseBodyInvocationsInvocation(TeaModel):
    def __init__(self, command_content=None, command_description=None, command_id=None, command_name=None,
                 command_type=None, container_id=None, container_name=None, creation_time=None, frequency=None,
                 invocation_status=None, invoke_id=None, invoke_instances=None, invoke_status=None, parameters=None, repeat_mode=None,
                 tags=None, timed=None, timeout=None, username=None, working_dir=None):
        # The Base64-encoded command content.
        self.command_content = command_content  # type: str
        # The description of the command.
        self.command_description = command_description  # type: str
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The name of the command.
        self.command_name = command_name  # type: str
        # The type of the command.
        self.command_type = command_type  # type: str
        # The ID of the container.
        self.container_id = container_id  # type: str
        # The name of the container.
        self.container_name = container_name  # type: str
        # The time when the command task was created.
        self.creation_time = creation_time  # type: str
        # The schedule on which to run the command. For information about the value specifications, see [Cron expression](~~64769~~).
        self.frequency = frequency  # type: str
        # The overall execution state of the command. The value of this parameter depends on the execution states on all the involved instances. Valid values:
        # 
        # *   Pending: The command is being verified or sent. When the execution state on at least one instance is Pending, the overall execution state is Pending.
        # 
        # *   Scheduled: The command scheduled to run is sent and pending execution. When the execution state on at least one instance is Scheduled, the overall execution state is Scheduled.
        # 
        # *   Running: The command is being run on the instances. When the execution state on at least one instance is Running, the overall execution state is Running.
        # 
        # *   Success: When the execution state on at least one instance is Success and the execution state on other instances is Stopped or Success, the overall execution state is Success.
        # 
        #     *   Command that is set to run only once: The execution is complete, and the exit code is 0.
        #     *   Command that is set to run on a schedule: The last execution is complete, the exit code is 0, and the specified cycle ends.
        # 
        # *   Failed: When the execution state on all instances is Stopped or Failed, the overall execution state is Failed. When the execution state on an instance is one of the following values, Failed is returned as the overall execution state:
        # 
        #     *   Invalid: The command is invalid.
        #     *   Aborted: The command failed to be sent.
        #     *   Failed: The command execution is complete, but the exit code is not 0.
        #     *   Timeout: The execution timed out.
        #     *   Error: An error occurred while the command was being run on the instance.
        # 
        # *   Stopping: The command task is being stopped. When the execution state on at least one instance is Stopping, the overall execution state is Stopping.
        # 
        # *   Stopped: The command task is stopped. When the execution state on all instances is Stopped, the overall execution state is Stopped. When the execution state on an instance is one of the following values, Stopped is returned as the overall execution state:
        # 
        #     *   Cancelled: The command task is canceled.
        #     *   Terminated: The command task is terminated.
        # 
        # *   PartialFailed: The execution is complete on some instances and fails on other instances. When the execution state is Success on some instances and is Failed or Stopped on other instances, the overall execution state is PartialFailed.
        # 
        # > The `InvokeStatus` response parameter functions similarly to this parameter. We recommend that you ignore InvokeStatus and check the value of InvocationStatus.
        self.invocation_status = invocation_status  # type: str
        # The ID of the command task.
        self.invoke_id = invoke_id  # type: str
        # Details about the instances on which the command is run.
        self.invoke_instances = invoke_instances  # type: DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances
        # The overall execution state of the command.
        # 
        # > We recommend that you ignore this parameter and check the value of the `InvocationStatus` response parameter for the overall execution state.
        self.invoke_status = invoke_status  # type: str
        # The custom parameters in the command.
        self.parameters = parameters  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: The command is immediately run.
        # *   Period: The command is run on a schedule.
        # *   NextRebootOnly: The command is automatically run the next time the instance starts.
        # *   EveryReboot: The command is automatically run every time the instance starts.
        self.repeat_mode = repeat_mode  # type: str
        # The tags of the command task.
        self.tags = tags  # type: DescribeInvocationsResponseBodyInvocationsInvocationTags
        # Indicates whether the command is to be automatically run.
        self.timed = timed  # type: bool
        # The maximum timeout period for the command execution on the instance. Unit: seconds.
        # 
        # When a command cannot be run, the command execution times out. When a command execution times out, the Cloud Assistant client forcefully terminates the command process by canceling the PID of the command.
        self.timeout = timeout  # type: long
        # The username that was used to run the command on the instance.
        self.username = username  # type: str
        # The execution path of the command.
        self.working_dir = working_dir  # type: str

    def validate(self):
        if self.invoke_instances:
            self.invoke_instances.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvocation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.command_description is not None:
            result['CommandDescription'] = self.command_description
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.command_name is not None:
            result['CommandName'] = self.command_name
        if self.command_type is not None:
            result['CommandType'] = self.command_type
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_instances is not None:
            result['InvokeInstances'] = self.invoke_instances.to_map()
        if self.invoke_status is not None:
            result['InvokeStatus'] = self.invoke_status
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.username is not None:
            result['Username'] = self.username
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('CommandDescription') is not None:
            self.command_description = m.get('CommandDescription')
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('CommandName') is not None:
            self.command_name = m.get('CommandName')
        if m.get('CommandType') is not None:
            self.command_type = m.get('CommandType')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeInstances') is not None:
            temp_model = DescribeInvocationsResponseBodyInvocationsInvocationInvokeInstances()
            self.invoke_instances = temp_model.from_map(m['InvokeInstances'])
        if m.get('InvokeStatus') is not None:
            self.invoke_status = m.get('InvokeStatus')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('Tags') is not None:
            temp_model = DescribeInvocationsResponseBodyInvocationsInvocationTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class DescribeInvocationsResponseBodyInvocations(TeaModel):
    def __init__(self, invocation=None):
        self.invocation = invocation  # type: list[DescribeInvocationsResponseBodyInvocationsInvocation]

    def validate(self):
        if self.invocation:
            for k in self.invocation:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Invocation'] = []
        if self.invocation is not None:
            for k in self.invocation:
                result['Invocation'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invocation = []
        if m.get('Invocation') is not None:
            for k in m.get('Invocation'):
                temp_model = DescribeInvocationsResponseBodyInvocationsInvocation()
                self.invocation.append(temp_model.from_map(k))
        return self


class DescribeInvocationsResponseBody(TeaModel):
    def __init__(self, invocations=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the command executions.
        self.invocations = invocations  # type: DescribeInvocationsResponseBodyInvocations
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of the commands.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.invocations:
            self.invocations.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invocations is not None:
            result['Invocations'] = self.invocations.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Invocations') is not None:
            temp_model = DescribeInvocationsResponseBodyInvocations()
            self.invocations = temp_model.from_map(m['Invocations'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeInvocationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInvocationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInvocationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeKeyPairsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the key pair. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that are bound with this tag can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that are bound with all these tags can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the key pair. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeKeyPairsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeKeyPairsRequest(TeaModel):
    def __init__(self, key_pair_finger_print=None, key_pair_name=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 tag=None):
        # The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716. For more information, see [RFC 4716](https://tools.ietf.org/html/rfc4716).
        self.key_pair_finger_print = key_pair_finger_print  # type: str
        # The name of the key pair. You can use the asterisk (\*) symbol as a wildcard in regular expressions to perform a fuzzy search for key pairs. Sample patterns:
        # 
        # *   `*SshKey`: queries key pairs whose names end with SshKey, including the key pair named SshKey.
        # *   `SshKey*`: queries key pairs whose names start with SshKey, including the key pair named SshKey.
        # *   `*SshKey*`: queries key pairs whose names include SshKey, including the key pair named SshKey.
        # *   `SshKey`: queries the key pair named SshKey.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the key pair. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[DescribeKeyPairsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeKeyPairsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the key pair.
        self.tag_key = tag_key  # type: str
        # The tag value of the key pair.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeKeyPairsResponseBodyKeyPairsKeyPairTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsResponseBodyKeyPairsKeyPairTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeKeyPairsResponseBodyKeyPairsKeyPairTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeKeyPairsResponseBodyKeyPairsKeyPair(TeaModel):
    def __init__(self, creation_time=None, key_pair_finger_print=None, key_pair_name=None, resource_group_id=None,
                 tags=None):
        # The time when the key pair was created.
        self.creation_time = creation_time  # type: str
        # The fingerprint of the key pair.
        self.key_pair_finger_print = key_pair_finger_print  # type: str
        # The name of the key pair.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The tags of the key pair.
        self.tags = tags  # type: DescribeKeyPairsResponseBodyKeyPairsKeyPairTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsResponseBodyKeyPairsKeyPair, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            temp_model = DescribeKeyPairsResponseBodyKeyPairsKeyPairTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeKeyPairsResponseBodyKeyPairs(TeaModel):
    def __init__(self, key_pair=None):
        self.key_pair = key_pair  # type: list[DescribeKeyPairsResponseBodyKeyPairsKeyPair]

    def validate(self):
        if self.key_pair:
            for k in self.key_pair:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsResponseBodyKeyPairs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['KeyPair'] = []
        if self.key_pair is not None:
            for k in self.key_pair:
                result['KeyPair'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.key_pair = []
        if m.get('KeyPair') is not None:
            for k in m.get('KeyPair'):
                temp_model = DescribeKeyPairsResponseBodyKeyPairsKeyPair()
                self.key_pair.append(temp_model.from_map(k))
        return self


class DescribeKeyPairsResponseBody(TeaModel):
    def __init__(self, key_pairs=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the key pairs.
        self.key_pairs = key_pairs  # type: DescribeKeyPairsResponseBodyKeyPairs
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of key pairs.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.key_pairs:
            self.key_pairs.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pairs is not None:
            result['KeyPairs'] = self.key_pairs.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairs') is not None:
            temp_model = DescribeKeyPairsResponseBodyKeyPairs()
            self.key_pairs = temp_model.from_map(m['KeyPairs'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeKeyPairsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeKeyPairsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeKeyPairsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeKeyPairsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLaunchTemplateVersionsRequest(TeaModel):
    def __init__(self, default_version=None, detail_flag=None, launch_template_id=None, launch_template_name=None,
                 launch_template_version=None, max_version=None, min_version=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to query the default version.
        self.default_version = default_version  # type: bool
        # Specifies whether to query the configurations of the launch template. Valid values:
        # 
        # *   true: queries the basic information and other details of the launch template. The details include the image ID and system disk size.
        # *   false: queries only the basic information of the launch template. The basic information includes the template ID, template name, and default version.
        # 
        # Default value: true.
        self.detail_flag = detail_flag  # type: bool
        # The ID of the launch template.
        # 
        # You must specify LaunchTemplateId or LaunchTemplateName to determine a launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template.
        self.launch_template_name = launch_template_name  # type: str
        self.launch_template_version = launch_template_version  # type: list[long]
        # The maximum version number in the version range to query.
        self.max_version = max_version  # type: long
        # The minimum version number in the version range to query.
        self.min_version = min_version  # type: long
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the launch template.
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_version is not None:
            result['DefaultVersion'] = self.default_version
        if self.detail_flag is not None:
            result['DetailFlag'] = self.detail_flag
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.launch_template_version is not None:
            result['LaunchTemplateVersion'] = self.launch_template_version
        if self.max_version is not None:
            result['MaxVersion'] = self.max_version
        if self.min_version is not None:
            result['MinVersion'] = self.min_version
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultVersion') is not None:
            self.default_version = m.get('DefaultVersion')
        if m.get('DetailFlag') is not None:
            self.detail_flag = m.get('DetailFlag')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('LaunchTemplateVersion') is not None:
            self.launch_template_version = m.get('LaunchTemplateVersion')
        if m.get('MaxVersion') is not None:
            self.max_version = m.get('MaxVersion')
        if m.get('MinVersion') is not None:
            self.min_version = m.get('MinVersion')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, disk_name=None, encrypted=None, iops=None, performance_level=None,
                 provisioned_iops=None, size=None):
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        self.bursting_enabled = bursting_enabled  # type: bool
        self.category = category  # type: str
        self.delete_with_instance = delete_with_instance  # type: bool
        self.description = description  # type: str
        self.disk_name = disk_name  # type: str
        self.encrypted = encrypted  # type: str
        self.iops = iops  # type: int
        self.performance_level = performance_level  # type: str
        self.provisioned_iops = provisioned_iops  # type: long
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.iops is not None:
            result['Iops'] = self.iops
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('Iops') is not None:
            self.iops = m.get('Iops')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, device=None, disk_name=None, encrypted=None, performance_level=None,
                 provisioned_iops=None, size=None, snapshot_id=None):
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of the data disk.
        self.category = category  # type: str
        # Indicates whether to release the data disk when the instance is released.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of the data disk.
        self.description = description  # type: str
        # The device name of the data disk.
        # 
        # >  This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.device = device  # type: str
        # The name of the data disk.
        self.disk_name = disk_name  # type: str
        # Specifies whether to encrypt the data disk.
        self.encrypted = encrypted  # type: str
        # The performance level of ESSD used as the data disk. This parameter is returned only when `Category` is set to cloud_essd. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        self.performance_level = performance_level  # type: str
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of the data disk.
        self.size = size  # type: int
        # The ID of the snapshot used to create the data disk.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks(TeaModel):
    def __init__(self, data_disk=None):
        self.data_disk = data_disk  # type: list[DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk]

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisksDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface(TeaModel):
    def __init__(self, description=None, instance_type=None, network_interface_name=None,
                 network_interface_traffic_mode=None, primary_ip_address=None, security_group_id=None, security_group_ids=None, v_switch_id=None):
        # The description of the secondary ENI.
        self.description = description  # type: str
        self.instance_type = instance_type  # type: str
        # The name of the secondary ENI.
        self.network_interface_name = network_interface_name  # type: str
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The primary private IP address of the secondary ENI.
        self.primary_ip_address = primary_ip_address  # type: str
        # The ID of the security group to which to assign the secondary ENI. The security group and the ENI must belong to the same VPC.  
        # 
        # >  The SecurityGroupId and SecurityGroupIds parameters are mutually exclusive in the response.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to which to assign the secondary ENI. 
        # 
        # >  The SecurityGroupId and SecurityGroupIds parameters are mutually exclusive in the response.
        self.security_group_ids = security_group_ids  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds
        # The ID of the vSwitch to which to connect the ENI.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        if self.security_group_ids:
            self.security_group_ids.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterfaceSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces(TeaModel):
    def __init__(self, network_interface=None):
        self.network_interface = network_interface  # type: list[DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface]

    def validate(self):
        if self.network_interface:
            for k in self.network_interface:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterface'] = []
        if self.network_interface is not None:
            for k in self.network_interface:
                result['NetworkInterface'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_interface = []
        if m.get('NetworkInterface') is not None:
            for k in m.get('NetworkInterface'):
                temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfacesNetworkInterface()
                self.network_interface.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the instance.
        self.key = key  # type: str
        # The tag value of the instance.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags(TeaModel):
    def __init__(self, instance_tag=None):
        self.instance_tag = instance_tag  # type: list[DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag]

    def validate(self):
        if self.instance_tag:
            for k in self.instance_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceTag'] = []
        if self.instance_tag is not None:
            for k in self.instance_tag:
                result['InstanceTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_tag = []
        if m.get('InstanceTag') is not None:
            for k in m.get('InstanceTag'):
                temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTagsInstanceTag()
                self.instance_tag.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData(TeaModel):
    def __init__(self, system_disk=None, auto_release_time=None, data_disks=None, deployment_set_id=None,
                 description=None, enable_vm_os_config=None, host_name=None, image_id=None, image_owner_alias=None,
                 instance_charge_type=None, instance_name=None, instance_type=None, internet_charge_type=None,
                 internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None, ipv_6address_count=None,
                 key_pair_name=None, network_interfaces=None, network_type=None, password_inherit=None, period=None,
                 private_ip_address=None, ram_role_name=None, resource_group_id=None, security_enhancement_strategy=None,
                 security_group_id=None, security_group_ids=None, spot_duration=None, spot_price_limit=None, spot_strategy=None,
                 tags=None, user_data=None, v_switch_id=None, vpc_id=None, zone_id=None):
        self.system_disk = system_disk  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk
        # The automatic release time of the instance.
        self.auto_release_time = auto_release_time  # type: str
        # Details about the data disks.
        self.data_disks = data_disks  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks
        # The ID of the deployment set.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance.
        self.description = description  # type: str
        # Indicates whether to enable the operating system configuration of the instance.
        self.enable_vm_os_config = enable_vm_os_config  # type: bool
        # The hostname of the instance.
        self.host_name = host_name  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The source of the image. Valid values:
        # 
        # *   system: public images provided by Alibaba Cloud.
        # *   self: custom images that you create.
        # *   others: shared images from other Alibaba Cloud accounts.
        # *   marketplace: Alibaba Cloud Marketplace images.
        self.image_owner_alias = image_owner_alias  # type: str
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # The number of IPv6 addresses to assign to the instance.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # The name of the key pair.
        self.key_pair_name = key_pair_name  # type: str
        # Details about the secondary elastic network interfaces (ENIs).
        self.network_interfaces = network_interfaces  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces
        # The network type. Valid values:
        # 
        # *   classic: classic network
        # *   vpc: VPC
        self.network_type = network_type  # type: str
        # Indicates whether the username and password pair preset in the image is used.
        self.password_inherit = password_inherit  # type: bool
        # The subscription duration.
        self.period = period  # type: int
        # The private IP address of the instance.
        self.private_ip_address = private_ip_address  # type: str
        # The name of the instance RAM role.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the resource group to which the launch template belongs.
        self.resource_group_id = resource_group_id  # type: str
        # Indicates whether to enable security hardening.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance.
        # 
        # >  The `SecurityGroupId` and `SecurityGroupIds` parameters are mutually exclusive in the response.
        self.security_group_id = security_group_id  # type: str
        # The IDs of the security groups to which to assign the instance. 
        # 
        # >  The `SecurityGroupId` and `SecurityGroupIds` parameters are mutually exclusive in the response.
        self.security_group_ids = security_group_ids  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # Take note of the following items:
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   A value of 0 indicates that no protection period is configured for the preemptible instance.
        self.spot_duration = spot_duration  # type: int
        # The maximum hourly price of the preemptible instance.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        self.spot_strategy = spot_strategy  # type: str
        # The tags of the instance.
        self.tags = tags  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags
        # The user data of the instance, which is Base64-encoded.
        self.user_data = user_data  # type: str
        # The ID of the vSwitch to which to connect the instance.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the virtual private cloud (VPC).
        self.vpc_id = vpc_id  # type: str
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        self.validate_required(self.system_disk, 'system_disk')
        if self.system_disk:
            self.system_disk.validate()
        if self.data_disks:
            self.data_disks.validate()
        if self.network_interfaces:
            self.network_interfaces.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.data_disks is not None:
            result['DataDisks'] = self.data_disks.to_map()
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_vm_os_config is not None:
            result['EnableVmOsConfig'] = self.enable_vm_os_config
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_owner_alias is not None:
            result['ImageOwnerAlias'] = self.image_owner_alias
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.network_interfaces is not None:
            result['NetworkInterfaces'] = self.network_interfaces.to_map()
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('DataDisks') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataDataDisks()
            self.data_disks = temp_model.from_map(m['DataDisks'])
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableVmOsConfig') is not None:
            self.enable_vm_os_config = m.get('EnableVmOsConfig')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageOwnerAlias') is not None:
            self.image_owner_alias = m.get('ImageOwnerAlias')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('NetworkInterfaces') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataNetworkInterfaces()
            self.network_interfaces = temp_model.from_map(m['NetworkInterfaces'])
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('Tags') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateDataTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet(TeaModel):
    def __init__(self, create_time=None, created_by=None, default_version=None, launch_template_data=None,
                 launch_template_id=None, launch_template_name=None, modified_time=None, version_description=None,
                 version_number=None):
        # The time when the launch template was created.
        self.create_time = create_time  # type: str
        # The creator of the launch template.
        self.created_by = created_by  # type: str
        # Indicates whether the launch template version is the default version.
        self.default_version = default_version  # type: bool
        # The configurations of the launch template.
        self.launch_template_data = launch_template_data  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData
        # The ID of the template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template.
        self.launch_template_name = launch_template_name  # type: str
        # The time when the launch template was modified.
        self.modified_time = modified_time  # type: str
        # The description of the launch template version.
        self.version_description = version_description  # type: str
        # The number of the launch template version.
        self.version_number = version_number  # type: long

    def validate(self):
        if self.launch_template_data:
            self.launch_template_data.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.created_by is not None:
            result['CreatedBy'] = self.created_by
        if self.default_version is not None:
            result['DefaultVersion'] = self.default_version
        if self.launch_template_data is not None:
            result['LaunchTemplateData'] = self.launch_template_data.to_map()
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.version_description is not None:
            result['VersionDescription'] = self.version_description
        if self.version_number is not None:
            result['VersionNumber'] = self.version_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatedBy') is not None:
            self.created_by = m.get('CreatedBy')
        if m.get('DefaultVersion') is not None:
            self.default_version = m.get('DefaultVersion')
        if m.get('LaunchTemplateData') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSetLaunchTemplateData()
            self.launch_template_data = temp_model.from_map(m['LaunchTemplateData'])
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('VersionDescription') is not None:
            self.version_description = m.get('VersionDescription')
        if m.get('VersionNumber') is not None:
            self.version_number = m.get('VersionNumber')
        return self


class DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets(TeaModel):
    def __init__(self, launch_template_version_set=None):
        self.launch_template_version_set = launch_template_version_set  # type: list[DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet]

    def validate(self):
        if self.launch_template_version_set:
            for k in self.launch_template_version_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LaunchTemplateVersionSet'] = []
        if self.launch_template_version_set is not None:
            for k in self.launch_template_version_set:
                result['LaunchTemplateVersionSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.launch_template_version_set = []
        if m.get('LaunchTemplateVersionSet') is not None:
            for k in m.get('LaunchTemplateVersionSet'):
                temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSetsLaunchTemplateVersionSet()
                self.launch_template_version_set.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplateVersionsResponseBody(TeaModel):
    def __init__(self, launch_template_version_sets=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the launch template versions.
        self.launch_template_version_sets = launch_template_version_sets  # type: DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of launch templates.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.launch_template_version_sets:
            self.launch_template_version_sets.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_version_sets is not None:
            result['LaunchTemplateVersionSets'] = self.launch_template_version_sets.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateVersionSets') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBodyLaunchTemplateVersionSets()
            self.launch_template_version_sets = temp_model.from_map(m['LaunchTemplateVersionSets'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLaunchTemplateVersionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLaunchTemplateVersionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplateVersionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLaunchTemplateVersionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLaunchTemplatesRequestTemplateTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the launch template. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the launch template. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplatesRequestTemplateTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLaunchTemplatesRequest(TeaModel):
    def __init__(self, launch_template_id=None, launch_template_name=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 template_resource_group_id=None, template_tag=None):
        # The IDs of one or more launch templates. You can specify up to 100 launch template IDs.
        self.launch_template_id = launch_template_id  # type: list[str]
        # The names of one or more launch templates. You can specify up to 100 launch template names.
        self.launch_template_name = launch_template_name  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the launch template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the resource group to which the launch template belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.template_resource_group_id = template_resource_group_id  # type: str
        # The tags.
        self.template_tag = template_tag  # type: list[DescribeLaunchTemplatesRequestTemplateTag]

    def validate(self):
        if self.template_tag:
            for k in self.template_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.template_resource_group_id is not None:
            result['TemplateResourceGroupId'] = self.template_resource_group_id
        result['TemplateTag'] = []
        if self.template_tag is not None:
            for k in self.template_tag:
                result['TemplateTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TemplateResourceGroupId') is not None:
            self.template_resource_group_id = m.get('TemplateResourceGroupId')
        self.template_tag = []
        if m.get('TemplateTag') is not None:
            for k in m.get('TemplateTag'):
                temp_model = DescribeLaunchTemplatesRequestTemplateTag()
                self.template_tag.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the launch template.
        self.tag_key = tag_key  # type: str
        # The tag value of the launch template.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet(TeaModel):
    def __init__(self, create_time=None, created_by=None, default_version_number=None, latest_version_number=None,
                 launch_template_id=None, launch_template_name=None, modified_time=None, resource_group_id=None, tags=None):
        # The time when the launch template was created.
        self.create_time = create_time  # type: str
        # The creator of the launch template.
        self.created_by = created_by  # type: str
        # The default version number of the launch template.
        self.default_version_number = default_version_number  # type: long
        # The latest version number of the launch template.
        self.latest_version_number = latest_version_number  # type: long
        # The ID of the launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template.
        self.launch_template_name = launch_template_name  # type: str
        # The time when the launch template was modified.
        self.modified_time = modified_time  # type: str
        # The ID of the resource group to which the launch template belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The tags of the launch template.
        self.tags = tags  # type: DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.created_by is not None:
            result['CreatedBy'] = self.created_by
        if self.default_version_number is not None:
            result['DefaultVersionNumber'] = self.default_version_number
        if self.latest_version_number is not None:
            result['LatestVersionNumber'] = self.latest_version_number
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('CreatedBy') is not None:
            self.created_by = m.get('CreatedBy')
        if m.get('DefaultVersionNumber') is not None:
            self.default_version_number = m.get('DefaultVersionNumber')
        if m.get('LatestVersionNumber') is not None:
            self.latest_version_number = m.get('LatestVersionNumber')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Tags') is not None:
            temp_model = DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSetTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeLaunchTemplatesResponseBodyLaunchTemplateSets(TeaModel):
    def __init__(self, launch_template_set=None):
        self.launch_template_set = launch_template_set  # type: list[DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet]

    def validate(self):
        if self.launch_template_set:
            for k in self.launch_template_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponseBodyLaunchTemplateSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['LaunchTemplateSet'] = []
        if self.launch_template_set is not None:
            for k in self.launch_template_set:
                result['LaunchTemplateSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.launch_template_set = []
        if m.get('LaunchTemplateSet') is not None:
            for k in m.get('LaunchTemplateSet'):
                temp_model = DescribeLaunchTemplatesResponseBodyLaunchTemplateSetsLaunchTemplateSet()
                self.launch_template_set.append(temp_model.from_map(k))
        return self


class DescribeLaunchTemplatesResponseBody(TeaModel):
    def __init__(self, launch_template_sets=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the launch templates.
        self.launch_template_sets = launch_template_sets  # type: DescribeLaunchTemplatesResponseBodyLaunchTemplateSets
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of launch templates.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.launch_template_sets:
            self.launch_template_sets.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.launch_template_sets is not None:
            result['LaunchTemplateSets'] = self.launch_template_sets.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LaunchTemplateSets') is not None:
            temp_model = DescribeLaunchTemplatesResponseBodyLaunchTemplateSets()
            self.launch_template_sets = temp_model.from_map(m['LaunchTemplateSets'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeLaunchTemplatesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLaunchTemplatesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLaunchTemplatesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLaunchTemplatesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLimitationRequest(TeaModel):
    def __init__(self, limitation=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.limitation = limitation  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLimitationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limitation is not None:
            result['Limitation'] = self.limitation
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Limitation') is not None:
            self.limitation = m.get('Limitation')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeLimitationResponseBody(TeaModel):
    def __init__(self, limitation=None, request_id=None, value=None):
        self.limitation = limitation  # type: str
        self.request_id = request_id  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLimitationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.limitation is not None:
            result['Limitation'] = self.limitation
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Limitation') is not None:
            self.limitation = m.get('Limitation')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLimitationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLimitationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLimitationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLimitationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeManagedInstancesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the managed instance. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the managed instance. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # It can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeManagedInstancesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeManagedInstancesRequest(TeaModel):
    def __init__(self, activation_id=None, instance_id=None, instance_ip=None, instance_name=None, os_type=None,
                 owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, tag=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The ID of managed instance N. Valid values of N: 1 to 50.
        self.instance_id = instance_id  # type: list[str]
        # The internal or public IP address of the managed instance.
        self.instance_ip = instance_ip  # type: str
        # The name of the managed instance.
        self.instance_name = instance_name  # type: str
        # The operating system type of the managed instance. Valid values:
        # 
        # *   windows
        # *   linux
        self.os_type = os_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the managed instance. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags of the managed instance.
        self.tag = tag  # type: list[DescribeManagedInstancesRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeManagedInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ip is not None:
            result['InstanceIp'] = self.instance_ip
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceIp') is not None:
            self.instance_ip = m.get('InstanceIp')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeManagedInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeManagedInstancesResponseBodyInstancesTags(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the managed instance. Up to 20 tag keys can be returned for each managed instance. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.tag_key = tag_key  # type: str
        # The tag value of the managed instance. Up to 20 tag values can be returned for each managed instance. The tag value can be an empty string.
        # 
        # It can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeManagedInstancesResponseBodyInstancesTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeManagedInstancesResponseBodyInstances(TeaModel):
    def __init__(self, activation_id=None, agent_version=None, connected=None, hostname=None, instance_id=None,
                 instance_name=None, internet_ip=None, intranet_ip=None, invocation_count=None, last_invoked_time=None,
                 machine_id=None, os_type=None, os_version=None, registration_time=None, tags=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The version number of the Cloud Assistant client.
        self.agent_version = agent_version  # type: str
        # Indicates whether the managed instance is connected. Valid values:
        # 
        # *   true: The managed instance is connected and you can manage the instance by using Cloud Assistant.
        # *   false: The managed instance is not connected because the managed instance is down or because the Cloud Assistant client is not installed correctly.
        self.connected = connected  # type: bool
        # The hostname of the managed instance.
        self.hostname = hostname  # type: str
        # The ID of the managed instance.
        self.instance_id = instance_id  # type: str
        # The name of the managed instance.
        self.instance_name = instance_name  # type: str
        # The public IP address of the managed instance.
        self.internet_ip = internet_ip  # type: str
        # The internal IP address of the managed instance.
        self.intranet_ip = intranet_ip  # type: str
        # The number of times that Cloud Assistant tasks were executed on the managed instance.
        self.invocation_count = invocation_count  # type: long
        # The last Cloud Assistant task execution time.
        self.last_invoked_time = last_invoked_time  # type: str
        # The machine code of the managed instance.
        self.machine_id = machine_id  # type: str
        # The operating system type of the managed instance.
        self.os_type = os_type  # type: str
        # The version information of the operating system.
        self.os_version = os_version  # type: str
        # The time when the managed instance was registered.
        self.registration_time = registration_time  # type: str
        # The tags of the managed instance.
        self.tags = tags  # type: list[DescribeManagedInstancesResponseBodyInstancesTags]

    def validate(self):
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeManagedInstancesResponseBodyInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.agent_version is not None:
            result['AgentVersion'] = self.agent_version
        if self.connected is not None:
            result['Connected'] = self.connected
        if self.hostname is not None:
            result['Hostname'] = self.hostname
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.internet_ip is not None:
            result['InternetIp'] = self.internet_ip
        if self.intranet_ip is not None:
            result['IntranetIp'] = self.intranet_ip
        if self.invocation_count is not None:
            result['InvocationCount'] = self.invocation_count
        if self.last_invoked_time is not None:
            result['LastInvokedTime'] = self.last_invoked_time
        if self.machine_id is not None:
            result['MachineId'] = self.machine_id
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.registration_time is not None:
            result['RegistrationTime'] = self.registration_time
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('AgentVersion') is not None:
            self.agent_version = m.get('AgentVersion')
        if m.get('Connected') is not None:
            self.connected = m.get('Connected')
        if m.get('Hostname') is not None:
            self.hostname = m.get('Hostname')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InternetIp') is not None:
            self.internet_ip = m.get('InternetIp')
        if m.get('IntranetIp') is not None:
            self.intranet_ip = m.get('IntranetIp')
        if m.get('InvocationCount') is not None:
            self.invocation_count = m.get('InvocationCount')
        if m.get('LastInvokedTime') is not None:
            self.last_invoked_time = m.get('LastInvokedTime')
        if m.get('MachineId') is not None:
            self.machine_id = m.get('MachineId')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('RegistrationTime') is not None:
            self.registration_time = m.get('RegistrationTime')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeManagedInstancesResponseBodyInstancesTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeManagedInstancesResponseBody(TeaModel):
    def __init__(self, instances=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the managed instances.
        self.instances = instances  # type: list[DescribeManagedInstancesResponseBodyInstances]
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of managed instances returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeManagedInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = DescribeManagedInstancesResponseBodyInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeManagedInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeManagedInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeManagedInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeManagedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNatGatewaysRequest(TeaModel):
    def __init__(self, nat_gateway_id=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, vpc_id=None):
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNatGatewaysRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds(TeaModel):
    def __init__(self, bandwidth_package_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        return self


class DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds(TeaModel):
    def __init__(self, forward_table_id=None):
        self.forward_table_id = forward_table_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        return self


class DescribeNatGatewaysResponseBodyNatGatewaysNatGateway(TeaModel):
    def __init__(self, bandwidth_package_ids=None, business_status=None, creation_time=None, description=None,
                 forward_table_ids=None, instance_charge_type=None, name=None, nat_gateway_id=None, region_id=None, spec=None,
                 status=None, vpc_id=None):
        self.bandwidth_package_ids = bandwidth_package_ids  # type: DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds
        self.business_status = business_status  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.forward_table_ids = forward_table_ids  # type: DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds
        self.instance_charge_type = instance_charge_type  # type: str
        self.name = name  # type: str
        self.nat_gateway_id = nat_gateway_id  # type: str
        self.region_id = region_id  # type: str
        self.spec = spec  # type: str
        self.status = status  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.bandwidth_package_ids:
            self.bandwidth_package_ids.validate()
        if self.forward_table_ids:
            self.forward_table_ids.validate()

    def to_map(self):
        _map = super(DescribeNatGatewaysResponseBodyNatGatewaysNatGateway, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_ids is not None:
            result['BandwidthPackageIds'] = self.bandwidth_package_ids.to_map()
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.forward_table_ids is not None:
            result['ForwardTableIds'] = self.forward_table_ids.to_map()
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.name is not None:
            result['Name'] = self.name
        if self.nat_gateway_id is not None:
            result['NatGatewayId'] = self.nat_gateway_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageIds') is not None:
            temp_model = DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayBandwidthPackageIds()
            self.bandwidth_package_ids = temp_model.from_map(m['BandwidthPackageIds'])
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ForwardTableIds') is not None:
            temp_model = DescribeNatGatewaysResponseBodyNatGatewaysNatGatewayForwardTableIds()
            self.forward_table_ids = temp_model.from_map(m['ForwardTableIds'])
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NatGatewayId') is not None:
            self.nat_gateway_id = m.get('NatGatewayId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeNatGatewaysResponseBodyNatGateways(TeaModel):
    def __init__(self, nat_gateway=None):
        self.nat_gateway = nat_gateway  # type: list[DescribeNatGatewaysResponseBodyNatGatewaysNatGateway]

    def validate(self):
        if self.nat_gateway:
            for k in self.nat_gateway:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNatGatewaysResponseBodyNatGateways, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NatGateway'] = []
        if self.nat_gateway is not None:
            for k in self.nat_gateway:
                result['NatGateway'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.nat_gateway = []
        if m.get('NatGateway') is not None:
            for k in m.get('NatGateway'):
                temp_model = DescribeNatGatewaysResponseBodyNatGatewaysNatGateway()
                self.nat_gateway.append(temp_model.from_map(k))
        return self


class DescribeNatGatewaysResponseBody(TeaModel):
    def __init__(self, nat_gateways=None, page_number=None, page_size=None, request_id=None, total_count=None):
        self.nat_gateways = nat_gateways  # type: DescribeNatGatewaysResponseBodyNatGateways
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.nat_gateways:
            self.nat_gateways.validate()

    def to_map(self):
        _map = super(DescribeNatGatewaysResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nat_gateways is not None:
            result['NatGateways'] = self.nat_gateways.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NatGateways') is not None:
            temp_model = DescribeNatGatewaysResponseBodyNatGateways()
            self.nat_gateways = temp_model.from_map(m['NatGateways'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNatGatewaysResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNatGatewaysResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNatGatewaysResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNatGatewaysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkInterfaceAttributeRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # > This parameter is unavailable.
        self.key = key  # type: str
        # > This parameter is unavailable.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeNetworkInterfaceAttributeRequest(TeaModel):
    def __init__(self, attribute=None, network_interface_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None):
        # The attribute of the ENI.
        self.attribute = attribute  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # > This parameter is unavailable.
        self.tag = tag  # type: list[DescribeNetworkInterfaceAttributeRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attribute is not None:
            result['Attribute'] = self.attribute
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Attribute') is not None:
            self.attribute = m.get('Attribute')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeNetworkInterfaceAttributeRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp(TeaModel):
    def __init__(self, allocation_id=None, public_ip_address=None):
        # The ID of the EIP.
        self.allocation_id = allocation_id  # type: str
        # The EIP of the ENI.
        self.public_ip_address = public_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds(TeaModel):
    def __init__(self, member_network_interface_id=None):
        self.member_network_interface_id = member_network_interface_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.member_network_interface_id is not None:
            result['MemberNetworkInterfaceId'] = self.member_network_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MemberNetworkInterfaceId') is not None:
            self.member_network_interface_id = m.get('MemberNetworkInterfaceId')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyAttachment(TeaModel):
    def __init__(self, device_index=None, instance_id=None, member_network_interface_ids=None,
                 network_card_index=None, trunk_network_interface_id=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.device_index = device_index  # type: int
        # > This parameter is in invitational preview and unavailable to general users.
        self.instance_id = instance_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.member_network_interface_ids = member_network_interface_ids  # type: DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds
        # The index of the network interface controller (NIC).
        # 
        # *   If the ENI is in the Available state or if no NIC index was specified when the ENI was attached, this parameter has no value.
        # *   If the ENI is in the InUse state and an NIC index was specified when the ENI was attached, the specified NIC index is returned as the value of this parameter.
        self.network_card_index = network_card_index  # type: int
        # > This parameter is in invitational preview and unavailable to general users.
        self.trunk_network_interface_id = trunk_network_interface_id  # type: str

    def validate(self):
        if self.member_network_interface_ids:
            self.member_network_interface_ids.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyAttachment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_index is not None:
            result['DeviceIndex'] = self.device_index
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.member_network_interface_ids is not None:
            result['MemberNetworkInterfaceIds'] = self.member_network_interface_ids.to_map()
        if self.network_card_index is not None:
            result['NetworkCardIndex'] = self.network_card_index
        if self.trunk_network_interface_id is not None:
            result['TrunkNetworkInterfaceId'] = self.trunk_network_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeviceIndex') is not None:
            self.device_index = m.get('DeviceIndex')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MemberNetworkInterfaceIds') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyAttachmentMemberNetworkInterfaceIds()
            self.member_network_interface_ids = temp_model.from_map(m['MemberNetworkInterfaceIds'])
        if m.get('NetworkCardIndex') is not None:
            self.network_card_index = m.get('NetworkCardIndex')
        if m.get('TrunkNetworkInterfaceId') is not None:
            self.trunk_network_interface_id = m.get('TrunkNetworkInterfaceId')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecificationSlaveInterfaceSpecificationSet(TeaModel):
    def __init__(self, bond_network_interface_id=None, slave_network_interface_id=None, work_state=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.bond_network_interface_id = bond_network_interface_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.slave_network_interface_id = slave_network_interface_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.work_state = work_state  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecificationSlaveInterfaceSpecificationSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bond_network_interface_id is not None:
            result['BondNetworkInterfaceId'] = self.bond_network_interface_id
        if self.slave_network_interface_id is not None:
            result['SlaveNetworkInterfaceId'] = self.slave_network_interface_id
        if self.work_state is not None:
            result['WorkState'] = self.work_state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BondNetworkInterfaceId') is not None:
            self.bond_network_interface_id = m.get('BondNetworkInterfaceId')
        if m.get('SlaveNetworkInterfaceId') is not None:
            self.slave_network_interface_id = m.get('SlaveNetworkInterfaceId')
        if m.get('WorkState') is not None:
            self.work_state = m.get('WorkState')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecification(TeaModel):
    def __init__(self, slave_interface_specification_set=None):
        self.slave_interface_specification_set = slave_interface_specification_set  # type: list[DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecificationSlaveInterfaceSpecificationSet]

    def validate(self):
        if self.slave_interface_specification_set:
            for k in self.slave_interface_specification_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecification, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SlaveInterfaceSpecificationSet'] = []
        if self.slave_interface_specification_set is not None:
            for k in self.slave_interface_specification_set:
                result['SlaveInterfaceSpecificationSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.slave_interface_specification_set = []
        if m.get('SlaveInterfaceSpecificationSet') is not None:
            for k in m.get('SlaveInterfaceSpecificationSet'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecificationSlaveInterfaceSpecificationSet()
                self.slave_interface_specification_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecification(TeaModel):
    def __init__(self, bond_mode=None, slave_interface_specification=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.bond_mode = bond_mode  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.slave_interface_specification = slave_interface_specification  # type: DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecification

    def validate(self):
        if self.slave_interface_specification:
            self.slave_interface_specification.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecification, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bond_mode is not None:
            result['BondMode'] = self.bond_mode
        if self.slave_interface_specification is not None:
            result['SlaveInterfaceSpecification'] = self.slave_interface_specification.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BondMode') is not None:
            self.bond_mode = m.get('BondMode')
        if m.get('SlaveInterfaceSpecification') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecificationSlaveInterfaceSpecification()
            self.slave_interface_specification = temp_model.from_map(m['SlaveInterfaceSpecification'])
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSetsIpv4PrefixSet(TeaModel):
    def __init__(self, ipv_4prefix=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.ipv_4prefix = ipv_4prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSetsIpv4PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSets(TeaModel):
    def __init__(self, ipv_4prefix_set=None):
        self.ipv_4prefix_set = ipv_4prefix_set  # type: list[DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSetsIpv4PrefixSet]

    def validate(self):
        if self.ipv_4prefix_set:
            for k in self.ipv_4prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4PrefixSet'] = []
        if self.ipv_4prefix_set is not None:
            for k in self.ipv_4prefix_set:
                result['Ipv4PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_4prefix_set = []
        if m.get('Ipv4PrefixSet') is not None:
            for k in m.get('Ipv4PrefixSet'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSetsIpv4PrefixSet()
                self.ipv_4prefix_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSetsIpv6PrefixSet(TeaModel):
    def __init__(self, ipv_6prefix=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.ipv_6prefix = ipv_6prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSetsIpv6PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSets(TeaModel):
    def __init__(self, ipv_6prefix_set=None):
        self.ipv_6prefix_set = ipv_6prefix_set  # type: list[DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSetsIpv6PrefixSet]

    def validate(self):
        if self.ipv_6prefix_set:
            for k in self.ipv_6prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6PrefixSet'] = []
        if self.ipv_6prefix_set is not None:
            for k in self.ipv_6prefix_set:
                result['Ipv6PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6prefix_set = []
        if m.get('Ipv6PrefixSet') is not None:
            for k in m.get('Ipv6PrefixSet'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSetsIpv6PrefixSet()
                self.ipv_6prefix_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set(TeaModel):
    def __init__(self, ipv_6address=None):
        # The IPv6 address of the ENI.
        self.ipv_6address = ipv_6address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets(TeaModel):
    def __init__(self, ipv_6set=None):
        self.ipv_6set = ipv_6set  # type: list[DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set]

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp(TeaModel):
    def __init__(self, allocation_id=None, public_ip_address=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.allocation_id = allocation_id  # type: str
        # The EIP of the ENI.
        self.public_ip_address = public_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(self, associated_public_ip=None, primary=None, private_ip_address=None):
        # The EIP that is associated with the secondary private IP address of the ENI.
        self.associated_public_ip = associated_public_ip  # type: DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp
        # Indicates whether the IP address is the primary private IP address. Valid values:
        # 
        # *   true: The IP address is the primary private IP address.
        # *   false: The IP address is a secondary private IP address.
        self.primary = primary  # type: bool
        # The private IP address of the ENI.
        self.private_ip_address = private_ip_address  # type: str

    def validate(self):
        if self.associated_public_ip:
            self.associated_public_ip.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_public_ip is not None:
            result['AssociatedPublicIp'] = self.associated_public_ip.to_map()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssociatedPublicIp') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSetAssociatedPublicIp()
            self.associated_public_ip = temp_model.from_map(m['AssociatedPublicIp'])
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets(TeaModel):
    def __init__(self, private_ip_set=None):
        self.private_ip_set = private_ip_set  # type: list[DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet]

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeNetworkInterfaceAttributeResponseBodySlaveInterfaceSpecification(TeaModel):
    def __init__(self, bond_network_interface_id=None, slave_network_interface_id=None, work_state=None):
        # > This parameter is in invitational preview and unavailable to general users.
        self.bond_network_interface_id = bond_network_interface_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.slave_network_interface_id = slave_network_interface_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.work_state = work_state  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodySlaveInterfaceSpecification, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bond_network_interface_id is not None:
            result['BondNetworkInterfaceId'] = self.bond_network_interface_id
        if self.slave_network_interface_id is not None:
            result['SlaveNetworkInterfaceId'] = self.slave_network_interface_id
        if self.work_state is not None:
            result['WorkState'] = self.work_state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BondNetworkInterfaceId') is not None:
            self.bond_network_interface_id = m.get('BondNetworkInterfaceId')
        if m.get('SlaveNetworkInterfaceId') is not None:
            self.slave_network_interface_id = m.get('SlaveNetworkInterfaceId')
        if m.get('WorkState') is not None:
            self.work_state = m.get('WorkState')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key.
        self.tag_key = tag_key  # type: str
        # The tag value.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeNetworkInterfaceAttributeResponseBodyTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeNetworkInterfaceAttributeResponseBodyTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBodyTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeNetworkInterfaceAttributeResponseBodyTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfaceAttributeResponseBody(TeaModel):
    def __init__(self, associated_public_ip=None, attachment=None, bond_interface_specification=None,
                 creation_time=None, description=None, instance_id=None, ipv_4prefix_sets=None, ipv_6prefix_sets=None,
                 ipv_6sets=None, mac_address=None, network_interface_id=None, network_interface_name=None,
                 network_interface_traffic_mode=None, owner_id=None, private_ip_address=None, private_ip_sets=None, queue_number=None,
                 queue_pair_number=None, request_id=None, resource_group_id=None, security_group_ids=None, service_id=None,
                 service_managed=None, slave_interface_specification=None, status=None, tags=None, type=None, v_switch_id=None,
                 vpc_id=None, zone_id=None):
        # The elastic IP address (EIP) that is associated with the secondary private IP address of the ENI.
        self.associated_public_ip = associated_public_ip  # type: DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp
        # > This parameter is in invitational preview and unavailable to general users.
        self.attachment = attachment  # type: DescribeNetworkInterfaceAttributeResponseBodyAttachment
        # > This parameter is in invitational preview and unavailable to general users.
        self.bond_interface_specification = bond_interface_specification  # type: DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecification
        # The time when the ENI was created.
        self.creation_time = creation_time  # type: str
        # The description of the ENI.
        self.description = description  # type: str
        # The ID of the instance to which the ENI is attached.
        # 
        # > If the ENI is managed and controlled by other Alibaba Cloud services, no instance ID is returned.
        self.instance_id = instance_id  # type: str
        # > This parameter is in invitational preview and unavailable to general users.
        self.ipv_4prefix_sets = ipv_4prefix_sets  # type: DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSets
        # > This parameter is in invitational preview and unavailable to general users.
        self.ipv_6prefix_sets = ipv_6prefix_sets  # type: DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSets
        # The IPv6 addresses of the ENI.
        self.ipv_6sets = ipv_6sets  # type: DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets
        # The media access control (MAC) address of the ENI.
        self.mac_address = mac_address  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The name of the ENI.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of the ENI. Valid values:
        # 
        # *   Standard: The TCP communication mode is used.
        # *   HighPerformance: Elastic RDMA Interface (ERI) is enabled and the remote direct memory access (RDMA) communication mode is used.
        # 
        # > This parameter can have a value of HighPerformance only when the ENI is attached to a c7re RDMA-enhanced instance that resides in Beijing Zone K.
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The ID of the account to which the ENI belongs.
        self.owner_id = owner_id  # type: str
        # The private IP address of the ENI.
        self.private_ip_address = private_ip_address  # type: str
        # Details about the private IP addresses of the ENI.
        self.private_ip_sets = private_ip_sets  # type: DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets
        # The number of queues supported by the ENI.
        # 
        # *   For a primary ENI: The default number of queues that the instance type supports for the ENI is returned.
        # 
        # *   For a secondary ENI:
        # 
        #     *   When the ENI is in the InUse state, the following situations occur for the QueueNumber parameter:
        # 
        #         *   If the number of queues supported by the ENI has not been modified, the default number of queues that the instance type supports for the ENI is returned.
        #         *   If the number of queues supported by the ENI has been modified, the new number of queues is returned.
        # 
        #     *   When the ENI is in the Available state, the following situations occur for the QueueNumber parameter:
        # 
        #         *   If the number of queues supported by the ENI has not been modified, the return value is empty.
        #         *   If the number of queues supported by the ENI has been modified, the new number of queues is returned.
        self.queue_number = queue_number  # type: int
        # > This parameter is in invitational preview and unavailable to general users.
        self.queue_pair_number = queue_pair_number  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the resource group to which the associated instance belongs. If a resource group is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # > Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        # The IDs of the security groups to which the ENI belongs.
        self.security_group_ids = security_group_ids  # type: DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds
        # The ID of the distributor to which the ENI belongs.
        self.service_id = service_id  # type: long
        # Indicates whether the user of the ENI is an Alibaba Cloud service or a distributor.
        self.service_managed = service_managed  # type: bool
        # > This parameter is in invitational preview and unavailable to general users.
        self.slave_interface_specification = slave_interface_specification  # type: DescribeNetworkInterfaceAttributeResponseBodySlaveInterfaceSpecification
        # The state of the ENI. Valid values:
        # 
        # *   Available: The ENI is not attached to an instance.
        # *   Attaching: The ENI is being attached to an instance.
        # *   InUse: The ENI is attached to an instance.
        # *   Detaching: The ENI is being detached from an instance.
        # *   Deleting: The ENI is being deleted.
        # 
        # This parameter is empty by default, which indicates that ENIs in all states are queried.
        self.status = status  # type: str
        # The tags of the ENI.
        self.tags = tags  # type: DescribeNetworkInterfaceAttributeResponseBodyTags
        # The type of the ENI. Valid values:
        # 
        # *   Primary
        # *   Secondary
        self.type = type  # type: str
        # The ID of the vSwitch to which the ENI is connected.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the virtual private cloud (VPC) to which the ENI belongs.
        self.vpc_id = vpc_id  # type: str
        # The zone ID of the ENI.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.associated_public_ip:
            self.associated_public_ip.validate()
        if self.attachment:
            self.attachment.validate()
        if self.bond_interface_specification:
            self.bond_interface_specification.validate()
        if self.ipv_4prefix_sets:
            self.ipv_4prefix_sets.validate()
        if self.ipv_6prefix_sets:
            self.ipv_6prefix_sets.validate()
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.slave_interface_specification:
            self.slave_interface_specification.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_public_ip is not None:
            result['AssociatedPublicIp'] = self.associated_public_ip.to_map()
        if self.attachment is not None:
            result['Attachment'] = self.attachment.to_map()
        if self.bond_interface_specification is not None:
            result['BondInterfaceSpecification'] = self.bond_interface_specification.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ipv_4prefix_sets is not None:
            result['Ipv4PrefixSets'] = self.ipv_4prefix_sets.to_map()
        if self.ipv_6prefix_sets is not None:
            result['Ipv6PrefixSets'] = self.ipv_6prefix_sets.to_map()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.queue_number is not None:
            result['QueueNumber'] = self.queue_number
        if self.queue_pair_number is not None:
            result['QueuePairNumber'] = self.queue_pair_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.service_id is not None:
            result['ServiceID'] = self.service_id
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        if self.slave_interface_specification is not None:
            result['SlaveInterfaceSpecification'] = self.slave_interface_specification.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssociatedPublicIp') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyAssociatedPublicIp()
            self.associated_public_ip = temp_model.from_map(m['AssociatedPublicIp'])
        if m.get('Attachment') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyAttachment()
            self.attachment = temp_model.from_map(m['Attachment'])
        if m.get('BondInterfaceSpecification') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyBondInterfaceSpecification()
            self.bond_interface_specification = temp_model.from_map(m['BondInterfaceSpecification'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ipv4PrefixSets') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv4PrefixSets()
            self.ipv_4prefix_sets = temp_model.from_map(m['Ipv4PrefixSets'])
        if m.get('Ipv6PrefixSets') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv6PrefixSets()
            self.ipv_6prefix_sets = temp_model.from_map(m['Ipv6PrefixSets'])
        if m.get('Ipv6Sets') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PrivateIpSets') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyPrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('QueueNumber') is not None:
            self.queue_number = m.get('QueueNumber')
        if m.get('QueuePairNumber') is not None:
            self.queue_pair_number = m.get('QueuePairNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodySecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('ServiceID') is not None:
            self.service_id = m.get('ServiceID')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        if m.get('SlaveInterfaceSpecification') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodySlaveInterfaceSpecification()
            self.slave_interface_specification = temp_model.from_map(m['SlaveInterfaceSpecification'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBodyTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeNetworkInterfaceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNetworkInterfaceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfaceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkInterfaceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkInterfacePermissionsRequest(TeaModel):
    def __init__(self, network_interface_id=None, network_interface_permission_id=None, owner_account=None,
                 owner_id=None, page_number=None, page_size=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the ENI. You must specify `NetworkInterfaceId` or `NetworkInterfacePermissionId.N` to determine the ENIs to query.
        self.network_interface_id = network_interface_id  # type: str
        # The IDs of permissions on the ENI. You can specify up to 100 ENI permission IDs.
        self.network_interface_permission_id = network_interface_permission_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacePermissionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_permission_id is not None:
            result['NetworkInterfacePermissionId'] = self.network_interface_permission_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfacePermissionId') is not None:
            self.network_interface_permission_id = m.get('NetworkInterfacePermissionId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission(TeaModel):
    def __init__(self, account_id=None, network_interface_id=None, network_interface_permission_id=None,
                 permission=None, permission_state=None, service_name=None):
        # The ID of the Alibaba Cloud partner (a certified ISV) or individual user.
        self.account_id = account_id  # type: long
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The ID of the permission on the ENI.
        self.network_interface_permission_id = network_interface_permission_id  # type: str
        # The permission on the ENI.
        self.permission = permission  # type: str
        # The status of the permission on the ENI. Valid values:
        # 
        # *   Pending: The permission is being granted.
        # *   Granted: The permission has been granted.
        # *   Revoking: The permission is being revoked.
        # *   Revoked: The permission has been revoked.
        self.permission_state = permission_state  # type: str
        # The name of the Alibaba Cloud service.
        self.service_name = service_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.account_id is not None:
            result['AccountId'] = self.account_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_permission_id is not None:
            result['NetworkInterfacePermissionId'] = self.network_interface_permission_id
        if self.permission is not None:
            result['Permission'] = self.permission
        if self.permission_state is not None:
            result['PermissionState'] = self.permission_state
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccountId') is not None:
            self.account_id = m.get('AccountId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfacePermissionId') is not None:
            self.network_interface_permission_id = m.get('NetworkInterfacePermissionId')
        if m.get('Permission') is not None:
            self.permission = m.get('Permission')
        if m.get('PermissionState') is not None:
            self.permission_state = m.get('PermissionState')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions(TeaModel):
    def __init__(self, network_interface_permission=None):
        self.network_interface_permission = network_interface_permission  # type: list[DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission]

    def validate(self):
        if self.network_interface_permission:
            for k in self.network_interface_permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterfacePermission'] = []
        if self.network_interface_permission is not None:
            for k in self.network_interface_permission:
                result['NetworkInterfacePermission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_interface_permission = []
        if m.get('NetworkInterfacePermission') is not None:
            for k in m.get('NetworkInterfacePermission'):
                temp_model = DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissionsNetworkInterfacePermission()
                self.network_interface_permission.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacePermissionsResponseBody(TeaModel):
    def __init__(self, network_interface_permissions=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # Details about the permissions on ENIs.
        self.network_interface_permissions = network_interface_permissions  # type: DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions
        # The number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.network_interface_permissions:
            self.network_interface_permissions.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacePermissionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_permissions is not None:
            result['NetworkInterfacePermissions'] = self.network_interface_permissions.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkInterfacePermissions') is not None:
            temp_model = DescribeNetworkInterfacePermissionsResponseBodyNetworkInterfacePermissions()
            self.network_interface_permissions = temp_model.from_map(m['NetworkInterfacePermissions'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNetworkInterfacePermissionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNetworkInterfacePermissionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacePermissionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkInterfacePermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkInterfacesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the ENI. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N of the ENI. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeNetworkInterfacesRequest(TeaModel):
    def __init__(self, instance_id=None, ipv_6address=None, max_results=None, network_interface_id=None,
                 network_interface_name=None, next_token=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 primary_ip_address=None, private_ip_address=None, region_id=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, security_group_id=None, service_managed=None, status=None, tag=None,
                 type=None, v_switch_id=None, vpc_id=None):
        # The ID of the instance to which the ENI is attached.
        self.instance_id = instance_id  # type: str
        # The IPv6 addresses of the ENI. You can specify multiple IPv6 addresses. Valid values of N: 1 to 100.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The maximum number of entries to return on each page. Valid values: 10 to 500.
        # 
        # Default values:
        # 
        # *   If this parameter is not specified or if this parameter is set to a value smaller than 10, the default value 10 is used.
        # *   If this parameter is set to a value greater than 500, the default value 500 is used.
        self.max_results = max_results  # type: int
        # The IDs of ENIs. You specify multiple ENI IDs. Valid values of N: 1 to 100.
        self.network_interface_id = network_interface_id  # type: list[str]
        # The name of the ENI.
        self.network_interface_name = network_interface_name  # type: str
        # The query token. Set the value to the `NextToken` value returned in the last call to the DescribeNetworkInterfaces operation.
        # 
        # For more information about how to check the responses returned by this operation, see the preceding "Description" section.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Page start from page 1.
        # 
        # Default value: 1.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters to perform a paged query.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 1000.
        # 
        # Default value: 10.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters to perform a paged query.
        self.page_size = page_size  # type: int
        # The primary private IPv4 address of the ENI.
        self.primary_ip_address = primary_ip_address  # type: str
        # The secondary private IPv4 addresses of the ENI. You can specify multiple secondary private IPv4 addresses. Valid values of N: 1 to 100.
        self.private_ip_address = private_ip_address  # type: list[str]
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the ENI belongs. If a resource group is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # > Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group to which the secondary ENI belongs.
        # 
        # *   To query the details of secondary ENIs based on the ID of a security group, specify this parameter.
        # *   To query the details of primary ENIs based on the ID of a security group, call the [DescribeInstances](~~25506~~) operation with the `SecurityGroupId` parameter specified.
        self.security_group_id = security_group_id  # type: str
        # Specifies whether the user of the ENI is an Alibaba Cloud service or a distributor.
        self.service_managed = service_managed  # type: bool
        # The state of the ENI. Valid values:
        # 
        # *   Available: The ENI is not attached to an instance.
        # *   Attaching: The ENI is being attached to an instance.
        # *   InUse: The ENI is attached to an instance.
        # *   Detaching: The ENI is being detached from an instance.
        # *   Deleting: The ENI is being deleted.
        # 
        # This parameter is empty by default, which indicates that ENIs in all states are queried.
        self.status = status  # type: str
        # The tags of the ENI.
        self.tag = tag  # type: list[DescribeNetworkInterfacesRequestTag]
        # The type of the ENI. Valid values:
        # 
        # *   Primary
        # *   Secondary
        # 
        # This parameter is empty by default, which indicates that both primary and secondary ENIs are queried.
        self.type = type  # type: str
        # The ID of the vSwitch to which the ENI is connected.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the virtual private cloud (VPC) to which the ENI belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeNetworkInterfacesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp(TeaModel):
    def __init__(self, allocation_id=None, public_ip_address=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.allocation_id = allocation_id  # type: str
        # The EIP.
        self.public_ip_address = public_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment(TeaModel):
    def __init__(self, device_index=None, instance_id=None, network_card_index=None,
                 trunk_network_interface_id=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.device_index = device_index  # type: int
        # > This parameter is in invitational preview and is unavailable to general users.
        self.instance_id = instance_id  # type: str
        # 网卡挂载指定的物理网卡索引。
        # - 如果网卡是未挂载（Available）状态或者挂载时未指定索引，则不返回此值。
        # - 如果网卡是已挂载（InUse）状态且挂载时指定，此值表示网卡挂载指定的物理网卡索引。
        self.network_card_index = network_card_index  # type: int
        # > This parameter is in invitational preview and is unavailable to general users.
        self.trunk_network_interface_id = trunk_network_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_index is not None:
            result['DeviceIndex'] = self.device_index
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_card_index is not None:
            result['NetworkCardIndex'] = self.network_card_index
        if self.trunk_network_interface_id is not None:
            result['TrunkNetworkInterfaceId'] = self.trunk_network_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeviceIndex') is not None:
            self.device_index = m.get('DeviceIndex')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkCardIndex') is not None:
            self.network_card_index = m.get('NetworkCardIndex')
        if m.get('TrunkNetworkInterfaceId') is not None:
            self.trunk_network_interface_id = m.get('TrunkNetworkInterfaceId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSetsIpv4PrefixSet(TeaModel):
    def __init__(self, ipv_4prefix=None):
        self.ipv_4prefix = ipv_4prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSetsIpv4PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSets(TeaModel):
    def __init__(self, ipv_4prefix_set=None):
        self.ipv_4prefix_set = ipv_4prefix_set  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSetsIpv4PrefixSet]

    def validate(self):
        if self.ipv_4prefix_set:
            for k in self.ipv_4prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv4PrefixSet'] = []
        if self.ipv_4prefix_set is not None:
            for k in self.ipv_4prefix_set:
                result['Ipv4PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_4prefix_set = []
        if m.get('Ipv4PrefixSet') is not None:
            for k in m.get('Ipv4PrefixSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSetsIpv4PrefixSet()
                self.ipv_4prefix_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSetsIpv6PrefixSet(TeaModel):
    def __init__(self, ipv_6prefix=None):
        self.ipv_6prefix = ipv_6prefix  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSetsIpv6PrefixSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSets(TeaModel):
    def __init__(self, ipv_6prefix_set=None):
        self.ipv_6prefix_set = ipv_6prefix_set  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSetsIpv6PrefixSet]

    def validate(self):
        if self.ipv_6prefix_set:
            for k in self.ipv_6prefix_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6PrefixSet'] = []
        if self.ipv_6prefix_set is not None:
            for k in self.ipv_6prefix_set:
                result['Ipv6PrefixSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6prefix_set = []
        if m.get('Ipv6PrefixSet') is not None:
            for k in m.get('Ipv6PrefixSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSetsIpv6PrefixSet()
                self.ipv_6prefix_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set(TeaModel):
    def __init__(self, ipv_6address=None):
        # The IPv6 address of the ENI.
        self.ipv_6address = ipv_6address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets(TeaModel):
    def __init__(self, ipv_6set=None):
        self.ipv_6set = ipv_6set  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set]

    def validate(self):
        if self.ipv_6set:
            for k in self.ipv_6set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Ipv6Set'] = []
        if self.ipv_6set is not None:
            for k in self.ipv_6set:
                result['Ipv6Set'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ipv_6set = []
        if m.get('Ipv6Set') is not None:
            for k in m.get('Ipv6Set'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6SetsIpv6Set()
                self.ipv_6set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp(TeaModel):
    def __init__(self, allocation_id=None, public_ip_address=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.allocation_id = allocation_id  # type: str
        # The EIP of the ENI.
        self.public_ip_address = public_ip_address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet(TeaModel):
    def __init__(self, associated_public_ip=None, primary=None, private_ip_address=None):
        # Details about the elastic IP address (EIP) associated with the ENI.
        self.associated_public_ip = associated_public_ip  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp
        # Indicates whether the IP address is the primary private IP address. Valid values:
        # 
        # *   true: The IP address is the primary private IP address.
        # *   false: The IP address is a secondary private IP address.
        self.primary = primary  # type: bool
        # The private IP address of the instance to which the ENI is attached.
        self.private_ip_address = private_ip_address  # type: str

    def validate(self):
        if self.associated_public_ip:
            self.associated_public_ip.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_public_ip is not None:
            result['AssociatedPublicIp'] = self.associated_public_ip.to_map()
        if self.primary is not None:
            result['Primary'] = self.primary
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssociatedPublicIp') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSetAssociatedPublicIp()
            self.associated_public_ip = temp_model.from_map(m['AssociatedPublicIp'])
        if m.get('Primary') is not None:
            self.primary = m.get('Primary')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets(TeaModel):
    def __init__(self, private_ip_set=None):
        self.private_ip_set = private_ip_set  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet]

    def validate(self):
        if self.private_ip_set:
            for k in self.private_ip_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrivateIpSet'] = []
        if self.private_ip_set is not None:
            for k in self.private_ip_set:
                result['PrivateIpSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.private_ip_set = []
        if m.get('PrivateIpSet') is not None:
            for k in m.get('PrivateIpSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSetsPrivateIpSet()
                self.private_ip_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds(TeaModel):
    def __init__(self, security_group_id=None):
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the ENI.
        self.tag_key = tag_key  # type: str
        # The tag value of the ENI.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet(TeaModel):
    def __init__(self, associated_public_ip=None, attachment=None, creation_time=None, description=None,
                 instance_id=None, ipv_4prefix_sets=None, ipv_6prefix_sets=None, ipv_6sets=None, mac_address=None,
                 network_interface_id=None, network_interface_name=None, network_interface_traffic_mode=None, owner_id=None,
                 private_ip_address=None, private_ip_sets=None, queue_number=None, queue_pair_number=None, resource_group_id=None,
                 security_group_ids=None, service_id=None, service_managed=None, status=None, tags=None, type=None, v_switch_id=None,
                 vpc_id=None, zone_id=None):
        # The EIP that is associated with the secondary private IP address of the ENI.
        self.associated_public_ip = associated_public_ip  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp
        # > This parameter is in invitational preview and is unavailable to general users.
        self.attachment = attachment  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment
        # The time when the ENI was created.
        self.creation_time = creation_time  # type: str
        # The description of the ENI.
        self.description = description  # type: str
        # The ID of the instance to which the ENI is attached.
        # 
        # > If the ENI is managed and controlled by other Alibaba Cloud services, no instance ID is returned.
        self.instance_id = instance_id  # type: str
        self.ipv_4prefix_sets = ipv_4prefix_sets  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSets
        self.ipv_6prefix_sets = ipv_6prefix_sets  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSets
        # The IPv6 addresses of the ENI.
        self.ipv_6sets = ipv_6sets  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets
        # The media access control (MAC) address of the ENI.
        self.mac_address = mac_address  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The name of the ENI.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of the ENI. Valid values:
        # 
        # *   Standard: The TCP communication mode is used.
        # *   HighPerformance: Elastic RDMA Interface (ERI) is enabled and the remote direct memory access (RDMA) communication mode is used.
        # 
        # > This parameter can have a value of HighPerformance only when the ENI is attached to a c7re RDMA-enhanced instance that resides in Beijing Zone K.
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The ID of the account to which the ENI belongs.
        self.owner_id = owner_id  # type: str
        # The private IP address of the ENI.
        self.private_ip_address = private_ip_address  # type: str
        # Details about the private IP addresses.
        self.private_ip_sets = private_ip_sets  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets
        # The number of queues supported by the ENI.
        # 
        # *   If the ENI is a secondary ENI in the InUse state and the number of queues supported by this ENI has never been modified, the default number of queues per secondary ENI that the instance type supports is returned.
        # *   If the number of queues supported by the secondary ENI has been modified, the new number of queues is returned.
        # *   If the ENI is a secondary ENI in the Available state and the number of queues supported by this ENI has never been modified, an empty value is returned.
        # *   If the ENI is a primary ENI, the default number of queues per primary ENI that the instance type supports is returned.
        self.queue_number = queue_number  # type: int
        # > This parameter is in invitational preview and is unavailable to general users.
        self.queue_pair_number = queue_pair_number  # type: int
        # The ID of the resource group to which the ENI belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The IDs of the security groups to which the ENI belongs.
        self.security_group_ids = security_group_ids  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds
        # The ID of the distributor to which the ENI belongs.
        self.service_id = service_id  # type: long
        # Indicates whether the user of the ENI is an Alibaba Cloud service or a distributor.
        self.service_managed = service_managed  # type: bool
        # The state of the ENI.
        self.status = status  # type: str
        # The tags of the ENI.
        self.tags = tags  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags
        # The type of the ENI.
        self.type = type  # type: str
        # The ID of the vSwitch to which the ENI is connected.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the VPC to which the ENI belongs.
        self.vpc_id = vpc_id  # type: str
        # The zone ID of the ENI.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.associated_public_ip:
            self.associated_public_ip.validate()
        if self.attachment:
            self.attachment.validate()
        if self.ipv_4prefix_sets:
            self.ipv_4prefix_sets.validate()
        if self.ipv_6prefix_sets:
            self.ipv_6prefix_sets.validate()
        if self.ipv_6sets:
            self.ipv_6sets.validate()
        if self.private_ip_sets:
            self.private_ip_sets.validate()
        if self.security_group_ids:
            self.security_group_ids.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated_public_ip is not None:
            result['AssociatedPublicIp'] = self.associated_public_ip.to_map()
        if self.attachment is not None:
            result['Attachment'] = self.attachment.to_map()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ipv_4prefix_sets is not None:
            result['Ipv4PrefixSets'] = self.ipv_4prefix_sets.to_map()
        if self.ipv_6prefix_sets is not None:
            result['Ipv6PrefixSets'] = self.ipv_6prefix_sets.to_map()
        if self.ipv_6sets is not None:
            result['Ipv6Sets'] = self.ipv_6sets.to_map()
        if self.mac_address is not None:
            result['MacAddress'] = self.mac_address
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.private_ip_sets is not None:
            result['PrivateIpSets'] = self.private_ip_sets.to_map()
        if self.queue_number is not None:
            result['QueueNumber'] = self.queue_number
        if self.queue_pair_number is not None:
            result['QueuePairNumber'] = self.queue_pair_number
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids.to_map()
        if self.service_id is not None:
            result['ServiceID'] = self.service_id
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.type is not None:
            result['Type'] = self.type
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssociatedPublicIp') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAssociatedPublicIp()
            self.associated_public_ip = temp_model.from_map(m['AssociatedPublicIp'])
        if m.get('Attachment') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetAttachment()
            self.attachment = temp_model.from_map(m['Attachment'])
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Ipv4PrefixSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv4PrefixSets()
            self.ipv_4prefix_sets = temp_model.from_map(m['Ipv4PrefixSets'])
        if m.get('Ipv6PrefixSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6PrefixSets()
            self.ipv_6prefix_sets = temp_model.from_map(m['Ipv6PrefixSets'])
        if m.get('Ipv6Sets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetIpv6Sets()
            self.ipv_6sets = temp_model.from_map(m['Ipv6Sets'])
        if m.get('MacAddress') is not None:
            self.mac_address = m.get('MacAddress')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('PrivateIpSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetPrivateIpSets()
            self.private_ip_sets = temp_model.from_map(m['PrivateIpSets'])
        if m.get('QueueNumber') is not None:
            self.queue_number = m.get('QueueNumber')
        if m.get('QueuePairNumber') is not None:
            self.queue_pair_number = m.get('QueuePairNumber')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupIds') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetSecurityGroupIds()
            self.security_group_ids = temp_model.from_map(m['SecurityGroupIds'])
        if m.get('ServiceID') is not None:
            self.service_id = m.get('ServiceID')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSetTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets(TeaModel):
    def __init__(self, network_interface_set=None):
        self.network_interface_set = network_interface_set  # type: list[DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet]

    def validate(self):
        if self.network_interface_set:
            for k in self.network_interface_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkInterfaceSet'] = []
        if self.network_interface_set is not None:
            for k in self.network_interface_set:
                result['NetworkInterfaceSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_interface_set = []
        if m.get('NetworkInterfaceSet') is not None:
            for k in m.get('NetworkInterfaceSet'):
                temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSetsNetworkInterfaceSet()
                self.network_interface_set.append(temp_model.from_map(k))
        return self


class DescribeNetworkInterfacesResponseBody(TeaModel):
    def __init__(self, network_interface_sets=None, next_token=None, page_number=None, page_size=None,
                 request_id=None, total_count=None):
        # Details about the ENIs.
        self.network_interface_sets = network_interface_sets  # type: DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets
        # The query token returned in this call.
        self.next_token = next_token  # type: str
        # The page number of the returned page.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters to perform a paged query.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters to perform a paged query.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of ENIs.
        # 
        # > If you specify the `MaxResults` and `NextToken` parameters to perform a paged query, the value of the `TotalCount` response parameter is invalid.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.network_interface_sets:
            self.network_interface_sets.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_interface_sets is not None:
            result['NetworkInterfaceSets'] = self.network_interface_sets.to_map()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkInterfaceSets') is not None:
            temp_model = DescribeNetworkInterfacesResponseBodyNetworkInterfaceSets()
            self.network_interface_sets = temp_model.from_map(m['NetworkInterfaceSets'])
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeNetworkInterfacesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNetworkInterfacesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNetworkInterfacesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkInterfacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNewProjectEipMonitorDataRequest(TeaModel):
    def __init__(self, allocation_id=None, end_time=None, owner_account=None, owner_id=None, period=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, start_time=None):
        self.allocation_id = allocation_id  # type: str
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.period = period  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNewProjectEipMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData(TeaModel):
    def __init__(self, eip_bandwidth=None, eip_flow=None, eip_packets=None, eip_rx=None, eip_tx=None,
                 time_stamp=None):
        self.eip_bandwidth = eip_bandwidth  # type: int
        self.eip_flow = eip_flow  # type: int
        self.eip_packets = eip_packets  # type: int
        self.eip_rx = eip_rx  # type: int
        self.eip_tx = eip_tx  # type: int
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_bandwidth is not None:
            result['EipBandwidth'] = self.eip_bandwidth
        if self.eip_flow is not None:
            result['EipFlow'] = self.eip_flow
        if self.eip_packets is not None:
            result['EipPackets'] = self.eip_packets
        if self.eip_rx is not None:
            result['EipRX'] = self.eip_rx
        if self.eip_tx is not None:
            result['EipTX'] = self.eip_tx
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EipBandwidth') is not None:
            self.eip_bandwidth = m.get('EipBandwidth')
        if m.get('EipFlow') is not None:
            self.eip_flow = m.get('EipFlow')
        if m.get('EipPackets') is not None:
            self.eip_packets = m.get('EipPackets')
        if m.get('EipRX') is not None:
            self.eip_rx = m.get('EipRX')
        if m.get('EipTX') is not None:
            self.eip_tx = m.get('EipTX')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas(TeaModel):
    def __init__(self, eip_monitor_data=None):
        self.eip_monitor_data = eip_monitor_data  # type: list[DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData]

    def validate(self):
        if self.eip_monitor_data:
            for k in self.eip_monitor_data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EipMonitorData'] = []
        if self.eip_monitor_data is not None:
            for k in self.eip_monitor_data:
                result['EipMonitorData'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.eip_monitor_data = []
        if m.get('EipMonitorData') is not None:
            for k in m.get('EipMonitorData'):
                temp_model = DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatasEipMonitorData()
                self.eip_monitor_data.append(temp_model.from_map(k))
        return self


class DescribeNewProjectEipMonitorDataResponseBody(TeaModel):
    def __init__(self, eip_monitor_datas=None, request_id=None):
        self.eip_monitor_datas = eip_monitor_datas  # type: DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas
        self.request_id = request_id  # type: str

    def validate(self):
        if self.eip_monitor_datas:
            self.eip_monitor_datas.validate()

    def to_map(self):
        _map = super(DescribeNewProjectEipMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.eip_monitor_datas is not None:
            result['EipMonitorDatas'] = self.eip_monitor_datas.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EipMonitorDatas') is not None:
            temp_model = DescribeNewProjectEipMonitorDataResponseBodyEipMonitorDatas()
            self.eip_monitor_datas = temp_model.from_map(m['EipMonitorDatas'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNewProjectEipMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNewProjectEipMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNewProjectEipMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNewProjectEipMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePhysicalConnectionsRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePhysicalConnectionsRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribePhysicalConnectionsRequest(TeaModel):
    def __init__(self, client_token=None, filter=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.filter = filter  # type: list[DescribePhysicalConnectionsRequestFilter]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePhysicalConnectionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribePhysicalConnectionsRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType(TeaModel):
    def __init__(self, access_point_id=None, ad_location=None, bandwidth=None, business_status=None,
                 circuit_code=None, creation_time=None, description=None, enabled_time=None, line_operator=None, name=None,
                 peer_location=None, physical_connection_id=None, port_number=None, port_type=None,
                 redundant_physical_connection_id=None, spec=None, status=None, type=None):
        self.access_point_id = access_point_id  # type: str
        self.ad_location = ad_location  # type: str
        self.bandwidth = bandwidth  # type: long
        self.business_status = business_status  # type: str
        self.circuit_code = circuit_code  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.enabled_time = enabled_time  # type: str
        self.line_operator = line_operator  # type: str
        self.name = name  # type: str
        self.peer_location = peer_location  # type: str
        self.physical_connection_id = physical_connection_id  # type: str
        self.port_number = port_number  # type: str
        self.port_type = port_type  # type: str
        self.redundant_physical_connection_id = redundant_physical_connection_id  # type: str
        self.spec = spec  # type: str
        self.status = status  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.ad_location is not None:
            result['AdLocation'] = self.ad_location
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.enabled_time is not None:
            result['EnabledTime'] = self.enabled_time
        if self.line_operator is not None:
            result['LineOperator'] = self.line_operator
        if self.name is not None:
            result['Name'] = self.name
        if self.peer_location is not None:
            result['PeerLocation'] = self.peer_location
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.port_number is not None:
            result['PortNumber'] = self.port_number
        if self.port_type is not None:
            result['PortType'] = self.port_type
        if self.redundant_physical_connection_id is not None:
            result['RedundantPhysicalConnectionId'] = self.redundant_physical_connection_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('AdLocation') is not None:
            self.ad_location = m.get('AdLocation')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnabledTime') is not None:
            self.enabled_time = m.get('EnabledTime')
        if m.get('LineOperator') is not None:
            self.line_operator = m.get('LineOperator')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PeerLocation') is not None:
            self.peer_location = m.get('PeerLocation')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('PortNumber') is not None:
            self.port_number = m.get('PortNumber')
        if m.get('PortType') is not None:
            self.port_type = m.get('PortType')
        if m.get('RedundantPhysicalConnectionId') is not None:
            self.redundant_physical_connection_id = m.get('RedundantPhysicalConnectionId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet(TeaModel):
    def __init__(self, physical_connection_type=None):
        self.physical_connection_type = physical_connection_type  # type: list[DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType]

    def validate(self):
        if self.physical_connection_type:
            for k in self.physical_connection_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PhysicalConnectionType'] = []
        if self.physical_connection_type is not None:
            for k in self.physical_connection_type:
                result['PhysicalConnectionType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.physical_connection_type = []
        if m.get('PhysicalConnectionType') is not None:
            for k in m.get('PhysicalConnectionType'):
                temp_model = DescribePhysicalConnectionsResponseBodyPhysicalConnectionSetPhysicalConnectionType()
                self.physical_connection_type.append(temp_model.from_map(k))
        return self


class DescribePhysicalConnectionsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, physical_connection_set=None, request_id=None,
                 total_count=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.physical_connection_set = physical_connection_set  # type: DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int

    def validate(self):
        if self.physical_connection_set:
            self.physical_connection_set.validate()

    def to_map(self):
        _map = super(DescribePhysicalConnectionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.physical_connection_set is not None:
            result['PhysicalConnectionSet'] = self.physical_connection_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PhysicalConnectionSet') is not None:
            temp_model = DescribePhysicalConnectionsResponseBodyPhysicalConnectionSet()
            self.physical_connection_set = temp_model.from_map(m['PhysicalConnectionSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribePhysicalConnectionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePhysicalConnectionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePhysicalConnectionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePhysicalConnectionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrefixListAssociationsRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, owner_account=None, owner_id=None, prefix_list_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The query token. Set the value to the `NextToken` value returned in the previous call to the DescribePrefixListAssociations operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The region ID of the prefix list. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListAssociationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation(TeaModel):
    def __init__(self, resource_id=None, resource_type=None):
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The type of the resource.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribePrefixListAssociationsResponseBodyPrefixListAssociations(TeaModel):
    def __init__(self, prefix_list_association=None):
        self.prefix_list_association = prefix_list_association  # type: list[DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation]

    def validate(self):
        if self.prefix_list_association:
            for k in self.prefix_list_association:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePrefixListAssociationsResponseBodyPrefixListAssociations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrefixListAssociation'] = []
        if self.prefix_list_association is not None:
            for k in self.prefix_list_association:
                result['PrefixListAssociation'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.prefix_list_association = []
        if m.get('PrefixListAssociation') is not None:
            for k in m.get('PrefixListAssociation'):
                temp_model = DescribePrefixListAssociationsResponseBodyPrefixListAssociationsPrefixListAssociation()
                self.prefix_list_association.append(temp_model.from_map(k))
        return self


class DescribePrefixListAssociationsResponseBody(TeaModel):
    def __init__(self, next_token=None, prefix_list_associations=None, request_id=None):
        # The query token returned in this call. If the return value is empty, no more data is returned.
        self.next_token = next_token  # type: str
        # Details about the resources that are associated with the prefix list.
        self.prefix_list_associations = prefix_list_associations  # type: DescribePrefixListAssociationsResponseBodyPrefixListAssociations
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.prefix_list_associations:
            self.prefix_list_associations.validate()

    def to_map(self):
        _map = super(DescribePrefixListAssociationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.prefix_list_associations is not None:
            result['PrefixListAssociations'] = self.prefix_list_associations.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PrefixListAssociations') is not None:
            temp_model = DescribePrefixListAssociationsResponseBodyPrefixListAssociations()
            self.prefix_list_associations = temp_model.from_map(m['PrefixListAssociations'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePrefixListAssociationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePrefixListAssociationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePrefixListAssociationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrefixListAssociationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrefixListAttributesRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, prefix_list_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The region ID of the prefix list. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribePrefixListAttributesResponseBodyEntriesEntry(TeaModel):
    def __init__(self, cidr=None, description=None):
        # The CIDR block in the entry in the prefix list.
        self.cidr = cidr  # type: str
        # The description of the entry in the prefix list.
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListAttributesResponseBodyEntriesEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr is not None:
            result['Cidr'] = self.cidr
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cidr') is not None:
            self.cidr = m.get('Cidr')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class DescribePrefixListAttributesResponseBodyEntries(TeaModel):
    def __init__(self, entry=None):
        self.entry = entry  # type: list[DescribePrefixListAttributesResponseBodyEntriesEntry]

    def validate(self):
        if self.entry:
            for k in self.entry:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePrefixListAttributesResponseBodyEntries, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Entry'] = []
        if self.entry is not None:
            for k in self.entry:
                result['Entry'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.entry = []
        if m.get('Entry') is not None:
            for k in m.get('Entry'):
                temp_model = DescribePrefixListAttributesResponseBodyEntriesEntry()
                self.entry.append(temp_model.from_map(k))
        return self


class DescribePrefixListAttributesResponseBody(TeaModel):
    def __init__(self, address_family=None, creation_time=None, description=None, entries=None, max_entries=None,
                 prefix_list_id=None, prefix_list_name=None, request_id=None):
        # The IP address family of the prefix list. Valid values:
        # 
        # *   IPv4
        # *   IPv6
        self.address_family = address_family  # type: str
        # The time when the prefix list was created.
        self.creation_time = creation_time  # type: str
        # The description of the prefix list.
        self.description = description  # type: str
        # Details about the entries in the prefix list.
        self.entries = entries  # type: DescribePrefixListAttributesResponseBodyEntries
        # The maximum number of entries that the prefix list can contain.
        self.max_entries = max_entries  # type: int
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The name of the prefix list.
        self.prefix_list_name = prefix_list_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.entries:
            self.entries.validate()

    def to_map(self):
        _map = super(DescribePrefixListAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_family is not None:
            result['AddressFamily'] = self.address_family
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.entries is not None:
            result['Entries'] = self.entries.to_map()
        if self.max_entries is not None:
            result['MaxEntries'] = self.max_entries
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.prefix_list_name is not None:
            result['PrefixListName'] = self.prefix_list_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddressFamily') is not None:
            self.address_family = m.get('AddressFamily')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Entries') is not None:
            temp_model = DescribePrefixListAttributesResponseBodyEntries()
            self.entries = temp_model.from_map(m['Entries'])
        if m.get('MaxEntries') is not None:
            self.max_entries = m.get('MaxEntries')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('PrefixListName') is not None:
            self.prefix_list_name = m.get('PrefixListName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePrefixListAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePrefixListAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePrefixListAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrefixListAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePrefixListsRequest(TeaModel):
    def __init__(self, address_family=None, max_results=None, next_token=None, owner_account=None, owner_id=None,
                 prefix_list_id=None, prefix_list_name=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IP address family of the prefix list. Valid values:
        # 
        # *   IPv4
        # *   IPv6
        # 
        # This parameter is empty by default, which indicates that all prefix lists are queried.
        self.address_family = address_family  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The query token. Set the value to the `NextToken` value returned in the previous call to the DescribePrefixLists operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The IDs of prefix list.
        self.prefix_list_id = prefix_list_id  # type: list[str]
        # The name of the prefix list.
        self.prefix_list_name = prefix_list_name  # type: str
        # The region ID. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_family is not None:
            result['AddressFamily'] = self.address_family
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.prefix_list_name is not None:
            result['PrefixListName'] = self.prefix_list_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddressFamily') is not None:
            self.address_family = m.get('AddressFamily')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('PrefixListName') is not None:
            self.prefix_list_name = m.get('PrefixListName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribePrefixListsResponseBodyPrefixListsPrefixList(TeaModel):
    def __init__(self, address_family=None, association_count=None, creation_time=None, description=None,
                 max_entries=None, prefix_list_id=None, prefix_list_name=None):
        # The IP address family of the prefix list. Valid values:
        # 
        # *   IPv4
        # *   IPv6
        self.address_family = address_family  # type: str
        # The number of associated resources.
        self.association_count = association_count  # type: int
        # The time when the prefix list was created.
        self.creation_time = creation_time  # type: str
        # The description of the prefix list.
        self.description = description  # type: str
        # The maximum number of entries that the prefix list can contain.
        self.max_entries = max_entries  # type: int
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The name of the prefix list.
        self.prefix_list_name = prefix_list_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePrefixListsResponseBodyPrefixListsPrefixList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address_family is not None:
            result['AddressFamily'] = self.address_family
        if self.association_count is not None:
            result['AssociationCount'] = self.association_count
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.max_entries is not None:
            result['MaxEntries'] = self.max_entries
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.prefix_list_name is not None:
            result['PrefixListName'] = self.prefix_list_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddressFamily') is not None:
            self.address_family = m.get('AddressFamily')
        if m.get('AssociationCount') is not None:
            self.association_count = m.get('AssociationCount')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MaxEntries') is not None:
            self.max_entries = m.get('MaxEntries')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('PrefixListName') is not None:
            self.prefix_list_name = m.get('PrefixListName')
        return self


class DescribePrefixListsResponseBodyPrefixLists(TeaModel):
    def __init__(self, prefix_list=None):
        self.prefix_list = prefix_list  # type: list[DescribePrefixListsResponseBodyPrefixListsPrefixList]

    def validate(self):
        if self.prefix_list:
            for k in self.prefix_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePrefixListsResponseBodyPrefixLists, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PrefixList'] = []
        if self.prefix_list is not None:
            for k in self.prefix_list:
                result['PrefixList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.prefix_list = []
        if m.get('PrefixList') is not None:
            for k in m.get('PrefixList'):
                temp_model = DescribePrefixListsResponseBodyPrefixListsPrefixList()
                self.prefix_list.append(temp_model.from_map(k))
        return self


class DescribePrefixListsResponseBody(TeaModel):
    def __init__(self, next_token=None, prefix_lists=None, request_id=None):
        # The query token returned in this call. If the return value is empty, no more data is returned.
        self.next_token = next_token  # type: str
        # Details about the prefix lists.
        self.prefix_lists = prefix_lists  # type: DescribePrefixListsResponseBodyPrefixLists
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.prefix_lists:
            self.prefix_lists.validate()

    def to_map(self):
        _map = super(DescribePrefixListsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.prefix_lists is not None:
            result['PrefixLists'] = self.prefix_lists.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PrefixLists') is not None:
            temp_model = DescribePrefixListsResponseBodyPrefixLists()
            self.prefix_lists = temp_model.from_map(m['PrefixLists'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePrefixListsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePrefixListsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePrefixListsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePrefixListsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePriceRequestDataDisk(TeaModel):
    def __init__(self, category=None, performance_level=None, size=None):
        self.category = category  # type: str
        self.performance_level = performance_level  # type: str
        self.size = size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePriceRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceRequestSystemDisk(TeaModel):
    def __init__(self, category=None, performance_level=None, size=None):
        # The category of the system disk. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   ephemeral_ssd: local SSD
        # *   cloud_essd: enhanced SSD (ESSD)
        # 
        # Description of the default values:
        # 
        # *   When the InstanceType parameter is set to a retired instance type and the `IoOptimized` parameter is set to `none`, the default value of this parameter is `cloud`.
        # *   In other cases, the default value of this parameter is `cloud_efficiency`.
        self.category = category  # type: str
        # The performance level of the system disk when it is an ESSD. This parameter is valid only when the `SystemDiskCategory` parameter is set to cloud_essd. Default value: PL1. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        self.performance_level = performance_level  # type: str
        # The size of the system disk. Unit: GiB. Valid values: 20 to 500.
        # 
        # Default value: 40 or the image size, whichever is greater.
        # 
        # >  The value of this parameter must be at least 20 and greater than or equal to the image size.
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePriceRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribePriceRequest(TeaModel):
    def __init__(self, data_disk=None, system_disk=None, amount=None, assurance_times=None, capacity=None,
                 dedicated_host_type=None, image_id=None, instance_amount=None, instance_cpu_core_count=None,
                 instance_network_type=None, instance_type=None, instance_type_list=None, internet_charge_type=None,
                 internet_max_bandwidth_out=None, io_optimized=None, isp=None, offering_type=None, owner_account=None, owner_id=None,
                 period=None, platform=None, price_unit=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, resource_type=None, scope=None, spot_duration=None, spot_strategy=None, zone_id=None):
        self.data_disk = data_disk  # type: list[DescribePriceRequestDataDisk]
        self.system_disk = system_disk  # type: DescribePriceRequestSystemDisk
        # The number of ECS instances. You can specify this parameter when you want to query the prices of multiple instances that have specific specifications. Valid values: 1 to 1000.
        # 
        # Default value: 1.
        self.amount = amount  # type: int
        # The total number of times that the elasticity assurance can be applied. Set the value to Unlimited. This value indicates that the elasticity assurance can be applied an unlimited number of times within its effective duration.
        # 
        # Default value: Unlimited.
        self.assurance_times = assurance_times  # type: str
        self.capacity = capacity  # type: int
        # The dedicated host type. You can call the [DescribeDedicatedHostTypes](~~134240~~) operation to obtain the most recent list of dedicated host types.
        self.dedicated_host_type = dedicated_host_type  # type: str
        # The ID of the image. Images contain the runtime environment to load when instances start. You can call the [DescribeImages](~~25534~~) operation to query the available images. If you do not specify this parameter, the system queries the prices of Linux images.
        self.image_id = image_id  # type: str
        self.instance_amount = instance_amount  # type: int
        self.instance_cpu_core_count = instance_cpu_core_count  # type: int
        # The network type of the instance. Valid values:
        # 
        # *   classic: classic network
        # *   vpc: Virtual Private Cloud (VPC)
        # 
        # Default value: vpc.
        self.instance_network_type = instance_network_type  # type: str
        # The instance type. When the `ResourceType` parameter is set to `instance`, you must specify the InstanceType parameter. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list.
        self.instance_type = instance_type  # type: str
        self.instance_type_list = instance_type_list  # type: list[str]
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # Default value: PayByTraffic.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # Default value: 0.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        # 
        # If the instance type specified by the InstanceType parameter belongs to [Generation I instance families](~~55263~~), the default value is none.
        # 
        # If the instance type specified by the InstanceType parameter does not belong to [Generation I instance families](~~55263~~), the default value is optimized.
        self.io_optimized = io_optimized  # type: str
        self.isp = isp  # type: str
        self.offering_type = offering_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The billing cycle of the ECS instance. Valid values:
        # 
        # *   Valid values when PriceUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, and 9.
        # *   Valid values when PriceUnit is set to Year: 1, 2, 3, 4, and 5.
        # *   Set the value to 1 when PriceUnit is set to Hour.
        # 
        # Default value: 1
        self.period = period  # type: int
        self.platform = platform  # type: str
        # The pricing unit of the ECS resource. Default value: Hour. Valid values:
        # 
        # *   Month
        # *   Year
        # *   Hour
        self.price_unit = price_unit  # type: str
        # The region ID of the ECS resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: queries the most recent prices of ECS instances. When this parameter is set to `instance`, you must specify the `InstanceType` parameter.
        # *   disk: queries the most recent prices of disks. When this parameter is set to `disk`, you must specify both the `DataDisk.1.Category` and `DataDisk.1.Size` parameters.
        # *   bandwidth: queries the most recent prices for network usage.
        # *   ddh: queries the most recent prices of dedicated hosts.
        # *   ElasticityAssurance: queries the most recent prices of elasticity assurances. When this parameter is set to `ElasticityAssurance`, you must specify the `InstanceType` parameter.
        # *   ElasticityAssurance: queries the most recent prices of capacity reservations. When this parameter is set to `CapacityReservation`, you must specify the `InstanceType` parameter.
        # 
        # Default value: instance.
        self.resource_type = resource_type  # type: str
        self.scope = scope  # type: str
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The preemption policy for the pay-as-you-go instance. Valid values:
        # 
        # *   NoSpot: The instance is a regular pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is a preemptible instance for which the market price is automatically used as the bid price. The market price can be up to the pay-as-you-go price.
        # 
        # Default value: NoSpot.
        # 
        # >  This parameter is valid only when the `PriceUnit` parameter is set to Hour and the `Period` parameter is set to 1. The default value of the `PriceUnit` parameter is `Hour` and the default value of the `Period` parameter is `1`. Therefore, you do not need to set the `PriceUnit` and `Period` parameters when you set the SpotStrategy parameter.
        self.spot_strategy = spot_strategy  # type: str
        # The zone ID of the ECS resource.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super(DescribePriceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.assurance_times is not None:
            result['AssuranceTimes'] = self.assurance_times
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_cpu_core_count is not None:
            result['InstanceCpuCoreCount'] = self.instance_cpu_core_count
        if self.instance_network_type is not None:
            result['InstanceNetworkType'] = self.instance_network_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_list is not None:
            result['InstanceTypeList'] = self.instance_type_list
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.offering_type is not None:
            result['OfferingType'] = self.offering_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.price_unit is not None:
            result['PriceUnit'] = self.price_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = DescribePriceRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('SystemDisk') is not None:
            temp_model = DescribePriceRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('AssuranceTimes') is not None:
            self.assurance_times = m.get('AssuranceTimes')
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceCpuCoreCount') is not None:
            self.instance_cpu_core_count = m.get('InstanceCpuCoreCount')
        if m.get('InstanceNetworkType') is not None:
            self.instance_network_type = m.get('InstanceNetworkType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeList') is not None:
            self.instance_type_list = m.get('InstanceTypeList')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('OfferingType') is not None:
            self.offering_type = m.get('OfferingType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('PriceUnit') is not None:
            self.price_unit = m.get('PriceUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule(TeaModel):
    def __init__(self, description=None, rule_id=None):
        # The description of the pricing rule.
        self.description = description  # type: str
        # The ID of the pricing rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules(TeaModel):
    def __init__(self, rule=None):
        self.rule = rule  # type: list[DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule]

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule()
                self.rule.append(temp_model.from_map(k))
        return self


class DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel(TeaModel):
    def __init__(self, discount_price=None, original_price=None, resource=None, sub_rules=None, trade_price=None):
        # The discount.
        self.discount_price = discount_price  # type: float
        # The original price.
        self.original_price = original_price  # type: float
        # The name of the resource.
        self.resource = resource  # type: str
        # Details about the pricing rules.
        self.sub_rules = sub_rules  # type: DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules
        # The transaction price.
        self.trade_price = trade_price  # type: float

    def validate(self):
        if self.sub_rules:
            self.sub_rules.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.resource is not None:
            result['Resource'] = self.resource
        if self.sub_rules is not None:
            result['SubRules'] = self.sub_rules.to_map()
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        if m.get('SubRules') is not None:
            temp_model = DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules()
            self.sub_rules = temp_model.from_map(m['SubRules'])
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribePriceResponseBodyPriceInfoPriceDetailInfos(TeaModel):
    def __init__(self, resource_price_model=None):
        self.resource_price_model = resource_price_model  # type: list[DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel]

    def validate(self):
        if self.resource_price_model:
            for k in self.resource_price_model:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoPriceDetailInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResourcePriceModel'] = []
        if self.resource_price_model is not None:
            for k in self.resource_price_model:
                result['ResourcePriceModel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource_price_model = []
        if m.get('ResourcePriceModel') is not None:
            for k in m.get('ResourcePriceModel'):
                temp_model = DescribePriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel()
                self.resource_price_model.append(temp_model.from_map(k))
        return self


class DescribePriceResponseBodyPriceInfoPrice(TeaModel):
    def __init__(self, currency=None, detail_infos=None, discount_price=None, original_price=None,
                 reserved_instance_hour_price=None, trade_price=None):
        # The currency unit. 
        # 
        # Alibaba Cloud China site (aliyun.com): CNY. 
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # Details about the price. 
        # 
        # >  This parameter is in invitational preview and unavailable.
        self.detail_infos = detail_infos  # type: DescribePriceResponseBodyPriceInfoPriceDetailInfos
        # The discount.
        self.discount_price = discount_price  # type: float
        # The original price.
        self.original_price = original_price  # type: float
        # The hourly price of the reserved instance for which the No Upfront or Partial Upfront payment option is used.
        self.reserved_instance_hour_price = reserved_instance_hour_price  # type: float
        # The transaction price, which is equal to the original price minus the discount.
        self.trade_price = trade_price  # type: float

    def validate(self):
        if self.detail_infos:
            self.detail_infos.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoPrice, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.detail_infos is not None:
            result['DetailInfos'] = self.detail_infos.to_map()
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.reserved_instance_hour_price is not None:
            result['ReservedInstanceHourPrice'] = self.reserved_instance_hour_price
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('DetailInfos') is not None:
            temp_model = DescribePriceResponseBodyPriceInfoPriceDetailInfos()
            self.detail_infos = temp_model.from_map(m['DetailInfos'])
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('ReservedInstanceHourPrice') is not None:
            self.reserved_instance_hour_price = m.get('ReservedInstanceHourPrice')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribePriceResponseBodyPriceInfoRulesRule(TeaModel):
    def __init__(self, description=None, rule_id=None):
        # The description of the promotion rule.
        self.description = description  # type: str
        # The ID of the promotion rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoRulesRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribePriceResponseBodyPriceInfoRules(TeaModel):
    def __init__(self, rule=None):
        self.rule = rule  # type: list[DescribePriceResponseBodyPriceInfoRulesRule]

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfoRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = DescribePriceResponseBodyPriceInfoRulesRule()
                self.rule.append(temp_model.from_map(k))
        return self


class DescribePriceResponseBodyPriceInfo(TeaModel):
    def __init__(self, price=None, rules=None):
        # The price.
        self.price = price  # type: DescribePriceResponseBodyPriceInfoPrice
        # Details about the promotion rules.
        self.rules = rules  # type: DescribePriceResponseBodyPriceInfoRules

    def validate(self):
        if self.price:
            self.price.validate()
        if self.rules:
            self.rules.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBodyPriceInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price is not None:
            result['Price'] = self.price.to_map()
        if self.rules is not None:
            result['Rules'] = self.rules.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Price') is not None:
            temp_model = DescribePriceResponseBodyPriceInfoPrice()
            self.price = temp_model.from_map(m['Price'])
        if m.get('Rules') is not None:
            temp_model = DescribePriceResponseBodyPriceInfoRules()
            self.rules = temp_model.from_map(m['Rules'])
        return self


class DescribePriceResponseBody(TeaModel):
    def __init__(self, price_info=None, request_id=None):
        # Details about the prices and discount rules.
        self.price_info = price_info  # type: DescribePriceResponseBodyPriceInfo
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.price_info:
            self.price_info.validate()

    def to_map(self):
        _map = super(DescribePriceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price_info is not None:
            result['PriceInfo'] = self.price_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PriceInfo') is not None:
            temp_model = DescribePriceResponseBodyPriceInfo()
            self.price_info = temp_model.from_map(m['PriceInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePriceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePriceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePriceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRecommendInstanceTypeRequest(TeaModel):
    def __init__(self, cores=None, instance_charge_type=None, instance_family_level=None, instance_type=None,
                 instance_type_family=None, io_optimized=None, max_price=None, memory=None, network_type=None, owner_account=None,
                 owner_id=None, priority_strategy=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 scene=None, spot_strategy=None, system_disk_category=None, zone_id=None, zone_match_mode=None):
        # The number of vCPUs of the instance.
        # 
        # >  If the `Cores` and `Memory` parameters are both specified, all instance types that offer the vCPUs and memory size specified by the parameters are matched.
        self.cores = cores  # type: int
        # The billing method of the instances of the instance type. For more information, see [Billing overview](~~25398~~). Valid values:
        # 
        # * PrePaid: subscription
        # * PostPaid: pay-as-you-go
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The level of the instance family. Valid values:
        # 
        # * EntryLevel
        # * EnterpriseLevel.
        # * CreditEntryLevel. For more information, see [Burstable instance families](~~59977~~).
        self.instance_family_level = instance_family_level  # type: str
        # The specified instance type. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list.
        # 
        # >  If the `InstanceType` parameter is specified, none of the `Cores` and `Memory` parameters can be specified.
        self.instance_type = instance_type  # type: str
        # Instance families to be filtered out. You can specify up to 10 instance families.
        self.instance_type_family = instance_type_family  # type: list[str]
        # Specifies whether to match I/O optimized instances. The IoOptimized parameter cannot be specified when the instance is not I/O optimized. Valid values:
        # 
        # * optimized: matches I/O optimized instances.
        # * none: matches non-I/O optimized instances.
        # 
        # Default value: optimized.
        # 
        # If you query alternative instance types for retired instance types, this parameter is set to none by default. Default value: none.
        self.io_optimized = io_optimized  # type: str
        # The maximum hourly price for pay-as-you-go instances or preemptible instances.
        # 
        # >  If this parameter is specified, the `SpotStrategy` parameter must be set to `SpotWithPriceLimit`.
        self.max_price = max_price  # type: float
        # The memory size of the instance. Unit: GiB.
        # 
        # >  If the `Cores` and `Memory` parameters are both specified, all instance types that offer the vCPUs and memory size specified by the parameters are matched.
        self.memory = memory  # type: float
        # The network type of the ECS instance. Valid values:
        # 
        # *   classic: classic network
        # *   vpc: VPC
        # 
        # Default value: vpc.
        self.network_type = network_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The policy for recommending instance types. Valid values:
        # 
        # * InventoryFirst: Instance types are recommended in descending order based on resource availability.
        # * PriceFirst: Instance types are recommended in ascending order based on hourly price per vCPU.
        # * NewProductFirst: The latest instance types are recommended first.
        # 
        # Default value: InventoryFirst.
        self.priority_strategy = priority_strategy  # type: str
        # The region ID of the alternative instance types. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies the scenario in which the instance type is recommended. Valid values:
        # 
        # * UPGRADE: instance type upgrade or downgrade
        # * CREATE: instance creation
        # 
        # Default value: CREATE.
        self.scene = scene  # type: str
        # The bidding policy of preemptible instances. Valid values:
        # 
        # * NoSpot: applies to regular pay-as-you-go instances.
        # * SpotWithPriceLimit: applies to preemptible instances that have user-defined maximum hourly prices.
        # * SpotAsPriceGo: applies to preemptible instances that are of the market price at the time of purchase.
        # 
        # > If the `SpotStrategy` parameter is specified, the `InstanceChargeType` parameter must be set to `PostPaid`.
        # 
        # Default value: NoSpot.
        self.spot_strategy = spot_strategy  # type: str
        # The category of the system disk. Valid values:
        # 
        # * cloud_efficiency: ultra disk
        # * cloud_ssd: standard SSD
        # * cloud_essd: enhanced SSD (ESSD)
        # * cloud: basic disk
        # 
        # For non-I/O optimized instances, the default value is cloud.
        # 
        # For I/O optimized instances, the default value is cloud_efficiency.
        self.system_disk_category = system_disk_category  # type: str
        # The zone ID of the alternative instance types. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        # 
        # When you specify this parameter, we recommend that you set ZoneMatchMode to the default value Include. This value indicates that instance types in the zone specified by ZoneId are preferentially recommended, and instance types in other zones in the same region are also listed.
        self.zone_id = zone_id  # type: str
        # Specifies which alternative instance types are recommended. Valid values:
        # 
        # * Strict: recommends only alternative instance types in the zone specified by ZoneId.
        # * Include: recommends all instance types in all the zones in the same region as the specified instance type.
        # 
        # When `ZoneId` is specified, the default value of this parameter is Strict. This value indicates that only alternative instance types in the zone specified by ZoneId are recommended.
        self.zone_match_mode = zone_match_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_family_level is not None:
            result['InstanceFamilyLevel'] = self.instance_family_level
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.max_price is not None:
            result['MaxPrice'] = self.max_price
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.priority_strategy is not None:
            result['PriorityStrategy'] = self.priority_strategy
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        if self.zone_match_mode is not None:
            result['ZoneMatchMode'] = self.zone_match_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceFamilyLevel') is not None:
            self.instance_family_level = m.get('InstanceFamilyLevel')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('MaxPrice') is not None:
            self.max_price = m.get('MaxPrice')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PriorityStrategy') is not None:
            self.priority_strategy = m.get('PriorityStrategy')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        if m.get('ZoneMatchMode') is not None:
            self.zone_match_mode = m.get('ZoneMatchMode')
        return self


class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType(TeaModel):
    def __init__(self, cores=None, generation=None, instance_type=None, instance_type_family=None, memory=None,
                 support_io_optimized=None):
        # The number of vCPUs of the instance type.
        self.cores = cores  # type: int
        # The generation of the instance family.
        self.generation = generation  # type: str
        # The name of the instance type.
        self.instance_type = instance_type  # type: str
        # The instance family.
        self.instance_type_family = instance_type_family  # type: str
        # The memory size of the instance type. Unit: MB.
        self.memory = memory  # type: int
        # Indicates whether the instance type supports I/O optimization.
        self.support_io_optimized = support_io_optimized  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.generation is not None:
            result['Generation'] = self.generation
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.support_io_optimized is not None:
            result['SupportIoOptimized'] = self.support_io_optimized
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('Generation') is not None:
            self.generation = m.get('Generation')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('SupportIoOptimized') is not None:
            self.support_io_optimized = m.get('SupportIoOptimized')
        return self


class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes(TeaModel):
    def __init__(self, network_type=None):
        self.network_type = network_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        return self


class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone(TeaModel):
    def __init__(self, network_types=None, zone_no=None):
        # Details of network types of the alternative instance types.
        self.network_types = network_types  # type: DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes
        # The zone ID of the specified instance type.
        self.zone_no = zone_no  # type: str

    def validate(self):
        if self.network_types:
            self.network_types.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_types is not None:
            result['NetworkTypes'] = self.network_types.to_map()
        if self.zone_no is not None:
            result['ZoneNo'] = self.zone_no
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkTypes') is not None:
            temp_model = DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZoneNetworkTypes()
            self.network_types = temp_model.from_map(m['NetworkTypes'])
        if m.get('ZoneNo') is not None:
            self.zone_no = m.get('ZoneNo')
        return self


class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones(TeaModel):
    def __init__(self, zone=None):
        self.zone = zone  # type: list[DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone]

    def validate(self):
        if self.zone:
            for k in self.zone:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['zone'] = []
        if self.zone is not None:
            for k in self.zone:
                result['zone'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.zone = []
        if m.get('zone') is not None:
            for k in m.get('zone'):
                temp_model = DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZonesZone()
                self.zone.append(temp_model.from_map(k))
        return self


class DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType(TeaModel):
    def __init__(self, commodity_code=None, instance_charge_type=None, instance_type=None, network_type=None,
                 priority=None, region_id=None, scene=None, spot_strategy=None, zone_id=None, zones=None):
        # The commodity code of the instance type.
        self.commodity_code = commodity_code  # type: str
        # The billing method of the instances of the instance type.
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance type.
        self.instance_type = instance_type  # type: DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType
        # The network type of the ECS instance.
        self.network_type = network_type  # type: str
        # The sorting priority.
        self.priority = priority  # type: int
        # The region ID of the instance type.
        self.region_id = region_id  # type: str
        # Indicates the scenario in which the instance type was recommended.
        self.scene = scene  # type: str
        # The preemption policy for the preemptible instance.
        self.spot_strategy = spot_strategy  # type: str
        # The zone ID of the instance type.
        self.zone_id = zone_id  # type: str
        # Details of the zones where the alternative instance types are available.
        self.zones = zones  # type: DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones

    def validate(self):
        if self.instance_type:
            self.instance_type.validate()
        if self.zones:
            self.zones.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.commodity_code is not None:
            result['CommodityCode'] = self.commodity_code
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type.to_map()
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scene is not None:
            result['Scene'] = self.scene
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        if self.zones is not None:
            result['Zones'] = self.zones.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommodityCode') is not None:
            self.commodity_code = m.get('CommodityCode')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            temp_model = DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeInstanceType()
            self.instance_type = temp_model.from_map(m['InstanceType'])
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scene') is not None:
            self.scene = m.get('Scene')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        if m.get('Zones') is not None:
            temp_model = DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceTypeZones()
            self.zones = temp_model.from_map(m['Zones'])
        return self


class DescribeRecommendInstanceTypeResponseBodyData(TeaModel):
    def __init__(self, recommend_instance_type=None):
        self.recommend_instance_type = recommend_instance_type  # type: list[DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType]

    def validate(self):
        if self.recommend_instance_type:
            for k in self.recommend_instance_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RecommendInstanceType'] = []
        if self.recommend_instance_type is not None:
            for k in self.recommend_instance_type:
                result['RecommendInstanceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.recommend_instance_type = []
        if m.get('RecommendInstanceType') is not None:
            for k in m.get('RecommendInstanceType'):
                temp_model = DescribeRecommendInstanceTypeResponseBodyDataRecommendInstanceType()
                self.recommend_instance_type.append(temp_model.from_map(k))
        return self


class DescribeRecommendInstanceTypeResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # Details of recommended instance types.
        self.data = data  # type: DescribeRecommendInstanceTypeResponseBodyData
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            temp_model = DescribeRecommendInstanceTypeResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRecommendInstanceTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRecommendInstanceTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRecommendInstanceTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRecommendInstanceTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionsRequest(TeaModel):
    def __init__(self, accept_language=None, instance_charge_type=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, resource_type=None):
        # The natural language that is used to filter responses. For more information, visit [RFC 7231](https://tools.ietf.org/html/rfc7231). Valid values:
        # 
        # *   zh-CN: Chinese
        # *   en-US: English
        # *   ja: Japanese
        # 
        # Default value: zh-CN.
        self.accept_language = accept_language  # type: str
        # The billing method of the instance. For more information, see [Billing overview](~~25398~~). Valid values:
        # 
        # *   PrePaid: subscription. If this parameter is set to PrePaid, make sure that you have sufficient balance or credits in your account. Otherwise, the InvalidPayMethod error code is returned.
        # *   PostPaid: pay-as-you-go.
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: Elastic Compute Service (ECS) instance
        # *   disk: disk
        # *   reservedinstance: reserved instance
        # *   scu: storage capacity unit (SCU)
        # 
        # Default value: instance.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRegionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeRegionsResponseBodyRegionsRegion(TeaModel):
    def __init__(self, local_name=None, region_endpoint=None, region_id=None, status=None):
        # The name of the region.
        self.local_name = local_name  # type: str
        # The endpoint of the region.
        self.region_endpoint = region_endpoint  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # Indicates whether clusters are sold out. Valid values:
        # 
        # *   available
        # *   soldOut
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRegionsResponseBodyRegionsRegion, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.region_endpoint is not None:
            result['RegionEndpoint'] = self.region_endpoint
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('RegionEndpoint') is not None:
            self.region_endpoint = m.get('RegionEndpoint')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRegionsResponseBodyRegions(TeaModel):
    def __init__(self, region=None):
        self.region = region  # type: list[DescribeRegionsResponseBodyRegionsRegion]

    def validate(self):
        if self.region:
            for k in self.region:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRegionsResponseBodyRegions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Region'] = []
        if self.region is not None:
            for k in self.region:
                result['Region'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.region = []
        if m.get('Region') is not None:
            for k in m.get('Region'):
                temp_model = DescribeRegionsResponseBodyRegionsRegion()
                self.region.append(temp_model.from_map(k))
        return self


class DescribeRegionsResponseBody(TeaModel):
    def __init__(self, regions=None, request_id=None):
        # Details about the regions.
        self.regions = regions  # type: DescribeRegionsResponseBodyRegions
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.regions:
            self.regions.validate()

    def to_map(self):
        _map = super(DescribeRegionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.regions is not None:
            result['Regions'] = self.regions.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Regions') is not None:
            temp_model = DescribeRegionsResponseBodyRegions()
            self.regions = temp_model.from_map(m['Regions'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRegionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRegionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRenewalPriceRequest(TeaModel):
    def __init__(self, expected_renew_day=None, owner_account=None, owner_id=None, period=None, price_unit=None,
                 region_id=None, resource_id=None, resource_owner_account=None, resource_owner_id=None, resource_type=None):
        # The synchronized expiration date. If you set this parameter, the price for renewing a specified instance to the specified synchronized expiration date is queried. Valid values: 1 to 28.
        # 
        # For information about how to synchronize the expiration dates of instances, see [Synchronize the expiration dates of instances](~~108486~~).
        # 
        # > The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the `ExpectedRenewDay` parameter are mutually exclusive.
        self.expected_renew_day = expected_renew_day  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The renewal period. Valid values:
        # 
        # *   Valid values when `PriceUnit` is set to `Month`: 1, 2, 3, 4, 5, 6, 7, 8, and 9.
        # *   Valid values when `PriceUnit` is set to `Year`: 1, 2, 3.
        # 
        # Default value: 1.
        # 
        # > The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the `ExpectedRenewDay` parameter are mutually exclusive.
        self.period = period  # type: int
        # The unit of the renewal period. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Month.
        self.price_unit = price_unit  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource. When the `ResourceType` parameter is set to`  instance `, `ResourceId` is interpreted as `InstanceId`.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Set the value to instance.
        # 
        # Default value: instance.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRenewalPriceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expected_renew_day is not None:
            result['ExpectedRenewDay'] = self.expected_renew_day
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.price_unit is not None:
            result['PriceUnit'] = self.price_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExpectedRenewDay') is not None:
            self.expected_renew_day = m.get('ExpectedRenewDay')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PriceUnit') is not None:
            self.price_unit = m.get('PriceUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule(TeaModel):
    def __init__(self, description=None, rule_id=None):
        # The description of the pricing rule.
        self.description = description  # type: str
        # The ID of the pricing rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules(TeaModel):
    def __init__(self, rule=None):
        self.rule = rule  # type: list[DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule]

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRulesRule()
                self.rule.append(temp_model.from_map(k))
        return self


class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel(TeaModel):
    def __init__(self, discount_price=None, original_price=None, resource=None, sub_rules=None, trade_price=None):
        # The discount.
        self.discount_price = discount_price  # type: float
        # The original price.
        self.original_price = original_price  # type: float
        # The name of the resource that corresponds to the price.
        self.resource = resource  # type: str
        # Details about the pricing rules.
        self.sub_rules = sub_rules  # type: DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules
        # The transaction price.
        self.trade_price = trade_price  # type: float

    def validate(self):
        if self.sub_rules:
            self.sub_rules.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.resource is not None:
            result['Resource'] = self.resource
        if self.sub_rules is not None:
            result['SubRules'] = self.sub_rules.to_map()
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        if m.get('SubRules') is not None:
            temp_model = DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModelSubRules()
            self.sub_rules = temp_model.from_map(m['SubRules'])
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos(TeaModel):
    def __init__(self, resource_price_model=None):
        self.resource_price_model = resource_price_model  # type: list[DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel]

    def validate(self):
        if self.resource_price_model:
            for k in self.resource_price_model:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResourcePriceModel'] = []
        if self.resource_price_model is not None:
            for k in self.resource_price_model:
                result['ResourcePriceModel'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource_price_model = []
        if m.get('ResourcePriceModel') is not None:
            for k in m.get('ResourcePriceModel'):
                temp_model = DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfosResourcePriceModel()
                self.resource_price_model.append(temp_model.from_map(k))
        return self


class DescribeRenewalPriceResponseBodyPriceInfoPrice(TeaModel):
    def __init__(self, currency=None, detail_infos=None, discount_price=None, original_price=None, trade_price=None):
        # The currency unit.
        # 
        # Alibaba Cloud China site (aliyun.com): CNY.
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # Details about the resource prices.
        self.detail_infos = detail_infos  # type: DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos
        # The discount.
        self.discount_price = discount_price  # type: float
        # The original price.
        self.original_price = original_price  # type: float
        # The transaction price, which is equal to the original price minus the discount.
        self.trade_price = trade_price  # type: float

    def validate(self):
        if self.detail_infos:
            self.detail_infos.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoPrice, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.detail_infos is not None:
            result['DetailInfos'] = self.detail_infos.to_map()
        if self.discount_price is not None:
            result['DiscountPrice'] = self.discount_price
        if self.original_price is not None:
            result['OriginalPrice'] = self.original_price
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('DetailInfos') is not None:
            temp_model = DescribeRenewalPriceResponseBodyPriceInfoPriceDetailInfos()
            self.detail_infos = temp_model.from_map(m['DetailInfos'])
        if m.get('DiscountPrice') is not None:
            self.discount_price = m.get('DiscountPrice')
        if m.get('OriginalPrice') is not None:
            self.original_price = m.get('OriginalPrice')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class DescribeRenewalPriceResponseBodyPriceInfoRulesRule(TeaModel):
    def __init__(self, description=None, rule_id=None):
        # The description of the promotion rule.
        self.description = description  # type: str
        # The ID of the promotion rule.
        self.rule_id = rule_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoRulesRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeRenewalPriceResponseBodyPriceInfoRules(TeaModel):
    def __init__(self, rule=None):
        self.rule = rule  # type: list[DescribeRenewalPriceResponseBodyPriceInfoRulesRule]

    def validate(self):
        if self.rule:
            for k in self.rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfoRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rule'] = []
        if self.rule is not None:
            for k in self.rule:
                result['Rule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rule = []
        if m.get('Rule') is not None:
            for k in m.get('Rule'):
                temp_model = DescribeRenewalPriceResponseBodyPriceInfoRulesRule()
                self.rule.append(temp_model.from_map(k))
        return self


class DescribeRenewalPriceResponseBodyPriceInfo(TeaModel):
    def __init__(self, price=None, rules=None):
        # The price.
        self.price = price  # type: DescribeRenewalPriceResponseBodyPriceInfoPrice
        # Details about the promotion rules.
        self.rules = rules  # type: DescribeRenewalPriceResponseBodyPriceInfoRules

    def validate(self):
        if self.price:
            self.price.validate()
        if self.rules:
            self.rules.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBodyPriceInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price is not None:
            result['Price'] = self.price.to_map()
        if self.rules is not None:
            result['Rules'] = self.rules.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Price') is not None:
            temp_model = DescribeRenewalPriceResponseBodyPriceInfoPrice()
            self.price = temp_model.from_map(m['Price'])
        if m.get('Rules') is not None:
            temp_model = DescribeRenewalPriceResponseBodyPriceInfoRules()
            self.rules = temp_model.from_map(m['Rules'])
        return self


class DescribeRenewalPriceResponseBody(TeaModel):
    def __init__(self, price_info=None, request_id=None):
        # Details about the prices and discount rules.
        self.price_info = price_info  # type: DescribeRenewalPriceResponseBodyPriceInfo
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.price_info:
            self.price_info.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.price_info is not None:
            result['PriceInfo'] = self.price_info.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PriceInfo') is not None:
            temp_model = DescribeRenewalPriceResponseBodyPriceInfo()
            self.price_info = temp_model.from_map(m['PriceInfo'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRenewalPriceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRenewalPriceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRenewalPriceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRenewalPriceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeReservedInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, reserved_instance_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.reserved_instance_id = reserved_instance_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeReservedInstanceAutoRenewAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributesReservedInstanceRenewAttribute(TeaModel):
    def __init__(self, duration=None, period_unit=None, renewal_status=None, reserved_instance_id=None):
        self.duration = duration  # type: int
        self.period_unit = period_unit  # type: str
        self.renewal_status = renewal_status  # type: str
        self.reserved_instance_id = reserved_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributesReservedInstanceRenewAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        return self


class DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributes(TeaModel):
    def __init__(self, reserved_instance_renew_attribute=None):
        self.reserved_instance_renew_attribute = reserved_instance_renew_attribute  # type: list[DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributesReservedInstanceRenewAttribute]

    def validate(self):
        if self.reserved_instance_renew_attribute:
            for k in self.reserved_instance_renew_attribute:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ReservedInstanceRenewAttribute'] = []
        if self.reserved_instance_renew_attribute is not None:
            for k in self.reserved_instance_renew_attribute:
                result['ReservedInstanceRenewAttribute'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.reserved_instance_renew_attribute = []
        if m.get('ReservedInstanceRenewAttribute') is not None:
            for k in m.get('ReservedInstanceRenewAttribute'):
                temp_model = DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributesReservedInstanceRenewAttribute()
                self.reserved_instance_renew_attribute.append(temp_model.from_map(k))
        return self


class DescribeReservedInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None, reserved_instance_renew_attributes=None):
        self.request_id = request_id  # type: str
        self.reserved_instance_renew_attributes = reserved_instance_renew_attributes  # type: DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributes

    def validate(self):
        if self.reserved_instance_renew_attributes:
            self.reserved_instance_renew_attributes.validate()

    def to_map(self):
        _map = super(DescribeReservedInstanceAutoRenewAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.reserved_instance_renew_attributes is not None:
            result['ReservedInstanceRenewAttributes'] = self.reserved_instance_renew_attributes.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ReservedInstanceRenewAttributes') is not None:
            temp_model = DescribeReservedInstanceAutoRenewAttributeResponseBodyReservedInstanceRenewAttributes()
            self.reserved_instance_renew_attributes = temp_model.from_map(m['ReservedInstanceRenewAttributes'])
        return self


class DescribeReservedInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeReservedInstanceAutoRenewAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeReservedInstanceAutoRenewAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeReservedInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeReservedInstancesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the reserved instance. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length. It cannot start with aliyun or acs: or contain http:// or https://.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that are bound with this tag can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that are bound with all these tags can be displayed in the response. To query more than 1,000 resources that are bound with specified tags, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the reserved instance. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with acs: or contain http:// or https://.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeReservedInstancesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeReservedInstancesRequest(TeaModel):
    def __init__(self, allocation_type=None, instance_type=None, instance_type_family=None, lock_reason=None,
                 offering_type=None, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 reserved_instance_id=None, reserved_instance_name=None, resource_owner_account=None, resource_owner_id=None,
                 scope=None, status=None, tag=None, zone_id=None):
        # The allocation type. Valid values:
        # 
        # *   Normal: queries all reserved instances that belong to the current account.
        # *   Shared: queries reserved instances that are shared between the main account and linked accounts.
        # 
        # Default value: Normal.
        self.allocation_type = allocation_type  # type: str
        # The instance type of the reserved instance. For more information about the valid values, see [Instance families](~~25378~~).
        self.instance_type = instance_type  # type: str
        # The instance family of the reserved instance. For more information about the valid values, see [Instance families](~~25378~~).
        self.instance_type_family = instance_type_family  # type: str
        # The reason why the reserved instance is locked. Valid values:
        # 
        # *   financial: You have an overdue payment in your account or the reserved instance has expired.
        # *   security: The reserved instance is locked for security reasons.
        self.lock_reason = lock_reason  # type: str
        # The payment option of the reserved instance. Valid values:
        # 
        # *   No Upfront
        # *   Partial Upfront
        # *   All Upfront
        self.offering_type = offering_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the reserved instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.reserved_instance_id = reserved_instance_id  # type: list[str]
        # The name of the reserved instance.
        self.reserved_instance_name = reserved_instance_name  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The scope of the reserved instance. Valid values:
        # 
        # *   Region: regional
        # *   Zone: zonal
        # 
        # Default value: Region.
        self.scope = scope  # type: str
        self.status = status  # type: list[str]
        self.tag = tag  # type: list[DescribeReservedInstancesRequestTag]
        # The zone ID of the reserved instance. This parameter is required when Scope is set to Zone. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_type is not None:
            result['AllocationType'] = self.allocation_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        if self.offering_type is not None:
            result['OfferingType'] = self.offering_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.reserved_instance_name is not None:
            result['ReservedInstanceName'] = self.reserved_instance_name
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationType') is not None:
            self.allocation_type = m.get('AllocationType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        if m.get('OfferingType') is not None:
            self.offering_type = m.get('OfferingType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ReservedInstanceName') is not None:
            self.reserved_instance_name = m.get('ReservedInstanceName')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeReservedInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock(TeaModel):
    def __init__(self, lock_reason=None):
        # The reason why the reserved instance was locked.
        self.lock_reason = lock_reason  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lock_reason is not None:
            result['LockReason'] = self.lock_reason
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LockReason') is not None:
            self.lock_reason = m.get('LockReason')
        return self


class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks(TeaModel):
    def __init__(self, operation_lock=None):
        self.operation_lock = operation_lock  # type: list[DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock]

    def validate(self):
        if self.operation_lock:
            for k in self.operation_lock:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationLock'] = []
        if self.operation_lock is not None:
            for k in self.operation_lock:
                result['OperationLock'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_lock = []
        if m.get('OperationLock') is not None:
            for k in m.get('OperationLock'):
                temp_model = DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocksOperationLock()
                self.operation_lock.append(temp_model.from_map(k))
        return self


class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the reserved instance.
        self.tag_key = tag_key  # type: str
        # The tag value of the reserved instance.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance(TeaModel):
    def __init__(self, allocation_status=None, creation_time=None, description=None, expired_time=None,
                 instance_amount=None, instance_type=None, offering_type=None, operation_locks=None, platform=None, region_id=None,
                 reserved_instance_id=None, reserved_instance_name=None, resource_group_id=None, scope=None, start_time=None,
                 status=None, tags=None, zone_id=None):
        # Indicates the sharing status of the reserved instance when the AllocationType parameter is set to Shared. Valid values:
        # 
        # *   allocated: The reserved instance is allocated to another account.
        # *   beAllocated: The reserved instance is allocated by another account.
        self.allocation_status = allocation_status  # type: str
        # The time when the reserved instance was created.
        self.creation_time = creation_time  # type: str
        # The description of the reserved instance.
        self.description = description  # type: str
        # The time when the reserved instance expires.
        self.expired_time = expired_time  # type: str
        # The number of pay-as-you-go instances that are of the same instance type as the reserved instance and can be matched to the reserved instance.
        self.instance_amount = instance_amount  # type: int
        # The instance type of the pay-as-you-go instances that can be matched to the reserved instance.
        self.instance_type = instance_type  # type: str
        # The payment option of the reserved instance.
        self.offering_type = offering_type  # type: str
        # Details about the lock status of the reserved instance.
        self.operation_locks = operation_locks  # type: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks
        # The operating system of the reserved instance. Valid values:
        # 
        # - Windows: Windows Server operating systems
        # - Linux: Linux and Unix-like operating systems
        self.platform = platform  # type: str
        # The region ID of the reserved instance.
        self.region_id = region_id  # type: str
        # The ID of the reserved instance.
        self.reserved_instance_id = reserved_instance_id  # type: str
        # The name of the reserved instance.
        self.reserved_instance_name = reserved_instance_name  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        # The scope of the reserved instance.
        self.scope = scope  # type: str
        # The time when the reserved instance took effect.
        self.start_time = start_time  # type: str
        # The status of the reserved instance.
        self.status = status  # type: str
        # Details about the tags of the reserved instance.
        self.tags = tags  # type: DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags
        # The zone ID of the reserved instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.operation_locks:
            self.operation_locks.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_status is not None:
            result['AllocationStatus'] = self.allocation_status
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.offering_type is not None:
            result['OfferingType'] = self.offering_type
        if self.operation_locks is not None:
            result['OperationLocks'] = self.operation_locks.to_map()
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.reserved_instance_name is not None:
            result['ReservedInstanceName'] = self.reserved_instance_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationStatus') is not None:
            self.allocation_status = m.get('AllocationStatus')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OfferingType') is not None:
            self.offering_type = m.get('OfferingType')
        if m.get('OperationLocks') is not None:
            temp_model = DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceOperationLocks()
            self.operation_locks = temp_model.from_map(m['OperationLocks'])
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ReservedInstanceName') is not None:
            self.reserved_instance_name = m.get('ReservedInstanceName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeReservedInstancesResponseBodyReservedInstancesReservedInstanceTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeReservedInstancesResponseBodyReservedInstances(TeaModel):
    def __init__(self, reserved_instance=None):
        self.reserved_instance = reserved_instance  # type: list[DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance]

    def validate(self):
        if self.reserved_instance:
            for k in self.reserved_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBodyReservedInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ReservedInstance'] = []
        if self.reserved_instance is not None:
            for k in self.reserved_instance:
                result['ReservedInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.reserved_instance = []
        if m.get('ReservedInstance') is not None:
            for k in m.get('ReservedInstance'):
                temp_model = DescribeReservedInstancesResponseBodyReservedInstancesReservedInstance()
                self.reserved_instance.append(temp_model.from_map(k))
        return self


class DescribeReservedInstancesResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, reserved_instances=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the reserved instances.
        self.reserved_instances = reserved_instances  # type: DescribeReservedInstancesResponseBodyReservedInstances
        # The total number of reserved instances.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.reserved_instances:
            self.reserved_instances.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.reserved_instances is not None:
            result['ReservedInstances'] = self.reserved_instances.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ReservedInstances') is not None:
            temp_model = DescribeReservedInstancesResponseBodyReservedInstances()
            self.reserved_instances = temp_model.from_map(m['ReservedInstances'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeReservedInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeReservedInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeReservedInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeReservedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeResourceByTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the resource. Valid values of N: 1 to 20 The tag key cannot be an empty string. It can be up to 128 characters in length.
        self.key = key  # type: str
        # The value of tag N of the resource. Valid values of N: 1 to 20 The tag value can be an empty string. It can be up to 128 characters in length.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeResourceByTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeResourceByTagsRequest(TeaModel):
    def __init__(self, owner_id=None, page_number=None, page_size=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, resource_type=None, tag=None):
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 50.
        self.page_size = page_size  # type: int
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: elastic network interface (ENI)
        # *   ddh: dedicated host
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # 
        # All the preceding values must be lowercase.
        self.resource_type = resource_type  # type: str
        # The tags.
        self.tag = tag  # type: list[DescribeResourceByTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeResourceByTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeResourceByTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeResourceByTagsResponseBodyResourcesResource(TeaModel):
    def __init__(self, region_id=None, resource_id=None, resource_type=None):
        # The region ID.
        self.region_id = region_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The type of the resource.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeResourceByTagsResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class DescribeResourceByTagsResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeResourceByTagsResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeResourceByTagsResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeResourceByTagsResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeResourceByTagsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, resources=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # An array consisting of Resource data.
        self.resources = resources  # type: DescribeResourceByTagsResponseBodyResources
        # The total number of resources returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeResourceByTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeResourceByTagsResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeResourceByTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeResourceByTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeResourceByTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeResourceByTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeResourcesModificationRequest(TeaModel):
    def __init__(self, cores=None, destination_resource=None, instance_type=None, memory=None,
                 migrate_across_zone=None, operation_type=None, owner_account=None, owner_id=None, region_id=None, resource_id=None,
                 resource_owner_account=None, resource_owner_id=None, zone_id=None):
        # The number of vCPU cores of the instance type. For more information, see [Instance families](~~25378~~). This parameter is valid only when DestinationResource is set to InstanceType.
        self.cores = cores  # type: int
        # The type of the resource. Valid values:
        # 
        # *   InstanceType
        # *   SystemDisk
        self.destination_resource = destination_resource  # type: str
        # The instance type. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent instance type list. This parameter is required when the DestinationResource parameter is set to SystemDisk.
        self.instance_type = instance_type  # type: str
        # The memory size of the instance type. Unit: GiB. For more information, see [Instance families](~~25378~~). This parameter is valid only when DestinationResource is set to InstanceType.
        self.memory = memory  # type: float
        # Specifies whether to support cross-cluster instance type upgrades. Valid values:
        # 
        # *   true: supports cross-cluster instance type upgrades.
        # *   false: does not support cross-cluster instance type upgrades.
        # 
        # Default value: false.
        # 
        # When the MigrateAcrossZone parameter is set to true and you upgrade the instance type of the Elastic Compute Service (ECS) instance based on returned information, take note of the following items:
        # 
        # *   Instances that reside in the classic network:
        # 
        #     *   For [retired instance types](~~55263~~), when a non-I/O-optimized instance is upgraded to an I/O-optimized instance, the private IP address, disk device names, and software authorization codes of the instance change. For Linux instances, basic disks (cloud) are identified by the prefix xvd. Ultra disks (cloud_efficiency) and standard SSDs (cloud_ssd) are identified by the prefix vd.
        #     *   For [instance families available for purchase](~~25378~~), when the instance type of an instance is changed, the private IP address of the instance changes.
        # 
        # *   Instances that reside in virtual private clouds (VPCs): For [retired instance types](~~55263~~), when a non-I/O-optimized instance is upgraded to an I/O-optimized instance, the disk device names and software authorization codes of the instance change. For Linux instances, basic disks (cloud) are identified by the prefix xvd. Ultra disks (cloud_efficiency) and standard SSDs (cloud_ssd) are identified by the prefix vd.
        self.migrate_across_zone = migrate_across_zone  # type: bool
        # The operation of changing resource configurations.
        # 
        # *   Valid values for subscription resources:
        # 
        #     *   Upgrade
        #     *   Downgrade
        #     *   RenewDowngrade
        #     *   RenewModify
        # 
        # *   Valid values for pay-as-you-go resources: Upgrade
        # 
        # Default value: Upgrade.
        self.operation_type = operation_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource. For example, when DestinationResource is set to InstanceType, this parameter can be interpreted as InstanceId.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the zone to query.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeResourcesModificationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.destination_resource is not None:
            result['DestinationResource'] = self.destination_resource
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.migrate_across_zone is not None:
            result['MigrateAcrossZone'] = self.migrate_across_zone
        if self.operation_type is not None:
            result['OperationType'] = self.operation_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('DestinationResource') is not None:
            self.destination_resource = m.get('DestinationResource')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MigrateAcrossZone') is not None:
            self.migrate_across_zone = m.get('MigrateAcrossZone')
        if m.get('OperationType') is not None:
            self.operation_type = m.get('OperationType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource(TeaModel):
    def __init__(self, max=None, min=None, status=None, status_category=None, unit=None, value=None):
        # The maximum resource specification value. This parameter is not returned if it has no value.
        self.max = max  # type: int
        # The minimum resource specification value. This parameter is not returned if it has no value.
        self.min = min  # type: int
        # The state of the resource. Valid values:
        # 
        # *   Available
        # *   SoldOut
        self.status = status  # type: str
        # The category of resource based on stock status. Valid values:
        # 
        # *   WithStock: resources that are in sufficient stock
        # *   ClosedWithStock: resources that are ininsufficient stock
        # *   WithoutStock: resources that are out of stock
        self.status_category = status_category  # type: str
        # The resource specification unit. This parameter is not returned if it has no value.
        self.unit = unit  # type: str
        # The resource value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        if self.status is not None:
            result['Status'] = self.status
        if self.status_category is not None:
            result['StatusCategory'] = self.status_category
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusCategory') is not None:
            self.status_category = m.get('StatusCategory')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources(TeaModel):
    def __init__(self, supported_resource=None):
        self.supported_resource = supported_resource  # type: list[DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource]

    def validate(self):
        if self.supported_resource:
            for k in self.supported_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SupportedResource'] = []
        if self.supported_resource is not None:
            for k in self.supported_resource:
                result['SupportedResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.supported_resource = []
        if m.get('SupportedResource') is not None:
            for k in m.get('SupportedResource'):
                temp_model = DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResourcesSupportedResource()
                self.supported_resource.append(temp_model.from_map(k))
        return self


class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource(TeaModel):
    def __init__(self, supported_resources=None, type=None):
        # Details about the resources.
        self.supported_resources = supported_resources  # type: DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources
        # The type of resource. Valid values:
        # 
        # *   Zone
        # *   IoOptimized
        # *   InstanceType
        # *   SystemDisk
        # *   DataDisk
        # *   Network
        self.type = type  # type: str

    def validate(self):
        if self.supported_resources:
            self.supported_resources.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_resources is not None:
            result['SupportedResources'] = self.supported_resources.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SupportedResources') is not None:
            temp_model = DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResourceSupportedResources()
            self.supported_resources = temp_model.from_map(m['SupportedResources'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources(TeaModel):
    def __init__(self, available_resource=None):
        self.available_resource = available_resource  # type: list[DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource]

    def validate(self):
        if self.available_resource:
            for k in self.available_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableResource'] = []
        if self.available_resource is not None:
            for k in self.available_resource:
                result['AvailableResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_resource = []
        if m.get('AvailableResource') is not None:
            for k in m.get('AvailableResource'):
                temp_model = DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResourcesAvailableResource()
                self.available_resource.append(temp_model.from_map(k))
        return self


class DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone(TeaModel):
    def __init__(self, available_resources=None, region_id=None, status=None, status_category=None, zone_id=None):
        # Details about the resources available in the zone.
        self.available_resources = available_resources  # type: DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources
        # The region ID of the zone.
        self.region_id = region_id  # type: str
        # The state of the resource. Valid values:
        # 
        # *   Available
        # *   SoldOut
        self.status = status  # type: str
        # The category of resource based on stock status. Valid values:
        # 
        # *   WithStock: resources that are in sufficient stock
        # *   ClosedWithStock: resources that are in insufficient stock
        # *   WithoutStock: resources that are out of stock
        self.status_category = status_category  # type: str
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.available_resources:
            self.available_resources.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_resources is not None:
            result['AvailableResources'] = self.available_resources.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.status_category is not None:
            result['StatusCategory'] = self.status_category
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableResources') is not None:
            temp_model = DescribeResourcesModificationResponseBodyAvailableZonesAvailableZoneAvailableResources()
            self.available_resources = temp_model.from_map(m['AvailableResources'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusCategory') is not None:
            self.status_category = m.get('StatusCategory')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeResourcesModificationResponseBodyAvailableZones(TeaModel):
    def __init__(self, available_zone=None):
        self.available_zone = available_zone  # type: list[DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone]

    def validate(self):
        if self.available_zone:
            for k in self.available_zone:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBodyAvailableZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableZone'] = []
        if self.available_zone is not None:
            for k in self.available_zone:
                result['AvailableZone'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_zone = []
        if m.get('AvailableZone') is not None:
            for k in m.get('AvailableZone'):
                temp_model = DescribeResourcesModificationResponseBodyAvailableZonesAvailableZone()
                self.available_zone.append(temp_model.from_map(k))
        return self


class DescribeResourcesModificationResponseBody(TeaModel):
    def __init__(self, available_zones=None, request_id=None):
        # Details about the available zones.
        self.available_zones = available_zones  # type: DescribeResourcesModificationResponseBodyAvailableZones
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.available_zones:
            self.available_zones.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_zones is not None:
            result['AvailableZones'] = self.available_zones.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableZones') is not None:
            temp_model = DescribeResourcesModificationResponseBodyAvailableZones()
            self.available_zones = temp_model.from_map(m['AvailableZones'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeResourcesModificationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeResourcesModificationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeResourcesModificationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeResourcesModificationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRouteTablesRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, route_table_id=None, route_table_name=None, router_id=None,
                 router_type=None, vrouter_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.route_table_id = route_table_id  # type: str
        self.route_table_name = route_table_name  # type: str
        self.router_id = router_id  # type: str
        self.router_type = router_type  # type: str
        self.vrouter_id = vrouter_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRouteTablesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_name is not None:
            result['RouteTableName'] = self.route_table_name
        if self.router_id is not None:
            result['RouterId'] = self.router_id
        if self.router_type is not None:
            result['RouterType'] = self.router_type
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableName') is not None:
            self.route_table_name = m.get('RouteTableName')
        if m.get('RouterId') is not None:
            self.router_id = m.get('RouterId')
        if m.get('RouterType') is not None:
            self.router_type = m.get('RouterType')
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        return self


class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop(TeaModel):
    def __init__(self, enabled=None, next_hop_id=None, next_hop_type=None, weight=None):
        self.enabled = enabled  # type: int
        self.next_hop_id = next_hop_id  # type: str
        self.next_hop_type = next_hop_type  # type: str
        self.weight = weight  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.next_hop_id is not None:
            result['NextHopId'] = self.next_hop_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        if self.weight is not None:
            result['Weight'] = self.weight
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('NextHopId') is not None:
            self.next_hop_id = m.get('NextHopId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        if m.get('Weight') is not None:
            self.weight = m.get('Weight')
        return self


class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops(TeaModel):
    def __init__(self, next_hop=None):
        self.next_hop = next_hop  # type: list[DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop]

    def validate(self):
        if self.next_hop:
            for k in self.next_hop:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NextHop'] = []
        if self.next_hop is not None:
            for k in self.next_hop:
                result['NextHop'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.next_hop = []
        if m.get('NextHop') is not None:
            for k in m.get('NextHop'):
                temp_model = DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHopsNextHop()
                self.next_hop.append(temp_model.from_map(k))
        return self


class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry(TeaModel):
    def __init__(self, destination_cidr_block=None, instance_id=None, next_hop_type=None, next_hops=None,
                 route_table_id=None, status=None, type=None):
        self.destination_cidr_block = destination_cidr_block  # type: str
        self.instance_id = instance_id  # type: str
        self.next_hop_type = next_hop_type  # type: str
        self.next_hops = next_hops  # type: DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops
        self.route_table_id = route_table_id  # type: str
        self.status = status  # type: str
        self.type = type  # type: str

    def validate(self):
        if self.next_hops:
            self.next_hops.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.next_hop_type is not None:
            result['NextHopType'] = self.next_hop_type
        if self.next_hops is not None:
            result['NextHops'] = self.next_hops.to_map()
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.status is not None:
            result['Status'] = self.status
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NextHopType') is not None:
            self.next_hop_type = m.get('NextHopType')
        if m.get('NextHops') is not None:
            temp_model = DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntryNextHops()
            self.next_hops = temp_model.from_map(m['NextHops'])
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys(TeaModel):
    def __init__(self, route_entry=None):
        self.route_entry = route_entry  # type: list[DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry]

    def validate(self):
        if self.route_entry:
            for k in self.route_entry:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RouteEntry'] = []
        if self.route_entry is not None:
            for k in self.route_entry:
                result['RouteEntry'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.route_entry = []
        if m.get('RouteEntry') is not None:
            for k in m.get('RouteEntry'):
                temp_model = DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrysRouteEntry()
                self.route_entry.append(temp_model.from_map(k))
        return self


class DescribeRouteTablesResponseBodyRouteTablesRouteTable(TeaModel):
    def __init__(self, creation_time=None, resource_group_id=None, route_entrys=None, route_table_id=None,
                 route_table_type=None, vrouter_id=None):
        self.creation_time = creation_time  # type: str
        self.resource_group_id = resource_group_id  # type: str
        self.route_entrys = route_entrys  # type: DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys
        self.route_table_id = route_table_id  # type: str
        self.route_table_type = route_table_type  # type: str
        self.vrouter_id = vrouter_id  # type: str

    def validate(self):
        if self.route_entrys:
            self.route_entrys.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTablesRouteTable, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.route_entrys is not None:
            result['RouteEntrys'] = self.route_entrys.to_map()
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.route_table_type is not None:
            result['RouteTableType'] = self.route_table_type
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RouteEntrys') is not None:
            temp_model = DescribeRouteTablesResponseBodyRouteTablesRouteTableRouteEntrys()
            self.route_entrys = temp_model.from_map(m['RouteEntrys'])
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('RouteTableType') is not None:
            self.route_table_type = m.get('RouteTableType')
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        return self


class DescribeRouteTablesResponseBodyRouteTables(TeaModel):
    def __init__(self, route_table=None):
        self.route_table = route_table  # type: list[DescribeRouteTablesResponseBodyRouteTablesRouteTable]

    def validate(self):
        if self.route_table:
            for k in self.route_table:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBodyRouteTables, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RouteTable'] = []
        if self.route_table is not None:
            for k in self.route_table:
                result['RouteTable'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.route_table = []
        if m.get('RouteTable') is not None:
            for k in m.get('RouteTable'):
                temp_model = DescribeRouteTablesResponseBodyRouteTablesRouteTable()
                self.route_table.append(temp_model.from_map(k))
        return self


class DescribeRouteTablesResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, route_tables=None, total_count=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.route_tables = route_tables  # type: DescribeRouteTablesResponseBodyRouteTables
        self.total_count = total_count  # type: int

    def validate(self):
        if self.route_tables:
            self.route_tables.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.route_tables is not None:
            result['RouteTables'] = self.route_tables.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouteTables') is not None:
            temp_model = DescribeRouteTablesResponseBodyRouteTables()
            self.route_tables = temp_model.from_map(m['RouteTables'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRouteTablesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRouteTablesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRouteTablesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRouteTablesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRouterInterfacesRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRouterInterfacesRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeRouterInterfacesRequest(TeaModel):
    def __init__(self, filter=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.filter = filter  # type: list[DescribeRouterInterfacesRequestFilter]
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRouterInterfacesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeRouterInterfacesRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType(TeaModel):
    def __init__(self, access_point_id=None, business_status=None, charge_type=None, connected_time=None,
                 creation_time=None, description=None, end_time=None, health_check_source_ip=None, health_check_target_ip=None,
                 name=None, opposite_access_point_id=None, opposite_interface_business_status=None,
                 opposite_interface_id=None, opposite_interface_owner_id=None, opposite_interface_spec=None,
                 opposite_interface_status=None, opposite_region_id=None, opposite_router_id=None, opposite_router_type=None, role=None,
                 router_id=None, router_interface_id=None, router_type=None, spec=None, status=None):
        self.access_point_id = access_point_id  # type: str
        self.business_status = business_status  # type: str
        self.charge_type = charge_type  # type: str
        self.connected_time = connected_time  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.end_time = end_time  # type: str
        self.health_check_source_ip = health_check_source_ip  # type: str
        self.health_check_target_ip = health_check_target_ip  # type: str
        self.name = name  # type: str
        self.opposite_access_point_id = opposite_access_point_id  # type: str
        self.opposite_interface_business_status = opposite_interface_business_status  # type: str
        self.opposite_interface_id = opposite_interface_id  # type: str
        self.opposite_interface_owner_id = opposite_interface_owner_id  # type: str
        self.opposite_interface_spec = opposite_interface_spec  # type: str
        self.opposite_interface_status = opposite_interface_status  # type: str
        self.opposite_region_id = opposite_region_id  # type: str
        self.opposite_router_id = opposite_router_id  # type: str
        self.opposite_router_type = opposite_router_type  # type: str
        self.role = role  # type: str
        self.router_id = router_id  # type: str
        self.router_interface_id = router_interface_id  # type: str
        self.router_type = router_type  # type: str
        self.spec = spec  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.business_status is not None:
            result['BusinessStatus'] = self.business_status
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.connected_time is not None:
            result['ConnectedTime'] = self.connected_time
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.health_check_source_ip is not None:
            result['HealthCheckSourceIp'] = self.health_check_source_ip
        if self.health_check_target_ip is not None:
            result['HealthCheckTargetIp'] = self.health_check_target_ip
        if self.name is not None:
            result['Name'] = self.name
        if self.opposite_access_point_id is not None:
            result['OppositeAccessPointId'] = self.opposite_access_point_id
        if self.opposite_interface_business_status is not None:
            result['OppositeInterfaceBusinessStatus'] = self.opposite_interface_business_status
        if self.opposite_interface_id is not None:
            result['OppositeInterfaceId'] = self.opposite_interface_id
        if self.opposite_interface_owner_id is not None:
            result['OppositeInterfaceOwnerId'] = self.opposite_interface_owner_id
        if self.opposite_interface_spec is not None:
            result['OppositeInterfaceSpec'] = self.opposite_interface_spec
        if self.opposite_interface_status is not None:
            result['OppositeInterfaceStatus'] = self.opposite_interface_status
        if self.opposite_region_id is not None:
            result['OppositeRegionId'] = self.opposite_region_id
        if self.opposite_router_id is not None:
            result['OppositeRouterId'] = self.opposite_router_id
        if self.opposite_router_type is not None:
            result['OppositeRouterType'] = self.opposite_router_type
        if self.role is not None:
            result['Role'] = self.role
        if self.router_id is not None:
            result['RouterId'] = self.router_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        if self.router_type is not None:
            result['RouterType'] = self.router_type
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('BusinessStatus') is not None:
            self.business_status = m.get('BusinessStatus')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('ConnectedTime') is not None:
            self.connected_time = m.get('ConnectedTime')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('HealthCheckSourceIp') is not None:
            self.health_check_source_ip = m.get('HealthCheckSourceIp')
        if m.get('HealthCheckTargetIp') is not None:
            self.health_check_target_ip = m.get('HealthCheckTargetIp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OppositeAccessPointId') is not None:
            self.opposite_access_point_id = m.get('OppositeAccessPointId')
        if m.get('OppositeInterfaceBusinessStatus') is not None:
            self.opposite_interface_business_status = m.get('OppositeInterfaceBusinessStatus')
        if m.get('OppositeInterfaceId') is not None:
            self.opposite_interface_id = m.get('OppositeInterfaceId')
        if m.get('OppositeInterfaceOwnerId') is not None:
            self.opposite_interface_owner_id = m.get('OppositeInterfaceOwnerId')
        if m.get('OppositeInterfaceSpec') is not None:
            self.opposite_interface_spec = m.get('OppositeInterfaceSpec')
        if m.get('OppositeInterfaceStatus') is not None:
            self.opposite_interface_status = m.get('OppositeInterfaceStatus')
        if m.get('OppositeRegionId') is not None:
            self.opposite_region_id = m.get('OppositeRegionId')
        if m.get('OppositeRouterId') is not None:
            self.opposite_router_id = m.get('OppositeRouterId')
        if m.get('OppositeRouterType') is not None:
            self.opposite_router_type = m.get('OppositeRouterType')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('RouterId') is not None:
            self.router_id = m.get('RouterId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        if m.get('RouterType') is not None:
            self.router_type = m.get('RouterType')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeRouterInterfacesResponseBodyRouterInterfaceSet(TeaModel):
    def __init__(self, router_interface_type=None):
        self.router_interface_type = router_interface_type  # type: list[DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType]

    def validate(self):
        if self.router_interface_type:
            for k in self.router_interface_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRouterInterfacesResponseBodyRouterInterfaceSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RouterInterfaceType'] = []
        if self.router_interface_type is not None:
            for k in self.router_interface_type:
                result['RouterInterfaceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.router_interface_type = []
        if m.get('RouterInterfaceType') is not None:
            for k in m.get('RouterInterfaceType'):
                temp_model = DescribeRouterInterfacesResponseBodyRouterInterfaceSetRouterInterfaceType()
                self.router_interface_type.append(temp_model.from_map(k))
        return self


class DescribeRouterInterfacesResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, router_interface_set=None,
                 total_count=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.router_interface_set = router_interface_set  # type: DescribeRouterInterfacesResponseBodyRouterInterfaceSet
        self.total_count = total_count  # type: int

    def validate(self):
        if self.router_interface_set:
            self.router_interface_set.validate()

    def to_map(self):
        _map = super(DescribeRouterInterfacesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.router_interface_set is not None:
            result['RouterInterfaceSet'] = self.router_interface_set.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RouterInterfaceSet') is not None:
            temp_model = DescribeRouterInterfacesResponseBodyRouterInterfaceSet()
            self.router_interface_set = temp_model.from_map(m['RouterInterfaceSet'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeRouterInterfacesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRouterInterfacesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRouterInterfacesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRouterInterfacesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityGroupAttributeRequest(TeaModel):
    def __init__(self, direction=None, nic_type=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, security_group_id=None):
        # The direction in which the security group rule is applied. Valid values:
        # 
        # *   egress: outbound
        # *   ingress: inbound
        # *   all: outbound and inbound
        # 
        # Default value: all.
        self.direction = direction  # type: str
        # The network interface controller (NIC) type of the security group rule.
        # 
        # *   Default value for rules of security groups in the classic network: internet. Valid values for rules of security groups in the classic network:
        # 
        #     *   internet
        # 
        #     *   intranet
        # 
        #         > You can query security group rules of only one NIC type in a single call. To query security group rules of both NIC types, call the operation twice.
        # 
        # *   When the security group is in a virtual private cloud (VPC), set the value to intranet. This is also the default value.
        # 
        #     > If you set this parameter to internet or leave this parameter empty, the intranet value is automatically used.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeSecurityGroupAttributeResponseBodyPermissionsPermission(TeaModel):
    def __init__(self, create_time=None, description=None, dest_cidr_ip=None, dest_group_id=None,
                 dest_group_name=None, dest_group_owner_account=None, dest_prefix_list_id=None, dest_prefix_list_name=None,
                 direction=None, ip_protocol=None, ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None,
                 policy=None, port_range=None, priority=None, security_group_rule_id=None, source_cidr_ip=None,
                 source_group_id=None, source_group_name=None, source_group_owner_account=None, source_port_range=None,
                 source_prefix_list_id=None, source_prefix_list_name=None):
        # The time when the security group rule was created. The time is displayed in UTC.
        self.create_time = create_time  # type: str
        # The description of the security group.
        self.description = description  # type: str
        # The destination CIDR blocks for outbound access control
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The ID of the destination security group for outbound access control.
        self.dest_group_id = dest_group_id  # type: str
        # The name of the destination security group.
        self.dest_group_name = dest_group_name  # type: str
        # The Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # The ID of the destination prefix list for outbound access control.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # The name of the destination prefix list.
        self.dest_prefix_list_name = dest_prefix_list_name  # type: str
        # The direction in which the security group rule is applied.
        self.direction = direction  # type: str
        # The transport layer protocol.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The NIC type of the security group rule.
        self.nic_type = nic_type  # type: str
        # The access control policy.
        self.policy = policy  # type: str
        # The port number range.
        self.port_range = port_range  # type: str
        # The priority of the rule.
        self.priority = priority  # type: str
        self.security_group_rule_id = security_group_rule_id  # type: str
        # The source CIDR block for inbound access control.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The source security group for inbound access control.
        self.source_group_id = source_group_id  # type: str
        # The name of the source security group.
        self.source_group_name = source_group_name  # type: str
        # The Alibaba Cloud account that manages the source security group.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # The source port number range.
        self.source_port_range = source_port_range  # type: str
        # The ID of the source prefix list for inbound access control.
        self.source_prefix_list_id = source_prefix_list_id  # type: str
        # The name of the source prefix list.
        self.source_prefix_list_name = source_prefix_list_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupAttributeResponseBodyPermissionsPermission, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_name is not None:
            result['DestGroupName'] = self.dest_group_name
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.dest_prefix_list_name is not None:
            result['DestPrefixListName'] = self.dest_prefix_list_name
        if self.direction is not None:
            result['Direction'] = self.direction
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.security_group_rule_id is not None:
            result['SecurityGroupRuleId'] = self.security_group_rule_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_name is not None:
            result['SourceGroupName'] = self.source_group_name
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        if self.source_prefix_list_name is not None:
            result['SourcePrefixListName'] = self.source_prefix_list_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupName') is not None:
            self.dest_group_name = m.get('DestGroupName')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('DestPrefixListName') is not None:
            self.dest_prefix_list_name = m.get('DestPrefixListName')
        if m.get('Direction') is not None:
            self.direction = m.get('Direction')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SecurityGroupRuleId') is not None:
            self.security_group_rule_id = m.get('SecurityGroupRuleId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupName') is not None:
            self.source_group_name = m.get('SourceGroupName')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        if m.get('SourcePrefixListName') is not None:
            self.source_prefix_list_name = m.get('SourcePrefixListName')
        return self


class DescribeSecurityGroupAttributeResponseBodyPermissions(TeaModel):
    def __init__(self, permission=None):
        self.permission = permission  # type: list[DescribeSecurityGroupAttributeResponseBodyPermissionsPermission]

    def validate(self):
        if self.permission:
            for k in self.permission:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupAttributeResponseBodyPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Permission'] = []
        if self.permission is not None:
            for k in self.permission:
                result['Permission'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.permission = []
        if m.get('Permission') is not None:
            for k in m.get('Permission'):
                temp_model = DescribeSecurityGroupAttributeResponseBodyPermissionsPermission()
                self.permission.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupAttributeResponseBody(TeaModel):
    def __init__(self, description=None, inner_access_policy=None, permissions=None, region_id=None,
                 request_id=None, security_group_id=None, security_group_name=None, vpc_id=None):
        # The description of the security group.
        self.description = description  # type: str
        # The access control policy of the security group. Valid values:
        # 
        # *   Accept: All instances in the security group can communicate with each other.
        # *   drop: All instances in the security group are isolated from each other.
        self.inner_access_policy = inner_access_policy  # type: str
        # Details about the security group rules.
        self.permissions = permissions  # type: DescribeSecurityGroupAttributeResponseBodyPermissions
        # The region ID.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the destination security group.
        self.security_group_id = security_group_id  # type: str
        # The name of the destination security group.
        self.security_group_name = security_group_name  # type: str
        # The ID of the VPC. If a VPC ID is returned, the network type of the security group is VPC. If no VPC ID is returned, the network type of the security group is classic network.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.permissions:
            self.permissions.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.inner_access_policy is not None:
            result['InnerAccessPolicy'] = self.inner_access_policy
        if self.permissions is not None:
            result['Permissions'] = self.permissions.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InnerAccessPolicy') is not None:
            self.inner_access_policy = m.get('InnerAccessPolicy')
        if m.get('Permissions') is not None:
            temp_model = DescribeSecurityGroupAttributeResponseBodyPermissions()
            self.permissions = temp_model.from_map(m['Permissions'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeSecurityGroupAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityGroupAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityGroupAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityGroupReferencesRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of security group N. Valid values of N: 1 to 10.
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup(TeaModel):
    def __init__(self, ali_uid=None, security_group_id=None):
        # The ID of the Alibaba Cloud account to which the security group belongs.
        self.ali_uid = ali_uid  # type: str
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups(TeaModel):
    def __init__(self, referencing_security_group=None):
        self.referencing_security_group = referencing_security_group  # type: list[DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup]

    def validate(self):
        if self.referencing_security_group:
            for k in self.referencing_security_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ReferencingSecurityGroup'] = []
        if self.referencing_security_group is not None:
            for k in self.referencing_security_group:
                result['ReferencingSecurityGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.referencing_security_group = []
        if m.get('ReferencingSecurityGroup') is not None:
            for k in m.get('ReferencingSecurityGroup'):
                temp_model = DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroupsReferencingSecurityGroup()
                self.referencing_security_group.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference(TeaModel):
    def __init__(self, referencing_security_groups=None, security_group_id=None):
        # Details about the security groups whose rules are referencing the specified security groups.
        self.referencing_security_groups = referencing_security_groups  # type: DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups
        # The ID of the specified security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        if self.referencing_security_groups:
            self.referencing_security_groups.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.referencing_security_groups is not None:
            result['ReferencingSecurityGroups'] = self.referencing_security_groups.to_map()
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ReferencingSecurityGroups') is not None:
            temp_model = DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReferenceReferencingSecurityGroups()
            self.referencing_security_groups = temp_model.from_map(m['ReferencingSecurityGroups'])
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences(TeaModel):
    def __init__(self, security_group_reference=None):
        self.security_group_reference = security_group_reference  # type: list[DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference]

    def validate(self):
        if self.security_group_reference:
            for k in self.security_group_reference:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SecurityGroupReference'] = []
        if self.security_group_reference is not None:
            for k in self.security_group_reference:
                result['SecurityGroupReference'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.security_group_reference = []
        if m.get('SecurityGroupReference') is not None:
            for k in m.get('SecurityGroupReference'):
                temp_model = DescribeSecurityGroupReferencesResponseBodySecurityGroupReferencesSecurityGroupReference()
                self.security_group_reference.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupReferencesResponseBody(TeaModel):
    def __init__(self, request_id=None, security_group_references=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the references to the specified security groups.
        self.security_group_references = security_group_references  # type: DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences

    def validate(self):
        if self.security_group_references:
            self.security_group_references.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_group_references is not None:
            result['SecurityGroupReferences'] = self.security_group_references.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroupReferences') is not None:
            temp_model = DescribeSecurityGroupReferencesResponseBodySecurityGroupReferences()
            self.security_group_references = temp_model.from_map(m['SecurityGroupReferences'])
        return self


class DescribeSecurityGroupReferencesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityGroupReferencesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupReferencesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityGroupReferencesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityGroupsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the security group. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the security group. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSecurityGroupsRequest(TeaModel):
    def __init__(self, dry_run=None, fuzzy_query=None, is_query_ecs_count=None, max_results=None, network_type=None,
                 next_token=None, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, security_group_id=None,
                 security_group_ids=None, security_group_name=None, security_group_type=None, tag=None, vpc_id=None):
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned, and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # > This parameter is deprecated.
        self.fuzzy_query = fuzzy_query  # type: bool
        # > This parameter is deprecated.
        self.is_query_ecs_count = is_query_ecs_count  # type: bool
        # The maximum number of entries to return on each page. If you specify the MaxResults parameter, both the `MaxResults` and `NextToken` parameters are used for a paged query.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The network type of the security group. Valid values:
        # 
        # *   vpc
        # *   classic
        self.network_type = network_type  # type: str
        # The query token. Set the value to the NextToken value returned in the previous call to the DescribeSecurityGroups operation. Leave this parameter empty the first time you call this operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters for a paged query.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters for a paged query.
        self.page_size = page_size  # type: int
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the security group belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response. You can call the [ListResourceGroups](~~158855~~) operation to query the most recent resource group list.
        # 
        # > Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # The IDs of security groups. The value is a JSON array that consists of up to 100 security group IDs. Separate the security group IDs with commas (,).
        self.security_group_ids = security_group_ids  # type: str
        # The name of the security group.
        self.security_group_name = security_group_name  # type: str
        # The type of the security group. Valid values:
        # 
        # *   normal: basic security group
        # *   enterprise: advanced security group
        # 
        # > If you do not specify this parameter, both basic and advanced security groups are queried.
        self.security_group_type = security_group_type  # type: str
        # The tags of the security group.
        self.tag = tag  # type: list[DescribeSecurityGroupsRequestTag]
        # The ID of the virtual private cloud (VPC) to which the security group belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.fuzzy_query is not None:
            result['FuzzyQuery'] = self.fuzzy_query
        if self.is_query_ecs_count is not None:
            result['IsQueryEcsCount'] = self.is_query_ecs_count
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        if self.security_group_type is not None:
            result['SecurityGroupType'] = self.security_group_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('FuzzyQuery') is not None:
            self.fuzzy_query = m.get('FuzzyQuery')
        if m.get('IsQueryEcsCount') is not None:
            self.is_query_ecs_count = m.get('IsQueryEcsCount')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        if m.get('SecurityGroupType') is not None:
            self.security_group_type = m.get('SecurityGroupType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSecurityGroupsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the security group.
        self.tag_key = tag_key  # type: str
        # The tag value of the security group.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup(TeaModel):
    def __init__(self, available_instance_amount=None, creation_time=None, description=None, ecs_count=None,
                 resource_group_id=None, security_group_id=None, security_group_name=None, security_group_type=None, service_id=None,
                 service_managed=None, tags=None, vpc_id=None):
        # > This parameter is in invitational preview and unavailable for general users.
        self.available_instance_amount = available_instance_amount  # type: int
        # The time when the security group was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddThh:mmZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The description of the security group.
        self.description = description  # type: str
        # > This parameter is in invitational preview and unavailable for general users.
        self.ecs_count = ecs_count  # type: int
        # The ID of the resource group to which the security group belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # The name of the security group.
        self.security_group_name = security_group_name  # type: str
        # The type of the security group. Valid values:
        # 
        # *   normal: basic security group
        # *   enterprise: advanced security group
        self.security_group_type = security_group_type  # type: str
        # The ID of the distributor to which the security group belongs.
        self.service_id = service_id  # type: long
        # Indicates whether the user of the security group is an Alibaba Cloud service or a distributor.
        self.service_managed = service_managed  # type: bool
        # The tags of the security groups.
        self.tags = tags  # type: DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags
        # The ID of the VPC to which the security group belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_instance_amount is not None:
            result['AvailableInstanceAmount'] = self.available_instance_amount
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ecs_count is not None:
            result['EcsCount'] = self.ecs_count
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        if self.security_group_type is not None:
            result['SecurityGroupType'] = self.security_group_type
        if self.service_id is not None:
            result['ServiceID'] = self.service_id
        if self.service_managed is not None:
            result['ServiceManaged'] = self.service_managed
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableInstanceAmount') is not None:
            self.available_instance_amount = m.get('AvailableInstanceAmount')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EcsCount') is not None:
            self.ecs_count = m.get('EcsCount')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        if m.get('SecurityGroupType') is not None:
            self.security_group_type = m.get('SecurityGroupType')
        if m.get('ServiceID') is not None:
            self.service_id = m.get('ServiceID')
        if m.get('ServiceManaged') is not None:
            self.service_managed = m.get('ServiceManaged')
        if m.get('Tags') is not None:
            temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroupTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeSecurityGroupsResponseBodySecurityGroups(TeaModel):
    def __init__(self, security_group=None):
        self.security_group = security_group  # type: list[DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup]

    def validate(self):
        if self.security_group:
            for k in self.security_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponseBodySecurityGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SecurityGroup'] = []
        if self.security_group is not None:
            for k in self.security_group:
                result['SecurityGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.security_group = []
        if m.get('SecurityGroup') is not None:
            for k in m.get('SecurityGroup'):
                temp_model = DescribeSecurityGroupsResponseBodySecurityGroupsSecurityGroup()
                self.security_group.append(temp_model.from_map(k))
        return self


class DescribeSecurityGroupsResponseBody(TeaModel):
    def __init__(self, next_token=None, page_number=None, page_size=None, region_id=None, request_id=None,
                 security_groups=None, total_count=None):
        # The query token returned in this call. If the return value of this parameter is empty when MaxResults and NextToken are used for a paged query, no more results are to be returned.
        self.next_token = next_token  # type: str
        # The page number of the returned page.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters for a paged query.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        # 
        # > This parameter will be removed in the future. We recommend that you use the NextToken and MaxResults parameters for a paged query.
        self.page_size = page_size  # type: int
        # The region ID of the security group.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the security groups.
        self.security_groups = security_groups  # type: DescribeSecurityGroupsResponseBodySecurityGroups
        # The total number of security groups. If the `MaxResults` and `NextToken` parameters are specified in the request, the value of this parameter is not returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.security_groups:
            self.security_groups.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_groups is not None:
            result['SecurityGroups'] = self.security_groups.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityGroups') is not None:
            temp_model = DescribeSecurityGroupsResponseBodySecurityGroups()
            self.security_groups = temp_model.from_map(m['SecurityGroups'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSecurityGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSendFileResultsRequest(TeaModel):
    def __init__(self, instance_id=None, invoke_id=None, name=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the instance whose records you want to query.
        self.instance_id = instance_id  # type: str
        # The ID of the file sending task.
        self.invoke_id = invoke_id  # type: str
        # The name of the file whose records you want to query.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The page number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        # 
        # Maximum value: 50.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group. After you set this parameter, you need to specify ResourceGroupId when you send files to query the file sending results in the specified resource group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSendFileResultsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance(TeaModel):
    def __init__(self, creation_time=None, error_code=None, error_info=None, finish_time=None, instance_id=None,
                 invocation_status=None, start_time=None, update_time=None):
        # The time when the file sending task was created.
        self.creation_time = creation_time  # type: str
        # The error code returned when the file failed to be sent to the instance. Valid values:
        # 
        # *   Null: The file is sent to the instance.
        # *   InstanceNotExists: The instance does not exist or was released.
        # *   InstanceReleased: The instance was released while the file was being sent.
        # *   InstanceNotRunning: The instance was not running when the file sending task was being created.
        # *   AccountNotExists: The specified account does not exist.
        # *   ClientNotRunning: The Cloud Assistant client is not running.
        # *   ClientNotResponse: The Cloud Assistant client is not responding.
        # *   ClientIsUpgrading: The Cloud Assistant client is being upgraded.
        # *   ClientNeedUpgrade: The Cloud Assistant client needs to be upgraded.
        # *   DeliveryTimeout: The file sending task timed out.
        # *   FileCreateFail: The file failed to be created.
        # *   FileAlreadyExists: A file with the same name already exists in the specified directory.
        # *   FileContentInvalid: The file content is invalid.
        # *   FileNameInvalid: The file name is invalid.
        # *   FilePathInvalid: The specified directory is invalid.
        # *   FileAuthorityInvalid: The specified permissions on the file are invalid.
        self.error_code = error_code  # type: str
        # The error message returned when the file failed to be sent or the file sending task failed to be executed. Valid values:
        # 
        # *   Null: The file is sent to the instance.
        # *   the specified instance does not exists: The specified instance does not exist or was released.
        # *   the instance has released when create task: The specified instance was released when the file was being sent.
        # *   the instance is not running when create task: The specified instance was not running when the file sending task was being created.
        # *   the specified account does not exists: The specified account does not exist.
        # *   the aliyun service is not running on the instance: The Cloud Assistance client is not running.
        # *   the aliyun service in the instance does not response: The Cloud Assistant client is not responding.
        # *   the aliyun service in the instance is upgrading now: The Cloud Assistant client is being upgraded.
        # *   the aliyun service in the instance need upgrade: The Cloud Assistant client needs to be upgraded.
        # *   the command delivery has been timeout: The file sending task timed out.
        # *   Unexpected error during creating: The file failed to be created.
        # *   File already exists: A file with the same name already exists in the specified directory.
        # *   File content error: The file content is invalid.
        # *   File name is invalid: The file name is invalid.
        # *   File path is invalid: The specified directory is invalid.
        # *   Owner not exists: The owner of the file does not exist.
        # *   Group not exists: The user group does not exist.
        # *   Mode is invalid: The specified permissions on the file are invalid.
        self.error_info = error_info  # type: str
        # The time when the file sending task finished being executed.
        self.finish_time = finish_time  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The state of the file sending task.
        self.invocation_status = invocation_status  # type: str
        # The time when the file sending task started to be executed on the instance.
        self.start_time = start_time  # type: str
        # The time when the execution status was last updated.
        self.update_time = update_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_info is not None:
            result['ErrorInfo'] = self.error_info
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorInfo') is not None:
            self.error_info = m.get('ErrorInfo')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances(TeaModel):
    def __init__(self, invoke_instance=None):
        self.invoke_instance = invoke_instance  # type: list[DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance]

    def validate(self):
        if self.invoke_instance:
            for k in self.invoke_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InvokeInstance'] = []
        if self.invoke_instance is not None:
            for k in self.invoke_instance:
                result['InvokeInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invoke_instance = []
        if m.get('InvokeInstance') is not None:
            for k in m.get('InvokeInstance'):
                temp_model = DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstancesInvokeInstance()
                self.invoke_instance.append(temp_model.from_map(k))
        return self


class DescribeSendFileResultsResponseBodyInvocationsInvocation(TeaModel):
    def __init__(self, content=None, content_type=None, creation_time=None, description=None, file_group=None,
                 file_mode=None, file_owner=None, invocation_status=None, invoke_id=None, invoke_instances=None, name=None,
                 overwrite=None, target_dir=None, vm_count=None):
        # The content of the file.
        self.content = content  # type: str
        # The content type of the file. Valid values:
        # 
        # *   PlainText: The file content is not encoded.
        # *   Base64: The file content is Base64-encoded.
        self.content_type = content_type  # type: str
        # The time when the file sending task was created.
        self.creation_time = creation_time  # type: str
        # The description.
        self.description = description  # type: str
        # The user group of the file.
        self.file_group = file_group  # type: str
        # The permissions on the file.
        self.file_mode = file_mode  # type: str
        # The owner of the file.
        self.file_owner = file_owner  # type: str
        # The overall sending state of the file. The overall sending state of the file depends on its sending state on all the destination instances. Valid values:
        # 
        # *   Pending: The file is being verified or sent. If the sending state of the file on at least one instance is Pending, the overall sending state of the file is Pending.
        # 
        # *   Running: The file creation task is running on the instances. If the sending state of the file on at least one instance is Running, the overall sending state of the file is Running.
        # 
        # *   Success: If the sending state of the file on all the instances is Success, the overall sending state of the file is Success.
        # 
        # *   Failed: If the sending state of the file on all the instances is Failed, the overall sending state of the file is Failed. If the sending state of the file on one or more instances is one of the following values, the overall sending state of the file is Failed:
        # 
        #     *   Invalid: The file is invalid.
        #     *   Aborted: The file failed to be sent.
        #     *   Failed: The file failed to be created.
        #     *   Timeout: The file sending task timed out.
        #     *   Error: An error occurred while the file is being sent.
        # 
        # *   PartialFailed: The file was sent to some of the specified instances and failed to be sent to the others. The overall sending state of the file is PartialFailed only when its sending state is Success on some instances and is Failed on the others.
        self.invocation_status = invocation_status  # type: str
        # The ID of the file sending task.
        self.invoke_id = invoke_id  # type: str
        # Details about the destination instances.
        self.invoke_instances = invoke_instances  # type: DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances
        # The name of the file.
        self.name = name  # type: str
        # Indicates whether a file in the destination directory is overwritten if the file has the same name as the sent file.
        self.overwrite = overwrite  # type: str
        # The destination directory.
        self.target_dir = target_dir  # type: str
        # The number of instances to which the file was sent.
        self.vm_count = vm_count  # type: int

    def validate(self):
        if self.invoke_instances:
            self.invoke_instances.validate()

    def to_map(self):
        _map = super(DescribeSendFileResultsResponseBodyInvocationsInvocation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.file_group is not None:
            result['FileGroup'] = self.file_group
        if self.file_mode is not None:
            result['FileMode'] = self.file_mode
        if self.file_owner is not None:
            result['FileOwner'] = self.file_owner
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_instances is not None:
            result['InvokeInstances'] = self.invoke_instances.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.target_dir is not None:
            result['TargetDir'] = self.target_dir
        if self.vm_count is not None:
            result['VmCount'] = self.vm_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileGroup') is not None:
            self.file_group = m.get('FileGroup')
        if m.get('FileMode') is not None:
            self.file_mode = m.get('FileMode')
        if m.get('FileOwner') is not None:
            self.file_owner = m.get('FileOwner')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeInstances') is not None:
            temp_model = DescribeSendFileResultsResponseBodyInvocationsInvocationInvokeInstances()
            self.invoke_instances = temp_model.from_map(m['InvokeInstances'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('TargetDir') is not None:
            self.target_dir = m.get('TargetDir')
        if m.get('VmCount') is not None:
            self.vm_count = m.get('VmCount')
        return self


class DescribeSendFileResultsResponseBodyInvocations(TeaModel):
    def __init__(self, invocation=None):
        self.invocation = invocation  # type: list[DescribeSendFileResultsResponseBodyInvocationsInvocation]

    def validate(self):
        if self.invocation:
            for k in self.invocation:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSendFileResultsResponseBodyInvocations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Invocation'] = []
        if self.invocation is not None:
            for k in self.invocation:
                result['Invocation'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invocation = []
        if m.get('Invocation') is not None:
            for k in m.get('Invocation'):
                temp_model = DescribeSendFileResultsResponseBodyInvocationsInvocation()
                self.invocation.append(temp_model.from_map(k))
        return self


class DescribeSendFileResultsResponseBody(TeaModel):
    def __init__(self, invocations=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the file sending records.
        self.invocations = invocations  # type: DescribeSendFileResultsResponseBodyInvocations
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of file sending tasks.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.invocations:
            self.invocations.validate()

    def to_map(self):
        _map = super(DescribeSendFileResultsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invocations is not None:
            result['Invocations'] = self.invocations.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Invocations') is not None:
            temp_model = DescribeSendFileResultsResponseBodyInvocations()
            self.invocations = temp_model.from_map(m['Invocations'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSendFileResultsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSendFileResultsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSendFileResultsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSendFileResultsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotGroupsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the snapshot-consistent group. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N of the snapshot-consistent group. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotGroupsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSnapshotGroupsRequest(TeaModel):
    def __init__(self, additional_attributes=None, instance_id=None, max_results=None, name=None, next_token=None,
                 owner_account=None, owner_id=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, snapshot_group_id=None, status=None, tag=None):
        self.additional_attributes = additional_attributes  # type: list[str]
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The name of the snapshot-consistent group.
        self.name = name  # type: str
        # The query token. Set the value to the NextToken value that is returned in the last call to the DescribeSnapshotGroups operation.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the snapshot-consistent group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the snapshot-consistent group belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.snapshot_group_id = snapshot_group_id  # type: list[str]
        self.status = status  # type: list[str]
        self.tag = tag  # type: list[DescribeSnapshotGroupsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.additional_attributes is not None:
            result['AdditionalAttributes'] = self.additional_attributes
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.name is not None:
            result['Name'] = self.name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_group_id is not None:
            result['SnapshotGroupId'] = self.snapshot_group_id
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdditionalAttributes') is not None:
            self.additional_attributes = m.get('AdditionalAttributes')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotGroupId') is not None:
            self.snapshot_group_id = m.get('SnapshotGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSnapshotGroupsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTagsTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of each snapshot in the snapshot-consistent group. The default values of Key and Value contain the details of the instance to which the snapshot-consistent group belongs.
        self.key = key  # type: str
        # The tag value of each snapshot in the snapshot-consistent group. The default values of Key and Value contain the details of the instance to which the snapshot-consistent group belongs.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot(TeaModel):
    def __init__(self, instant_access=None, instant_access_retention_days=None, progress=None, snapshot_id=None,
                 source_disk_id=None, source_disk_type=None, tags=None):
        # Indicates whether the instant access feature is enabled. Valid values:
        # 
        # - true: The instant access feature is enabled. This feature can be enabled only for enhanced SSDs (ESSDs).
        # - false: The instant access feature is disabled. The snapshot is a normal snapshot for which the instant access feature is disabled.
        self.instant_access = instant_access  # type: bool
        # The retention period of the instant access feature. After the retention period ends, the snapshot is automatically released.
        self.instant_access_retention_days = instant_access_retention_days  # type: int
        # The progress of the snapshot creation task. Unit: percent (%).
        self.progress = progress  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The ID of the source disk. This parameter is retained even after the source disk of the snapshot is released.
        self.source_disk_id = source_disk_id  # type: str
        # The type of the source disk. Valid values:
        # 
        # - system: system disk
        # - data: data disk
        self.source_disk_type = source_disk_type  # type: str
        # The tags of the snapshots in the snapshot-consistent group. The default value contains the details of the instance to which the snapshot-consistent group belongs.
        self.tags = tags  # type: DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instant_access is not None:
            result['InstantAccess'] = self.instant_access
        if self.instant_access_retention_days is not None:
            result['InstantAccessRetentionDays'] = self.instant_access_retention_days
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.source_disk_id is not None:
            result['SourceDiskId'] = self.source_disk_id
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstantAccess') is not None:
            self.instant_access = m.get('InstantAccess')
        if m.get('InstantAccessRetentionDays') is not None:
            self.instant_access_retention_days = m.get('InstantAccessRetentionDays')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SourceDiskId') is not None:
            self.source_disk_id = m.get('SourceDiskId')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('Tags') is not None:
            temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshotTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots(TeaModel):
    def __init__(self, snapshot=None):
        self.snapshot = snapshot  # type: list[DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot]

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshotsSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTagsTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the snapshot-consistent group.
        self.key = key  # type: str
        # The tag value of the snapshot-consistent group.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup(TeaModel):
    def __init__(self, creation_time=None, description=None, instance_id=None, name=None, progress_status=None,
                 resource_group_id=None, snapshot_group_id=None, snapshots=None, status=None, tags=None):
        # The time when the snapshot-consistent group was created.
        self.creation_time = creation_time  # type: str
        # The description of the snapshot-consistent group.
        self.description = description  # type: str
        # The ID of the instance to which the snapshot-consistent group belongs. This parameter has a value only when all disk snapshots in the snapshot-consistent group belong to the same instance. If disk snapshots in the snapshot-consistent group belong to different instances, you can use parameters starting with `Snapshots.Snapshot.Tags.` in the response to view the ID of the instance to which each snapshot in the snapshot-consistent group belongs.
        self.instance_id = instance_id  # type: str
        # The name of the snapshot-consistent group.
        self.name = name  # type: str
        # >  This parameter is unavailable.
        self.progress_status = progress_status  # type: str
        # The ID of the resource group to which the snapshot-consistent group belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of the snapshot-consistent group.
        self.snapshot_group_id = snapshot_group_id  # type: str
        # Details of the snapshots in the snapshot-consistent group.
        self.snapshots = snapshots  # type: DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots
        # The state of the snapshot-consistent group. Valid values:
        # 
        # *   progressing: The snapshot-consistent group is being created.
        # *   accomplished: The snapshot-consistent group is created.
        # *   failed: The snapshot-consistent group fails to be created.
        self.status = status  # type: str
        # The tags of the snapshot-consistent group.
        self.tags = tags  # type: DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTags

    def validate(self):
        if self.snapshots:
            self.snapshots.validate()
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.progress_status is not None:
            result['ProgressStatus'] = self.progress_status
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.snapshot_group_id is not None:
            result['SnapshotGroupId'] = self.snapshot_group_id
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots.to_map()
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('ProgressStatus') is not None:
            self.progress_status = m.get('ProgressStatus')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('SnapshotGroupId') is not None:
            self.snapshot_group_id = m.get('SnapshotGroupId')
        if m.get('Snapshots') is not None:
            temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupSnapshots()
            self.snapshots = temp_model.from_map(m['Snapshots'])
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroupTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeSnapshotGroupsResponseBodySnapshotGroups(TeaModel):
    def __init__(self, snapshot_group=None):
        self.snapshot_group = snapshot_group  # type: list[DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup]

    def validate(self):
        if self.snapshot_group:
            for k in self.snapshot_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBodySnapshotGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotGroup'] = []
        if self.snapshot_group is not None:
            for k in self.snapshot_group:
                result['SnapshotGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.snapshot_group = []
        if m.get('SnapshotGroup') is not None:
            for k in m.get('SnapshotGroup'):
                temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroupsSnapshotGroup()
                self.snapshot_group.append(temp_model.from_map(k))
        return self


class DescribeSnapshotGroupsResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, snapshot_groups=None):
        # The token used to start the next query.
        # 
        # >  If this parameter is empty, no more data is returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details of the snapshot-consistent groups.
        self.snapshot_groups = snapshot_groups  # type: DescribeSnapshotGroupsResponseBodySnapshotGroups

    def validate(self):
        if self.snapshot_groups:
            self.snapshot_groups.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_groups is not None:
            result['SnapshotGroups'] = self.snapshot_groups.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotGroups') is not None:
            temp_model = DescribeSnapshotGroupsResponseBodySnapshotGroups()
            self.snapshot_groups = temp_model.from_map(m['SnapshotGroups'])
        return self


class DescribeSnapshotGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotLinksRequest(TeaModel):
    def __init__(self, disk_ids=None, instance_id=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None, snapshot_link_ids=None):
        # The IDs of disks. The value is a JSON array that consists of up to 100 disk IDs. Separate the disk IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values: 1 to 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the disk. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of snapshot chains. The value is a JSON array that consists of up to 100 snapshot chain IDs. Separate the snapshot chain IDs with commas (,).
        self.snapshot_link_ids = snapshot_link_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotLinksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_link_ids is not None:
            result['SnapshotLinkIds'] = self.snapshot_link_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotLinkIds') is not None:
            self.snapshot_link_ids = m.get('SnapshotLinkIds')
        return self


class DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink(TeaModel):
    def __init__(self, category=None, instance_id=None, instance_name=None, instant_access=None, region_id=None,
                 snapshot_link_id=None, source_disk_id=None, source_disk_name=None, source_disk_size=None, source_disk_type=None,
                 total_count=None, total_size=None):
        # The category of the snapshot.
        # 
        # > This parameter will be removed in the future. We recommend that you use the `InstantAccess` parameter to ensure future compatibility.
        self.category = category  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # Indicates whether the instant access feature was enabled. Valid values:
        # 
        # *   true: The instant access feature was enabled. This feature can be enabled only for enhanced SSDs (ESSDs).
        # *   false: The instant access feature was disabled. The snapshot is a normal snapshot for which the instant access feature was disabled.
        self.instant_access = instant_access  # type: bool
        # The ID of the region where the source disk of the snapshot chain is located.
        self.region_id = region_id  # type: str
        # The ID of the snapshot chain.
        self.snapshot_link_id = snapshot_link_id  # type: str
        # The ID of the source disk. This parameter is retained even if the source disk is deleted.
        self.source_disk_id = source_disk_id  # type: str
        # The name of the source disk.
        self.source_disk_name = source_disk_name  # type: str
        # The size of the source disk. Unit: GiB.
        self.source_disk_size = source_disk_size  # type: int
        # The type of the source disk. Valid values:
        # 
        # *   system: system disk
        # *   data: data disk
        self.source_disk_type = source_disk_type  # type: str
        # The total number of snapshots.
        self.total_count = total_count  # type: int
        # The total size of all snapshots in the snapshot chain. Unit: bytes.
        self.total_size = total_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instant_access is not None:
            result['InstantAccess'] = self.instant_access
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_link_id is not None:
            result['SnapshotLinkId'] = self.snapshot_link_id
        if self.source_disk_id is not None:
            result['SourceDiskId'] = self.source_disk_id
        if self.source_disk_name is not None:
            result['SourceDiskName'] = self.source_disk_name
        if self.source_disk_size is not None:
            result['SourceDiskSize'] = self.source_disk_size
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstantAccess') is not None:
            self.instant_access = m.get('InstantAccess')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotLinkId') is not None:
            self.snapshot_link_id = m.get('SnapshotLinkId')
        if m.get('SourceDiskId') is not None:
            self.source_disk_id = m.get('SourceDiskId')
        if m.get('SourceDiskName') is not None:
            self.source_disk_name = m.get('SourceDiskName')
        if m.get('SourceDiskSize') is not None:
            self.source_disk_size = m.get('SourceDiskSize')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class DescribeSnapshotLinksResponseBodySnapshotLinks(TeaModel):
    def __init__(self, snapshot_link=None):
        self.snapshot_link = snapshot_link  # type: list[DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink]

    def validate(self):
        if self.snapshot_link:
            for k in self.snapshot_link:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotLinksResponseBodySnapshotLinks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotLink'] = []
        if self.snapshot_link is not None:
            for k in self.snapshot_link:
                result['SnapshotLink'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.snapshot_link = []
        if m.get('SnapshotLink') is not None:
            for k in m.get('SnapshotLink'):
                temp_model = DescribeSnapshotLinksResponseBodySnapshotLinksSnapshotLink()
                self.snapshot_link.append(temp_model.from_map(k))
        return self


class DescribeSnapshotLinksResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, snapshot_links=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the snapshot chains.
        self.snapshot_links = snapshot_links  # type: DescribeSnapshotLinksResponseBodySnapshotLinks
        # The total number of snapshot chains.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.snapshot_links:
            self.snapshot_links.validate()

    def to_map(self):
        _map = super(DescribeSnapshotLinksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_links is not None:
            result['SnapshotLinks'] = self.snapshot_links.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotLinks') is not None:
            temp_model = DescribeSnapshotLinksResponseBodySnapshotLinks()
            self.snapshot_links = temp_model.from_map(m['SnapshotLinks'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotLinksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotLinksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotLinksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotLinksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotMonitorDataRequest(TeaModel):
    def __init__(self, category=None, end_time=None, owner_account=None, owner_id=None, period=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, start_time=None):
        # The type of the snapshot. Valid values:
        # 
        # *   Standard: normal snapshot
        # *   Flash: local snapshot
        # 
        # Default value: Standard.
        self.category = category  # type: str
        # The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The interval at which to query the monitoring data of snapshot sizes. Unit: seconds. Valid values:
        # 
        # *   60
        # *   600
        # *   3600
        # 
        # Default value: 60
        self.period = period  # type: int
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If the value of seconds (ss) is not 00, the time is rounded up to the next minute.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint(TeaModel):
    def __init__(self, size=None, time_stamp=None):
        # The total size of the snapshots. Unit: bytes.
        self.size = size  # type: long
        # The timestamp that corresponds to a snapshot size.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeSnapshotMonitorDataResponseBodyMonitorData(TeaModel):
    def __init__(self, data_point=None):
        self.data_point = data_point  # type: list[DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint]

    def validate(self):
        if self.data_point:
            for k in self.data_point:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotMonitorDataResponseBodyMonitorData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DataPoint'] = []
        if self.data_point is not None:
            for k in self.data_point:
                result['DataPoint'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.data_point = []
        if m.get('DataPoint') is not None:
            for k in m.get('DataPoint'):
                temp_model = DescribeSnapshotMonitorDataResponseBodyMonitorDataDataPoint()
                self.data_point.append(temp_model.from_map(k))
        return self


class DescribeSnapshotMonitorDataResponseBody(TeaModel):
    def __init__(self, monitor_data=None, request_id=None):
        # Details about the monitoring data of snapshot sizes.
        self.monitor_data = monitor_data  # type: DescribeSnapshotMonitorDataResponseBodyMonitorData
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.monitor_data:
            self.monitor_data.validate()

    def to_map(self):
        _map = super(DescribeSnapshotMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.monitor_data is not None:
            result['MonitorData'] = self.monitor_data.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MonitorData') is not None:
            temp_model = DescribeSnapshotMonitorDataResponseBodyMonitorData()
            self.monitor_data = temp_model.from_map(m['MonitorData'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSnapshotMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotPackageRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        # RAM用户的虚拟账号ID。
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the snapshot. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # 资源主账号的账号名称。
        self.resource_owner_account = resource_owner_account  # type: str
        # 资源主账号的ID，亦即UID。
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotPackageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage(TeaModel):
    def __init__(self, display_name=None, end_time=None, init_capacity=None, start_time=None):
        # The name of the OSS storage plan.
        self.display_name = display_name  # type: str
        # The time when the OSS storage plan expires. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time  # type: str
        # The maximum storage capacity offered by the OSS storage plan.
        self.init_capacity = init_capacity  # type: long
        # The time when the OSS storage plan was purchased. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.init_capacity is not None:
            result['InitCapacity'] = self.init_capacity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InitCapacity') is not None:
            self.init_capacity = m.get('InitCapacity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSnapshotPackageResponseBodySnapshotPackages(TeaModel):
    def __init__(self, snapshot_package=None):
        self.snapshot_package = snapshot_package  # type: list[DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage]

    def validate(self):
        if self.snapshot_package:
            for k in self.snapshot_package:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotPackageResponseBodySnapshotPackages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SnapshotPackage'] = []
        if self.snapshot_package is not None:
            for k in self.snapshot_package:
                result['SnapshotPackage'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.snapshot_package = []
        if m.get('SnapshotPackage') is not None:
            for k in m.get('SnapshotPackage'):
                temp_model = DescribeSnapshotPackageResponseBodySnapshotPackagesSnapshotPackage()
                self.snapshot_package.append(temp_model.from_map(k))
        return self


class DescribeSnapshotPackageResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, snapshot_packages=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the OSS storage plans.
        self.snapshot_packages = snapshot_packages  # type: DescribeSnapshotPackageResponseBodySnapshotPackages
        # The total number of returned OSS storage plans.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.snapshot_packages:
            self.snapshot_packages.validate()

    def to_map(self):
        _map = super(DescribeSnapshotPackageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_packages is not None:
            result['SnapshotPackages'] = self.snapshot_packages.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotPackages') is not None:
            temp_model = DescribeSnapshotPackageResponseBodySnapshotPackages()
            self.snapshot_packages = temp_model.from_map(m['SnapshotPackages'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotPackageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotPackageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotPackageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of filter 1 used to query resources. Set the value to `CreationStartTime`. You can specify a time by setting both `Filter.1.Key` and `Filter.1.Value` to query resources that were created after the time.
        self.key = key  # type: str
        # The value of filter 1 used to query resources. Set the value to a time. If you specify this parameter, you must also specify the `Filter.1.Key` parameter. Specify the time in the `yyyy-MM-ddTHH:mmZ` format. The time must be in UTC.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSnapshotsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the snapshot. Valid values of N: 1 to 20.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        self.key = key  # type: str
        # The value of tag N of the snapshot. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeSnapshotsRequest(TeaModel):
    def __init__(self, filter=None, category=None, disk_id=None, dry_run=None, encrypted=None, instance_id=None,
                 kmskey_id=None, max_results=None, next_token=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 snapshot_ids=None, snapshot_link_id=None, snapshot_name=None, snapshot_type=None, source_disk_type=None,
                 status=None, tag=None, usage=None):
        self.filter = filter  # type: list[DescribeSnapshotsRequestFilter]
        # The category of the snapshot. Valid values:
        # 
        # *   Standard: normal snapshot
        # *   Flash: local snapshot
        # 
        # The local snapshot feature is replaced by the instant access feature. When you specify this parameter, take note of the following items:
        # 
        # *   If you have used local snapshots before December 14, 2020, you can use this parameter.
        # *   If you have not used local snapshots before December 14, 2020, you cannot use this parameter.
        # 
        # For more information, see [Snapshot service upgrade and addition of a new billable item on December 14, 2020](https://help.aliyun.com/noticelist/articleid/1060755542.html).
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.category = category  # type: str
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned, and the request is made.
        self.dry_run = dry_run  # type: bool
        # Specifies whether the snapshot is encrypted. Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the Key Management Service (KMS) key that is used for the data disk.
        self.kmskey_id = kmskey_id  # type: str
        # The maximum number of entries to return on each page. Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token used to start the query. Set the value to the NextToken value obtained from the response to the previous request.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the disk. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the snapshot belongs. If a resource group is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.
        # 
        # > Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of snapshots. The value can be a JSON array that consists of up to 100 snapshot IDs. Separate the snapshot IDs with commas (,).
        self.snapshot_ids = snapshot_ids  # type: str
        # The ID of the snapshot chain. The value is a JSON array that consists of up to 100 snapshot chain IDs. Separate the snapshot chain IDs with commas (,).
        self.snapshot_link_id = snapshot_link_id  # type: str
        # The name of the snapshot.
        self.snapshot_name = snapshot_name  # type: str
        # The type of the snapshot. Default value: all. Valid values:
        # 
        # *   auto: automatic snapshot
        # *   user: manual snapshot
        # *   all: all snapshot types
        self.snapshot_type = snapshot_type  # type: str
        # The type of the source disk for which the snapshot was created. Valid values:
        # 
        # *   System: system disk
        # *   data: data disk
        # 
        # > The value of this parameter is case-insensitive.
        self.source_disk_type = source_disk_type  # type: str
        # The state of the snapshot. Default value: all. Valid values:
        # 
        # *   progressing: The snapshot is being created.
        # *   accomplished: The snapshot is created.
        # *   failed: The snapshot fails to be created.
        # *   all: This value indicates all snapshot states.
        self.status = status  # type: str
        # The tags of the snapshot.
        self.tag = tag  # type: list[DescribeSnapshotsRequestTag]
        # Specifies whether the snapshot has been used to create custom images or disks. Valid values:
        # 
        # *   image: The snapshot has been used to create custom images.
        # *   disk: The snapshot is used to create disks.
        # *   image_disk: The snapshot has been used to create both custom images and data disks.
        # *   none: The snapshot has not been used to create custom images or disks.
        self.usage = usage  # type: str

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.category is not None:
            result['Category'] = self.category
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_ids is not None:
            result['SnapshotIds'] = self.snapshot_ids
        if self.snapshot_link_id is not None:
            result['SnapshotLinkId'] = self.snapshot_link_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.snapshot_type is not None:
            result['SnapshotType'] = self.snapshot_type
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.status is not None:
            result['Status'] = self.status
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeSnapshotsRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotIds') is not None:
            self.snapshot_ids = m.get('SnapshotIds')
        if m.get('SnapshotLinkId') is not None:
            self.snapshot_link_id = m.get('SnapshotLinkId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SnapshotType') is not None:
            self.snapshot_type = m.get('SnapshotType')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSnapshotsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the snapshot.
        self.tag_key = tag_key  # type: str
        # The tag value of the snapshot.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeSnapshotsResponseBodySnapshotsSnapshotTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshotsSnapshotTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeSnapshotsResponseBodySnapshotsSnapshotTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeSnapshotsResponseBodySnapshotsSnapshot(TeaModel):
    def __init__(self, category=None, creation_time=None, description=None, encrypted=None, instant_access=None,
                 instant_access_retention_days=None, kmskey_id=None, last_modified_time=None, product_code=None, progress=None, remain_time=None,
                 resource_group_id=None, retention_days=None, snapshot_id=None, snapshot_name=None, snapshot_sn=None,
                 snapshot_type=None, source_disk_id=None, source_disk_size=None, source_disk_type=None, source_region_id=None,
                 source_snapshot_id=None, source_storage_type=None, status=None, tags=None, usage=None):
        # The category of the snapshot.
        # 
        # > This parameter will be removed in the future. We recommend that you use the `InstantAccess` parameter to ensure future compatibility.
        self.category = category  # type: str
        # The time when the snapshot was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The description of the snapshot.
        self.description = description  # type: str
        # Indicates whether the snapshot was encrypted.
        self.encrypted = encrypted  # type: bool
        # Indicates whether the instant access feature is enabled. Valid values:
        # 
        # *   true: The instant access feature is enabled. This feature can be enabled only for enhanced SSDs (ESSDs).
        # *   false: The instant access feature is disabled. The snapshot is a normal snapshot for which the instant access feature is disabled.
        self.instant_access = instant_access  # type: bool
        # The duration of the instant access feature. The instant access feature is automatically disabled when the specified duration expires.
        # 
        # By default, the value of this parameter is the same as that of `RetentionDays`.
        self.instant_access_retention_days = instant_access_retention_days  # type: int
        # The ID of the KMS key used by the data disk.
        self.kmskey_id = kmskey_id  # type: str
        # The time when the snapshot was last changed. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.last_modified_time = last_modified_time  # type: str
        # The product code of the Alibaba Cloud Marketplace image.
        self.product_code = product_code  # type: str
        # The progress of the snapshot creation task. Unit: percent (%).
        self.progress = progress  # type: str
        # The remaining time that is required to create the snapshot. Unit: seconds.
        self.remain_time = remain_time  # type: int
        # The ID of the resource group to which the snapshot belongs.
        self.resource_group_id = resource_group_id  # type: str
        # The retention period of the automatic snapshot. Unit: days.
        self.retention_days = retention_days  # type: int
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The name of the snapshot. This parameter is returned only if a snapshot name was specified when the snapshot was created.
        self.snapshot_name = snapshot_name  # type: str
        # The serial number of the snapshot.
        self.snapshot_sn = snapshot_sn  # type: str
        # The type of snapshot. Valid values:
        # 
        # *   auto or timer: automatic snapshot
        # *   user: manual snapshot
        # *   all: all snapshot types
        self.snapshot_type = snapshot_type  # type: str
        # The ID of the source disk. This parameter is retained even after the source disk for which the snapshot was created is released.
        self.source_disk_id = source_disk_id  # type: str
        # The capacity of the source disk. Unit: GiB.
        self.source_disk_size = source_disk_size  # type: str
        # The type of the source disk. Valid values:
        # 
        # *   system
        # *   data
        self.source_disk_type = source_disk_type  # type: str
        # The region ID of the source snapshot.
        self.source_region_id = source_region_id  # type: str
        # The ID of the source snapshot.
        self.source_snapshot_id = source_snapshot_id  # type: str
        # The type of the source disk.
        # 
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.source_storage_type = source_storage_type  # type: str
        # The state of the snapshot. Valid values:
        # 
        # *   progressing
        # *   accomplished
        # *   failed
        self.status = status  # type: str
        # The tags of the snapshot.
        self.tags = tags  # type: DescribeSnapshotsResponseBodySnapshotsSnapshotTags
        # Indicates whether the snapshot has been used to create images or disks. Valid values:
        # 
        # *   image
        # *   disk
        # *   image_disk
        # *   none
        self.usage = usage  # type: str

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshotsSnapshot, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.instant_access is not None:
            result['InstantAccess'] = self.instant_access
        if self.instant_access_retention_days is not None:
            result['InstantAccessRetentionDays'] = self.instant_access_retention_days
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.last_modified_time is not None:
            result['LastModifiedTime'] = self.last_modified_time
        if self.product_code is not None:
            result['ProductCode'] = self.product_code
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.remain_time is not None:
            result['RemainTime'] = self.remain_time
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.snapshot_sn is not None:
            result['SnapshotSN'] = self.snapshot_sn
        if self.snapshot_type is not None:
            result['SnapshotType'] = self.snapshot_type
        if self.source_disk_id is not None:
            result['SourceDiskId'] = self.source_disk_id
        if self.source_disk_size is not None:
            result['SourceDiskSize'] = self.source_disk_size
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.source_region_id is not None:
            result['SourceRegionId'] = self.source_region_id
        if self.source_snapshot_id is not None:
            result['SourceSnapshotId'] = self.source_snapshot_id
        if self.source_storage_type is not None:
            result['SourceStorageType'] = self.source_storage_type
        if self.status is not None:
            result['Status'] = self.status
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.usage is not None:
            result['Usage'] = self.usage
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('InstantAccess') is not None:
            self.instant_access = m.get('InstantAccess')
        if m.get('InstantAccessRetentionDays') is not None:
            self.instant_access_retention_days = m.get('InstantAccessRetentionDays')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('LastModifiedTime') is not None:
            self.last_modified_time = m.get('LastModifiedTime')
        if m.get('ProductCode') is not None:
            self.product_code = m.get('ProductCode')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('RemainTime') is not None:
            self.remain_time = m.get('RemainTime')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SnapshotSN') is not None:
            self.snapshot_sn = m.get('SnapshotSN')
        if m.get('SnapshotType') is not None:
            self.snapshot_type = m.get('SnapshotType')
        if m.get('SourceDiskId') is not None:
            self.source_disk_id = m.get('SourceDiskId')
        if m.get('SourceDiskSize') is not None:
            self.source_disk_size = m.get('SourceDiskSize')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('SourceRegionId') is not None:
            self.source_region_id = m.get('SourceRegionId')
        if m.get('SourceSnapshotId') is not None:
            self.source_snapshot_id = m.get('SourceSnapshotId')
        if m.get('SourceStorageType') is not None:
            self.source_storage_type = m.get('SourceStorageType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tags') is not None:
            temp_model = DescribeSnapshotsResponseBodySnapshotsSnapshotTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Usage') is not None:
            self.usage = m.get('Usage')
        return self


class DescribeSnapshotsResponseBodySnapshots(TeaModel):
    def __init__(self, snapshot=None):
        self.snapshot = snapshot  # type: list[DescribeSnapshotsResponseBodySnapshotsSnapshot]

    def validate(self):
        if self.snapshot:
            for k in self.snapshot:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshots, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Snapshot'] = []
        if self.snapshot is not None:
            for k in self.snapshot:
                result['Snapshot'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.snapshot = []
        if m.get('Snapshot') is not None:
            for k in m.get('Snapshot'):
                temp_model = DescribeSnapshotsResponseBodySnapshotsSnapshot()
                self.snapshot.append(temp_model.from_map(k))
        return self


class DescribeSnapshotsResponseBody(TeaModel):
    def __init__(self, next_token=None, page_number=None, page_size=None, request_id=None, snapshots=None,
                 total_count=None):
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the snapshots.
        self.snapshots = snapshots  # type: DescribeSnapshotsResponseBodySnapshots
        # The total number of snapshots.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.snapshots:
            self.snapshots.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshots is not None:
            result['Snapshots'] = self.snapshots.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Snapshots') is not None:
            temp_model = DescribeSnapshotsResponseBodySnapshots()
            self.snapshots = temp_model.from_map(m['Snapshots'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSnapshotsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsUsageRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the snapshot. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsUsageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeSnapshotsUsageResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_count=None, snapshot_size=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of snapshots stored in the current region.
        self.snapshot_count = snapshot_count  # type: int
        # The total size of snapshots stored in the current region. Unit: byte.
        self.snapshot_size = snapshot_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsUsageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_count is not None:
            result['SnapshotCount'] = self.snapshot_count
        if self.snapshot_size is not None:
            result['SnapshotSize'] = self.snapshot_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotCount') is not None:
            self.snapshot_count = m.get('SnapshotCount')
        if m.get('SnapshotSize') is not None:
            self.snapshot_size = m.get('SnapshotSize')
        return self


class DescribeSnapshotsUsageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotsUsageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsUsageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsUsageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSpotAdviceRequest(TeaModel):
    def __init__(self, cores=None, gpu_amount=None, gpu_spec=None, instance_family_level=None,
                 instance_type_family=None, instance_types=None, memory=None, min_cores=None, min_memory=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, zone_id=None):
        # The number of vCPUs of the instance type. For information about the valid values, see [Instance families](~~25378~~).
        self.cores = cores  # type: int
        # The number of GPUs per GPU-accelerated instance. For information about the valid values, see [GPU-accelerated compute optimized instance types](~~108496~~).
        self.gpu_amount = gpu_amount  # type: int
        # The GPU type. Valid values:
        # 
        # *   NVIDIA P4
        # *   NVIDIA T4
        # *   NVIDIA P100
        # *   NVIDIA V100
        # *   NVIDIA A100
        # 
        # This parameter is empty by default, which indicates that all GPU types are queried. For more information, see [GPU-accelerated compute optimized instance types](~~108496~~).
        self.gpu_spec = gpu_spec  # type: str
        # The level of the instance family. Valid values:
        # 
        # *   EntryLevel
        # *   EnterpriseLevel
        # *   CreditEntryLevel. For more information, see [Burstable instance overview](~~59977~~).
        # 
        # This parameter is empty by default, which indicates that instance families of all levels are queried.
        self.instance_family_level = instance_family_level  # type: str
        # The instance family. For information about the valid values, see [Instance families](~~25378~~).
        self.instance_type_family = instance_type_family  # type: str
        # The list of instance types. You can enter up to 10 instance types.
        self.instance_types = instance_types  # type: list[str]
        # The memory size of the instance type. Unit: GiB. For information about the valid values, see [Instance families](~~25378~~).
        self.memory = memory  # type: float
        # The minimum number of vCPUs of the instance type. For information about the valid values, see [Instance families](~~25378~~).
        self.min_cores = min_cores  # type: int
        # The minimum memory size of the instance type. For information about the valid values, see [Instance families](~~25378~~).
        self.min_memory = min_memory  # type: float
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the zone.
        # 
        # This parameter is empty by default, which indicates that all zones in the specified region are queried.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSpotAdviceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cores is not None:
            result['Cores'] = self.cores
        if self.gpu_amount is not None:
            result['GpuAmount'] = self.gpu_amount
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.instance_family_level is not None:
            result['InstanceFamilyLevel'] = self.instance_family_level
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.min_cores is not None:
            result['MinCores'] = self.min_cores
        if self.min_memory is not None:
            result['MinMemory'] = self.min_memory
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cores') is not None:
            self.cores = m.get('Cores')
        if m.get('GpuAmount') is not None:
            self.gpu_amount = m.get('GpuAmount')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('InstanceFamilyLevel') is not None:
            self.instance_family_level = m.get('InstanceFamilyLevel')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MinCores') is not None:
            self.min_cores = m.get('MinCores')
        if m.get('MinMemory') is not None:
            self.min_memory = m.get('MinMemory')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource(TeaModel):
    def __init__(self, average_spot_discount=None, instance_type=None, interrupt_rate_desc=None,
                 interruption_rate=None):
        # The percentage of the average preemptible instance relative to the pay-as-you-go instance price in the last 30 days. Unit: percent (%). Valid values: 1 to 100.
        # 
        # You can calculate the average preemptible instance price based on the return value. For example, if the pay-as-you-go instance price is 1 and the return value of this parameter is 20, the average preemptible instance price in the last 30 days is 0.2.
        self.average_spot_discount = average_spot_discount  # type: int
        # The instance type.
        self.instance_type = instance_type  # type: str
        # The release rate range of preemptible instances in the last 30 days, which corresponds to the `InterruptionRate` value. Valid values:
        # 
        # *   0-3%\
        # *   3-5%\
        # *   5-10%\
        # *   10-100%\
        self.interrupt_rate_desc = interrupt_rate_desc  # type: str
        # The average release rate of preemptible instances in the last 30 days. Unit: percent (%).
        self.interruption_rate = interruption_rate  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.average_spot_discount is not None:
            result['AverageSpotDiscount'] = self.average_spot_discount
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.interrupt_rate_desc is not None:
            result['InterruptRateDesc'] = self.interrupt_rate_desc
        if self.interruption_rate is not None:
            result['InterruptionRate'] = self.interruption_rate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AverageSpotDiscount') is not None:
            self.average_spot_discount = m.get('AverageSpotDiscount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InterruptRateDesc') is not None:
            self.interrupt_rate_desc = m.get('InterruptRateDesc')
        if m.get('InterruptionRate') is not None:
            self.interruption_rate = m.get('InterruptionRate')
        return self


class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources(TeaModel):
    def __init__(self, available_spot_resource=None):
        self.available_spot_resource = available_spot_resource  # type: list[DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource]

    def validate(self):
        if self.available_spot_resource:
            for k in self.available_spot_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableSpotResource'] = []
        if self.available_spot_resource is not None:
            for k in self.available_spot_resource:
                result['AvailableSpotResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_spot_resource = []
        if m.get('AvailableSpotResource') is not None:
            for k in m.get('AvailableSpotResource'):
                temp_model = DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResourcesAvailableSpotResource()
                self.available_spot_resource.append(temp_model.from_map(k))
        return self


class DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone(TeaModel):
    def __init__(self, available_spot_resources=None, zone_id=None):
        # Details about preemptible instances in the last 30 days, including release rates and percentages of average preemptible instance prices relative to pay-as-you-go instance prices.
        self.available_spot_resources = available_spot_resources  # type: DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.available_spot_resources:
            self.available_spot_resources.validate()

    def to_map(self):
        _map = super(DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_spot_resources is not None:
            result['AvailableSpotResources'] = self.available_spot_resources.to_map()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableSpotResources') is not None:
            temp_model = DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZoneAvailableSpotResources()
            self.available_spot_resources = temp_model.from_map(m['AvailableSpotResources'])
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeSpotAdviceResponseBodyAvailableSpotZones(TeaModel):
    def __init__(self, available_spot_zone=None):
        self.available_spot_zone = available_spot_zone  # type: list[DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone]

    def validate(self):
        if self.available_spot_zone:
            for k in self.available_spot_zone:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSpotAdviceResponseBodyAvailableSpotZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AvailableSpotZone'] = []
        if self.available_spot_zone is not None:
            for k in self.available_spot_zone:
                result['AvailableSpotZone'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.available_spot_zone = []
        if m.get('AvailableSpotZone') is not None:
            for k in m.get('AvailableSpotZone'):
                temp_model = DescribeSpotAdviceResponseBodyAvailableSpotZonesAvailableSpotZone()
                self.available_spot_zone.append(temp_model.from_map(k))
        return self


class DescribeSpotAdviceResponseBody(TeaModel):
    def __init__(self, available_spot_zones=None, region_id=None, request_id=None):
        # Details about preemptible instances in the zones of the specified region.
        # 
        # >  The return values are sorted based on the historical percentages of average preemptible instance prices relative to pay-as-you-go instance prices for instance types.
        self.available_spot_zones = available_spot_zones  # type: DescribeSpotAdviceResponseBodyAvailableSpotZones
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.available_spot_zones:
            self.available_spot_zones.validate()

    def to_map(self):
        _map = super(DescribeSpotAdviceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_spot_zones is not None:
            result['AvailableSpotZones'] = self.available_spot_zones.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableSpotZones') is not None:
            temp_model = DescribeSpotAdviceResponseBodyAvailableSpotZones()
            self.available_spot_zones = temp_model.from_map(m['AvailableSpotZones'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeSpotAdviceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSpotAdviceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSpotAdviceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSpotAdviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSpotPriceHistoryRequest(TeaModel):
    def __init__(self, end_time=None, instance_type=None, io_optimized=None, network_type=None, ostype=None,
                 offset=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, spot_duration=None, start_time=None, zone_id=None):
        # The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC`.
        # 
        # This parameter is empty by default. If this parameter is empty, the current time is used.
        self.end_time = end_time  # type: str
        # The instance type of the instance.
        self.instance_type = instance_type  # type: str
        # Specifies whether the instance is I/O optimized. Valid values:
        # 
        # *   optimized: The instance is I/O optimized.
        # *   none: The instance is not I/O optimized.
        # 
        # For generation I instance families, the default value is none.
        # 
        # For other instance families, the default value is optimized.
        self.io_optimized = io_optimized  # type: str
        # The network type of the preemptible instance. Valid values:
        # 
        # *   classic
        # *   vpc
        self.network_type = network_type  # type: str
        # The type of the operating system platform. Valid values:
        # 
        # *   linux
        # *   windows
        self.ostype = ostype  # type: str
        # The line from which the next query starts.
        # 
        # Default value: 0.
        self.offset = offset  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC`.
        # 
        # This parameter is empty by default. If this parameter is empty, it indicates 3 hours earlier than the specified EndTime value. You can specify a StartTime value of up to 30 days earlier than the specified EndTime value.
        self.start_time = start_time  # type: str
        # The zone ID of the instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSpotPriceHistoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.offset is not None:
            result['Offset'] = self.offset
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('Offset') is not None:
            self.offset = m.get('Offset')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType(TeaModel):
    def __init__(self, instance_type=None, io_optimized=None, network_type=None, origin_price=None, spot_price=None,
                 timestamp=None, zone_id=None):
        # The instance type of the preemptible instance.
        self.instance_type = instance_type  # type: str
        # Indicates whether the preemptible instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # The network type of the preemptible instance.
        self.network_type = network_type  # type: str
        # The price for a pay-as-you-go instance that has the same configuration as the specified preemptible instance.
        self.origin_price = origin_price  # type: float
        # The spot price of the preemptible instance.
        self.spot_price = spot_price  # type: float
        # The time that corresponds to the queried spot price. The time is in the `yyyy-MM-ddTHH:mm:ssZ` format.
        self.timestamp = timestamp  # type: str
        # The zone ID of the preemptible instance.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.origin_price is not None:
            result['OriginPrice'] = self.origin_price
        if self.spot_price is not None:
            result['SpotPrice'] = self.spot_price
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OriginPrice') is not None:
            self.origin_price = m.get('OriginPrice')
        if m.get('SpotPrice') is not None:
            self.spot_price = m.get('SpotPrice')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeSpotPriceHistoryResponseBodySpotPrices(TeaModel):
    def __init__(self, spot_price_type=None):
        self.spot_price_type = spot_price_type  # type: list[DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType]

    def validate(self):
        if self.spot_price_type:
            for k in self.spot_price_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSpotPriceHistoryResponseBodySpotPrices, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SpotPriceType'] = []
        if self.spot_price_type is not None:
            for k in self.spot_price_type:
                result['SpotPriceType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.spot_price_type = []
        if m.get('SpotPriceType') is not None:
            for k in m.get('SpotPriceType'):
                temp_model = DescribeSpotPriceHistoryResponseBodySpotPricesSpotPriceType()
                self.spot_price_type.append(temp_model.from_map(k))
        return self


class DescribeSpotPriceHistoryResponseBody(TeaModel):
    def __init__(self, currency=None, next_offset=None, request_id=None, spot_prices=None):
        # The currency unit of the price.
        # 
        # Alibaba Cloud China site (aliyun.com): CNY.
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # The start row of the next page. It is the value of the `Offset` parameter.
        self.next_offset = next_offset  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the spot prices.
        self.spot_prices = spot_prices  # type: DescribeSpotPriceHistoryResponseBodySpotPrices

    def validate(self):
        if self.spot_prices:
            self.spot_prices.validate()

    def to_map(self):
        _map = super(DescribeSpotPriceHistoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.next_offset is not None:
            result['NextOffset'] = self.next_offset
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.spot_prices is not None:
            result['SpotPrices'] = self.spot_prices.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('NextOffset') is not None:
            self.next_offset = m.get('NextOffset')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SpotPrices') is not None:
            temp_model = DescribeSpotPriceHistoryResponseBodySpotPrices()
            self.spot_prices = temp_model.from_map(m['SpotPrices'])
        return self


class DescribeSpotPriceHistoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSpotPriceHistoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSpotPriceHistoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSpotPriceHistoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStorageCapacityUnitsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the SCU. N indicates that you can set multiple tag keys to query. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N of the SCU. N indicates that you can set multiple tag values to query and corresponds to N of `Tag.N.Key`. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeStorageCapacityUnitsRequest(TeaModel):
    def __init__(self, allocation_type=None, capacity=None, name=None, owner_account=None, owner_id=None,
                 page_number=None, page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 status=None, storage_capacity_unit_id=None, tag=None):
        # The allocation type. Valid values:
        # 
        # *   Normal: queries SCUs within the current Alibaba Cloud account.
        # *   Shared: queries SCUs shared between the Alibaba Cloud account and RAM users.
        # 
        # Default value: Normal.
        self.allocation_type = allocation_type  # type: str
        # The capacity of the SCU. Unit: GiB. Valid values: 20, 40, 100, 200, 500, 1024, 2048, 5120, 10240, 20480, and 51200.
        self.capacity = capacity  # type: int
        # The name of the SCU. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the SCU. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The statuses of SCUs.
        self.status = status  # type: list[str]
        # The IDs of the SCUs. You can enter at most 100 SCU IDs.
        self.storage_capacity_unit_id = storage_capacity_unit_id  # type: list[str]
        # The tags.
        self.tag = tag  # type: list[DescribeStorageCapacityUnitsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_type is not None:
            result['AllocationType'] = self.allocation_type
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_capacity_unit_id is not None:
            result['StorageCapacityUnitId'] = self.storage_capacity_unit_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationType') is not None:
            self.allocation_type = m.get('AllocationType')
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageCapacityUnitId') is not None:
            self.storage_capacity_unit_id = m.get('StorageCapacityUnitId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeStorageCapacityUnitsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag(TeaModel):
    def __init__(self, tag_key=None, tag_value=None):
        # The tag key of the SCU.
        self.tag_key = tag_key  # type: str
        # The tag value of the SCU.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit(TeaModel):
    def __init__(self, allocation_status=None, capacity=None, creation_time=None, description=None,
                 expired_time=None, name=None, region_id=None, start_time=None, status=None, storage_capacity_unit_id=None,
                 tags=None):
        # Indicates the allocation state of the SCU when the AllocationType parameter is set to Shared. Valid values:
        # 
        # *   allocated: The SCU is allocated to other accounts.
        # *   BeAllocated: The SCU is allocated from another account.
        self.allocation_status = allocation_status  # type: str
        # The capacity of the SCU.
        self.capacity = capacity  # type: int
        # The time when the SCU was created.
        self.creation_time = creation_time  # type: str
        # The description of the SCU.
        self.description = description  # type: str
        # The time when the SCU expires.
        self.expired_time = expired_time  # type: str
        # The name of the SCU.
        self.name = name  # type: str
        # The region ID of the SCU.
        self.region_id = region_id  # type: str
        # The time when the SCU took effect.
        self.start_time = start_time  # type: str
        # The state of the SCU.
        self.status = status  # type: str
        # The ID of the SCU.
        self.storage_capacity_unit_id = storage_capacity_unit_id  # type: str
        # The tag key-value pairs of the SCU.
        self.tags = tags  # type: DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_status is not None:
            result['AllocationStatus'] = self.allocation_status
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        if self.storage_capacity_unit_id is not None:
            result['StorageCapacityUnitId'] = self.storage_capacity_unit_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationStatus') is not None:
            self.allocation_status = m.get('AllocationStatus')
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StorageCapacityUnitId') is not None:
            self.storage_capacity_unit_id = m.get('StorageCapacityUnitId')
        if m.get('Tags') is not None:
            temp_model = DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnitTags()
            self.tags = temp_model.from_map(m['Tags'])
        return self


class DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits(TeaModel):
    def __init__(self, storage_capacity_unit=None):
        self.storage_capacity_unit = storage_capacity_unit  # type: list[DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit]

    def validate(self):
        if self.storage_capacity_unit:
            for k in self.storage_capacity_unit:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StorageCapacityUnit'] = []
        if self.storage_capacity_unit is not None:
            for k in self.storage_capacity_unit:
                result['StorageCapacityUnit'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.storage_capacity_unit = []
        if m.get('StorageCapacityUnit') is not None:
            for k in m.get('StorageCapacityUnit'):
                temp_model = DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnitsStorageCapacityUnit()
                self.storage_capacity_unit.append(temp_model.from_map(k))
        return self


class DescribeStorageCapacityUnitsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, storage_capacity_units=None,
                 total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the SCUs.
        self.storage_capacity_units = storage_capacity_units  # type: DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits
        # The total number of SCUs.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.storage_capacity_units:
            self.storage_capacity_units.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.storage_capacity_units is not None:
            result['StorageCapacityUnits'] = self.storage_capacity_units.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StorageCapacityUnits') is not None:
            temp_model = DescribeStorageCapacityUnitsResponseBodyStorageCapacityUnits()
            self.storage_capacity_units = temp_model.from_map(m['StorageCapacityUnits'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeStorageCapacityUnitsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStorageCapacityUnitsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStorageCapacityUnitsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStorageCapacityUnitsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStorageSetDetailsRequest(TeaModel):
    def __init__(self, client_token=None, disk_ids=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None, storage_set_id=None,
                 storage_set_partition_number=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The value of **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The IDs of disks or Shared Block Storage devices. The value can be a JSON array that consists of up to 100 disk or Shared Block Storage device IDs. Separate the IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the storage set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The maximum number of partitions in the storage set.
        self.storage_set_partition_number = storage_set_partition_number  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageSetDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        return self


class DescribeStorageSetDetailsResponseBodyDisksDisk(TeaModel):
    def __init__(self, category=None, creation_time=None, disk_id=None, disk_name=None, region_id=None,
                 storage_set_id=None, storage_set_partition_number=None, zone_id=None):
        # The category of the disk or Shared Block Storage device.
        self.category = category  # type: str
        # The time when the disk or Shared Block Storage device was created.
        self.creation_time = creation_time  # type: str
        # The ID of the disk or Shared Block Storage device.
        self.disk_id = disk_id  # type: str
        # The name of the disk or Shared Block Storage device.
        self.disk_name = disk_name  # type: str
        # The region to which the disk or Shared Block Storage device belongs.
        self.region_id = region_id  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The number of partitions in the storage set.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # The zone to which the disk or Shared Block Storage device belongs.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageSetDetailsResponseBodyDisksDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeStorageSetDetailsResponseBodyDisks(TeaModel):
    def __init__(self, disk=None):
        self.disk = disk  # type: list[DescribeStorageSetDetailsResponseBodyDisksDisk]

    def validate(self):
        if self.disk:
            for k in self.disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStorageSetDetailsResponseBodyDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Disk'] = []
        if self.disk is not None:
            for k in self.disk:
                result['Disk'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk = []
        if m.get('Disk') is not None:
            for k in m.get('Disk'):
                temp_model = DescribeStorageSetDetailsResponseBodyDisksDisk()
                self.disk.append(temp_model.from_map(k))
        return self


class DescribeStorageSetDetailsResponseBody(TeaModel):
    def __init__(self, disks=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about the disks or Shared Block Storage devices in the storage set.
        self.disks = disks  # type: DescribeStorageSetDetailsResponseBodyDisks
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of storage sets.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.disks:
            self.disks.validate()

    def to_map(self):
        _map = super(DescribeStorageSetDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disks is not None:
            result['Disks'] = self.disks.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Disks') is not None:
            temp_model = DescribeStorageSetDetailsResponseBodyDisks()
            self.disks = temp_model.from_map(m['Disks'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeStorageSetDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStorageSetDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStorageSetDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStorageSetDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeStorageSetsRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, storage_set_ids=None,
                 storage_set_name=None, zone_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The value of **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return. Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the storage set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of storage sets. The value is a JSON array that consists of up to 100 storage set IDs. Separate the IDs with commas (,).
        self.storage_set_ids = storage_set_ids  # type: str
        # The name of the storage set.
        self.storage_set_name = storage_set_name  # type: str
        # The zone ID of the storage set. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageSetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_set_ids is not None:
            result['StorageSetIds'] = self.storage_set_ids
        if self.storage_set_name is not None:
            result['StorageSetName'] = self.storage_set_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageSetIds') is not None:
            self.storage_set_ids = m.get('StorageSetIds')
        if m.get('StorageSetName') is not None:
            self.storage_set_name = m.get('StorageSetName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeStorageSetsResponseBodyStorageSetsStorageSet(TeaModel):
    def __init__(self, creation_time=None, description=None, region_id=None, storage_set_id=None,
                 storage_set_name=None, storage_set_partition_number=None, zone_id=None):
        # The time when the storage set was created.
        self.creation_time = creation_time  # type: str
        # The description of the storage set.
        self.description = description  # type: str
        # The ID of the region to which the storage set belongs.
        self.region_id = region_id  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The name of the storage set.
        self.storage_set_name = storage_set_name  # type: str
        # The maximum number of partitions supported by the storage set.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # The ID of the zone to which the storage set belongs.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeStorageSetsResponseBodyStorageSetsStorageSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_name is not None:
            result['StorageSetName'] = self.storage_set_name
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetName') is not None:
            self.storage_set_name = m.get('StorageSetName')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeStorageSetsResponseBodyStorageSets(TeaModel):
    def __init__(self, storage_set=None):
        self.storage_set = storage_set  # type: list[DescribeStorageSetsResponseBodyStorageSetsStorageSet]

    def validate(self):
        if self.storage_set:
            for k in self.storage_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeStorageSetsResponseBodyStorageSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['StorageSet'] = []
        if self.storage_set is not None:
            for k in self.storage_set:
                result['StorageSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.storage_set = []
        if m.get('StorageSet') is not None:
            for k in m.get('StorageSet'):
                temp_model = DescribeStorageSetsResponseBodyStorageSetsStorageSet()
                self.storage_set.append(temp_model.from_map(k))
        return self


class DescribeStorageSetsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, storage_sets=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the storage sets. The value of this parameter is an array that consists of StorageSet data.
        self.storage_sets = storage_sets  # type: DescribeStorageSetsResponseBodyStorageSets
        # The total number of storage sets.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.storage_sets:
            self.storage_sets.validate()

    def to_map(self):
        _map = super(DescribeStorageSetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.storage_sets is not None:
            result['StorageSets'] = self.storage_sets.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StorageSets') is not None:
            temp_model = DescribeStorageSetsResponseBodyStorageSets()
            self.storage_sets = temp_model.from_map(m['StorageSets'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeStorageSetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeStorageSetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeStorageSetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeStorageSetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the resource. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeTagsRequest(TeaModel):
    def __init__(self, category=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_id=None, resource_owner_account=None, resource_owner_id=None, resource_type=None, tag=None):
        # > This parameter will be removed in the future. We recommend that you use other parameters to ensure future compatibility.
        self.category = category  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 50.
        self.page_size = page_size  # type: int
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        # The ID of the resource. For example, when ResourceType is set to instance, this parameter is interpreted as the ID of the instance (InstanceId).
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource to which the tag is added. Valid values:
        # 
        # *   instance: Elastic Compute Service (ECS) instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: elastic network interface (ENI)
        # *   ddh: dedicated host
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # *   reservedinstance: reserved instance
        # *   snapshotpolicy: automatic snapshot policy
        # 
        # All values must be lowercase.
        self.resource_type = resource_type  # type: str
        # The list of tags.
        self.tag = tag  # type: list[DescribeTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeTagsResponseBodyTagsTagResourceTypeCount(TeaModel):
    def __init__(self, ddh=None, disk=None, eni=None, image=None, instance=None, key_pair=None, launch_template=None,
                 reserved_instance=None, securitygroup=None, snapshot=None, snapshot_policy=None, volume=None):
        # The number of dedicated hosts to which the tag is added.
        self.ddh = ddh  # type: int
        # The number of disks to which the tag is added.
        self.disk = disk  # type: int
        # The number of ENIs to which the tag is added.
        self.eni = eni  # type: int
        # The number of images to which the tag is added.
        self.image = image  # type: int
        # The number of instances to which the tag is added.
        self.instance = instance  # type: int
        # The number of key pairs to which the tag is added.
        self.key_pair = key_pair  # type: int
        # The number of launch templates to which the tag is added.
        self.launch_template = launch_template  # type: int
        # The number of reserved instances to which the tag is added.
        self.reserved_instance = reserved_instance  # type: int
        # The number of security groups to which the tag is added.
        self.securitygroup = securitygroup  # type: int
        # The number of snapshots to which the tag is added.
        self.snapshot = snapshot  # type: int
        # The number of automatic snapshot policies to which the tag is added.
        self.snapshot_policy = snapshot_policy  # type: int
        # The number of storage volumes to which the tag is added.
        self.volume = volume  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagsResponseBodyTagsTagResourceTypeCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ddh is not None:
            result['Ddh'] = self.ddh
        if self.disk is not None:
            result['Disk'] = self.disk
        if self.eni is not None:
            result['Eni'] = self.eni
        if self.image is not None:
            result['Image'] = self.image
        if self.instance is not None:
            result['Instance'] = self.instance
        if self.key_pair is not None:
            result['KeyPair'] = self.key_pair
        if self.launch_template is not None:
            result['LaunchTemplate'] = self.launch_template
        if self.reserved_instance is not None:
            result['ReservedInstance'] = self.reserved_instance
        if self.securitygroup is not None:
            result['Securitygroup'] = self.securitygroup
        if self.snapshot is not None:
            result['Snapshot'] = self.snapshot
        if self.snapshot_policy is not None:
            result['SnapshotPolicy'] = self.snapshot_policy
        if self.volume is not None:
            result['Volume'] = self.volume
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ddh') is not None:
            self.ddh = m.get('Ddh')
        if m.get('Disk') is not None:
            self.disk = m.get('Disk')
        if m.get('Eni') is not None:
            self.eni = m.get('Eni')
        if m.get('Image') is not None:
            self.image = m.get('Image')
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        if m.get('KeyPair') is not None:
            self.key_pair = m.get('KeyPair')
        if m.get('LaunchTemplate') is not None:
            self.launch_template = m.get('LaunchTemplate')
        if m.get('ReservedInstance') is not None:
            self.reserved_instance = m.get('ReservedInstance')
        if m.get('Securitygroup') is not None:
            self.securitygroup = m.get('Securitygroup')
        if m.get('Snapshot') is not None:
            self.snapshot = m.get('Snapshot')
        if m.get('SnapshotPolicy') is not None:
            self.snapshot_policy = m.get('SnapshotPolicy')
        if m.get('Volume') is not None:
            self.volume = m.get('Volume')
        return self


class DescribeTagsResponseBodyTagsTag(TeaModel):
    def __init__(self, resource_type_count=None, tag_key=None, tag_value=None):
        # The number of resource types.
        self.resource_type_count = resource_type_count  # type: DescribeTagsResponseBodyTagsTagResourceTypeCount
        # The key of the tag.
        self.tag_key = tag_key  # type: str
        # The value of the tag.
        self.tag_value = tag_value  # type: str

    def validate(self):
        if self.resource_type_count:
            self.resource_type_count.validate()

    def to_map(self):
        _map = super(DescribeTagsResponseBodyTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_type_count is not None:
            result['ResourceTypeCount'] = self.resource_type_count.to_map()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceTypeCount') is not None:
            temp_model = DescribeTagsResponseBodyTagsTagResourceTypeCount()
            self.resource_type_count = temp_model.from_map(m['ResourceTypeCount'])
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeTagsResponseBodyTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeTagsResponseBodyTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTagsResponseBodyTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeTagsResponseBodyTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeTagsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, tags=None, total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The tags that match all the filter conditions.
        self.tags = tags  # type: DescribeTagsResponseBodyTags
        # The total number of tags.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.tags:
            self.tags.validate()

    def to_map(self):
        _map = super(DescribeTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Tags') is not None:
            temp_model = DescribeTagsResponseBodyTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTaskAttributeRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 task_id=None):
        self.owner_id = owner_id  # type: long
        # The region ID of the task. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the task. You can call the [DescribeTasks](~~25622~~) operation to query the list of task IDs.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTaskAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(TeaModel):
    def __init__(self, name=None, value=None):
        # The name of the related item.
        self.name = name  # type: str
        # The value of the related item.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet(TeaModel):
    def __init__(self, related_item=None):
        self.related_item = related_item  # type: list[DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem]

    def validate(self):
        if self.related_item:
            for k in self.related_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RelatedItem'] = []
        if self.related_item is not None:
            for k in self.related_item:
                result['RelatedItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.related_item = []
        if m.get('RelatedItem') is not None:
            for k in m.get('RelatedItem'):
                temp_model = DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem()
                self.related_item.append(temp_model.from_map(k))
        return self


class DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress(TeaModel):
    def __init__(self, error_code=None, error_msg=None, operation_status=None, related_item_set=None):
        # The error code.
        self.error_code = error_code  # type: str
        # The error message.
        self.error_msg = error_msg  # type: str
        # The status of the operation.
        self.operation_status = operation_status  # type: str
        # An array consisting of RelatedItem data.
        self.related_item_set = related_item_set  # type: DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet

    def validate(self):
        if self.related_item_set:
            self.related_item_set.validate()

    def to_map(self):
        _map = super(DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.operation_status is not None:
            result['OperationStatus'] = self.operation_status
        if self.related_item_set is not None:
            result['RelatedItemSet'] = self.related_item_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('OperationStatus') is not None:
            self.operation_status = m.get('OperationStatus')
        if m.get('RelatedItemSet') is not None:
            temp_model = DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgressRelatedItemSet()
            self.related_item_set = temp_model.from_map(m['RelatedItemSet'])
        return self


class DescribeTaskAttributeResponseBodyOperationProgressSet(TeaModel):
    def __init__(self, operation_progress=None):
        self.operation_progress = operation_progress  # type: list[DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress]

    def validate(self):
        if self.operation_progress:
            for k in self.operation_progress:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTaskAttributeResponseBodyOperationProgressSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationProgress'] = []
        if self.operation_progress is not None:
            for k in self.operation_progress:
                result['OperationProgress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_progress = []
        if m.get('OperationProgress') is not None:
            for k in m.get('OperationProgress'):
                temp_model = DescribeTaskAttributeResponseBodyOperationProgressSetOperationProgress()
                self.operation_progress.append(temp_model.from_map(k))
        return self


class DescribeTaskAttributeResponseBody(TeaModel):
    def __init__(self, creation_time=None, failed_count=None, finished_time=None, operation_progress_set=None,
                 region_id=None, request_id=None, success_count=None, support_cancel=None, task_action=None, task_id=None,
                 task_process=None, task_status=None, total_count=None):
        # The time when the task was created.
        self.creation_time = creation_time  # type: str
        # The number of failed tasks.
        self.failed_count = failed_count  # type: int
        # The time when the task was complete.
        self.finished_time = finished_time  # type: str
        # An array consisting of OperationProgress data of each subtask.
        self.operation_progress_set = operation_progress_set  # type: DescribeTaskAttributeResponseBodyOperationProgressSet
        # The region ID of the task.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of completed tasks.
        self.success_count = success_count  # type: int
        # Indicates whether the task can be canceled ([CancelTask](https://www.alibabacloud.com/help/en/elastic-compute-service/latest/canceltask)). Valid values: 
        # 
        # - true: The task can be canceled.
        # - false: The task cannot be canceled.
        self.support_cancel = support_cancel  # type: str
        # The operation name of the task.
        self.task_action = task_action  # type: str
        # The ID of the task.
        self.task_id = task_id  # type: str
        # The progress of the task.
        self.task_process = task_process  # type: str
        # The status of the task.
        self.task_status = task_status  # type: str
        # The total number of tasks.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.operation_progress_set:
            self.operation_progress_set.validate()

    def to_map(self):
        _map = super(DescribeTaskAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.failed_count is not None:
            result['FailedCount'] = self.failed_count
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.operation_progress_set is not None:
            result['OperationProgressSet'] = self.operation_progress_set.to_map()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success_count is not None:
            result['SuccessCount'] = self.success_count
        if self.support_cancel is not None:
            result['SupportCancel'] = self.support_cancel
        if self.task_action is not None:
            result['TaskAction'] = self.task_action
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_process is not None:
            result['TaskProcess'] = self.task_process
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FailedCount') is not None:
            self.failed_count = m.get('FailedCount')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('OperationProgressSet') is not None:
            temp_model = DescribeTaskAttributeResponseBodyOperationProgressSet()
            self.operation_progress_set = temp_model.from_map(m['OperationProgressSet'])
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SuccessCount') is not None:
            self.success_count = m.get('SuccessCount')
        if m.get('SupportCancel') is not None:
            self.support_cancel = m.get('SupportCancel')
        if m.get('TaskAction') is not None:
            self.task_action = m.get('TaskAction')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskProcess') is not None:
            self.task_process = m.get('TaskProcess')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTaskAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTaskAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTaskAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTaskAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTasksRequest(TeaModel):
    def __init__(self, end_time=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_ids=None, resource_owner_account=None, resource_owner_id=None, start_time=None,
                 task_action=None, task_ids=None, task_status=None):
        # The end point of the time period for which to query created tasks. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.end_time = end_time  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The page number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The region ID of the task. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_ids = resource_ids  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start point of the time period for which to query created tasks. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.start_time = start_time  # type: str
        # The name of the operation that generates the task. Valid values:
        # 
        # *   ImportImage
        # *   ExportImage
        # *   RedeployInstance
        # *   ModifyDiskSpec
        self.task_action = task_action  # type: str
        # The IDs of the tasks. You can specify up to 100 tasks at a time. Separate multiple task IDs with commas (,).
        self.task_ids = task_ids  # type: str
        # The status of the task. Valid values:
        # 
        # *   Finished
        # *   Processing
        # *   Failed
        # 
        # This parameter has no default value.
        # 
        # >  The system only retrieves tasks in the Finished, Processing, and Failed states and ignores other values.
        self.task_status = task_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTasksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_ids is not None:
            result['ResourceIds'] = self.resource_ids
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_action is not None:
            result['TaskAction'] = self.task_action
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceIds') is not None:
            self.resource_ids = m.get('ResourceIds')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskAction') is not None:
            self.task_action = m.get('TaskAction')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeTasksResponseBodyTaskSetTask(TeaModel):
    def __init__(self, creation_time=None, finished_time=None, resource_id=None, support_cancel=None,
                 task_action=None, task_id=None, task_status=None):
        # The time when the task was created.
        self.creation_time = creation_time  # type: str
        # The time when the task was completed.
        self.finished_time = finished_time  # type: str
        self.resource_id = resource_id  # type: str
        # Indicates whether the task can be canceled.
        self.support_cancel = support_cancel  # type: str
        # The name of the task.
        self.task_action = task_action  # type: str
        # The ID of the task.
        self.task_id = task_id  # type: str
        # The status of the task.
        self.task_status = task_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTasksResponseBodyTaskSetTask, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.finished_time is not None:
            result['FinishedTime'] = self.finished_time
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.support_cancel is not None:
            result['SupportCancel'] = self.support_cancel
        if self.task_action is not None:
            result['TaskAction'] = self.task_action
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('FinishedTime') is not None:
            self.finished_time = m.get('FinishedTime')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('SupportCancel') is not None:
            self.support_cancel = m.get('SupportCancel')
        if m.get('TaskAction') is not None:
            self.task_action = m.get('TaskAction')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeTasksResponseBodyTaskSet(TeaModel):
    def __init__(self, task=None):
        self.task = task  # type: list[DescribeTasksResponseBodyTaskSetTask]

    def validate(self):
        if self.task:
            for k in self.task:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeTasksResponseBodyTaskSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Task'] = []
        if self.task is not None:
            for k in self.task:
                result['Task'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.task = []
        if m.get('Task') is not None:
            for k in m.get('Task'):
                temp_model = DescribeTasksResponseBodyTaskSetTask()
                self.task.append(temp_model.from_map(k))
        return self


class DescribeTasksResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None, request_id=None, task_set=None,
                 total_count=None):
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The region ID of the task.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the tasks.
        self.task_set = task_set  # type: DescribeTasksResponseBodyTaskSet
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.task_set:
            self.task_set.validate()

    def to_map(self):
        _map = super(DescribeTasksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_set is not None:
            result['TaskSet'] = self.task_set.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskSet') is not None:
            temp_model = DescribeTasksResponseBodyTaskSet()
            self.task_set = temp_model.from_map(m['TaskSet'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeTasksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTasksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTasksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserBusinessBehaviorRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, status_key=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.status_key = status_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserBusinessBehaviorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status_key is not None:
            result['statusKey'] = self.status_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('statusKey') is not None:
            self.status_key = m.get('statusKey')
        return self


class DescribeUserBusinessBehaviorResponseBody(TeaModel):
    def __init__(self, request_id=None, status_value=None):
        self.request_id = request_id  # type: str
        self.status_value = status_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserBusinessBehaviorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.status_value is not None:
            result['StatusValue'] = self.status_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StatusValue') is not None:
            self.status_value = m.get('StatusValue')
        return self


class DescribeUserBusinessBehaviorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserBusinessBehaviorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserBusinessBehaviorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserBusinessBehaviorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserDataRequest(TeaModel):
    def __init__(self, instance_id=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeUserDataResponseBody(TeaModel):
    def __init__(self, instance_id=None, region_id=None, request_id=None, user_data=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The user data of the instance.
        self.user_data = user_data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class DescribeUserDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVRoutersRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, vrouter_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vrouter_id = vrouter_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVRoutersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        return self


class DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds(TeaModel):
    def __init__(self, route_table_id=None):
        self.route_table_id = route_table_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        return self


class DescribeVRoutersResponseBodyVRoutersVRouter(TeaModel):
    def __init__(self, creation_time=None, description=None, region_id=None, route_table_ids=None, vrouter_id=None,
                 vrouter_name=None, vpc_id=None):
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.region_id = region_id  # type: str
        self.route_table_ids = route_table_ids  # type: DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds
        self.vrouter_id = vrouter_id  # type: str
        self.vrouter_name = vrouter_name  # type: str
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.route_table_ids:
            self.route_table_ids.validate()

    def to_map(self):
        _map = super(DescribeVRoutersResponseBodyVRoutersVRouter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.route_table_ids is not None:
            result['RouteTableIds'] = self.route_table_ids.to_map()
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        if self.vrouter_name is not None:
            result['VRouterName'] = self.vrouter_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RouteTableIds') is not None:
            temp_model = DescribeVRoutersResponseBodyVRoutersVRouterRouteTableIds()
            self.route_table_ids = temp_model.from_map(m['RouteTableIds'])
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        if m.get('VRouterName') is not None:
            self.vrouter_name = m.get('VRouterName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeVRoutersResponseBodyVRouters(TeaModel):
    def __init__(self, vrouter=None):
        self.vrouter = vrouter  # type: list[DescribeVRoutersResponseBodyVRoutersVRouter]

    def validate(self):
        if self.vrouter:
            for k in self.vrouter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVRoutersResponseBodyVRouters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VRouter'] = []
        if self.vrouter is not None:
            for k in self.vrouter:
                result['VRouter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.vrouter = []
        if m.get('VRouter') is not None:
            for k in m.get('VRouter'):
                temp_model = DescribeVRoutersResponseBodyVRoutersVRouter()
                self.vrouter.append(temp_model.from_map(k))
        return self


class DescribeVRoutersResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, total_count=None, vrouters=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.vrouters = vrouters  # type: DescribeVRoutersResponseBodyVRouters

    def validate(self):
        if self.vrouters:
            self.vrouters.validate()

    def to_map(self):
        _map = super(DescribeVRoutersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.vrouters is not None:
            result['VRouters'] = self.vrouters.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('VRouters') is not None:
            temp_model = DescribeVRoutersResponseBodyVRouters()
            self.vrouters = temp_model.from_map(m['VRouters'])
        return self


class DescribeVRoutersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVRoutersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVRoutersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVRoutersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVSwitchesRequest(TeaModel):
    def __init__(self, is_default=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, v_switch_id=None, vpc_id=None,
                 zone_id=None):
        self.is_default = is_default  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.v_switch_id = v_switch_id  # type: str
        self.vpc_id = vpc_id  # type: str
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVSwitchesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeVSwitchesResponseBodyVSwitchesVSwitch(TeaModel):
    def __init__(self, available_ip_address_count=None, cidr_block=None, creation_time=None, description=None,
                 is_default=None, resource_group_id=None, status=None, v_switch_id=None, v_switch_name=None, vpc_id=None,
                 zone_id=None):
        self.available_ip_address_count = available_ip_address_count  # type: long
        self.cidr_block = cidr_block  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.is_default = is_default  # type: bool
        self.resource_group_id = resource_group_id  # type: str
        self.status = status  # type: str
        self.v_switch_id = v_switch_id  # type: str
        self.v_switch_name = v_switch_name  # type: str
        self.vpc_id = vpc_id  # type: str
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVSwitchesResponseBodyVSwitchesVSwitch, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_ip_address_count is not None:
            result['AvailableIpAddressCount'] = self.available_ip_address_count
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.status is not None:
            result['Status'] = self.status
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableIpAddressCount') is not None:
            self.available_ip_address_count = m.get('AvailableIpAddressCount')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeVSwitchesResponseBodyVSwitches(TeaModel):
    def __init__(self, v_switch=None):
        self.v_switch = v_switch  # type: list[DescribeVSwitchesResponseBodyVSwitchesVSwitch]

    def validate(self):
        if self.v_switch:
            for k in self.v_switch:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVSwitchesResponseBodyVSwitches, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VSwitch'] = []
        if self.v_switch is not None:
            for k in self.v_switch:
                result['VSwitch'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.v_switch = []
        if m.get('VSwitch') is not None:
            for k in m.get('VSwitch'):
                temp_model = DescribeVSwitchesResponseBodyVSwitchesVSwitch()
                self.v_switch.append(temp_model.from_map(k))
        return self


class DescribeVSwitchesResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, total_count=None, v_switches=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.v_switches = v_switches  # type: DescribeVSwitchesResponseBodyVSwitches

    def validate(self):
        if self.v_switches:
            self.v_switches.validate()

    def to_map(self):
        _map = super(DescribeVSwitchesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.v_switches is not None:
            result['VSwitches'] = self.v_switches.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('VSwitches') is not None:
            temp_model = DescribeVSwitchesResponseBodyVSwitches()
            self.v_switches = temp_model.from_map(m['VSwitches'])
        return self


class DescribeVSwitchesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVSwitchesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVSwitchesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVSwitchesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVirtualBorderRoutersRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeVirtualBorderRoutersRequest(TeaModel):
    def __init__(self, filter=None, owner_id=None, page_number=None, page_size=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.filter = filter  # type: list[DescribeVirtualBorderRoutersRequestFilter]
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeVirtualBorderRoutersRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType(TeaModel):
    def __init__(self, access_point_id=None, activation_time=None, circuit_code=None, creation_time=None,
                 description=None, local_gateway_ip=None, name=None, peer_gateway_ip=None, peering_subnet_mask=None,
                 physical_connection_business_status=None, physical_connection_id=None, physical_connection_owner_uid=None,
                 physical_connection_status=None, recovery_time=None, route_table_id=None, status=None, termination_time=None, vbr_id=None,
                 vlan_id=None, vlan_interface_id=None):
        self.access_point_id = access_point_id  # type: str
        self.activation_time = activation_time  # type: str
        self.circuit_code = circuit_code  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.local_gateway_ip = local_gateway_ip  # type: str
        self.name = name  # type: str
        self.peer_gateway_ip = peer_gateway_ip  # type: str
        self.peering_subnet_mask = peering_subnet_mask  # type: str
        self.physical_connection_business_status = physical_connection_business_status  # type: str
        self.physical_connection_id = physical_connection_id  # type: str
        self.physical_connection_owner_uid = physical_connection_owner_uid  # type: str
        self.physical_connection_status = physical_connection_status  # type: str
        self.recovery_time = recovery_time  # type: str
        self.route_table_id = route_table_id  # type: str
        self.status = status  # type: str
        self.termination_time = termination_time  # type: str
        self.vbr_id = vbr_id  # type: str
        self.vlan_id = vlan_id  # type: int
        self.vlan_interface_id = vlan_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_point_id is not None:
            result['AccessPointId'] = self.access_point_id
        if self.activation_time is not None:
            result['ActivationTime'] = self.activation_time
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.local_gateway_ip is not None:
            result['LocalGatewayIp'] = self.local_gateway_ip
        if self.name is not None:
            result['Name'] = self.name
        if self.peer_gateway_ip is not None:
            result['PeerGatewayIp'] = self.peer_gateway_ip
        if self.peering_subnet_mask is not None:
            result['PeeringSubnetMask'] = self.peering_subnet_mask
        if self.physical_connection_business_status is not None:
            result['PhysicalConnectionBusinessStatus'] = self.physical_connection_business_status
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.physical_connection_owner_uid is not None:
            result['PhysicalConnectionOwnerUid'] = self.physical_connection_owner_uid
        if self.physical_connection_status is not None:
            result['PhysicalConnectionStatus'] = self.physical_connection_status
        if self.recovery_time is not None:
            result['RecoveryTime'] = self.recovery_time
        if self.route_table_id is not None:
            result['RouteTableId'] = self.route_table_id
        if self.status is not None:
            result['Status'] = self.status
        if self.termination_time is not None:
            result['TerminationTime'] = self.termination_time
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        if self.vlan_interface_id is not None:
            result['VlanInterfaceId'] = self.vlan_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessPointId') is not None:
            self.access_point_id = m.get('AccessPointId')
        if m.get('ActivationTime') is not None:
            self.activation_time = m.get('ActivationTime')
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LocalGatewayIp') is not None:
            self.local_gateway_ip = m.get('LocalGatewayIp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PeerGatewayIp') is not None:
            self.peer_gateway_ip = m.get('PeerGatewayIp')
        if m.get('PeeringSubnetMask') is not None:
            self.peering_subnet_mask = m.get('PeeringSubnetMask')
        if m.get('PhysicalConnectionBusinessStatus') is not None:
            self.physical_connection_business_status = m.get('PhysicalConnectionBusinessStatus')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('PhysicalConnectionOwnerUid') is not None:
            self.physical_connection_owner_uid = m.get('PhysicalConnectionOwnerUid')
        if m.get('PhysicalConnectionStatus') is not None:
            self.physical_connection_status = m.get('PhysicalConnectionStatus')
        if m.get('RecoveryTime') is not None:
            self.recovery_time = m.get('RecoveryTime')
        if m.get('RouteTableId') is not None:
            self.route_table_id = m.get('RouteTableId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TerminationTime') is not None:
            self.termination_time = m.get('TerminationTime')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        if m.get('VlanInterfaceId') is not None:
            self.vlan_interface_id = m.get('VlanInterfaceId')
        return self


class DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet(TeaModel):
    def __init__(self, virtual_border_router_type=None):
        self.virtual_border_router_type = virtual_border_router_type  # type: list[DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType]

    def validate(self):
        if self.virtual_border_router_type:
            for k in self.virtual_border_router_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VirtualBorderRouterType'] = []
        if self.virtual_border_router_type is not None:
            for k in self.virtual_border_router_type:
                result['VirtualBorderRouterType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.virtual_border_router_type = []
        if m.get('VirtualBorderRouterType') is not None:
            for k in m.get('VirtualBorderRouterType'):
                temp_model = DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSetVirtualBorderRouterType()
                self.virtual_border_router_type.append(temp_model.from_map(k))
        return self


class DescribeVirtualBorderRoutersResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, total_count=None,
                 virtual_border_router_set=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.virtual_border_router_set = virtual_border_router_set  # type: DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet

    def validate(self):
        if self.virtual_border_router_set:
            self.virtual_border_router_set.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.virtual_border_router_set is not None:
            result['VirtualBorderRouterSet'] = self.virtual_border_router_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('VirtualBorderRouterSet') is not None:
            temp_model = DescribeVirtualBorderRoutersResponseBodyVirtualBorderRouterSet()
            self.virtual_border_router_set = temp_model.from_map(m['VirtualBorderRouterSet'])
        return self


class DescribeVirtualBorderRoutersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVirtualBorderRoutersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVirtualBorderRoutersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionRequest(TeaModel):
    def __init__(self, filter=None, owner_id=None, page_number=None, page_size=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.filter = filter  # type: list[DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter]
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeVirtualBorderRoutersForPhysicalConnectionRequestFilter()
                self.filter.append(temp_model.from_map(k))
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType(TeaModel):
    def __init__(self, activation_time=None, circuit_code=None, creation_time=None, recovery_time=None,
                 termination_time=None, vbr_id=None, vbr_owner_uid=None, vlan_id=None):
        self.activation_time = activation_time  # type: str
        self.circuit_code = circuit_code  # type: str
        self.creation_time = creation_time  # type: str
        self.recovery_time = recovery_time  # type: str
        self.termination_time = termination_time  # type: str
        self.vbr_id = vbr_id  # type: str
        self.vbr_owner_uid = vbr_owner_uid  # type: long
        self.vlan_id = vlan_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_time is not None:
            result['ActivationTime'] = self.activation_time
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.recovery_time is not None:
            result['RecoveryTime'] = self.recovery_time
        if self.termination_time is not None:
            result['TerminationTime'] = self.termination_time
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        if self.vbr_owner_uid is not None:
            result['VbrOwnerUid'] = self.vbr_owner_uid
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationTime') is not None:
            self.activation_time = m.get('ActivationTime')
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('RecoveryTime') is not None:
            self.recovery_time = m.get('RecoveryTime')
        if m.get('TerminationTime') is not None:
            self.termination_time = m.get('TerminationTime')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        if m.get('VbrOwnerUid') is not None:
            self.vbr_owner_uid = m.get('VbrOwnerUid')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet(TeaModel):
    def __init__(self, virtual_border_router_for_physical_connection_type=None):
        self.virtual_border_router_for_physical_connection_type = virtual_border_router_for_physical_connection_type  # type: list[DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType]

    def validate(self):
        if self.virtual_border_router_for_physical_connection_type:
            for k in self.virtual_border_router_for_physical_connection_type:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['VirtualBorderRouterForPhysicalConnectionType'] = []
        if self.virtual_border_router_for_physical_connection_type is not None:
            for k in self.virtual_border_router_for_physical_connection_type:
                result['VirtualBorderRouterForPhysicalConnectionType'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.virtual_border_router_for_physical_connection_type = []
        if m.get('VirtualBorderRouterForPhysicalConnectionType') is not None:
            for k in m.get('VirtualBorderRouterForPhysicalConnectionType'):
                temp_model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSetVirtualBorderRouterForPhysicalConnectionType()
                self.virtual_border_router_for_physical_connection_type.append(temp_model.from_map(k))
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, total_count=None,
                 virtual_border_router_for_physical_connection_set=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.virtual_border_router_for_physical_connection_set = virtual_border_router_for_physical_connection_set  # type: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet

    def validate(self):
        if self.virtual_border_router_for_physical_connection_set:
            self.virtual_border_router_for_physical_connection_set.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.virtual_border_router_for_physical_connection_set is not None:
            result['VirtualBorderRouterForPhysicalConnectionSet'] = self.virtual_border_router_for_physical_connection_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('VirtualBorderRouterForPhysicalConnectionSet') is not None:
            temp_model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBodyVirtualBorderRouterForPhysicalConnectionSet()
            self.virtual_border_router_for_physical_connection_set = temp_model.from_map(m['VirtualBorderRouterForPhysicalConnectionSet'])
        return self


class DescribeVirtualBorderRoutersForPhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVirtualBorderRoutersForPhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVpcsRequest(TeaModel):
    def __init__(self, is_default=None, owner_account=None, owner_id=None, page_number=None, page_size=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, vpc_id=None):
        self.is_default = is_default  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeVpcsResponseBodyVpcsVpcUserCidrs(TeaModel):
    def __init__(self, user_cidr=None):
        self.user_cidr = user_cidr  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcsResponseBodyVpcsVpcUserCidrs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class DescribeVpcsResponseBodyVpcsVpcVSwitchIds(TeaModel):
    def __init__(self, v_switch_id=None):
        self.v_switch_id = v_switch_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVpcsResponseBodyVpcsVpcVSwitchIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeVpcsResponseBodyVpcsVpc(TeaModel):
    def __init__(self, cidr_block=None, creation_time=None, description=None, is_default=None, region_id=None,
                 status=None, user_cidrs=None, vrouter_id=None, v_switch_ids=None, vpc_id=None, vpc_name=None):
        self.cidr_block = cidr_block  # type: str
        self.creation_time = creation_time  # type: str
        self.description = description  # type: str
        self.is_default = is_default  # type: bool
        self.region_id = region_id  # type: str
        self.status = status  # type: str
        self.user_cidrs = user_cidrs  # type: DescribeVpcsResponseBodyVpcsVpcUserCidrs
        self.vrouter_id = vrouter_id  # type: str
        self.v_switch_ids = v_switch_ids  # type: DescribeVpcsResponseBodyVpcsVpcVSwitchIds
        self.vpc_id = vpc_id  # type: str
        self.vpc_name = vpc_name  # type: str

    def validate(self):
        if self.user_cidrs:
            self.user_cidrs.validate()
        if self.v_switch_ids:
            self.v_switch_ids.validate()

    def to_map(self):
        _map = super(DescribeVpcsResponseBodyVpcsVpc, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.is_default is not None:
            result['IsDefault'] = self.is_default
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.user_cidrs is not None:
            result['UserCidrs'] = self.user_cidrs.to_map()
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids.to_map()
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IsDefault') is not None:
            self.is_default = m.get('IsDefault')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UserCidrs') is not None:
            temp_model = DescribeVpcsResponseBodyVpcsVpcUserCidrs()
            self.user_cidrs = temp_model.from_map(m['UserCidrs'])
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        if m.get('VSwitchIds') is not None:
            temp_model = DescribeVpcsResponseBodyVpcsVpcVSwitchIds()
            self.v_switch_ids = temp_model.from_map(m['VSwitchIds'])
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class DescribeVpcsResponseBodyVpcs(TeaModel):
    def __init__(self, vpc=None):
        self.vpc = vpc  # type: list[DescribeVpcsResponseBodyVpcsVpc]

    def validate(self):
        if self.vpc:
            for k in self.vpc:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVpcsResponseBodyVpcs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Vpc'] = []
        if self.vpc is not None:
            for k in self.vpc:
                result['Vpc'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.vpc = []
        if m.get('Vpc') is not None:
            for k in m.get('Vpc'):
                temp_model = DescribeVpcsResponseBodyVpcsVpc()
                self.vpc.append(temp_model.from_map(k))
        return self


class DescribeVpcsResponseBody(TeaModel):
    def __init__(self, page_number=None, page_size=None, request_id=None, total_count=None, vpcs=None):
        self.page_number = page_number  # type: int
        self.page_size = page_size  # type: int
        self.request_id = request_id  # type: str
        self.total_count = total_count  # type: int
        self.vpcs = vpcs  # type: DescribeVpcsResponseBodyVpcs

    def validate(self):
        if self.vpcs:
            self.vpcs.validate()

    def to_map(self):
        _map = super(DescribeVpcsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        if self.vpcs is not None:
            result['Vpcs'] = self.vpcs.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        if m.get('Vpcs') is not None:
            temp_model = DescribeVpcsResponseBodyVpcs()
            self.vpcs = temp_model.from_map(m['Vpcs'])
        return self


class DescribeVpcsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVpcsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVpcsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVpcsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeZonesRequest(TeaModel):
    def __init__(self, accept_language=None, instance_charge_type=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, spot_strategy=None, verbose=None):
        # The natural language that is used to filter responses. For more information, see [RFC 7231](https://tools.ietf.org/html/rfc7231). Valid values:
        # 
        # *   zh-CN
        # *   en-US
        # *   ja
        # 
        # Default value: zh-CN.
        self.accept_language = accept_language  # type: str
        # The billing method of resources. For more information, see [Billing overview](~~25398~~). Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        # 
        # Default value: PostPaid.
        self.instance_charge_type = instance_charge_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The bidding policy for pay-as-you-go instances. You can specify this parameter when the `InstanceChargeType` parameter is set to PostPaid. For more information, see [Preemptible instances](~~52088~~). Valid values:
        # 
        # *   NoSpot: The instances are regular pay-as-you-go instances.
        # *   SpotWithPriceLimit: The instances are preemptible instances with user-defined maximum hourly prices.
        # *   SpotAsPriceGo: The instances are preemptible instances for which the market price at the time of purchase is automatically used as the bid price. The market price can be up to the pay-as-you-go price.
        # 
        # Default value: NoSpot.
        self.spot_strategy = spot_strategy  # type: str
        # Specifies whether to display detailed information.
        # 
        # *   true: displays detailed information.
        # *   false: does not display detailed information.
        # 
        # Default value: true.
        self.verbose = verbose  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.verbose is not None:
            result['Verbose'] = self.verbose
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('Verbose') is not None:
            self.verbose = m.get('Verbose')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes(TeaModel):
    def __init__(self, dedicated_host_type=None):
        self.dedicated_host_type = dedicated_host_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_type is not None:
            result['DedicatedHostType'] = self.dedicated_host_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostType') is not None:
            self.dedicated_host_type = m.get('DedicatedHostType')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableDiskCategories(TeaModel):
    def __init__(self, disk_categories=None):
        self.disk_categories = disk_categories  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableDiskCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_categories is not None:
            result['DiskCategories'] = self.disk_categories
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskCategories') is not None:
            self.disk_categories = m.get('DiskCategories')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes(TeaModel):
    def __init__(self, instance_types=None):
        self.instance_types = instance_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceTypes') is not None:
            self.instance_types = m.get('InstanceTypes')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourceCreation(TeaModel):
    def __init__(self, resource_types=None):
        self.resource_types = resource_types  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourceCreation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_types is not None:
            result['ResourceTypes'] = self.resource_types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceTypes') is not None:
            self.resource_types = m.get('ResourceTypes')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories(TeaModel):
    def __init__(self, supported_data_disk_category=None):
        self.supported_data_disk_category = supported_data_disk_category  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_data_disk_category is not None:
            result['supportedDataDiskCategory'] = self.supported_data_disk_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedDataDiskCategory') is not None:
            self.supported_data_disk_category = m.get('supportedDataDiskCategory')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations(TeaModel):
    def __init__(self, supported_instance_generation=None):
        self.supported_instance_generation = supported_instance_generation  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_generation is not None:
            result['supportedInstanceGeneration'] = self.supported_instance_generation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedInstanceGeneration') is not None:
            self.supported_instance_generation = m.get('supportedInstanceGeneration')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies(TeaModel):
    def __init__(self, supported_instance_type_family=None):
        self.supported_instance_type_family = supported_instance_type_family  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_type_family is not None:
            result['supportedInstanceTypeFamily'] = self.supported_instance_type_family
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedInstanceTypeFamily') is not None:
            self.supported_instance_type_family = m.get('supportedInstanceTypeFamily')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes(TeaModel):
    def __init__(self, supported_instance_type=None):
        self.supported_instance_type = supported_instance_type  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_instance_type is not None:
            result['supportedInstanceType'] = self.supported_instance_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedInstanceType') is not None:
            self.supported_instance_type = m.get('supportedInstanceType')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes(TeaModel):
    def __init__(self, supported_network_category=None):
        self.supported_network_category = supported_network_category  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_network_category is not None:
            result['supportedNetworkCategory'] = self.supported_network_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedNetworkCategory') is not None:
            self.supported_network_category = m.get('supportedNetworkCategory')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories(TeaModel):
    def __init__(self, supported_system_disk_category=None):
        self.supported_system_disk_category = supported_system_disk_category  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.supported_system_disk_category is not None:
            result['supportedSystemDiskCategory'] = self.supported_system_disk_category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('supportedSystemDiskCategory') is not None:
            self.supported_system_disk_category = m.get('supportedSystemDiskCategory')
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo(TeaModel):
    def __init__(self, data_disk_categories=None, instance_generations=None, instance_type_families=None,
                 instance_types=None, io_optimized=None, network_types=None, system_disk_categories=None):
        # The categories of data disks that can be created.
        self.data_disk_categories = data_disk_categories  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories
        # The supported generations of instance families.
        self.instance_generations = instance_generations  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations
        # The supported instance families.
        self.instance_type_families = instance_type_families  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies
        # The supported instance types.
        self.instance_types = instance_types  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes
        # Indicates whether the instance is I/O optimized.
        self.io_optimized = io_optimized  # type: bool
        # The supported network types
        self.network_types = network_types  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes
        # The supported categories of system disks that can be created.
        self.system_disk_categories = system_disk_categories  # type: DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories

    def validate(self):
        if self.data_disk_categories:
            self.data_disk_categories.validate()
        if self.instance_generations:
            self.instance_generations.validate()
        if self.instance_type_families:
            self.instance_type_families.validate()
        if self.instance_types:
            self.instance_types.validate()
        if self.network_types:
            self.network_types.validate()
        if self.system_disk_categories:
            self.system_disk_categories.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_categories is not None:
            result['DataDiskCategories'] = self.data_disk_categories.to_map()
        if self.instance_generations is not None:
            result['InstanceGenerations'] = self.instance_generations.to_map()
        if self.instance_type_families is not None:
            result['InstanceTypeFamilies'] = self.instance_type_families.to_map()
        if self.instance_types is not None:
            result['InstanceTypes'] = self.instance_types.to_map()
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.network_types is not None:
            result['NetworkTypes'] = self.network_types.to_map()
        if self.system_disk_categories is not None:
            result['SystemDiskCategories'] = self.system_disk_categories.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataDiskCategories') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoDataDiskCategories()
            self.data_disk_categories = temp_model.from_map(m['DataDiskCategories'])
        if m.get('InstanceGenerations') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceGenerations()
            self.instance_generations = temp_model.from_map(m['InstanceGenerations'])
        if m.get('InstanceTypeFamilies') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypeFamilies()
            self.instance_type_families = temp_model.from_map(m['InstanceTypeFamilies'])
        if m.get('InstanceTypes') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoInstanceTypes()
            self.instance_types = temp_model.from_map(m['InstanceTypes'])
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('NetworkTypes') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoNetworkTypes()
            self.network_types = temp_model.from_map(m['NetworkTypes'])
        if m.get('SystemDiskCategories') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfoSystemDiskCategories()
            self.system_disk_categories = temp_model.from_map(m['SystemDiskCategories'])
        return self


class DescribeZonesResponseBodyZonesZoneAvailableResources(TeaModel):
    def __init__(self, resources_info=None):
        self.resources_info = resources_info  # type: list[DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo]

    def validate(self):
        if self.resources_info:
            for k in self.resources_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ResourcesInfo'] = []
        if self.resources_info is not None:
            for k in self.resources_info:
                result['ResourcesInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resources_info = []
        if m.get('ResourcesInfo') is not None:
            for k in m.get('ResourcesInfo'):
                temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourcesResourcesInfo()
                self.resources_info.append(temp_model.from_map(k))
        return self


class DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories(TeaModel):
    def __init__(self, volume_categories=None):
        self.volume_categories = volume_categories  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.volume_categories is not None:
            result['VolumeCategories'] = self.volume_categories
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VolumeCategories') is not None:
            self.volume_categories = m.get('VolumeCategories')
        return self


class DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations(TeaModel):
    def __init__(self, dedicated_host_generation=None):
        self.dedicated_host_generation = dedicated_host_generation  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_generation is not None:
            result['DedicatedHostGeneration'] = self.dedicated_host_generation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostGeneration') is not None:
            self.dedicated_host_generation = m.get('DedicatedHostGeneration')
        return self


class DescribeZonesResponseBodyZonesZone(TeaModel):
    def __init__(self, available_dedicated_host_types=None, available_disk_categories=None,
                 available_instance_types=None, available_resource_creation=None, available_resources=None,
                 available_volume_categories=None, dedicated_host_generations=None, local_name=None, zone_id=None, zone_type=None):
        # The supported dedicated host types.
        self.available_dedicated_host_types = available_dedicated_host_types  # type: DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes
        # The supported disk categories. Valid values:
        # 
        # *   cloud: basic disk
        # *   cloud_ssd: standard SSD
        # *   cloud_efficiency: ultra disk
        # *   cloud_essd: ESSD
        self.available_disk_categories = available_disk_categories  # type: DescribeZonesResponseBodyZonesZoneAvailableDiskCategories
        # The supported instance types.
        self.available_instance_types = available_instance_types  # type: DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes
        # The types of resources that can be created. Valid values:
        # 
        # *   VSwitch: vSwitch
        # *   IoOptimized: I/O optimized instance
        # *   Instance: instance
        # *   DedicatedHost: dedicated host
        # *   disk: disk
        self.available_resource_creation = available_resource_creation  # type: DescribeZonesResponseBodyZonesZoneAvailableResourceCreation
        # Details about the resources that can be created in the zone.
        self.available_resources = available_resources  # type: DescribeZonesResponseBodyZonesZoneAvailableResources
        # The supported Shared Block Storage device categories.
        self.available_volume_categories = available_volume_categories  # type: DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories
        # The supported generations of dedicated hosts.
        self.dedicated_host_generations = dedicated_host_generations  # type: DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations
        # The name of the zone in the local language.
        self.local_name = local_name  # type: str
        # The ID of the zone.
        self.zone_id = zone_id  # type: str
        # The type of the zone. Valid values:
        # 
        # *   AvailabilityZone: zone for the Alibaba Cloud public cloud
        # *   CloudBoxZone: zone for CloudBox
        self.zone_type = zone_type  # type: str

    def validate(self):
        if self.available_dedicated_host_types:
            self.available_dedicated_host_types.validate()
        if self.available_disk_categories:
            self.available_disk_categories.validate()
        if self.available_instance_types:
            self.available_instance_types.validate()
        if self.available_resource_creation:
            self.available_resource_creation.validate()
        if self.available_resources:
            self.available_resources.validate()
        if self.available_volume_categories:
            self.available_volume_categories.validate()
        if self.dedicated_host_generations:
            self.dedicated_host_generations.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZonesZone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.available_dedicated_host_types is not None:
            result['AvailableDedicatedHostTypes'] = self.available_dedicated_host_types.to_map()
        if self.available_disk_categories is not None:
            result['AvailableDiskCategories'] = self.available_disk_categories.to_map()
        if self.available_instance_types is not None:
            result['AvailableInstanceTypes'] = self.available_instance_types.to_map()
        if self.available_resource_creation is not None:
            result['AvailableResourceCreation'] = self.available_resource_creation.to_map()
        if self.available_resources is not None:
            result['AvailableResources'] = self.available_resources.to_map()
        if self.available_volume_categories is not None:
            result['AvailableVolumeCategories'] = self.available_volume_categories.to_map()
        if self.dedicated_host_generations is not None:
            result['DedicatedHostGenerations'] = self.dedicated_host_generations.to_map()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        if self.zone_type is not None:
            result['ZoneType'] = self.zone_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailableDedicatedHostTypes') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableDedicatedHostTypes()
            self.available_dedicated_host_types = temp_model.from_map(m['AvailableDedicatedHostTypes'])
        if m.get('AvailableDiskCategories') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableDiskCategories()
            self.available_disk_categories = temp_model.from_map(m['AvailableDiskCategories'])
        if m.get('AvailableInstanceTypes') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableInstanceTypes()
            self.available_instance_types = temp_model.from_map(m['AvailableInstanceTypes'])
        if m.get('AvailableResourceCreation') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResourceCreation()
            self.available_resource_creation = temp_model.from_map(m['AvailableResourceCreation'])
        if m.get('AvailableResources') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableResources()
            self.available_resources = temp_model.from_map(m['AvailableResources'])
        if m.get('AvailableVolumeCategories') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneAvailableVolumeCategories()
            self.available_volume_categories = temp_model.from_map(m['AvailableVolumeCategories'])
        if m.get('DedicatedHostGenerations') is not None:
            temp_model = DescribeZonesResponseBodyZonesZoneDedicatedHostGenerations()
            self.dedicated_host_generations = temp_model.from_map(m['DedicatedHostGenerations'])
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        if m.get('ZoneType') is not None:
            self.zone_type = m.get('ZoneType')
        return self


class DescribeZonesResponseBodyZones(TeaModel):
    def __init__(self, zone=None):
        self.zone = zone  # type: list[DescribeZonesResponseBodyZonesZone]

    def validate(self):
        if self.zone:
            for k in self.zone:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Zone'] = []
        if self.zone is not None:
            for k in self.zone:
                result['Zone'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.zone = []
        if m.get('Zone') is not None:
            for k in m.get('Zone'):
                temp_model = DescribeZonesResponseBodyZonesZone()
                self.zone.append(temp_model.from_map(k))
        return self


class DescribeZonesResponseBody(TeaModel):
    def __init__(self, request_id=None, zones=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details of the zones and their supported resources.
        self.zones = zones  # type: DescribeZonesResponseBodyZones

    def validate(self):
        if self.zones:
            self.zones.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.zones is not None:
            result['Zones'] = self.zones.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Zones') is not None:
            temp_model = DescribeZonesResponseBodyZones()
            self.zones = temp_model.from_map(m['Zones'])
        return self


class DescribeZonesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeZonesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeZonesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeZonesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachClassicLinkVpcRequest(TeaModel):
    def __init__(self, instance_id=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, vpc_id=None):
        # The ID of the classic network-type instance.
        self.instance_id = instance_id  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the classic network-type instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the VPC to which the instance is linked.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachClassicLinkVpcRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DetachClassicLinkVpcResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachClassicLinkVpcResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachClassicLinkVpcResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachClassicLinkVpcResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachClassicLinkVpcResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachClassicLinkVpcResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachDiskRequest(TeaModel):
    def __init__(self, delete_with_instance=None, disk_id=None, instance_id=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to automatically release the system disk when the instance from which the system disk is to be detached is released. Valid values:
        # 
        # *   true: The system disk is released when the instance is released.
        # *   false: The system disk is not released when the instance is released. The system disk is retained as a pay-as-you-go data disk.
        # 
        # Default value: true.
        # 
        # When you call this operation, take note of the following items:
        # 
        # *   This parameter cannot be set for disks for which the multi-attach feature is enabled.
        # *   If a data disk is to be detached, the default value is `false`.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The ID of the disk to be detached.
        self.disk_id = disk_id  # type: str
        # The ID of the ECS instance from which the disk is to be detached.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DetachDiskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachInstanceRamRoleRequest(TeaModel):
    def __init__(self, instance_ids=None, owner_id=None, ram_role_name=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances from which you want to detach an instance RAM role. It can be a JSON array that consists of up to 100 instance IDs. Separate multiple instance IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        self.owner_id = owner_id  # type: long
        # The name of the instance RAM role to be detached. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you have created.
        self.ram_role_name = ram_role_name  # type: str
        # The region ID of the instances. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachInstanceRamRoleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet(TeaModel):
    def __init__(self, instance_id=None, ram_role_name=None):
        # The ID of the instance from which the RAM role was detached.
        self.instance_id = instance_id  # type: str
        # The name of the instance RAM role.
        self.ram_role_name = ram_role_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        return self


class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets(TeaModel):
    def __init__(self, instance_ram_role_set=None):
        self.instance_ram_role_set = instance_ram_role_set  # type: list[DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet]

    def validate(self):
        if self.instance_ram_role_set:
            for k in self.instance_ram_role_set:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceRamRoleSet'] = []
        if self.instance_ram_role_set is not None:
            for k in self.instance_ram_role_set:
                result['InstanceRamRoleSet'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_ram_role_set = []
        if m.get('InstanceRamRoleSet') is not None:
            for k in m.get('InstanceRamRoleSet'):
                temp_model = DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSetsInstanceRamRoleSet()
                self.instance_ram_role_set.append(temp_model.from_map(k))
        return self


class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult(TeaModel):
    def __init__(self, code=None, instance_id=None, instance_ram_role_sets=None, message=None, success=None):
        # The code that indicates whether the instance RAM role was detached. If 200 is returned, the instance RAM role was detached. If any other value is returned, the instance RAM role failed to be detached. For more information, see the "Error codes" section.
        self.code = code  # type: str
        # The ID of the instance from which you attempted to detach the instance RAM role.
        self.instance_id = instance_id  # type: str
        # The details about the instance RAM roles of the instances.
        self.instance_ram_role_sets = instance_ram_role_sets  # type: DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets
        # The message that indicates whether the instance RAM role was detached. If success is returned, the instance RAM role was detached. If any other value is returned, the instance RAM role failed to be detached. For more information, see the "Error codes" section.
        self.message = message  # type: str
        # Indicates whether the RAM role was detached.
        self.success = success  # type: bool

    def validate(self):
        if self.instance_ram_role_sets:
            self.instance_ram_role_sets.validate()

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_ram_role_sets is not None:
            result['InstanceRamRoleSets'] = self.instance_ram_role_sets.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceRamRoleSets') is not None:
            temp_model = DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResultInstanceRamRoleSets()
            self.instance_ram_role_sets = temp_model.from_map(m['InstanceRamRoleSets'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults(TeaModel):
    def __init__(self, detach_instance_ram_role_result=None):
        self.detach_instance_ram_role_result = detach_instance_ram_role_result  # type: list[DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult]

    def validate(self):
        if self.detach_instance_ram_role_result:
            for k in self.detach_instance_ram_role_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DetachInstanceRamRoleResult'] = []
        if self.detach_instance_ram_role_result is not None:
            for k in self.detach_instance_ram_role_result:
                result['DetachInstanceRamRoleResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.detach_instance_ram_role_result = []
        if m.get('DetachInstanceRamRoleResult') is not None:
            for k in m.get('DetachInstanceRamRoleResult'):
                temp_model = DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResultsDetachInstanceRamRoleResult()
                self.detach_instance_ram_role_result.append(temp_model.from_map(k))
        return self


class DetachInstanceRamRoleResponseBody(TeaModel):
    def __init__(self, detach_instance_ram_role_results=None, fail_count=None, ram_role_name=None, request_id=None,
                 total_count=None):
        # Details about the results of detaching the instance RAM role from the instances.
        self.detach_instance_ram_role_results = detach_instance_ram_role_results  # type: DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults
        # The number of the instances from which the RAM role failed to be detached.
        self.fail_count = fail_count  # type: int
        # The name of the instance RAM role.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of the instances from which you detached the RAM role.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.detach_instance_ram_role_results:
            self.detach_instance_ram_role_results.validate()

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.detach_instance_ram_role_results is not None:
            result['DetachInstanceRamRoleResults'] = self.detach_instance_ram_role_results.to_map()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DetachInstanceRamRoleResults') is not None:
            temp_model = DetachInstanceRamRoleResponseBodyDetachInstanceRamRoleResults()
            self.detach_instance_ram_role_results = temp_model.from_map(m['DetachInstanceRamRoleResults'])
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DetachInstanceRamRoleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachInstanceRamRoleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachInstanceRamRoleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachInstanceRamRoleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachKeyPairRequest(TeaModel):
    def __init__(self, instance_ids=None, key_pair_name=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances from which you want to unbind the SSH key pair. The value can be a JSON array that consists of up to 50 instance IDs. Separate multiple instance IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # The names of SSH key pairs.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the SSH key pair. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachKeyPairRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DetachKeyPairResponseBodyResultsResult(TeaModel):
    def __init__(self, code=None, instance_id=None, message=None, success=None):
        # The operation status code returned. 200 indicates that the operation was successful.
        self.code = code  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The result of the operation. For example, when the value of `Code` is 200, the value of `Message` is `successful`.
        self.message = message  # type: str
        # Indicates whether the operation was successful.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachKeyPairResponseBodyResultsResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DetachKeyPairResponseBodyResults(TeaModel):
    def __init__(self, result=None):
        self.result = result  # type: list[DetachKeyPairResponseBodyResultsResult]

    def validate(self):
        if self.result:
            for k in self.result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DetachKeyPairResponseBodyResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Result'] = []
        if self.result is not None:
            for k in self.result:
                result['Result'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.result = []
        if m.get('Result') is not None:
            for k in m.get('Result'):
                temp_model = DetachKeyPairResponseBodyResultsResult()
                self.result.append(temp_model.from_map(k))
        return self


class DetachKeyPairResponseBody(TeaModel):
    def __init__(self, fail_count=None, key_pair_name=None, request_id=None, results=None, total_count=None):
        # The number of instances from which the SSH key pair failed to be unbound.
        self.fail_count = fail_count  # type: str
        # The names of the key pairs.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The result set of the unbind operation.
        self.results = results  # type: DetachKeyPairResponseBodyResults
        # The total number of instances from which you attempted to unbind the SSH key pair.
        self.total_count = total_count  # type: str

    def validate(self):
        if self.results:
            self.results.validate()

    def to_map(self):
        _map = super(DetachKeyPairResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fail_count is not None:
            result['FailCount'] = self.fail_count
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.results is not None:
            result['Results'] = self.results.to_map()
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FailCount') is not None:
            self.fail_count = m.get('FailCount')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Results') is not None:
            temp_model = DetachKeyPairResponseBodyResults()
            self.results = temp_model.from_map(m['Results'])
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DetachKeyPairResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachKeyPairResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachKeyPairResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachNetworkInterfaceRequest(TeaModel):
    def __init__(self, instance_id=None, network_interface_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, trunk_network_instance_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The trunk network card ID.
        # 
        # > This parameter is not online yet and cannot be used.
        self.trunk_network_instance_id = trunk_network_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachNetworkInterfaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.trunk_network_instance_id is not None:
            result['TrunkNetworkInstanceId'] = self.trunk_network_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TrunkNetworkInstanceId') is not None:
            self.trunk_network_instance_id = m.get('TrunkNetworkInstanceId')
        return self


class DetachNetworkInterfaceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachNetworkInterfaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachNetworkInterfaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachNetworkInterfaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachNetworkInterfaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachNetworkInterfaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableActivationRequest(TeaModel):
    def __init__(self, activation_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the activation code. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableActivationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class DisableActivationResponseBodyActivation(TeaModel):
    def __init__(self, activation_id=None, creation_time=None, deregistered_count=None, description=None,
                 disabled=None, instance_count=None, instance_name=None, ip_address_range=None, registered_count=None,
                 time_to_live_in_hours=None):
        # The ID of the activation code.
        self.activation_id = activation_id  # type: str
        # The time when the activation code was created.
        self.creation_time = creation_time  # type: str
        # The number of instances that were deregistered.
        self.deregistered_count = deregistered_count  # type: int
        # The description of the activation code.
        self.description = description  # type: str
        # Indicates whether the activation code is disabled.
        self.disabled = disabled  # type: bool
        # The maximum number of times that the activation code can be used to register managed instances.
        self.instance_count = instance_count  # type: int
        # The default instance name prefix.
        self.instance_name = instance_name  # type: str
        # The IP addresses of hosts that are allowed to use the activation code.
        self.ip_address_range = ip_address_range  # type: str
        # The number of instances that were registered.
        self.registered_count = registered_count  # type: int
        # The validity period of the activation code. Unit: hours.
        self.time_to_live_in_hours = time_to_live_in_hours  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableActivationResponseBodyActivation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation_id is not None:
            result['ActivationId'] = self.activation_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.deregistered_count is not None:
            result['DeregisteredCount'] = self.deregistered_count
        if self.description is not None:
            result['Description'] = self.description
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.instance_count is not None:
            result['InstanceCount'] = self.instance_count
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.ip_address_range is not None:
            result['IpAddressRange'] = self.ip_address_range
        if self.registered_count is not None:
            result['RegisteredCount'] = self.registered_count
        if self.time_to_live_in_hours is not None:
            result['TimeToLiveInHours'] = self.time_to_live_in_hours
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActivationId') is not None:
            self.activation_id = m.get('ActivationId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DeregisteredCount') is not None:
            self.deregistered_count = m.get('DeregisteredCount')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('InstanceCount') is not None:
            self.instance_count = m.get('InstanceCount')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('IpAddressRange') is not None:
            self.ip_address_range = m.get('IpAddressRange')
        if m.get('RegisteredCount') is not None:
            self.registered_count = m.get('RegisteredCount')
        if m.get('TimeToLiveInHours') is not None:
            self.time_to_live_in_hours = m.get('TimeToLiveInHours')
        return self


class DisableActivationResponseBody(TeaModel):
    def __init__(self, activation=None, request_id=None):
        # Details about the activation code and its usage information.
        self.activation = activation  # type: DisableActivationResponseBodyActivation
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.activation:
            self.activation.validate()

    def to_map(self):
        _map = super(DisableActivationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.activation is not None:
            result['Activation'] = self.activation.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Activation') is not None:
            temp_model = DisableActivationResponseBodyActivation()
            self.activation = temp_model.from_map(m['Activation'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableActivationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableActivationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableActivationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableActivationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EipFillParamsRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, user_cidr=None, data=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.data = data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipFillParamsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class EipFillParamsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipFillParamsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class EipFillParamsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EipFillParamsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EipFillParamsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EipFillParamsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EipFillProductRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, user_cidr=None, data=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.data = data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipFillProductRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class EipFillProductResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipFillProductResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class EipFillProductResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EipFillProductResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EipFillProductResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EipFillProductResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EipNotifyPaidRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, user_cidr=None, data=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.data = data  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipNotifyPaidRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.data is not None:
            result['data'] = self.data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('data') is not None:
            self.data = m.get('data')
        return self


class EipNotifyPaidResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EipNotifyPaidResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.data is not None:
            result['data'] = self.data
        if self.message is not None:
            result['message'] = self.message
        if self.request_id is not None:
            result['requestId'] = self.request_id
        if self.success is not None:
            result['success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('data') is not None:
            self.data = m.get('data')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('requestId') is not None:
            self.request_id = m.get('requestId')
        if m.get('success') is not None:
            self.success = m.get('success')
        return self


class EipNotifyPaidResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EipNotifyPaidResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EipNotifyPaidResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EipNotifyPaidResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnablePhysicalConnectionRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnablePhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class EnablePhysicalConnectionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnablePhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class EnablePhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnablePhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnablePhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnablePhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportImageRequest(TeaModel):
    def __init__(self, image_format=None, image_id=None, ossbucket=None, ossprefix=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, role_name=None):
        # The format to export the custom image. Valid values:
        # 
        # - raw.
        # - vhd.
        # - qcow2.
        # - vmdk.
        # - vdi.
        # 
        # Default value: raw.
        self.image_format = image_format  # type: str
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # The OSS bucket to which to export the custom image.
        self.ossbucket = ossbucket  # type: str
        # The prefix of the object as which to store the custom image in the OSS bucket. The prefix must be 1 to 30 characters in length and can contain digits and letters.
        self.ossprefix = ossprefix  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The name of the RAM role used to export the custom image.
        self.role_name = role_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_format is not None:
            result['ImageFormat'] = self.image_format
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossprefix is not None:
            result['OSSPrefix'] = self.ossprefix
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageFormat') is not None:
            self.image_format = m.get('ImageFormat')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSPrefix') is not None:
            self.ossprefix = m.get('OSSPrefix')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        return self


class ExportImageResponseBody(TeaModel):
    def __init__(self, region_id=None, request_id=None, task_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the image export task.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ExportImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportSnapshotRequest(TeaModel):
    def __init__(self, oss_bucket=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, role_name=None, snapshot_id=None):
        self.oss_bucket = oss_bucket  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.role_name = role_name  # type: str
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class ExportSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None, task_id=None):
        self.request_id = request_id  # type: str
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ExportSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceConsoleOutputRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None, remove_symbols=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # Specifies whether to remove symbols from the returned command output. Valid values:
        # 
        # *   true: removes the symbols
        # *   false: does not remove the symbols
        # 
        # Default value: false.
        self.remove_symbols = remove_symbols  # type: bool
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceConsoleOutputRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_symbols is not None:
            result['RemoveSymbols'] = self.remove_symbols
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveSymbols') is not None:
            self.remove_symbols = m.get('RemoveSymbols')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class GetInstanceConsoleOutputResponseBody(TeaModel):
    def __init__(self, console_output=None, instance_id=None, last_update_time=None, request_id=None):
        # The Base64-encoded command output of the instance.
        self.console_output = console_output  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The time when the instance was last started, restarted, or shut down. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.last_update_time = last_update_time  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceConsoleOutputResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.console_output is not None:
            result['ConsoleOutput'] = self.console_output
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.last_update_time is not None:
            result['LastUpdateTime'] = self.last_update_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConsoleOutput') is not None:
            self.console_output = m.get('ConsoleOutput')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LastUpdateTime') is not None:
            self.last_update_time = m.get('LastUpdateTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetInstanceConsoleOutputResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetInstanceConsoleOutputResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetInstanceConsoleOutputResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceConsoleOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetInstanceScreenshotRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, wake_up=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to wake up the instance for which the instance hibernation feature is enabled.
        # 
        # Default value: false.
        self.wake_up = wake_up  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceScreenshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.wake_up is not None:
            result['WakeUp'] = self.wake_up
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('WakeUp') is not None:
            self.wake_up = m.get('WakeUp')
        return self


class GetInstanceScreenshotResponseBody(TeaModel):
    def __init__(self, instance_id=None, request_id=None, screenshot=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The JPG-formatted instance screenshot, which is encoded in Base64.
        self.screenshot = screenshot  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetInstanceScreenshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.screenshot is not None:
            result['Screenshot'] = self.screenshot
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Screenshot') is not None:
            self.screenshot = m.get('Screenshot')
        return self


class GetInstanceScreenshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetInstanceScreenshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetInstanceScreenshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetInstanceScreenshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportImageRequestDiskDeviceMapping(TeaModel):
    def __init__(self, device=None, disk_im_size=None, disk_image_size=None, format=None, ossbucket=None,
                 ossobject=None):
        # The device name of disk N in the custom image.
        # 
        # >  This parameter will be removed in the future. To ensure future compatibility, we recommend that you do not use this parameter.
        self.device = device  # type: str
        # The size of the custom image.
        # 
        # >  This parameter will be removed in the future. To ensure future compatibility, we recommend that you use the `DiskDeviceMapping.N.DiskImageSize` parameter.
        self.disk_im_size = disk_im_size  # type: int
        # The size of disk N in the custom image.
        # 
        # You can use this parameter to specify the sizes of the system disk and data disks in the custom image. When you specify the size of the system disk, make sure that the specified size is greater than or equal to the size of the custom image file. Unit: GiB. Valid values:
        # 
        # *   When the N value is 1, this parameter specifies the size of the system disk in the custom image. Valid values: 5 to 500.
        # *   When the N value is an integer in the range of 2 to 17, this parameter specifies the size of a data disk in the custom image. Valid values: 5 to 2000.
        # 
        # After the source image is uploaded to an OSS bucket, you can view the size of the image in the OSS bucket.
        self.disk_image_size = disk_image_size  # type: int
        # The format of the custom image. Valid values:
        # 
        # *   RAW
        # *   VHD
        # *   QCOW2
        # 
        # This parameter is empty by default, which indicates that the system checks the format of the custom image and uses the check result as the value of this parameter.
        self.format = format  # type: str
        # The OSS bucket in which the source image is stored.
        # 
        # >  Before you import images for the first time, you must use RAM to authorize ECS to access your OSS buckets. If ECS is not authorized to access your OSS buckets, the **NoSetRoletoECSServiceAcount** error code is returned when you call the ImportImage operation. For more information, see the `Description` section of this topic.
        self.ossbucket = ossbucket  # type: str
        # The name (key) of the object that the uploaded source image is stored as in the OSS bucket.
        self.ossobject = ossobject  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportImageRequestDiskDeviceMapping, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_im_size is not None:
            result['DiskImSize'] = self.disk_im_size
        if self.disk_image_size is not None:
            result['DiskImageSize'] = self.disk_image_size
        if self.format is not None:
            result['Format'] = self.format
        if self.ossbucket is not None:
            result['OSSBucket'] = self.ossbucket
        if self.ossobject is not None:
            result['OSSObject'] = self.ossobject
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskImSize') is not None:
            self.disk_im_size = m.get('DiskImSize')
        if m.get('DiskImageSize') is not None:
            self.disk_image_size = m.get('DiskImageSize')
        if m.get('Format') is not None:
            self.format = m.get('Format')
        if m.get('OSSBucket') is not None:
            self.ossbucket = m.get('OSSBucket')
        if m.get('OSSObject') is not None:
            self.ossobject = m.get('OSSObject')
        return self


class ImportImageRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the custom image. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `aliyun` or `acs:`.
        self.key = key  # type: str
        # The value of tag N to add to the custom image. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportImageRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ImportImageRequest(TeaModel):
    def __init__(self, architecture=None, boot_mode=None, description=None, detection_strategy=None,
                 disk_device_mapping=None, image_name=None, license_type=None, ostype=None, owner_id=None, platform=None, region_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, role_name=None, tag=None):
        # The system architecture. Valid values:
        # 
        # *   i386
        # *   x86\_64
        # *   arm64
        # 
        # Default value: x86\_64.
        self.architecture = architecture  # type: str
        # The boot mode of the custom image. Valid values:
        # 
        # *   BIOS
        # *   UEFI
        # 
        # Default value: BIOS. If you set the `Architecture` parameter to arm64, the BootMode parameter can only be set to UEFI.
        # 
        # >  You must be aware of the boot modes supported by the specified image. When you use this parameter to change the boot mode of the image, specify a boot mode supported by the image to ensure that instances that use this image can start normally.
        self.boot_mode = boot_mode  # type: str
        # The description of the custom image. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The mode in which to check the source image. If you do not specify this parameter, the source image is not checked. Only Linux images can be checked. Set the value to Standard, which indicates standard check mode.
        # 
        # The following items are checked in standard check mode:
        # 
        # *   Virtio: whether the virtio driver is installed.
        # *   Fstab: whether mounting configurations in the fstab file are correct.
        # *   Grub: whether GRUB configurations are correct.
        # *   SystemImage: whether the image is valid. Do not import images that are in the ISO format or empty.
        # *   CloudInit: whether cloud-init is installed.
        # *   NVMe: whether the NVMe driver is installed.
        # *   Selinux: whether SElinux is enabled.
        # *   OnlineResizeFS: whether the root partition can be automatically resized.
        # *   Dhcp: whether Dynamic Host Configuration Protocol (DHCP) is enabled for network interface controllers (NICs).
        # *   RtcTimeMode: the RTC time mode.
        # *   Platform: the platform. Example: Linux or Windows.
        # *   OSVersion: the operating system version. Example: Centos 7.9.
        # *   Architecture: the architecture. Example: ARM or x86\_64.
        # *   BootMode: the boot mode. Example: UEFI or Legacy.
        # *   KernelVersion: the kernel version.
        # *   CloudAssistant: whether the Cloud Assistant client is installed.
        # *   SecurityCenterAgent: whether the Security Center agent is installed.
        self.detection_strategy = detection_strategy  # type: str
        # The mappings of the disk devices.
        self.disk_device_mapping = disk_device_mapping  # type: list[ImportImageRequestDiskDeviceMapping]
        # The name of the custom image. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        self.image_name = image_name  # type: str
        # The type of the license to use to activate the operating system after the source image is imported. Valid values:
        # 
        # *   Auto: ECS checks the operating system of the source image and allocates a license to the operating system. ECS first checks whether the operating system distribution specified by `Platform` has a license allocated through an official Alibaba Cloud channel. If yes, the allocated license is used. If not, the license that comes with the source operating system is used.
        # *   Aliyun: The license allocated through an official Alibaba Cloud channel is used for the operating system distribution specified by `Platform`.
        # *   BYOL: The license that comes with the source operating system is used. In this case, make sure that your license key can be used in Alibaba Cloud.
        # 
        # Default value: Auto.
        self.license_type = license_type  # type: str
        # The operating system platform. Valid values:
        # 
        # *   windows
        # *   linux
        # 
        # Default value: linux.
        self.ostype = ostype  # type: str
        self.owner_id = owner_id  # type: long
        # The operating system distribution. Valid values:
        # 
        # *   CentOS
        # *   CentOS Stream
        # *   Ubuntu
        # *   SUSE
        # *   openSUSE
        # *   Debian
        # *   CoreOS
        # *   Aliyun
        # *   Anolis
        # *   AlmaLinux
        # *   FreeBSD
        # *   Fedora
        # *   Rocky Linux
        # *   UOS
        # *   Kylin
        # *   Others Linux
        # *   Customized Linux
        # *   Windows Server 2022
        # *   Windows Server 2019
        # *   Windows Server 2016
        # *   Windows Server 2012
        # *   Windows Server 2008
        # *   Windows Server 2003
        # 
        # Default value: Others Linux.
        self.platform = platform  # type: str
        # The region ID of the source custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the custom image.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The name of the RAM role to use to import the source image.
        self.role_name = role_name  # type: str
        # The tags of the imported custom image.
        self.tag = tag  # type: list[ImportImageRequestTag]

    def validate(self):
        if self.disk_device_mapping:
            for k in self.disk_device_mapping:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ImportImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        if self.boot_mode is not None:
            result['BootMode'] = self.boot_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.detection_strategy is not None:
            result['DetectionStrategy'] = self.detection_strategy
        result['DiskDeviceMapping'] = []
        if self.disk_device_mapping is not None:
            for k in self.disk_device_mapping:
                result['DiskDeviceMapping'].append(k.to_map() if k else None)
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.license_type is not None:
            result['LicenseType'] = self.license_type
        if self.ostype is not None:
            result['OSType'] = self.ostype
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        if m.get('BootMode') is not None:
            self.boot_mode = m.get('BootMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DetectionStrategy') is not None:
            self.detection_strategy = m.get('DetectionStrategy')
        self.disk_device_mapping = []
        if m.get('DiskDeviceMapping') is not None:
            for k in m.get('DiskDeviceMapping'):
                temp_model = ImportImageRequestDiskDeviceMapping()
                self.disk_device_mapping.append(temp_model.from_map(k))
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('LicenseType') is not None:
            self.license_type = m.get('LicenseType')
        if m.get('OSType') is not None:
            self.ostype = m.get('OSType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ImportImageRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ImportImageResponseBody(TeaModel):
    def __init__(self, image_id=None, region_id=None, request_id=None, task_id=None):
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # The region ID of the image.
        self.region_id = region_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the image import task.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ImportImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ImportImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ImportImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportKeyPairRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the key pair. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length. The tag key cannot start with `acs:` or `aliyun` or contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the key pair. Valid values of N: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportKeyPairRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ImportKeyPairRequest(TeaModel):
    def __init__(self, key_pair_name=None, owner_id=None, public_key_body=None, region_id=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, tag=None):
        # The name of the key pair. The name must be unique. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.key_pair_name = key_pair_name  # type: str
        self.owner_id = owner_id  # type: long
        # The public key of the key pair.
        self.public_key_body = public_key_body  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which the key pair belongs.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags to add to the key pair.
        self.tag = tag  # type: list[ImportKeyPairRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ImportKeyPairRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.public_key_body is not None:
            result['PublicKeyBody'] = self.public_key_body
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PublicKeyBody') is not None:
            self.public_key_body = m.get('PublicKeyBody')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ImportKeyPairRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ImportKeyPairResponseBody(TeaModel):
    def __init__(self, key_pair_finger_print=None, key_pair_name=None, request_id=None):
        # The fingerprint of the key pair. The message-digest algorithm 5 (MD5) is used based on the public key fingerprint format defined in RFC 4716.
        self.key_pair_finger_print = key_pair_finger_print  # type: str
        # The name of the key pair.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportKeyPairResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key_pair_finger_print is not None:
            result['KeyPairFingerPrint'] = self.key_pair_finger_print
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeyPairFingerPrint') is not None:
            self.key_pair_finger_print = m.get('KeyPairFingerPrint')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ImportKeyPairResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ImportKeyPairResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ImportKeyPairResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportKeyPairResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ImportSnapshotRequest(TeaModel):
    def __init__(self, oss_bucket=None, oss_object=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, role_name=None, snapshot_name=None):
        self.oss_bucket = oss_bucket  # type: str
        self.oss_object = oss_object  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.role_name = role_name  # type: str
        self.snapshot_name = snapshot_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.oss_bucket is not None:
            result['OssBucket'] = self.oss_bucket
        if self.oss_object is not None:
            result['OssObject'] = self.oss_object
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.role_name is not None:
            result['RoleName'] = self.role_name
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OssBucket') is not None:
            self.oss_bucket = m.get('OssBucket')
        if m.get('OssObject') is not None:
            self.oss_object = m.get('OssObject')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RoleName') is not None:
            self.role_name = m.get('RoleName')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        return self


class ImportSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_id=None, task_id=None):
        self.request_id = request_id  # type: str
        self.snapshot_id = snapshot_id  # type: str
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ImportSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ImportSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ImportSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ImportSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ImportSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallCloudAssistantRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The IDs of instances. You can specify up to 50 instance IDs in a single request.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallCloudAssistantRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class InstallCloudAssistantResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallCloudAssistantResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InstallCloudAssistantResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InstallCloudAssistantResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InstallCloudAssistantResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallCloudAssistantResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InvokeCommandRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the resource.
        self.key = key  # type: str
        # The value of tag of the resource.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InvokeCommandRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class InvokeCommandRequest(TeaModel):
    def __init__(self, command_id=None, container_id=None, container_name=None, frequency=None, instance_id=None,
                 owner_account=None, owner_id=None, parameters=None, region_id=None, repeat_mode=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None, timed=None, timeout=None, username=None,
                 windows_password_name=None):
        # The ID of the command. You can call the [DescribeCommands](~~64843~~) operation to query all available command IDs.
        # 
        # >  Common Cloud Assistant commands can be run based on their names. For more information, see [View and run common Cloud Assistant commands](~~429635~~).
        self.command_id = command_id  # type: str
        # The ID of the container. Only 64-bit hexadecimal strings are supported. Container IDs that are prefixed with `docker://`, `containerd://`, or `cri-o://` are allowed to specify container runtimes.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # 
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # 
        #     *   For information about how to view the version of the Cloud Assistant client, see [Install the Cloud Assistant client](~~64921~~).
        #     *   For information about how to upgrade the version of the Cloud Assistant client, see [Upgrade or disable upgrades for the Cloud Assistant client](~~134383~~).
        # 
        # *   If this parameter is specified, the `Username` parameter specified in a request to this operation and the `WorkingDir` parameter specified in a request to the [CreateCommand](~~64844~~) operation do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # 
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_id = container_id  # type: str
        # The name of the container.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # 
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # 
        #     *   For information about how to view the version of the Cloud Assistant client, see [Install the Cloud Assistant client](~~64921~~).
        #     *   For information about how to upgrade the version of the Cloud Assistant client, see [Upgrade or disable upgrades for the Cloud Assistant client](~~134383~~).
        # 
        # *   If this parameter is specified, the `Username` parameter specified in a request to this operation and the `WorkingDir` parameter specified in a request to the [CreateCommand](~~64844~~) operation do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # 
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_name = container_name  # type: str
        # The schedule on which to run the command. You must specify this parameter when you set `Timed` to `true`. You can specify a schedule to run the command at a fixed interval based on a rate expression, only once at a specified time, or at designated times based on a cron expression.
        # 
        # *   Run at Fixed Interval: To run the command at a fixed interval, use a rate expression to specify the interval. You can specify the interval in seconds, minutes, hours, or days. This option is applicable when tasks need to be executed at a fixed interval. Specify the interval in the following format: `rate(<Execution interval value><Execution interval unit>)`. For example, specify `rate(5m)` to run the command every 5 minutes. Take note of the following limits when you set an interval:
        # 
        #     *   The specified interval can be anywhere from 60 seconds to 7 days and must be longer than the timeout period of the scheduled task.
        #     *   The interval is the duration between two consecutive executions. The interval is irrelevant to the amount of time required to run the command once. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. Each time the command is run, the system waits 3 minutes before it runs the command again.
        #     *   A task is not executed immediately after it is created. For example, assume that you set the interval to 5 minutes for a task. The task begins to be executed 5 minutes after it is created.
        # 
        # *   Run Only Once at Specified Time: To run the command only once at a specified time, specify a point in time and a time zone. Specify the time in the following format: `at(yyyy-MM-dd HH:mm:ss <Time zone>)`, which indicates `at(Year-Month-Day Hour:Minute:Second <Time zone>)`. If you do not specify a time zone, the UTC time zone is used by default. The time zone supports the following forms:
        # 
        #     *   The time zone name. Examples: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from Greenwich Mean Time (GMT). Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         To specify a command to run only once at 13:15:30 on June 06, 2022 (Shanghai time), set the time to `at(2022-06-06 13:15:30 Asia/Shanghai)`. To specify a command to run only once at 13:15:30 on June 06, 2022 (UTC-7), set the time to `at(2022-06-06 13:15:30 GMT-7:00)`.
        # 
        # *   Run on Clock-based Schedule: To run the command at designated times, specify a cron expression. Specify the time in the following format: `<Cron expression> <Time zone>`, where the cron expression is in the format of `<seconds> <minutes> <hours> <day of the month> <month> <day of the week> <year (optional)> <time zone>`. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance on which to run the command is used by default. For more information about cron expressions, see [Cron expressions](~~64769~~). The time zone supports the following forms:
        # 
        #     *   The time zone name. Examples: `Asia/Shanghai` and `sAmerica/Los_Angeles`.
        # 
        #     *   The time offset from GMT. Examples: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         For example, to specify a command to run at 10:15:00 every day in 2022 (Shanghai time), set the time to `0 15 10 ? * * 2022 Asia/Shanghai`. To specify a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the time to `0 0/30 10-11 * ? 2022 GMT +8:00`. To specify a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years from 2022 (UTC), set the time to `0 0/5 14 * 10 ? 2022/2 UTC`.
        # 
        #         > The minimum interval must be 10 seconds or more and cannot be shorter than the timeout period of scheduled executions.
        self.frequency = frequency  # type: str
        # The IDs of instances on which to run the command. You can specify up to 50 instance IDs in each request.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The key-value pairs of custom parameters to pass in when the custom parameter feature is enabled. Number of custom parameters: 0 to 10.
        # 
        # *   Each key in a Map collection cannot be an empty string and can be up to 64 characters in length.
        # *   Values in a Map collection can be empty strings.
        # *   The size of the command (including custom parameters and original command content) after Base64 encoding cannot exceed 18 KB.
        # *   The custom parameter names specified in the value of Parameters must be included in the custom parameters specified when you created the command. You can use empty strings to represent the parameters that are not passed in.
        # 
        # You can leave this parameter empty to disable the custom parameter feature.
        self.parameters = parameters  # type: dict[str, any]
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: runs the command instantly.
        # *   Period: runs the command on a schedule. If you set this parameter to `Period`, you must set `Timed` to true and specify `Frequency`.
        # *   NextRebootOnly: automatically runs the command the next time the instance starts.
        # *   EveryReboot: automatically runs the command every time the instance starts.
        # 
        # Default value:
        # 
        # *   When `Timed` is set to false and `Frequency` is not specified, the default value of RepeatMode is `Once`.
        # *   When `Timed` is set to true and `Frequency` is specified, `Period` is used as the value of RepeatMode regardless of whether RepeatMode is specified.
        # 
        # Take note of the following items:
        # 
        # *   When this parameter is set to `Period`, `NextRebootOnly`, or `EveryReboot`, you can call the [StopInvocation](~~64838~~) operation to stop the pending or scheduled executions of the command.
        # *   When this parameter is set to `Period` or `EveryReboot`, you can call the [DescribeInvocationResults](~~64845~~) operation and set `IncludeHistory` to true to view the results of historical scheduled executions.
        self.repeat_mode = repeat_mode  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[InvokeCommandRequestTag]
        # Specifies whether to run the command on a schedule. Valid values:
        # 
        # *   true: runs the command on the schedule specified by `Frequency`. The results of each execution of a command do not affect the next execution of the command.
        # *   false: runs the command only once.
        # 
        # Default value: false.
        self.timed = timed  # type: bool
        # The maximum timeout period for the command execution on the instance. Unit: seconds. When a command cannot be run, a timeout error occurs. After that, the command process is forcefully terminated by canceling the PID of the command.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long
        # The username to use to run the command on ECS instances.
        # 
        # *   For Linux instances, the root user is used.
        # *   For Windows instances, the System user is used.
        # 
        # You can also specify other usernames that already exist in the ECS instance to run the command. For security purposes, we recommend that you run Cloud Assistant commands as a regular user. For more information, see [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        self.username = username  # type: str
        # The name of the password to use to run the command on a Windows instance.
        # 
        # If you want to use a username other than the default System username to run the command on the Windows instance, you must specify both the WindowsPasswordName and `Username` parameter. The password is hosted in plaintext in the parameter repository of Operation Orchestration Service (OOS) to reduce the risk of password leaks. Only the name of the password is passed in by using the WindowsPasswordName parameter. For more information, see [Manage encryption parameters](~~186828~~) and [Run Cloud Assistant commands as a regular user](~~203771~~).
        # 
        # >  When you use the root username for Linux instances or the System username for Windows instances to run the command, you do not need to specify the WindowsPasswordName parameter.
        self.windows_password_name = windows_password_name  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(InvokeCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.username is not None:
            result['Username'] = self.username
        if self.windows_password_name is not None:
            result['WindowsPasswordName'] = self.windows_password_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = InvokeCommandRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('WindowsPasswordName') is not None:
            self.windows_password_name = m.get('WindowsPasswordName')
        return self


class InvokeCommandShrinkRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the resource.
        self.key = key  # type: str
        # The value of tag of the resource.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InvokeCommandShrinkRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class InvokeCommandShrinkRequest(TeaModel):
    def __init__(self, command_id=None, container_id=None, container_name=None, frequency=None, instance_id=None,
                 owner_account=None, owner_id=None, parameters_shrink=None, region_id=None, repeat_mode=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, tag=None, timed=None, timeout=None,
                 username=None, windows_password_name=None):
        # The ID of the command. You can call the [DescribeCommands](~~64843~~) operation to query all available command IDs.
        # 
        # >  Common Cloud Assistant commands can be run based on their names. For more information, see [View and run common Cloud Assistant commands](~~429635~~).
        self.command_id = command_id  # type: str
        # The ID of the container. Only 64-bit hexadecimal strings are supported. Container IDs that are prefixed with `docker://`, `containerd://`, or `cri-o://` are allowed to specify container runtimes.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # 
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # 
        #     *   For information about how to view the version of the Cloud Assistant client, see [Install the Cloud Assistant client](~~64921~~).
        #     *   For information about how to upgrade the version of the Cloud Assistant client, see [Upgrade or disable upgrades for the Cloud Assistant client](~~134383~~).
        # 
        # *   If this parameter is specified, the `Username` parameter specified in a request to this operation and the `WorkingDir` parameter specified in a request to the [CreateCommand](~~64844~~) operation do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # 
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_id = container_id  # type: str
        # The name of the container.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # 
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # 
        #     *   For information about how to view the version of the Cloud Assistant client, see [Install the Cloud Assistant client](~~64921~~).
        #     *   For information about how to upgrade the version of the Cloud Assistant client, see [Upgrade or disable upgrades for the Cloud Assistant client](~~134383~~).
        # 
        # *   If this parameter is specified, the `Username` parameter specified in a request to this operation and the `WorkingDir` parameter specified in a request to the [CreateCommand](~~64844~~) operation do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # 
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_name = container_name  # type: str
        # The schedule on which to run the command. You must specify this parameter when you set `Timed` to `true`. You can specify a schedule to run the command at a fixed interval based on a rate expression, only once at a specified time, or at designated times based on a cron expression.
        # 
        # *   Run at Fixed Interval: To run the command at a fixed interval, use a rate expression to specify the interval. You can specify the interval in seconds, minutes, hours, or days. This option is applicable when tasks need to be executed at a fixed interval. Specify the interval in the following format: `rate(<Execution interval value><Execution interval unit>)`. For example, specify `rate(5m)` to run the command every 5 minutes. Take note of the following limits when you set an interval:
        # 
        #     *   The specified interval can be anywhere from 60 seconds to 7 days and must be longer than the timeout period of the scheduled task.
        #     *   The interval is the duration between two consecutive executions. The interval is irrelevant to the amount of time required to run the command once. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. Each time the command is run, the system waits 3 minutes before it runs the command again.
        #     *   A task is not executed immediately after it is created. For example, assume that you set the interval to 5 minutes for a task. The task begins to be executed 5 minutes after it is created.
        # 
        # *   Run Only Once at Specified Time: To run the command only once at a specified time, specify a point in time and a time zone. Specify the time in the following format: `at(yyyy-MM-dd HH:mm:ss <Time zone>)`, which indicates `at(Year-Month-Day Hour:Minute:Second <Time zone>)`. If you do not specify a time zone, the UTC time zone is used by default. The time zone supports the following forms:
        # 
        #     *   The time zone name. Examples: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from Greenwich Mean Time (GMT). Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         To specify a command to run only once at 13:15:30 on June 06, 2022 (Shanghai time), set the time to `at(2022-06-06 13:15:30 Asia/Shanghai)`. To specify a command to run only once at 13:15:30 on June 06, 2022 (UTC-7), set the time to `at(2022-06-06 13:15:30 GMT-7:00)`.
        # 
        # *   Run on Clock-based Schedule: To run the command at designated times, specify a cron expression. Specify the time in the following format: `<Cron expression> <Time zone>`, where the cron expression is in the format of `<seconds> <minutes> <hours> <day of the month> <month> <day of the week> <year (optional)> <time zone>`. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance on which to run the command is used by default. For more information about cron expressions, see [Cron expressions](~~64769~~). The time zone supports the following forms:
        # 
        #     *   The time zone name. Examples: `Asia/Shanghai` and `sAmerica/Los_Angeles`.
        # 
        #     *   The time offset from GMT. Examples: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         For example, to specify a command to run at 10:15:00 every day in 2022 (Shanghai time), set the time to `0 15 10 ? * * 2022 Asia/Shanghai`. To specify a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the time to `0 0/30 10-11 * ? 2022 GMT +8:00`. To specify a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years from 2022 (UTC), set the time to `0 0/5 14 * 10 ? 2022/2 UTC`.
        # 
        #         > The minimum interval must be 10 seconds or more and cannot be shorter than the timeout period of scheduled executions.
        self.frequency = frequency  # type: str
        # The IDs of instances on which to run the command. You can specify up to 50 instance IDs in each request.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The key-value pairs of custom parameters to pass in when the custom parameter feature is enabled. Number of custom parameters: 0 to 10.
        # 
        # *   Each key in a Map collection cannot be an empty string and can be up to 64 characters in length.
        # *   Values in a Map collection can be empty strings.
        # *   The size of the command (including custom parameters and original command content) after Base64 encoding cannot exceed 18 KB.
        # *   The custom parameter names specified in the value of Parameters must be included in the custom parameters specified when you created the command. You can use empty strings to represent the parameters that are not passed in.
        # 
        # You can leave this parameter empty to disable the custom parameter feature.
        self.parameters_shrink = parameters_shrink  # type: str
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: runs the command instantly.
        # *   Period: runs the command on a schedule. If you set this parameter to `Period`, you must set `Timed` to true and specify `Frequency`.
        # *   NextRebootOnly: automatically runs the command the next time the instance starts.
        # *   EveryReboot: automatically runs the command every time the instance starts.
        # 
        # Default value:
        # 
        # *   When `Timed` is set to false and `Frequency` is not specified, the default value of RepeatMode is `Once`.
        # *   When `Timed` is set to true and `Frequency` is specified, `Period` is used as the value of RepeatMode regardless of whether RepeatMode is specified.
        # 
        # Take note of the following items:
        # 
        # *   When this parameter is set to `Period`, `NextRebootOnly`, or `EveryReboot`, you can call the [StopInvocation](~~64838~~) operation to stop the pending or scheduled executions of the command.
        # *   When this parameter is set to `Period` or `EveryReboot`, you can call the [DescribeInvocationResults](~~64845~~) operation and set `IncludeHistory` to true to view the results of historical scheduled executions.
        self.repeat_mode = repeat_mode  # type: str
        # The ID of the resource group.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[InvokeCommandShrinkRequestTag]
        # Specifies whether to run the command on a schedule. Valid values:
        # 
        # *   true: runs the command on the schedule specified by `Frequency`. The results of each execution of a command do not affect the next execution of the command.
        # *   false: runs the command only once.
        # 
        # Default value: false.
        self.timed = timed  # type: bool
        # The maximum timeout period for the command execution on the instance. Unit: seconds. When a command cannot be run, a timeout error occurs. After that, the command process is forcefully terminated by canceling the PID of the command.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long
        # The username to use to run the command on ECS instances.
        # 
        # *   For Linux instances, the root user is used.
        # *   For Windows instances, the System user is used.
        # 
        # You can also specify other usernames that already exist in the ECS instance to run the command. For security purposes, we recommend that you run Cloud Assistant commands as a regular user. For more information, see [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        self.username = username  # type: str
        # The name of the password to use to run the command on a Windows instance.
        # 
        # If you want to use a username other than the default System username to run the command on the Windows instance, you must specify both the WindowsPasswordName and `Username` parameter. The password is hosted in plaintext in the parameter repository of Operation Orchestration Service (OOS) to reduce the risk of password leaks. Only the name of the password is passed in by using the WindowsPasswordName parameter. For more information, see [Manage encryption parameters](~~186828~~) and [Run Cloud Assistant commands as a regular user](~~203771~~).
        # 
        # >  When you use the root username for Linux instances or the System username for Windows instances to run the command, you do not need to specify the WindowsPasswordName parameter.
        self.windows_password_name = windows_password_name  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(InvokeCommandShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.parameters_shrink is not None:
            result['Parameters'] = self.parameters_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.username is not None:
            result['Username'] = self.username
        if self.windows_password_name is not None:
            result['WindowsPasswordName'] = self.windows_password_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Parameters') is not None:
            self.parameters_shrink = m.get('Parameters')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = InvokeCommandShrinkRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('WindowsPasswordName') is not None:
            self.windows_password_name = m.get('WindowsPasswordName')
        return self


class InvokeCommandResponseBody(TeaModel):
    def __init__(self, invoke_id=None, request_id=None):
        # The ID of the command task.
        self.invoke_id = invoke_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InvokeCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class InvokeCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InvokeCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InvokeCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InvokeCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinResourceGroupRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_group_id=None, resource_id=None,
                 resource_owner_account=None, resource_owner_id=None, resource_type=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to add the resource.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of the resource. This parameter depends on the ResourceType value. For example, when ResourceType is set to instance, ResourceId can be interpreted as InstanceId.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the ECS resource. Valid values:
        # 
        # *   instance: instance
        # *   disk: Elastic Block Storage device
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   ddh: dedicated host
        # *   ddhcluster: dedicated host cluster
        # *   eni: ENI
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # 
        # These values are case-sensitive.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinResourceGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class JoinResourceGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinResourceGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinResourceGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: JoinResourceGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(JoinResourceGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinResourceGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class JoinSecurityGroupRequest(TeaModel):
    def __init__(self, instance_id=None, network_interface_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, security_group_id=None):
        # The ID of the instance.
        # 
        # >  If this parameter is specified, the `NetworkInterfaceId` parameter cannot be specified.
        self.instance_id = instance_id  # type: str
        # The ID of the ENI.
        # 
        # >  If this parameter is specified, the `InstanceId` parameter cannot be specified.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        # 
        # *   You do not need to specify a region ID when you add an instance to a security group.
        # *   You must specify a region ID when you add an ENI to a security group.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group. You can call the [DescribeSecurityGroups](~~25556~~) operation to query available security groups.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class JoinSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(JoinSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class JoinSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: JoinSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(JoinSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = JoinSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LeaveSecurityGroupRequest(TeaModel):
    def __init__(self, instance_id=None, network_interface_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, security_group_id=None):
        # The ID of the instance.
        # 
        # > If this parameter is specified, the `NetworkInterfaceId` parameter cannot be specified.
        self.instance_id = instance_id  # type: str
        # The ID of the ENI.
        # 
        # > If this parameter is specified, the `InstanceId` parameter cannot be specified.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        # 
        # *   If you want to remove an instance from a security group, you do not need to specify a region ID.
        # *   If you want to remove an ENI from a security group, you must specify the ID of the region in which the ENI resides.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(LeaveSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class LeaveSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(LeaveSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class LeaveSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: LeaveSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(LeaveSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LeaveSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListPluginStatusRequest(TeaModel):
    def __init__(self, instance_id=None, name=None, owner_account=None, owner_id=None, page_number=None,
                 page_size=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IDs of ECS instances. You can specify up to 50 instance IDs in each request.
        self.instance_id = instance_id  # type: list[str]
        # The name of the Cloud Assistant plug-in. The name supports all character sets and must be 1 to 255 characters in length.
        # 
        # * If this parameter is not specified, the states of all Cloud Assistant plug-ins that are installed on the specified ECS instances are queried.
        # 
        #     > If this parameter is not specified, only a single instance ID can be specified.
        # 
        # * If this parameter is specified, the state of the specified Cloud Assistant plug-in is queried.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of the page to return.
        # 
        # *   Pages start from page 1.
        # *   Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 50.
        # *   Default value: 10.
        self.page_size = page_size  # type: long
        # The region ID of the ECS instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPluginStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSetPluginStatus(TeaModel):
    def __init__(self, first_heartbeat_time=None, last_heartbeat_time=None, plugin_name=None, plugin_status=None,
                 plugin_version=None):
        # The first time when Cloud Assistant reported the state of the plug-in.
        self.first_heartbeat_time = first_heartbeat_time  # type: str
        # The last time when Cloud Assistant reported the state of the plug-in.
        self.last_heartbeat_time = last_heartbeat_time  # type: str
        # The name of the plug-in.
        self.plugin_name = plugin_name  # type: str
        # The state of the Cloud Assistant plug-in. Valid values:
        # 
        # * NotInstalled: The plug-in is not installed.
        # * Installed: The one-time plug-in is installed.
        # * Running: The long-running plug-in is running.
        # * Stopped: The long-running plug-in is not running.
        # * Crashed: The plug-in is abnormal.
        # * Removed: The plug-in is uninstalled.
        # * Unknown: The state of the plug-in is unknown.
        self.plugin_status = plugin_status  # type: str
        # The version of the plug-in
        self.plugin_version = plugin_version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSetPluginStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.first_heartbeat_time is not None:
            result['FirstHeartbeatTime'] = self.first_heartbeat_time
        if self.last_heartbeat_time is not None:
            result['LastHeartbeatTime'] = self.last_heartbeat_time
        if self.plugin_name is not None:
            result['PluginName'] = self.plugin_name
        if self.plugin_status is not None:
            result['PluginStatus'] = self.plugin_status
        if self.plugin_version is not None:
            result['PluginVersion'] = self.plugin_version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FirstHeartbeatTime') is not None:
            self.first_heartbeat_time = m.get('FirstHeartbeatTime')
        if m.get('LastHeartbeatTime') is not None:
            self.last_heartbeat_time = m.get('LastHeartbeatTime')
        if m.get('PluginName') is not None:
            self.plugin_name = m.get('PluginName')
        if m.get('PluginStatus') is not None:
            self.plugin_status = m.get('PluginStatus')
        if m.get('PluginVersion') is not None:
            self.plugin_version = m.get('PluginVersion')
        return self


class ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSet(TeaModel):
    def __init__(self, plugin_status=None):
        self.plugin_status = plugin_status  # type: list[ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSetPluginStatus]

    def validate(self):
        if self.plugin_status:
            for k in self.plugin_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['PluginStatus'] = []
        if self.plugin_status is not None:
            for k in self.plugin_status:
                result['PluginStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.plugin_status = []
        if m.get('PluginStatus') is not None:
            for k in m.get('PluginStatus'):
                temp_model = ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSetPluginStatus()
                self.plugin_status.append(temp_model.from_map(k))
        return self


class ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatus(TeaModel):
    def __init__(self, instance_id=None, plugin_status_set=None):
        # The ID of the ECS instance.
        self.instance_id = instance_id  # type: str
        # Details about the Cloud Assistant plug-in.
        self.plugin_status_set = plugin_status_set  # type: ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSet

    def validate(self):
        if self.plugin_status_set:
            self.plugin_status_set.validate()

    def to_map(self):
        _map = super(ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.plugin_status_set is not None:
            result['PluginStatusSet'] = self.plugin_status_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PluginStatusSet') is not None:
            temp_model = ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatusPluginStatusSet()
            self.plugin_status_set = temp_model.from_map(m['PluginStatusSet'])
        return self


class ListPluginStatusResponseBodyInstancePluginStatusSet(TeaModel):
    def __init__(self, instance_plugin_status=None):
        self.instance_plugin_status = instance_plugin_status  # type: list[ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatus]

    def validate(self):
        if self.instance_plugin_status:
            for k in self.instance_plugin_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListPluginStatusResponseBodyInstancePluginStatusSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstancePluginStatus'] = []
        if self.instance_plugin_status is not None:
            for k in self.instance_plugin_status:
                result['InstancePluginStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_plugin_status = []
        if m.get('InstancePluginStatus') is not None:
            for k in m.get('InstancePluginStatus'):
                temp_model = ListPluginStatusResponseBodyInstancePluginStatusSetInstancePluginStatus()
                self.instance_plugin_status.append(temp_model.from_map(k))
        return self


class ListPluginStatusResponseBody(TeaModel):
    def __init__(self, instance_plugin_status_set=None, page_number=None, page_size=None, request_id=None,
                 total_count=None):
        # The states of the Cloud Assistant plug-ins on the ECS instances.
        self.instance_plugin_status_set = instance_plugin_status_set  # type: ListPluginStatusResponseBodyInstancePluginStatusSet
        # The page number of the returned page.
        self.page_number = page_number  # type: long
        # The number of entries returned per page.
        self.page_size = page_size  # type: long
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: long

    def validate(self):
        if self.instance_plugin_status_set:
            self.instance_plugin_status_set.validate()

    def to_map(self):
        _map = super(ListPluginStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_plugin_status_set is not None:
            result['InstancePluginStatusSet'] = self.instance_plugin_status_set.to_map()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstancePluginStatusSet') is not None:
            temp_model = ListPluginStatusResponseBodyInstancePluginStatusSet()
            self.instance_plugin_status_set = temp_model.from_map(m['InstancePluginStatusSet'])
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class ListPluginStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListPluginStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListPluginStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListPluginStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N used for exact search of ECS resources. The tag key must be 1 to 128 characters in length. Valid values of N: 1 to 20.
        # 
        # Methods of using the `Tag.N` parameter pair (Tag.N.Key and Tag.N.Value):
        # 
        # *   Method 1: Use this parameter pair for exact search of ECS resources that have specified tags added. Each tag is a key-value pair.
        # 
        #     *   If you specify only `Tag.N.Key`, all ECS resources whose tags contain the specified tag key are returned.
        #     *   If you specify only `Tag.N.Value`, the `InvalidParameter.TagValue` error is returned.
        #     *   If you specify multiple tag key-value pairs, only the ECS resources that have all these tag key-value pairs added are returned.
        # 
        # *   Method 2: Use this parameter pair to query resource information of a non-default resource group. Set `Tag.1.Key` to `acs:rm:rgId` and `Tag.1.Value` to the ID of a resource group.
        # 
        #     *   If you set `Tag.1.Key` to `acs:rm:rgId`, you must set `Tag.1.Value` to the ID of a non-default resource group. If you set Tag.1.Value to the ID of the default resource group, an error message is returned.
        #     *   If you set `Tag.1.Key` to `acs:rm:rgId`, you cannot specify other Tag.N parameter pairs. If you specify multiple `Tag.N` parameter pairs to query resource groups and resource tags at the same time, an error message is returned.
        self.key = key  # type: str
        # The value of tag N used for exact search of ECS resources. The tag value must be 1 to 128 characters in length. Valid values of N: 1 to 20.
        # 
        # > When Tag.1.Key is set to `acs:rm:rgId`, you can set Tag.1.Value only to the ID of a non-default resource group.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTagResourcesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTagResourcesRequestTagFilter(TeaModel):
    def __init__(self, tag_key=None, tag_values=None):
        # The key of tag N used for fuzzy search of ECS resources. The tag key must be 1 to 128 characters in length. Valid values of N: 1 to 5.
        # 
        # The `TagFilter.N` parameter pair (TagFilter.N.TagKey and TagFilter.N.TagValues.N) is used for fuzzy search of ECS resources that have specified tags added. In the specified tags, a single tag key may correspond to one or more tag values. Fuzzy search may have a latency of 2 seconds. A fuzzy search can return a result set of entries about up to 5,000 resources.
        # 
        # *   When you use `TagFilter.N.TagKey` for fuzzy search of ECS resources, you must leave `TagFilter.N.TagValues.N` empty. For example, to query ECS resources whose tags contain the `environment` tag key, you can set `TagFilter.1.TagKey` to `env*` for prefix search, `*env*` for infix search, or `env` for exact search, but you must leave `TagFilter.1.TagValues` empty.
        # *   When you use `TagFilter.N.TagValues.N` for fuzzy search of ECS resources, you must set `TagFilter.N.TagKey` to an exact value. For example, to query ECS resources that have a tag consisting of the `env` tag key and the `product` tag value, you must set `TagFilter.1.TagKey` to `env` and can set `TagFilter.1.TagValues.1` to `proc*` for prefix search, to `*proc*` for infix search, or to `proc` for exact search. Only one of the preceding search methods can be used for each tag key (`TagFilter.N.TagKey`). If multiple search methods are configured for a tag key, the first search method prevails.
        # *   If you specify multiple tag keys, only the ECS resources that have all of the specified tag keys added are returned.
        # *   If you specify a tag key that corresponds to multiple tag values, all the ECS resources that have one or more of these tag key-value pairs added are returned.
        # 
        # > The `TagFilter.N` parameter pair (TagFilter.N.TagKey and TagFilter.N.TagValues.N) cannot be used together with the `Tag.N` parameter pair (Tag.N.Key and Tag.N.Value). Otherwise, an error message is returned.
        self.tag_key = tag_key  # type: str
        # The value of tag N used for fuzzy search of ECS resources. The tag value must be 1 to 128 characters in length. Valid values of N: 1 to 5. For more information, see the description of `TagFilter.N.TagKey`.
        self.tag_values = tag_values  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTagResourcesRequestTagFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_values is not None:
            result['TagValues'] = self.tag_values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValues') is not None:
            self.tag_values = m.get('TagValues')
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(self, next_token=None, owner_account=None, owner_id=None, region_id=None, resource_id=None,
                 resource_owner_account=None, resource_owner_id=None, resource_type=None, tag=None, tag_filter=None):
        # The token that is required for the next query.
        self.next_token = next_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of resource N. Valid values of N: 1 to 50.
        self.resource_id = resource_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: elastic network interface (ENI)
        # *   ddh: dedicated host
        # *   ddhcluster: dedicated host cluster
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # *   reservedinstance: reserved instance
        # *   snapshotpolicy: automatic snapshot policy
        # *   elasticityassurance: elasticity assurance
        # *   capacityreservation: capacity reservation
        # *   command: Cloud Assistant command
        # *   invocation: Cloud Assistant command execution result
        self.resource_type = resource_type  # type: str
        # Details about the tags.
        self.tag = tag  # type: list[ListTagResourcesRequestTag]
        # The regular expression used to filter tags.
        self.tag_filter = tag_filter  # type: list[ListTagResourcesRequestTagFilter]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()
        if self.tag_filter:
            for k in self.tag_filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        result['TagFilter'] = []
        if self.tag_filter is not None:
            for k in self.tag_filter:
                result['TagFilter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListTagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        self.tag_filter = []
        if m.get('TagFilter') is not None:
            for k in m.get('TagFilter'):
                temp_model = ListTagResourcesRequestTagFilter()
                self.tag_filter.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBodyTagResourcesTagResource(TeaModel):
    def __init__(self, resource_id=None, resource_type=None, tag_key=None, tag_value=None):
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: ENI
        # *   ddh: dedicated host
        # *   ddhcluster: dedicated host cluster
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # *   reservedinstance: reserved instance
        # *   snapshotpolicy: automatic snapshot policy
        # *   elasticityassurance: elasticity assurance
        # *   capacityreservation: capacity reservation
        # *   command: Cloud Assistant command
        # *   invocation: Cloud Assistant command execution result
        self.resource_type = resource_type  # type: str
        # The key of the tag.
        self.tag_key = tag_key  # type: str
        # The value of the tag.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTagResourcesResponseBodyTagResourcesTagResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(self, tag_resource=None):
        self.tag_resource = tag_resource  # type: list[ListTagResourcesResponseBodyTagResourcesTagResource]

    def validate(self):
        if self.tag_resource:
            for k in self.tag_resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTagResourcesResponseBodyTagResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagResource'] = []
        if self.tag_resource is not None:
            for k in self.tag_resource:
                result['TagResource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag_resource = []
        if m.get('TagResource') is not None:
            for k in m.get('TagResource'):
                temp_model = ListTagResourcesResponseBodyTagResourcesTagResource()
                self.tag_resource.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, tag_resources=None):
        # The token that is required for the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about resources and tags, including resource IDs, resource types, and tag key-value pairs.
        self.tag_resources = tag_resources  # type: ListTagResourcesResponseBodyTagResources

    def validate(self):
        if self.tag_resources:
            self.tag_resources.validate()

    def to_map(self):
        _map = super(ListTagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.tag_resources is not None:
            result['TagResources'] = self.tag_resources.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TagResources') is not None:
            temp_model = ListTagResourcesResponseBodyTagResources()
            self.tag_resources = temp_model.from_map(m['TagResources'])
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoProvisioningGroupRequestLaunchTemplateConfig(TeaModel):
    def __init__(self, instance_type=None, max_price=None, priority=None, v_switch_id=None, weighted_capacity=None):
        # The instance type in extended configuration N. Valid values of N: 1 to 20. For more information about the valid values of this parameter, see [Instance families](~~25378~~).
        self.instance_type = instance_type  # type: str
        # The maximum price of preemptible instances in extended configuration N.
        self.max_price = max_price  # type: float
        # The priority of extended configuration N. A value of 0 indicates the highest priority. The value must be greater than 0.
        self.priority = priority  # type: int
        # The ID of the vSwitch in extended configuration N. The zone of the instances created from the extended configuration is determined by the vSwitch.
        self.v_switch_id = v_switch_id  # type: str
        # The weight of the instance type in extended configuration N. A greater weight indicates that a single instance has more computing power and that fewer instances are required. The value must be greater than 0.
        # 
        # The weight is calculated based on the computing power of the instance type and the minimum computing power of a single instance in the cluster to be created by the auto provisioning group. For example, assume that the minimum computing power of a single instance is 8 vCPUs and 60 GiB of memory.
        # 
        # *   For an instance type with 8 vCPUs and 60 GiB of memory, you can set the weight to 1.
        # *   For an instance type with 16 vCPUs and 120 GiB of memory, you can set the weight to 2.
        self.weighted_capacity = weighted_capacity  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoProvisioningGroupRequestLaunchTemplateConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.max_price is not None:
            result['MaxPrice'] = self.max_price
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.weighted_capacity is not None:
            result['WeightedCapacity'] = self.weighted_capacity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MaxPrice') is not None:
            self.max_price = m.get('MaxPrice')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('WeightedCapacity') is not None:
            self.weighted_capacity = m.get('WeightedCapacity')
        return self


class ModifyAutoProvisioningGroupRequest(TeaModel):
    def __init__(self, auto_provisioning_group_id=None, auto_provisioning_group_name=None,
                 default_target_capacity_type=None, excess_capacity_termination_policy=None, launch_template_config=None, max_spot_price=None,
                 owner_account=None, owner_id=None, pay_as_you_go_target_capacity=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, spot_target_capacity=None,
                 terminate_instances_with_expiration=None, total_target_capacity=None):
        # The ID of the auto provisioning group.
        self.auto_provisioning_group_id = auto_provisioning_group_id  # type: str
        # The name of the auto provisioning group. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with [http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).](http://https://。、（:）、（\_）（-）。)
        self.auto_provisioning_group_name = auto_provisioning_group_name  # type: str
        # The type of supplemental instances. When the sum of the PayAsYouGoTargetCapacity and SpotTargetCapacity values is smaller than the TotalTargetCapacity value, the auto provisioning group creates instances of the specified billing method to meet the target capacity. Valid values:
        # 
        # *   PayAsYouGo: pay-as-you-go instances
        # *   Spot: preemptible instances
        self.default_target_capacity_type = default_target_capacity_type  # type: str
        # Specifies whether to release the removed instances when the real-time capacity of the auto provisioning group exceeds the target capacity and a scale-in event is triggered. Valid values:
        # 
        # *   termination: releases the removed instances.
        # *   no-termination: only removes the instances from the auto provisioning group but does not release them.
        self.excess_capacity_termination_policy = excess_capacity_termination_policy  # type: str
        # The extended configurations.
        self.launch_template_config = launch_template_config  # type: list[ModifyAutoProvisioningGroupRequestLaunchTemplateConfig]
        # The maximum price of preemptible instances in the auto provisioning group.
        # 
        # > When both the MaxSpotPrice and LaunchTemplateConfig.N.MaxPrice parameters are specified, the smaller one of the two parameter values is used. The LaunchTemplateConfig.N.MaxPrice parameter is set when the auto provisioning group is created, and cannot be modified.
        self.max_spot_price = max_spot_price  # type: float
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The target capacity of pay-as-you-go instances in the auto provisioning group. The value must be smaller than the TotalTargetCapacity value.
        self.pay_as_you_go_target_capacity = pay_as_you_go_target_capacity  # type: str
        # The region ID of the auto provisioning group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The target capacity of preemptible instances in the auto provisioning group. The value must be smaller than the TotalTargetCapacity value.
        self.spot_target_capacity = spot_target_capacity  # type: str
        # Specifies whether to release instances in the auto provisioning group when the auto provisioning group expires. Valid values:
        # 
        # *   true: releases instances in the auto provisioning group.
        # *   false: only removes instances from the auto provisioning group but does not release them.
        self.terminate_instances_with_expiration = terminate_instances_with_expiration  # type: bool
        # The total target capacity of the auto provisioning group. The value must be a positive integer.
        # 
        # The total target capacity of the auto provisioning group must be greater than or equal to the sum of the target capacity of pay-as-you-go instances specified by the PayAsYouGoTargetCapacity parameter and the target capacity of preemptible instances specified by the SpotTargetCapacity parameter.
        self.total_target_capacity = total_target_capacity  # type: str

    def validate(self):
        if self.launch_template_config:
            for k in self.launch_template_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyAutoProvisioningGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_provisioning_group_id is not None:
            result['AutoProvisioningGroupId'] = self.auto_provisioning_group_id
        if self.auto_provisioning_group_name is not None:
            result['AutoProvisioningGroupName'] = self.auto_provisioning_group_name
        if self.default_target_capacity_type is not None:
            result['DefaultTargetCapacityType'] = self.default_target_capacity_type
        if self.excess_capacity_termination_policy is not None:
            result['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy
        result['LaunchTemplateConfig'] = []
        if self.launch_template_config is not None:
            for k in self.launch_template_config:
                result['LaunchTemplateConfig'].append(k.to_map() if k else None)
        if self.max_spot_price is not None:
            result['MaxSpotPrice'] = self.max_spot_price
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.pay_as_you_go_target_capacity is not None:
            result['PayAsYouGoTargetCapacity'] = self.pay_as_you_go_target_capacity
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.spot_target_capacity is not None:
            result['SpotTargetCapacity'] = self.spot_target_capacity
        if self.terminate_instances_with_expiration is not None:
            result['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration
        if self.total_target_capacity is not None:
            result['TotalTargetCapacity'] = self.total_target_capacity
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoProvisioningGroupId') is not None:
            self.auto_provisioning_group_id = m.get('AutoProvisioningGroupId')
        if m.get('AutoProvisioningGroupName') is not None:
            self.auto_provisioning_group_name = m.get('AutoProvisioningGroupName')
        if m.get('DefaultTargetCapacityType') is not None:
            self.default_target_capacity_type = m.get('DefaultTargetCapacityType')
        if m.get('ExcessCapacityTerminationPolicy') is not None:
            self.excess_capacity_termination_policy = m.get('ExcessCapacityTerminationPolicy')
        self.launch_template_config = []
        if m.get('LaunchTemplateConfig') is not None:
            for k in m.get('LaunchTemplateConfig'):
                temp_model = ModifyAutoProvisioningGroupRequestLaunchTemplateConfig()
                self.launch_template_config.append(temp_model.from_map(k))
        if m.get('MaxSpotPrice') is not None:
            self.max_spot_price = m.get('MaxSpotPrice')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PayAsYouGoTargetCapacity') is not None:
            self.pay_as_you_go_target_capacity = m.get('PayAsYouGoTargetCapacity')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SpotTargetCapacity') is not None:
            self.spot_target_capacity = m.get('SpotTargetCapacity')
        if m.get('TerminateInstancesWithExpiration') is not None:
            self.terminate_instances_with_expiration = m.get('TerminateInstancesWithExpiration')
        if m.get('TotalTargetCapacity') is not None:
            self.total_target_capacity = m.get('TotalTargetCapacity')
        return self


class ModifyAutoProvisioningGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoProvisioningGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoProvisioningGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAutoProvisioningGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAutoProvisioningGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoProvisioningGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, data_disk_policy_enabled=None, data_disk_policy_retention_days=None,
                 data_disk_policy_retention_last_week=None, data_disk_policy_time_period=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, system_disk_policy_enabled=None,
                 system_disk_policy_retention_days=None, system_disk_policy_retention_last_week=None, system_disk_policy_time_period=None):
        self.data_disk_policy_enabled = data_disk_policy_enabled  # type: bool
        self.data_disk_policy_retention_days = data_disk_policy_retention_days  # type: int
        self.data_disk_policy_retention_last_week = data_disk_policy_retention_last_week  # type: bool
        self.data_disk_policy_time_period = data_disk_policy_time_period  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.system_disk_policy_enabled = system_disk_policy_enabled  # type: bool
        self.system_disk_policy_retention_days = system_disk_policy_retention_days  # type: int
        self.system_disk_policy_retention_last_week = system_disk_policy_retention_last_week  # type: bool
        self.system_disk_policy_time_period = system_disk_policy_time_period  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_policy_enabled is not None:
            result['DataDiskPolicyEnabled'] = self.data_disk_policy_enabled
        if self.data_disk_policy_retention_days is not None:
            result['DataDiskPolicyRetentionDays'] = self.data_disk_policy_retention_days
        if self.data_disk_policy_retention_last_week is not None:
            result['DataDiskPolicyRetentionLastWeek'] = self.data_disk_policy_retention_last_week
        if self.data_disk_policy_time_period is not None:
            result['DataDiskPolicyTimePeriod'] = self.data_disk_policy_time_period
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.system_disk_policy_enabled is not None:
            result['SystemDiskPolicyEnabled'] = self.system_disk_policy_enabled
        if self.system_disk_policy_retention_days is not None:
            result['SystemDiskPolicyRetentionDays'] = self.system_disk_policy_retention_days
        if self.system_disk_policy_retention_last_week is not None:
            result['SystemDiskPolicyRetentionLastWeek'] = self.system_disk_policy_retention_last_week
        if self.system_disk_policy_time_period is not None:
            result['SystemDiskPolicyTimePeriod'] = self.system_disk_policy_time_period
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataDiskPolicyEnabled') is not None:
            self.data_disk_policy_enabled = m.get('DataDiskPolicyEnabled')
        if m.get('DataDiskPolicyRetentionDays') is not None:
            self.data_disk_policy_retention_days = m.get('DataDiskPolicyRetentionDays')
        if m.get('DataDiskPolicyRetentionLastWeek') is not None:
            self.data_disk_policy_retention_last_week = m.get('DataDiskPolicyRetentionLastWeek')
        if m.get('DataDiskPolicyTimePeriod') is not None:
            self.data_disk_policy_time_period = m.get('DataDiskPolicyTimePeriod')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SystemDiskPolicyEnabled') is not None:
            self.system_disk_policy_enabled = m.get('SystemDiskPolicyEnabled')
        if m.get('SystemDiskPolicyRetentionDays') is not None:
            self.system_disk_policy_retention_days = m.get('SystemDiskPolicyRetentionDays')
        if m.get('SystemDiskPolicyRetentionLastWeek') is not None:
            self.system_disk_policy_retention_last_week = m.get('SystemDiskPolicyRetentionLastWeek')
        if m.get('SystemDiskPolicyTimePeriod') is not None:
            self.system_disk_policy_time_period = m.get('SystemDiskPolicyTimePeriod')
        return self


class ModifyAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoSnapshotPolicyExRequest(TeaModel):
    def __init__(self, copied_snapshots_retention_days=None, enable_cross_region_copy=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, target_copy_regions=None, auto_snapshot_policy_id=None,
                 auto_snapshot_policy_name=None, region_id=None, repeat_weekdays=None, retention_days=None, time_points=None):
        # The retention period of the snapshot copy in the destination region. Unit: days. Valid values:
        # 
        # *   \-1: The snapshot is permanently retained.
        # *   1 to 65535: The automatic snapshot is retained for the specified number of days.
        # 
        # Default value: -1.
        self.copied_snapshots_retention_days = copied_snapshots_retention_days  # type: int
        # Specifies whether to enable cross-region replication for the automatic snapshot.
        # 
        # *   true: enables cross-region replication for the automatic snapshot.
        # *   false: disables cross-region replication for the automatic snapshot.
        self.enable_cross_region_copy = enable_cross_region_copy  # type: bool
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The destination region to which to copy the snapshot. You can specify only a single destination region.
        self.target_copy_regions = target_copy_regions  # type: str
        # The ID of the automatic snapshot policy. You can call the [DescribeAutoSnapshotPolicyEx](~~25530~~) operation to query available automatic snapshot policies.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The name of the automatic snapshot policy. If this parameter is not specified, the original name of the automatic snapshot policy is retained.
        self.auto_snapshot_policy_name = auto_snapshot_policy_name  # type: str
        # The region ID of the automatic snapshot policy to be modified. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The days of the week on which to create automatic snapshots. Valid values are 1 to 7, which correspond to the days of the week. For example, a value of 1 indicates Monday.
        # 
        # To schedule multiple automatic snapshots to be created in a week, you can specify multiple days.
        # 
        # *   You can specify up to seven days over a one-week period.
        # *   You must set this parameter to a JSON array such as `["1", "2" ... "7"]`. Separate the values in the array with commas (,).
        self.repeat_weekdays = repeat_weekdays  # type: str
        # The retention period of the automatic snapshot. Unit: days. Valid values:
        # 
        # *   \-1: The automatic snapshot is permanently retained.
        # *   1 to 65536: The auto snapshot is retained for the specified number of days.
        # 
        # Default value: -1.
        self.retention_days = retention_days  # type: int
        # The points in time of the day at which to create automatic snapshots. The time must be in UTC+8. Unit: hours. Valid values are 0 to 23, which correspond to the 24 points in time on the hour from 00:00:00 to 23:00:00. For example, a value of 1 indicates 01:00:00.
        # 
        # To schedule multiple automatic snapshots to be created in a day, you can specify multiple hours.
        # 
        # *   You can specify up to 24 points in time.
        # *   You must set this parameter to a JSON array such as `["0", "1", ... "23"]`. Separate the points in time with commas (,).
        self.time_points = time_points  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyExRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.copied_snapshots_retention_days is not None:
            result['CopiedSnapshotsRetentionDays'] = self.copied_snapshots_retention_days
        if self.enable_cross_region_copy is not None:
            result['EnableCrossRegionCopy'] = self.enable_cross_region_copy
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.target_copy_regions is not None:
            result['TargetCopyRegions'] = self.target_copy_regions
        if self.auto_snapshot_policy_id is not None:
            result['autoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.auto_snapshot_policy_name is not None:
            result['autoSnapshotPolicyName'] = self.auto_snapshot_policy_name
        if self.region_id is not None:
            result['regionId'] = self.region_id
        if self.repeat_weekdays is not None:
            result['repeatWeekdays'] = self.repeat_weekdays
        if self.retention_days is not None:
            result['retentionDays'] = self.retention_days
        if self.time_points is not None:
            result['timePoints'] = self.time_points
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CopiedSnapshotsRetentionDays') is not None:
            self.copied_snapshots_retention_days = m.get('CopiedSnapshotsRetentionDays')
        if m.get('EnableCrossRegionCopy') is not None:
            self.enable_cross_region_copy = m.get('EnableCrossRegionCopy')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TargetCopyRegions') is not None:
            self.target_copy_regions = m.get('TargetCopyRegions')
        if m.get('autoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('autoSnapshotPolicyId')
        if m.get('autoSnapshotPolicyName') is not None:
            self.auto_snapshot_policy_name = m.get('autoSnapshotPolicyName')
        if m.get('regionId') is not None:
            self.region_id = m.get('regionId')
        if m.get('repeatWeekdays') is not None:
            self.repeat_weekdays = m.get('repeatWeekdays')
        if m.get('retentionDays') is not None:
            self.retention_days = m.get('retentionDays')
        if m.get('timePoints') is not None:
            self.time_points = m.get('timePoints')
        return self


class ModifyAutoSnapshotPolicyExResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyExResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoSnapshotPolicyExResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAutoSnapshotPolicyExResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyExResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoSnapshotPolicyExResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBandwidthPackageSpecRequest(TeaModel):
    def __init__(self, bandwidth=None, bandwidth_package_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.bandwidth = bandwidth  # type: str
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBandwidthPackageSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyBandwidthPackageSpecResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBandwidthPackageSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBandwidthPackageSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyBandwidthPackageSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyBandwidthPackageSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBandwidthPackageSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCapacityReservationRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None, name=None):
        # The ID of the capacity reservation.
        self.id = id  # type: str
        # The name of the capacity reservation. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCapacityReservationRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ModifyCapacityReservationRequest(TeaModel):
    def __init__(self, private_pool_options=None, description=None, end_time=None, end_time_type=None,
                 instance_amount=None, owner_account=None, owner_id=None, platform=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, start_time=None):
        self.private_pool_options = private_pool_options  # type: ModifyCapacityReservationRequestPrivatePoolOptions
        # The description of the capacity reservation. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The expiration time of the capacity reservation. This parameter takes effect only when `EndTimeType` is set to Limited. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC. For more information, see [ISO 8601](~~25696~~).
        self.end_time = end_time  # type: str
        # The release mode of the capacity reservation. Valid values:
        # 
        # *   Limited: The capacity reservation is released at the specified time. You must also specify the `EndTime` parameter.
        # *   Unlimited: You must manually release the capacity reservation. You can release capacity reservations at any time.
        self.end_time_type = end_time_type  # type: str
        # The total number of instances reserved by the capacity reservation. Valid values: the number of created instances to 1000.
        # 
        # >  When you increase the number of instances reserved, the increase may fail due to insufficient resources.
        self.instance_amount = instance_amount  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The operating system type of the instance reserved. Valid values:
        # 
        # *   Windows: Windows Server operating systems
        # *   Linux: Linux and Unix-like operating systems
        # 
        # >  This parameter is unavailable.
        self.platform = platform  # type: str
        # The region ID of the capacity reservation. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The effective mode of the capacity reservation. The capacity reservation can be set only to take effect immediately. You do not need to pass in a value for the parameter.
        # 
        # >  The capacity reservation takes effect immediately when this parameter is left empty.
        self.start_time = start_time  # type: str

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(ModifyCapacityReservationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_time_type is not None:
            result['EndTimeType'] = self.end_time_type
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = ModifyCapacityReservationRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndTimeType') is not None:
            self.end_time_type = m.get('EndTimeType')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifyCapacityReservationResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCapacityReservationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCapacityReservationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCapacityReservationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCapacityReservationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCapacityReservationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCommandRequest(TeaModel):
    def __init__(self, command_content=None, command_id=None, description=None, name=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, timeout=None,
                 working_dir=None):
        # The content of the command. The command content can be plaintext or Base64-encoded. When you call this operation, take note of the following items:
        # 
        # *   The Base64-encoded command content cannot exceed 16 KB in size.
        # 
        # *   If the command content is Base64-encoded, set `ContentEncoding` to Base64.
        # 
        # *   When `EnableParameter` is set to true, the custom parameter feature is enabled and you can configure custom parameters based on the following rules:
        # 
        #     *   Define custom parameters in the `{{}}` format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
        #     *   The number of custom parameters cannot exceed 20.
        #     *   A custom parameter name can contain only letters, digits, underscores (\_), and hyphens (-). The name is case-insensitive.
        #     *   Each custom parameter name cannot exceed 64 bytes in length.
        self.command_content = command_content  # type: str
        # The ID of the command. You can call the [DescribeCommands](~~64843~~) operation to query all available command IDs.
        self.command_id = command_id  # type: str
        # The description of the command. The description supports all character sets and can be up to 512 characters in length.
        self.description = description  # type: str
        # The name of the command. The name supports all character sets and can be up to 128 characters in length.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The maximum timeout period for command execution. Unit: seconds. When a command cannot run within the specified time range, the command times out. When a command execution times out, the Cloud Assistant client forcefully terminates the command process by canceling the process ID (PID) of the command.
        self.timeout = timeout  # type: long
        # The working directory of the command on the Elastic Compute Service (ECS) instance.
        self.working_dir = working_dir  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class ModifyCommandResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDedicatedHostAttributeRequestNetworkAttributes(TeaModel):
    def __init__(self, slb_udp_timeout=None, udp_timeout=None):
        # The timeout period for a UDP session between a Server Load Balancer (SLB) instance and the dedicated host. Unit: seconds. Valid values: 15 to 310.
        self.slb_udp_timeout = slb_udp_timeout  # type: int
        # The timeout period for a UDP session between a user and an Alibaba Cloud service on the dedicated host. Unit: seconds. Valid values: 15 to 310.
        self.udp_timeout = udp_timeout  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAttributeRequestNetworkAttributes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slb_udp_timeout is not None:
            result['SlbUdpTimeout'] = self.slb_udp_timeout
        if self.udp_timeout is not None:
            result['UdpTimeout'] = self.udp_timeout
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SlbUdpTimeout') is not None:
            self.slb_udp_timeout = m.get('SlbUdpTimeout')
        if m.get('UdpTimeout') is not None:
            self.udp_timeout = m.get('UdpTimeout')
        return self


class ModifyDedicatedHostAttributeRequest(TeaModel):
    def __init__(self, network_attributes=None, action_on_maintenance=None, auto_placement=None,
                 cpu_over_commit_ratio=None, dedicated_host_cluster_id=None, dedicated_host_id=None, dedicated_host_name=None,
                 description=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.network_attributes = network_attributes  # type: ModifyDedicatedHostAttributeRequestNetworkAttributes
        # The policy for migrating the instances deployed on the dedicated host when the dedicated host fails or needs to be repaired online. Valid values:
        # 
        # *   Migrate: The instances are migrated to another physical machine and then restarted.
        # *   Stop: The instances are stopped. If the dedicated host cannot be repaired, the instances are migrated to another physical machine and then restarted.
        # 
        # If the dedicated host has cloud disks attached, the default value is Migrate.
        # 
        # If the dedicated host has local disks attached, the default value is Stop.
        self.action_on_maintenance = action_on_maintenance  # type: str
        # Specifies whether to add the dedicated host to the resource pool for automatic deployment. If you do not specify the **DedicatedHostId** parameter when you create an instance on a dedicated host, Alibaba Cloud automatically selects a dedicated host from the resource pool to host the instance. Valid values:
        # 
        # *   on: adds the dedicated host to the resource pool for automatic deployment.
        # *   off: does not add the dedicated host to the resource pool for automatic deployment.
        # 
        # For information about automatic deployment, see [Features](~~118938~~).
        self.auto_placement = auto_placement  # type: str
        # The CPU overcommit ratio. You can configure CPU overcommit ratios only for the following dedicated host types: g6s, c6s, and r6s. Valid values: 1 to 5.
        # 
        # The CPU overcommit ratio affects the number of available vCPUs on a dedicated host. You can use the following formula to calculate the number of available vCPUs on a dedicated host: Number of available vCPUs = Number of physical CPU cores × 2 × CPU overcommit ratio. For example, the number of physical CPU cores on each g6s dedicated host is 52. If you change the CPU overcommit ratio of a g6s dedicated host to 4, the number of available vCPUs on the dedicated host is 416. For scenarios that have minimal requirements for CPU stability or where CPU load is not heavy, such as development and test environments, you can increase the number of available vCPUs on a dedicated host by increasing the CPU overcommit ratio. This way, you can deploy more ECS instances of the same specifications on the dedicated host and reduce the unit deployment cost.
        self.cpu_over_commit_ratio = cpu_over_commit_ratio  # type: float
        # The ID of the dedicated host cluster to which the dedicated host belongs.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The name of the dedicated host. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. The name can contain digits, letters, colons (:), underscores (\_), and hyphens (-).
        self.dedicated_host_name = dedicated_host_name  # type: str
        # The description of the dedicated host. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.network_attributes:
            self.network_attributes.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_attributes is not None:
            result['NetworkAttributes'] = self.network_attributes.to_map()
        if self.action_on_maintenance is not None:
            result['ActionOnMaintenance'] = self.action_on_maintenance
        if self.auto_placement is not None:
            result['AutoPlacement'] = self.auto_placement
        if self.cpu_over_commit_ratio is not None:
            result['CpuOverCommitRatio'] = self.cpu_over_commit_ratio
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.dedicated_host_name is not None:
            result['DedicatedHostName'] = self.dedicated_host_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkAttributes') is not None:
            temp_model = ModifyDedicatedHostAttributeRequestNetworkAttributes()
            self.network_attributes = temp_model.from_map(m['NetworkAttributes'])
        if m.get('ActionOnMaintenance') is not None:
            self.action_on_maintenance = m.get('ActionOnMaintenance')
        if m.get('AutoPlacement') is not None:
            self.auto_placement = m.get('AutoPlacement')
        if m.get('CpuOverCommitRatio') is not None:
            self.cpu_over_commit_ratio = m.get('CpuOverCommitRatio')
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DedicatedHostName') is not None:
            self.dedicated_host_name = m.get('DedicatedHostName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDedicatedHostAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDedicatedHostAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDedicatedHostAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDedicatedHostAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDedicatedHostAutoReleaseTimeRequest(TeaModel):
    def __init__(self, auto_release_time=None, dedicated_host_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The automatic release time of the dedicated host. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC+0.
        # 
        # *   The automatic release time must be at least 30 minutes from the current time.
        # *   The automatic release time must be at most three years from the current time.
        # *   If the value of seconds (ss) is not 00, it is automatically set to 00.
        # *   If you do not specify the `AutoReleaseTime` parameter, the automatic release time is canceled the dedicated host is automatically released.
        self.auto_release_time = auto_release_time  # type: str
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoReleaseTimeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDedicatedHostAutoReleaseTimeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoReleaseTimeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDedicatedHostAutoReleaseTimeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDedicatedHostAutoReleaseTimeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoReleaseTimeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDedicatedHostAutoReleaseTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDedicatedHostAutoRenewAttributeRequest(TeaModel):
    def __init__(self, auto_renew=None, auto_renew_with_ecs=None, dedicated_host_ids=None, duration=None,
                 owner_account=None, owner_id=None, period_unit=None, region_id=None, renewal_status=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to automatically renew the subscription dedicated host. Valid values:
        # 
        # *   true: automatically renews the subscription dedicated host.
        # *   false: does not automatically renew the subscription dedicated host.
        # 
        # Default value: false.
        self.auto_renew = auto_renew  # type: bool
        # Specifies whether to automatically renew the subscription dedicated host along with the subscription ECS instances hosted on it.
        # 
        # If auto-renewal is enabled for the subscription ECS instances hosted on your subscription dedicated host, you can specify this parameter to automatically renew the dedicated host along with the subscription ECS instances. When the subscription ECS instances hosted on your dedicated host are automatically renewed, the dedicated host is also automatically renewed if the expiration time of the dedicated host is earlier than the expiration time of the renewed instances.
        # 
        # When the dedicated host is configured to be automatically renewed along with the subscription ECS instances hosted on it, the dedicated host determines the expiration time of the renewed instances, and selects a minimum value from the valid values of the Duration parameter so that the dedicated host is renewed by a duration that expires later than the expiration time of the renewed instances. For more information about supported renewal durations, see the descriptions of the `PeriodUnit` and `Duration` parameters.
        # 
        # For example, assume that you have a subscription dedicated host that expires on January 15 of the current year. Subscription ECS instances hosted on the dedicated host have the auto-renewal feature enabled, and are automatically renewed to November 15 of the same year. The expiration time of the dedicated host is earlier than the expiration time of the ECS instances by 10 months. In this case, the dedicated host selects a renewal duration of 12 months, which is the minimum value of the `Duration` parameter (`PeriodUnit=Month`) that allows the dedicated host to expire later than the ECS instances.
        # 
        # Valid values:
        # 
        # *   AutoRenewWithEcs: automatically renews the subscription dedicated host along with the subscription ECS instances hosted on it.
        # *   StopRenewWithEcs: does not automatically renew the subscription dedicated host along with the subscription ECS instances hosted on it.
        # *   NoOperation: does not change the current settings for the dedicated host.
        # 
        # >  If you set this parameter to AutoRenewWithEcs, make sure that `AutoRenew` is set to true to enable auto-renewal for the dedicated host. Otherwise, only the parameter value is changed. The dedicated host is not automatically renewed along with the subscription ECS instances hosted on it.
        # 
        # Default value: NoOperation.
        self.auto_renew_with_ecs = auto_renew_with_ecs  # type: str
        # The IDs of the dedicated hosts. You can specify up to 100 subscription dedicated host IDs. Separate multiple IDs with commas (,).
        self.dedicated_host_ids = dedicated_host_ids  # type: str
        # The renewal duration of the dedicated host. Valid values:
        # 
        # *   When the PeriodUnit parameter is set to Week, the valid values of the Duration parameter are 1, 2, and 3.
        # *   When the PeriodUnit parameter is set to Month, the valid values of the Duration parameter are 1, 2, 3, 6, and 12.
        self.duration = duration  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The unit of the renewal duration. Valid values:
        # 
        # *   Week
        # *   Month
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The region ID of the dedicated host.
        self.region_id = region_id  # type: str
        # Specifies whether to automatically renew the subscription dedicated host. The `RenewalStatus` parameter takes precedence over the `AutoRenew` parameter. Valid values:
        # 
        # *   AutoRenewal: automatically renews the subscription dedicated host.
        # *   Normal: does not automatically renew the subscription dedicated host, but notifications for renewal are sent.
        # *   NotRenewal: does not automatically renew the subscription dedicated host, and no expiration notification is sent. Notifications for renewal are automatically sent three days before the expiration time of the subscription dedicated host. You can change the value of this parameter from NotRenewal to Normal for the dedicated host and manually renew it by calling the [RenewDedicatedHosts](~~134250~~) operation. Alternatively, you can renew it by setting this parameter to AutoRenewal.
        self.renewal_status = renewal_status  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoRenewAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_with_ecs is not None:
            result['AutoRenewWithEcs'] = self.auto_renew_with_ecs
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewWithEcs') is not None:
            self.auto_renew_with_ecs = m.get('AutoRenewWithEcs')
        if m.get('DedicatedHostIds') is not None:
            self.dedicated_host_ids = m.get('DedicatedHostIds')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDedicatedHostAutoRenewAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoRenewAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDedicatedHostAutoRenewAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDedicatedHostAutoRenewAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostAutoRenewAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDedicatedHostAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDedicatedHostClusterAttributeRequest(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None, dedicated_host_cluster_name=None, description=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The new name of the dedicated host cluster. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). It must start with a letter. It cannot contain `http://` or `https://`.
        self.dedicated_host_cluster_name = dedicated_host_cluster_name  # type: str
        # The new description of the dedicated host cluster. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostClusterAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_cluster_name is not None:
            result['DedicatedHostClusterName'] = self.dedicated_host_cluster_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostClusterName') is not None:
            self.dedicated_host_cluster_name = m.get('DedicatedHostClusterName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDedicatedHostClusterAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostClusterAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDedicatedHostClusterAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDedicatedHostClusterAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostClusterAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDedicatedHostClusterAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDedicatedHostsChargeTypeRequest(TeaModel):
    def __init__(self, auto_pay=None, client_token=None, dedicated_host_charge_type=None, dedicated_host_ids=None,
                 detail_fee=None, dry_run=None, owner_account=None, owner_id=None, period=None, period_unit=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable automatic payment. Valid values:
        # 
        # *   true: enables automatic payment. Make sure that your account balance is sufficient. Otherwise, your order becomes invalid and must be canceled.
        # *   false: An order is generated but no payment is made.
        # 
        # Default value: true.
        # 
        # >  If your account balance is insufficient, you can set the `AutoPay` parameter to `false` to generate an unpaid order. Then, you can pay for the order.
        self.auto_pay = auto_pay  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The `ClientToken` value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The new billing method for the dedicated host. Valid values:
        # 
        # *   PrePaid: changes the billing method from pay-as-you-go to subscription.
        # *   PostPaid: changes the billing method from subscription to pay-as-you-go.
        # 
        # Default value: PrePaid.
        self.dedicated_host_charge_type = dedicated_host_charge_type  # type: str
        # The IDs of dedicated hosts. The value can be a JSON array that consists of up to 20 dedicated host IDs. Separate the dedicated host IDs with commas (,).
        self.dedicated_host_ids = dedicated_host_ids  # type: str
        # Specifies whether to return the billing details of the order when the billing method is changed from subscription to pay-as-you-go.
        # 
        # Default value: false.
        self.detail_fee = detail_fee  # type: bool
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether RAM users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned, and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The renewal duration of the subscription dedicated host. Valid values:
        # 
        # *   When `PeriodUnit` is set to Week, valid values of `Period` are 1, 2, 3, and 4.
        # *   When `PeriodUnit` is set to Month, valid values of `Period` are 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The unit of the renewal duration (`Period`). Valid values:
        # 
        # *   Week
        # *   Month
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostsChargeTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dedicated_host_charge_type is not None:
            result['DedicatedHostChargeType'] = self.dedicated_host_charge_type
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids
        if self.detail_fee is not None:
            result['DetailFee'] = self.detail_fee
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DedicatedHostChargeType') is not None:
            self.dedicated_host_charge_type = m.get('DedicatedHostChargeType')
        if m.get('DedicatedHostIds') is not None:
            self.dedicated_host_ids = m.get('DedicatedHostIds')
        if m.get('DetailFee') is not None:
            self.detail_fee = m.get('DetailFee')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance(TeaModel):
    def __init__(self, currency=None, fee=None, instance_id=None):
        # The unit of currency for the bill.
        # 
        # Alibaba Cloud China site (aliyun.com): CNY.
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # The cost value.
        self.fee = fee  # type: str
        # The ID of the dedicated host.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.fee is not None:
            result['Fee'] = self.fee
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('Fee') is not None:
            self.fee = m.get('Fee')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances(TeaModel):
    def __init__(self, fee_of_instance=None):
        self.fee_of_instance = fee_of_instance  # type: list[ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance]

    def validate(self):
        if self.fee_of_instance:
            for k in self.fee_of_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FeeOfInstance'] = []
        if self.fee_of_instance is not None:
            for k in self.fee_of_instance:
                result['FeeOfInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fee_of_instance = []
        if m.get('FeeOfInstance') is not None:
            for k in m.get('FeeOfInstance'):
                temp_model = ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstancesFeeOfInstance()
                self.fee_of_instance.append(temp_model.from_map(k))
        return self


class ModifyDedicatedHostsChargeTypeResponseBody(TeaModel):
    def __init__(self, fee_of_instances=None, order_id=None, request_id=None):
        # Details about the charges for the order.
        self.fee_of_instances = fee_of_instances  # type: ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.fee_of_instances:
            self.fee_of_instances.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostsChargeTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fee_of_instances is not None:
            result['FeeOfInstances'] = self.fee_of_instances.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FeeOfInstances') is not None:
            temp_model = ModifyDedicatedHostsChargeTypeResponseBodyFeeOfInstances()
            self.fee_of_instances = temp_model.from_map(m['FeeOfInstances'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDedicatedHostsChargeTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDedicatedHostsChargeTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDedicatedHostsChargeTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDedicatedHostsChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDemandRequest(TeaModel):
    def __init__(self, amount=None, client_token=None, demand_description=None, demand_id=None, demand_name=None,
                 end_time=None, instance_charge_type=None, instance_type=None, owner_account=None, owner_id=None,
                 period=None, period_unit=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 start_time=None, zone_id=None):
        # The number of instances. Valid values: 1 to 100000.
        self.amount = amount  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The ClientToken value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the demand. The description must be 2 to 256 characters in length. It cannot start with http:// or https://.
        self.demand_description = demand_description  # type: str
        # The ID of the demand that you want to modify.
        self.demand_id = demand_id  # type: str
        # The name of the demand. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with [http:// or https://](http://https://). It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
        # 
        # The default value is the instance type name.
        self.demand_name = demand_name  # type: str
        # The end time of the subscription period. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-dd HH:mm:ss format. The time must be in UTC.
        # 
        # If the value of seconds (ss) is not 00, the time is automatically set to the beginning of the specified minute (mm).
        # 
        # The value of EndTime is later than the value of Starttime.
        # 
        # Typically, the interval between the two times cannot be more than 10 days.
        self.end_time = end_time  # type: str
        # The billing method of the instance. Default value: PostPaid. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.instance_charge_type = instance_charge_type  # type: str
        # The instance type. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the performance data of the filed instance type, or see [Select instance types](~~58291~~) to learn how to select instance types.
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The subscription period of the resource. Unit: month. You must specify the parameter. This parameter is valid only when `InstanceChargeType` is set to PrePaid. Valid values:
        # 
        # *   Valid values when PeriodUnit is set to Week: 1, 2, 3, and 4.
        # *   Valid values when PeriodUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The unit of the subscription period of the resource. Default value: Month. Valid values:
        # 
        # *   Day
        # *   Week
        # *   Month
        self.period_unit = period_unit  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start time of the subscription period. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-dd HH:mm:ss format. The time must be in UTC.
        # 
        # If the value of seconds (ss) is not 00, the time is automatically set to the beginning of the specified minute (mm).
        # 
        # The value of EndTime must be later than the value of Starttime.
        # 
        # Typically, the interval between the two times cannot be more than 10 days.
        self.start_time = start_time  # type: str
        # The zone ID of the instance. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        # 
        # This parameter is empty by default. If you leave this parameter empty, the system randomly selects a zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDemandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.demand_description is not None:
            result['DemandDescription'] = self.demand_description
        if self.demand_id is not None:
            result['DemandId'] = self.demand_id
        if self.demand_name is not None:
            result['DemandName'] = self.demand_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DemandDescription') is not None:
            self.demand_description = m.get('DemandDescription')
        if m.get('DemandId') is not None:
            self.demand_id = m.get('DemandId')
        if m.get('DemandName') is not None:
            self.demand_name = m.get('DemandName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ModifyDemandResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDemandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDemandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDemandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDemandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDemandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDeploymentSetAttributeRequest(TeaModel):
    def __init__(self, deployment_set_id=None, deployment_set_name=None, description=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The ID of the deployment set.
        self.deployment_set_id = deployment_set_id  # type: str
        # The new name of the deployment set. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.deployment_set_name = deployment_set_name  # type: str
        # The new description of the deployment set. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the deployment set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDeploymentSetAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.deployment_set_name is not None:
            result['DeploymentSetName'] = self.deployment_set_name
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('DeploymentSetName') is not None:
            self.deployment_set_name = m.get('DeploymentSetName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDeploymentSetAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDeploymentSetAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDeploymentSetAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDeploymentSetAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDeploymentSetAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDeploymentSetAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDiagnosticMetricSetRequest(TeaModel):
    def __init__(self, description=None, metric_ids=None, metric_set_id=None, metric_set_name=None, region_id=None,
                 resource_type=None):
        # The new description of the diagnostic metric set.
        self.description = description  # type: str
        # The IDs of diagnostic metrics.
        self.metric_ids = metric_ids  # type: list[str]
        # The ID of the diagnostic metric set.
        self.metric_set_id = metric_set_id  # type: str
        # The new name of the diagnostic metric set.
        self.metric_set_name = metric_set_name  # type: str
        # The region ID of the diagnostic metric set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of the resource.
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiagnosticMetricSetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.metric_ids is not None:
            result['MetricIds'] = self.metric_ids
        if self.metric_set_id is not None:
            result['MetricSetId'] = self.metric_set_id
        if self.metric_set_name is not None:
            result['MetricSetName'] = self.metric_set_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('MetricIds') is not None:
            self.metric_ids = m.get('MetricIds')
        if m.get('MetricSetId') is not None:
            self.metric_set_id = m.get('MetricSetId')
        if m.get('MetricSetName') is not None:
            self.metric_set_name = m.get('MetricSetName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class ModifyDiagnosticMetricSetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiagnosticMetricSetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDiagnosticMetricSetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDiagnosticMetricSetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDiagnosticMetricSetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDiagnosticMetricSetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDiskAttributeRequest(TeaModel):
    def __init__(self, bursting_enabled=None, delete_auto_snapshot=None, delete_with_instance=None,
                 description=None, disk_id=None, disk_ids=None, disk_name=None, enable_auto_snapshot=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # 是否开启Burst（性能突发）。取值范围：
        # 
        # - true：是。
        # - false：否。
        self.bursting_enabled = bursting_enabled  # type: bool
        # Specifies whether to delete the automatic snapshots of the disk when the disk is released. This parameter is empty by default, which indicates that the current value remains unchanged.
        self.delete_auto_snapshot = delete_auto_snapshot  # type: bool
        # Specifies whether to release the disk along with its associated instance. This parameter is empty by default, which indicates that the current value remains unchanged.
        # 
        # An error is returned if you set this parameter to false in the following cases:
        # 
        # *   Category is set to ephemeral.
        # *   Category is set to cloud and Portable is set to false.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of the disk. It must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description  # type: str
        # The ID of the disk.
        # 
        # >  You can specify `DiskId` or `DiskIds.N`, but you cannot specify both of them.
        self.disk_id = disk_id  # type: str
        # 待修改明细的多个磁盘ID。N的取值范围为0 ~ 100。
        # > `DiskId`和`DiskIds.N`两个参数不能同时被调用，请您根据需求任选其一传值。
        self.disk_ids = disk_ids  # type: list[str]
        # The name of the disk. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # Specifies whether to enable the automatic snapshot policy feature for the disk.
        # 
        # *   true: enables the automatic snapshot policy feature for the disk.
        # *   false: disables the automatic snapshot policy feature for the disk.
        # 
        # This parameter is empty by default, which indicates that the current value remains unchanged.
        # 
        # >  By default, the automatic snapshot policy feature is enabled for created disks. You need only to apply an automatic snapshot policy to a disk before you can use the policy.
        self.enable_auto_snapshot = enable_auto_snapshot  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the disk. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.delete_auto_snapshot is not None:
            result['DeleteAutoSnapshot'] = self.delete_auto_snapshot
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.enable_auto_snapshot is not None:
            result['EnableAutoSnapshot'] = self.enable_auto_snapshot
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('DeleteAutoSnapshot') is not None:
            self.delete_auto_snapshot = m.get('DeleteAutoSnapshot')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('EnableAutoSnapshot') is not None:
            self.enable_auto_snapshot = m.get('EnableAutoSnapshot')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDiskAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDiskAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDiskAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDiskAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDiskAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDiskChargeTypeRequest(TeaModel):
    def __init__(self, auto_pay=None, client_token=None, disk_charge_type=None, disk_ids=None, instance_id=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable automatic payment. Default value: true. Valid values:
        # 
        # *   true: Automatic payment is enabled. Make sure that you have sufficient balance in your account. Otherwise, your order becomes invalid and must be canceled.
        # *   false: An order is generated but no payment is made. If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ECS console to pay for the order.
        self.auto_pay = auto_pay  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value must contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The new billing method of the disk. Default value: PrePaid. Valid values:
        # 
        # *   PrePaid: changes the billing method from pay-as-you-go to subscription.
        # *   PostPaid: changes the billing method from subscription to pay-as-you-go.
        self.disk_charge_type = disk_charge_type  # type: str
        # The list of disk IDs. The value is a JSON array that consists of up to 16 disk IDs. Separate multiple disk IDs with commas (,).
        self.disk_ids = disk_ids  # type: str
        # The ID of the instance to which the disk is attached.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        # 资源主账号的ID，亦即UID。
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # 资源主账号的账号名称。
        self.resource_owner_account = resource_owner_account  # type: str
        # RAM用户的虚拟账号ID。
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskChargeTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.disk_charge_type is not None:
            result['DiskChargeType'] = self.disk_charge_type
        if self.disk_ids is not None:
            result['DiskIds'] = self.disk_ids
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DiskChargeType') is not None:
            self.disk_charge_type = m.get('DiskChargeType')
        if m.get('DiskIds') is not None:
            self.disk_ids = m.get('DiskIds')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDiskChargeTypeResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the generated order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskChargeTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDiskChargeTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDiskChargeTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDiskChargeTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDiskChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDiskSpecRequest(TeaModel):
    def __init__(self, disk_category=None, disk_id=None, dry_run=None, owner_account=None, owner_id=None,
                 performance_level=None, provisioned_iops=None, resource_owner_account=None, resource_owner_id=None):
        # The new category of the disk. Valid values:
        # 
        # *   cloud_essd: ESSD
        # *   cloud_ssd: standard SSD
        # *   cloud_efficiency: ultra disk
        # 
        # This parameter is empty by default, which indicates that the disk category is not changed.
        # 
        # >  The preceding values are listed in descending order of disk performance. The disk cannot be downgraded if it is a subscription disk.
        self.disk_category = disk_category  # type: str
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include the required parameters, request format, service limits, and available ECS resources. If the check fails, the corresponding error message is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2xx HTTP status code is returned and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The new performance level of the ESSD. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # Default value: PL1.
        self.performance_level = performance_level  # type: str
        # 是否修改ESSD AutoPL云盘预配置读写IOPS。取值范围：0~min{50000, 1000*容量-基准性能}。
        # 
        # 基准性能=min{1,800+50*容量, 50,000}
        # 
        # > 当DiskCategory取值为cloud_auto时才支持设置该参数。更多信息，请参见[ESSD AutoPL云盘](~~368372~~)和[修改ESSD AutoPL云盘预配置信息](~~413275~~)。
        self.provisioned_iops = provisioned_iops  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_category is not None:
            result['DiskCategory'] = self.disk_category
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskCategory') is not None:
            self.disk_category = m.get('DiskCategory')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyDiskSpecResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None, task_id=None):
        # The ID of the order.
        # 
        # >  This parameter is returned only when the category of a subscription disk or the performance level of a subscription ESSD is modified.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The task ID of changing the disk category.
        # 
        # >  If you only modify the performance level of an ESSD, this parameter is not returned.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class ModifyDiskSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDiskSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDiskSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDiskSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEipAddressAttributeRequest(TeaModel):
    def __init__(self, allocation_id=None, bandwidth=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.allocation_id = allocation_id  # type: str
        self.bandwidth = bandwidth  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEipAddressAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyEipAddressAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEipAddressAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEipAddressAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyEipAddressAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyEipAddressAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEipAddressAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyElasticityAssuranceRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None, name=None):
        # The ID of the elasticity assurance.
        self.id = id  # type: str
        # The name of the elasticity assurance. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with http:// or https://. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyElasticityAssuranceRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class ModifyElasticityAssuranceRequest(TeaModel):
    def __init__(self, private_pool_options=None, description=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: ModifyElasticityAssuranceRequestPrivatePoolOptions
        # The description of the elasticity assurance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the elasticity assurance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(ModifyElasticityAssuranceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = ModifyElasticityAssuranceRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyElasticityAssuranceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyElasticityAssuranceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyElasticityAssuranceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyElasticityAssuranceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyElasticityAssuranceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyElasticityAssuranceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyForwardEntryRequest(TeaModel):
    def __init__(self, external_ip=None, external_port=None, forward_entry_id=None, forward_table_id=None,
                 internal_ip=None, internal_port=None, ip_protocol=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.external_ip = external_ip  # type: str
        self.external_port = external_port  # type: str
        self.forward_entry_id = forward_entry_id  # type: str
        self.forward_table_id = forward_table_id  # type: str
        self.internal_ip = internal_ip  # type: str
        self.internal_port = internal_port  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyForwardEntryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_ip is not None:
            result['ExternalIp'] = self.external_ip
        if self.external_port is not None:
            result['ExternalPort'] = self.external_port
        if self.forward_entry_id is not None:
            result['ForwardEntryId'] = self.forward_entry_id
        if self.forward_table_id is not None:
            result['ForwardTableId'] = self.forward_table_id
        if self.internal_ip is not None:
            result['InternalIp'] = self.internal_ip
        if self.internal_port is not None:
            result['InternalPort'] = self.internal_port
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExternalIp') is not None:
            self.external_ip = m.get('ExternalIp')
        if m.get('ExternalPort') is not None:
            self.external_port = m.get('ExternalPort')
        if m.get('ForwardEntryId') is not None:
            self.forward_entry_id = m.get('ForwardEntryId')
        if m.get('ForwardTableId') is not None:
            self.forward_table_id = m.get('ForwardTableId')
        if m.get('InternalIp') is not None:
            self.internal_ip = m.get('InternalIp')
        if m.get('InternalPort') is not None:
            self.internal_port = m.get('InternalPort')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyForwardEntryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyForwardEntryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyForwardEntryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyForwardEntryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyForwardEntryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyForwardEntryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHaVipAttributeRequest(TeaModel):
    def __init__(self, client_token=None, description=None, ha_vip_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.ha_vip_id = ha_vip_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHaVipAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyHaVipAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHaVipAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyHaVipAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHaVipAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHaVipAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHaVipAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHpcClusterAttributeRequest(TeaModel):
    def __init__(self, client_token=None, description=None, hpc_cluster_id=None, name=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The **ClientToken** value must contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the HPC cluster. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The ID of the HPC cluster.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # The name of the HPC cluster. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with http:// or https://. It can contain letters, digits, underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the HPC cluster. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHpcClusterAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyHpcClusterAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHpcClusterAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyHpcClusterAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHpcClusterAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHpcClusterAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHpcClusterAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageAttributeRequestFeatures(TeaModel):
    def __init__(self, nvme_support=None):
        # Specifies whether to support the Non-Volatile Memory Express (NVMe) protocol. Valid values:
        # 
        # *   supported: The custom image supports the NVMe protocol. Instances created from this image also support the NVMe protocol.
        # *   unsupported: The custom image does not support the NVMe protocol. Instances created from this image do not support the NVMe protocol.
        self.nvme_support = nvme_support  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageAttributeRequestFeatures, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.nvme_support is not None:
            result['NvmeSupport'] = self.nvme_support
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NvmeSupport') is not None:
            self.nvme_support = m.get('NvmeSupport')
        return self


class ModifyImageAttributeRequest(TeaModel):
    def __init__(self, boot_mode=None, description=None, features=None, image_family=None, image_id=None,
                 image_name=None, license_type=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, status=None):
        # The new boot mode of the custom image. Valid values:
        # 
        # *   BIOS
        # *   UEFI
        # 
        # >  You must know which boot modes the specified image supports. When you use this parameter to change the boot mode of the image, specify a boot mode supported by the image to ensure that instances which use this image can start normally.
        self.boot_mode = boot_mode  # type: str
        # The new description of the custom image. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default, which indicates that the original description is retained.
        self.description = description  # type: str
        # The attributes of the custom image.
        self.features = features  # type: ModifyImageAttributeRequestFeatures
        # The new name of the image family. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with acs: or aliyun. It cannot contain http:// or https://. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.image_family = image_family  # type: str
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # The new name of the custom image. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with acs: or aliyun. It cannot contain http:// or https://. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default, which indicates that the original name is retained.
        self.image_name = image_name  # type: str
        # The type of the license to use to activate the operating system after the source image is imported. Valid values:
        # 
        # *   Auto: ECS checks the operating system of the source image and allocates a license to the operating system. ECS first checks whether the operating system distribution specified by `Platform` has a license allocated through an official Alibaba Cloud channel. If yes, the allocated license is used. If not, the license that comes with the source operating system is used.
        # *   Aliyun: The license allocated through an official Alibaba Cloud channel is used for the operating system distribution specified by `Platform`.
        # *   BYOL: The license that comes with the source operating system is used. In this case, make sure that your license key can be used in Alibaba Cloud.
        # 
        # Default value: Auto.
        self.license_type = license_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The new state of the custom image. Valid values:
        # 
        # *   Deprecated: puts the image into the Deprecated state. If the custom image is shared, you must unshare it before you can put it into the Deprecated state. Images in the Deprecated state cannot be shared or copied, but can be used to create instances or replace system disks.
        # *   Available: puts the image into the Available state. You can restore an image from the Deprecated state to the Available state.
        # 
        # >  If you want to roll back a custom image in the image family to a previous version, you can put the latest available custom image into the Deprecated state. An instance family cannot be used to create instances if no custom images are in the Available state within the instance family. Proceed with caution if only a single custom image is in the Available state within the image family.
        self.status = status  # type: str

    def validate(self):
        if self.features:
            self.features.validate()

    def to_map(self):
        _map = super(ModifyImageAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.boot_mode is not None:
            result['BootMode'] = self.boot_mode
        if self.description is not None:
            result['Description'] = self.description
        if self.features is not None:
            result['Features'] = self.features.to_map()
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.license_type is not None:
            result['LicenseType'] = self.license_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BootMode') is not None:
            self.boot_mode = m.get('BootMode')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Features') is not None:
            temp_model = ModifyImageAttributeRequestFeatures()
            self.features = temp_model.from_map(m['Features'])
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('LicenseType') is not None:
            self.license_type = m.get('LicenseType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyImageAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyImageAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyImageAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageShareGroupPermissionRequest(TeaModel):
    def __init__(self, add_group=None, remove_group=None, image_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.add_group = add_group  # type: list[str]
        self.remove_group = remove_group  # type: list[str]
        self.image_id = image_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageShareGroupPermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_group is not None:
            result['AddGroup'] = self.add_group
        if self.remove_group is not None:
            result['RemoveGroup'] = self.remove_group
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddGroup') is not None:
            self.add_group = m.get('AddGroup')
        if m.get('RemoveGroup') is not None:
            self.remove_group = m.get('RemoveGroup')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyImageShareGroupPermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageShareGroupPermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageShareGroupPermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyImageShareGroupPermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyImageShareGroupPermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageShareGroupPermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageSharePermissionRequest(TeaModel):
    def __init__(self, add_account=None, image_id=None, is_public=None, launch_permission=None, owner_account=None,
                 owner_id=None, region_id=None, remove_account=None, resource_owner_account=None, resource_owner_id=None):
        self.add_account = add_account  # type: list[str]
        # The ID of the custom image.
        self.image_id = image_id  # type: str
        # Specifies whether to publish the specified custom image as a community image. Valid values:
        # 
        # *   true: publishes the image as a community image. When the image is published, it enters the public state
        # *   false: unpublishes the community image. When the image is unpublished, it enters the private state.
        # 
        # >  If the parameter value is set to `true`, other optional parameters are not allowed to be specified.
        self.is_public = is_public  # type: bool
        self.launch_permission = launch_permission  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the custom image. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.remove_account = remove_account  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageSharePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_account is not None:
            result['AddAccount'] = self.add_account
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.is_public is not None:
            result['IsPublic'] = self.is_public
        if self.launch_permission is not None:
            result['LaunchPermission'] = self.launch_permission
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_account is not None:
            result['RemoveAccount'] = self.remove_account
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddAccount') is not None:
            self.add_account = m.get('AddAccount')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('IsPublic') is not None:
            self.is_public = m.get('IsPublic')
        if m.get('LaunchPermission') is not None:
            self.launch_permission = m.get('LaunchPermission')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveAccount') is not None:
            self.remove_account = m.get('RemoveAccount')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyImageSharePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageSharePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageSharePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyImageSharePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyImageSharePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageSharePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None, match_criteria=None):
        # The ID of the private pool. Set the value to the ID of the elasticity assurance or capacity reservation that generates the private pool.
        # 
        # *   This parameter is required when `PrivatePoolOptions.MatchCriteria` is set to `Target`.
        # *   This parameter must be empty when `PrivatePoolOptions.MatchCriteria` is set to `Open` or `None`.
        self.id = id  # type: str
        # The match mode of the private pool. Valid values:
        # 
        # *   Open: open private pool The system matches the instance with open private pools.
        # *   Target: specified private pool. You must use `PrivatePoolOptions.Id` to specify the ID of a private pool.
        # *   None: no private pool. The instance starts normally without using private pools.
        self.match_criteria = match_criteria  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        return self


class ModifyInstanceAttachmentAttributesRequest(TeaModel):
    def __init__(self, private_pool_options=None, instance_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions
        # The ID of the instance for which you want to modify the attributes of the private pool.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the private pool. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(ModifyInstanceAttachmentAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = ModifyInstanceAttachmentAttributesRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceAttachmentAttributesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAttachmentAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAttachmentAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceAttachmentAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceAttachmentAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAttachmentAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAttributeRequestRemoteConnectionOptions(TeaModel):
    def __init__(self, password=None, type=None):
        # > This parameter is in invitational preview and unavailable for general users.
        self.password = password  # type: str
        # > This parameter is in invitational preview and unavailable for general users.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAttributeRequestRemoteConnectionOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.password is not None:
            result['Password'] = self.password
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyInstanceAttributeRequest(TeaModel):
    def __init__(self, credit_specification=None, deletion_protection=None, description=None, host_name=None,
                 instance_id=None, instance_name=None, network_interface_queue_number=None, owner_account=None, owner_id=None,
                 password=None, recyclable=None, remote_connection_options=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_ids=None, user_data=None):
        # The performance mode of the burstable instance. Valid values:
        # 
        # *   Standard: standard mode
        # *   Unlimited: unlimited mode
        # 
        # For more information about the performance modes of burstable instances, see [Burstable instances](~~59977~~).
        self.credit_specification = credit_specification  # type: str
        # The release protection attribute of the instance. This parameter specifies whether you can use the ECS console or call the [DeleteInstance](~~25507~~) operation to release the instance.
        # 
        # > This parameter is applicable to only pay-as-you-go instances. It can protect instances against manual releases, but not against automatic releases.
        self.deletion_protection = deletion_protection  # type: bool
        # The description of the instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The hostname of the instance. Take note of the following items:
        # 
        # *   When you modify the hostname of an instance, the instance must not be in the Creating (Pending) or Starting (Starting) state. Otherwise, the new hostname and the configurations in `/etc/hosts` cannot take effect. You can call the [DescribeInstances](~~25506~~) operation to query the state of the instance.
        # *   After the hostname is modified, you must call the [RebootInstance](~~25502~~) operation for the new hostname to take effect.
        # 
        # The following limits apply to the hostnames of instances that run different operating systems:
        # 
        # *   For Windows Server, the hostname must be 2 to 15 characters in length and can contain letters, digits, and hyphens (-). It cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
        # *   For other operating systems such as Linux, the hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-). The hostname cannot contain consecutive periods (.) or hyphens (-). It cannot start or end with a period (.) or a hyphen (-).
        self.host_name = host_name  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.instance_name = instance_name  # type: str
        # The number of queues supported by the primary ENI.
        self.network_interface_queue_number = network_interface_queue_number  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The password of the instance. The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        #     ()`~!@#$%^&*-_+=|{}[]:;\"<>,.?/\
        # 
        # The password of a Windows instance cannot start with a forward slash (/).
        # 
        # > If the `Password` parameter is specified, we recommend that you send requests over HTTPS to prevent password leaks.
        self.password = password  # type: str
        # > This parameter is in invitational preview and unavailable for general users.
        self.recyclable = recyclable  # type: bool
        # > This parameter is in invitational preview and unavailable for general users.
        self.remote_connection_options = remote_connection_options  # type: ModifyInstanceAttributeRequestRemoteConnectionOptions
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of replacement security groups.
        # 
        # *   All security group IDs must be unique.
        # *   The instance is moved from the current security groups to the replacement security groups. If you want the instance to remain in the current security groups, you must add the IDs of the current security groups to the list.
        # *   You can move the instance to security groups of a different type. However, the list cannot contain the IDs of both basic and advanced security groups.
        # *   The specified security group and instance must belong to the same virtual private cloud (VPC).
        # *   The valid values of N are based on the maximum number of security groups to which the instance can belong. For more information, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # *   New security groups become valid for corresponding instances after a short latency.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The user data of the instance. User data must be encoded in Base64.
        # 
        # The size of the user data must be no greater than 16 KB before it is encoded in Base64. We recommend that you do not pass in confidential information such as passwords and private keys in the plaintext format. If you must pass in confidential information, we recommend that you encrypt and Base64-encode the information before you pass it in. Then you can decode and decrypt the information in the same way within the instance.
        self.user_data = user_data  # type: str

    def validate(self):
        if self.remote_connection_options:
            self.remote_connection_options.validate()

    def to_map(self):
        _map = super(ModifyInstanceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.description is not None:
            result['Description'] = self.description
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.network_interface_queue_number is not None:
            result['NetworkInterfaceQueueNumber'] = self.network_interface_queue_number
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.recyclable is not None:
            result['Recyclable'] = self.recyclable
        if self.remote_connection_options is not None:
            result['RemoteConnectionOptions'] = self.remote_connection_options.to_map()
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.user_data is not None:
            result['UserData'] = self.user_data
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('NetworkInterfaceQueueNumber') is not None:
            self.network_interface_queue_number = m.get('NetworkInterfaceQueueNumber')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('Recyclable') is not None:
            self.recyclable = m.get('Recyclable')
        if m.get('RemoteConnectionOptions') is not None:
            temp_model = ModifyInstanceAttributeRequestRemoteConnectionOptions()
            self.remote_connection_options = temp_model.from_map(m['RemoteConnectionOptions'])
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        return self


class ModifyInstanceAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAutoReleaseTimeRequest(TeaModel):
    def __init__(self, auto_release_time=None, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The time scheduled for the instance to be automatically released. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # *   If the value of the field `ss` is not `00`, the field is automatically set to the start time of the current minute (`mm`).
        # *   The release time must be at least 30 minutes later than the current time.
        # *   The release time must be at most three years from the current time.
        # 
        # If `AutoReleaseTime` is not specified, the automatic release feature is disabled and the ECS instance will not be automatically released.
        self.auto_release_time = auto_release_time  # type: str
        # The ID of the ECS instance to be automatically released.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAutoReleaseTimeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceAutoReleaseTimeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAutoReleaseTimeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAutoReleaseTimeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceAutoReleaseTimeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceAutoReleaseTimeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAutoReleaseTimeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(self, auto_renew=None, duration=None, instance_id=None, owner_account=None, owner_id=None,
                 period_unit=None, region_id=None, renewal_status=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable auto-renewal for the instance.
        # 
        # Default value: false.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal period for the instance.
        # 
        # *   Valid values of `Duration` when `PeriodUnit` is set to `Year` (year): 1, 2, 3, 4, and 5.
        # *   Valid values of `Duration` when `PeriodUnit` is set to `Month` (month): 1, 2, 3, 6, 12, 24, 36, 48, and 60.
        # *   Valid values of `Duration` when `PeriodUnit` is set to `Week` (week): 1, 2, 3, and 4.
        self.duration = duration  # type: int
        # The ID of the instance. You can specify IDs of up to 100 subscription instances. Separate the instance IDs with commas (,).
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The unit of the renewal period (`Duration`). Default value: Month. Valid values:
        # 
        # *   Week
        # *   Month
        # *   Year
        self.period_unit = period_unit  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The auto-renewal state of the instance. Valid values:
        # 
        # *   AutoRenewal: Auto-renewal is enabled for the instance.
        # *   Normal: Auto-renewal is disabled for the instance.
        # *   NotRenewal: The instance is not renewed. The system no longer sends an expiration notification. Notifications for renewal are sent three days before the expiration time of the instance. You can change the value of this parameter from NotRenewal to `Normal` for an instance, and then manually renew the instance. Alternatively, you can set the RenewalStatus parameter to AutoRenewal.
        # 
        # > `RenewalStatus` takes precedence over `AutoRenew`. If you do not specify `RenewalStatus`, the `AutoRenew` parameter is used by default.
        self.renewal_status = renewal_status  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAutoRenewAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.duration is not None:
            result['Duration'] = self.duration
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('Duration') is not None:
            self.duration = m.get('Duration')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceAutoRenewAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceAutoRenewAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceAutoRenewAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceChargeTypeRequest(TeaModel):
    def __init__(self, auto_pay=None, client_token=None, dry_run=None, include_data_disks=None,
                 instance_charge_type=None, instance_ids=None, is_detail_fee=None, owner_account=None, owner_id=None, period=None,
                 period_unit=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable automatic payment. Valid values:
        # 
        # *   true: enables automatic payment. Make sure that you have a sufficient balance in your account. Otherwise, your order becomes invalid and is canceled.
        # *   false: An order is generated but no payment is made.
        # 
        # Default value: true.
        # 
        # >  If your account balance is insufficient, you can set the AutoPay parameter to false to generate an unpaid order. Then, you can log on to the ECS console to pay for the order.
        self.auto_pay = auto_pay  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether RAM users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to change the billing method of all data disks attached to the instance from pay-as-you-go to subscription.
        # 
        # Default value: false.
        self.include_data_disks = include_data_disks  # type: bool
        # The new billing method. Valid values:
        # 
        # *   PrePaid: the subscription billing method
        # *   PostPaid: the pay-as-you-go billing method
        # 
        # Default value: PrePaid.
        self.instance_charge_type = instance_charge_type  # type: str
        # The IDs of instances. The value can be a JSON array that consists of up to 20 instance IDs. Separate multiple instance IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        # Specifies whether to return cost details of the order when the billing method is changed from subscription to pay-as-you-go.
        # 
        # Default value: false.
        self.is_detail_fee = is_detail_fee  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The renewal period of the subscription instance. If the instance is hosted on a dedicated host, the renewal period of the instance cannot exceed the subscription duration of the dedicated host. Valid values:
        # 
        # Valid values when the `PeriodUnit` parameter is set to Month: `1, 2, 3, 4, 5, 6, 7, 8, 9, and 12`.
        self.period = period  # type: int
        # The unit of the renewal period (`Period`). Valid values:
        # 
        # Month
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The ID of the region in which the instance is located. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceChargeTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.include_data_disks is not None:
            result['IncludeDataDisks'] = self.include_data_disks
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.is_detail_fee is not None:
            result['IsDetailFee'] = self.is_detail_fee
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('IncludeDataDisks') is not None:
            self.include_data_disks = m.get('IncludeDataDisks')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('IsDetailFee') is not None:
            self.is_detail_fee = m.get('IsDetailFee')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance(TeaModel):
    def __init__(self, currency=None, fee=None, instance_id=None):
        # The unit of currency for the bill.
        # 
        # Alibaba Cloud China site (aliyun.com): CNY.
        # 
        # Alibaba Cloud International site (alibabacloud.com): USD.
        self.currency = currency  # type: str
        # The cost value.
        self.fee = fee  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.currency is not None:
            result['Currency'] = self.currency
        if self.fee is not None:
            result['Fee'] = self.fee
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Currency') is not None:
            self.currency = m.get('Currency')
        if m.get('Fee') is not None:
            self.fee = m.get('Fee')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        return self


class ModifyInstanceChargeTypeResponseBodyFeeOfInstances(TeaModel):
    def __init__(self, fee_of_instance=None):
        self.fee_of_instance = fee_of_instance  # type: list[ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance]

    def validate(self):
        if self.fee_of_instance:
            for k in self.fee_of_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyInstanceChargeTypeResponseBodyFeeOfInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FeeOfInstance'] = []
        if self.fee_of_instance is not None:
            for k in self.fee_of_instance:
                result['FeeOfInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fee_of_instance = []
        if m.get('FeeOfInstance') is not None:
            for k in m.get('FeeOfInstance'):
                temp_model = ModifyInstanceChargeTypeResponseBodyFeeOfInstancesFeeOfInstance()
                self.fee_of_instance.append(temp_model.from_map(k))
        return self


class ModifyInstanceChargeTypeResponseBody(TeaModel):
    def __init__(self, fee_of_instances=None, order_id=None, request_id=None):
        # Details about the charges for the order.
        self.fee_of_instances = fee_of_instances  # type: ModifyInstanceChargeTypeResponseBodyFeeOfInstances
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.fee_of_instances:
            self.fee_of_instances.validate()

    def to_map(self):
        _map = super(ModifyInstanceChargeTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fee_of_instances is not None:
            result['FeeOfInstances'] = self.fee_of_instances.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FeeOfInstances') is not None:
            temp_model = ModifyInstanceChargeTypeResponseBodyFeeOfInstances()
            self.fee_of_instances = temp_model.from_map(m['FeeOfInstances'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceChargeTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceChargeTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceChargeTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceDeploymentRequest(TeaModel):
    def __init__(self, affinity=None, dedicated_host_cluster_id=None, dedicated_host_id=None,
                 deployment_set_group_no=None, deployment_set_id=None, force=None, instance_id=None, instance_type=None,
                 migration_type=None, owner_account=None, owner_id=None, region_id=None, remove_from_deployment_set=None,
                 resource_owner_account=None, resource_owner_id=None, tenancy=None):
        # Specifies whether to associate the instance with a dedicated host. Valid values:
        # 
        # *   host: associates the instance with a dedicated host. When you start a stopped instance in economical mode, the instance remains on its original dedicated host.
        # *   default: does not associate the instance with a dedicated host. When you start a stopped instance in economical mode, the instance can be automatically deployed to another dedicated host in the automatic deployment resource pool if resources of the original dedicated host are insufficient.
        # 
        # If you want to migrate the instance from a shared host to a dedicated host, use the default value. Default value: default.
        self.affinity = affinity  # type: str
        # The ID of the dedicated host cluster.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str
        # The ID of the destination dedicated host. You can call the [DescribeDedicatedHosts](~~134242~~) operation to query the most recent list of dedicated hosts.
        # 
        # When you migrate an instance from a shared host to a dedicated host or between dedicated hosts, take note of the following items:
        # 
        # *   To migrate the instance to a specific dedicated host, specify this parameter.
        # *   To migrate the instance to a system-selected dedicated host, leave this parameter empty and set `Tenancy` to host.
        # 
        # For information about the automatic deployment feature, see [Features of dedicated hosts](~~118938~~).
        self.dedicated_host_id = dedicated_host_id  # type: str
        # The number of the deployment set group in which to deploy the instance in the destination deployment set. This parameter is valid only when the destination deployment set uses the high availability group strategy (AvailabilityGroup). Valid values: 1 to 7.
        # 
        # > If you call this operation to deploy an instance to a deployment set that uses the high availability group strategy (`AvailablilityGroup`) and leave this parameter empty, the system evenly distributes instances among the deployment set groups in the deployment set. If you call this operation to change the deployment set of an instance and specify the current deployment set of the instance as the destination deployment set, the system evenly distributes instances again among the deployment set groups in the deployment set.
        self.deployment_set_group_no = deployment_set_group_no  # type: int
        # The ID of the destination deployment set.
        # 
        # This parameter is required when you add an instance to a deployment set or change the deployment set of an instance.
        # 
        # > You cannot change the deployment set when you modify dedicated host configurations, including the `Tenancy`, `Affinity`, and `DedicatedHostId` parameters.
        self.deployment_set_id = deployment_set_id  # type: str
        # Specifies whether to forcefully change the host of the instance when the deployment set of the instance is changed. Valid values:
        # 
        # *   true: forcefully changes the host of the instance when the deployment set of the instance is changed. Hosts can be forcefully changed only for instances in the Running (Running) or Stopped (Stopped) state. The instances that are in the Stopped (Stopped) state do not include pay-as-you-go instances that are stopped in economical mode.
        # 
        #     **\
        # 
        #     **Note**If the specified instance has local disks attached, the local disks are forcefully changed when the host of the instance is forcefully changed. This may cause data loss in the local disks. Proceed with caution.
        # 
        # *   false: does not forcefully change the host of the instance when the deployment set of the instance is changed. You can add the instance to a deployment set only when the instance remains on the current host. When the Force parameter is set to false, the deployment set may fail to be changed.
        # 
        # Default value: false.
        self.force = force  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The instance type to which to change the instance. You can call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent list of instance types.
        # 
        # You can change the instance type of an instance when you migrate the instance to a dedicated host. The new instance type must match the type of the specified dedicated host. For more information, see [Dedicated host types](~~68564~~).
        # 
        # *   If you specify this parameter, you must also specify the `DedicatedHostId` parameter.
        # *   You cannot change the instance type of an instance if you use the automatic deployment feature to migrate the instance.
        self.instance_type = instance_type  # type: str
        # Specifies whether to stop the instance before it is migrated to the destination dedicated host. Valid values:
        # 
        # *   reboot: stops the instance before it is migrated.
        # *   live: migrates the instance without stopping it. If you set the MigrationType parameter to live, you must specify the DedicatedHostId parameter. In this case, you cannot change the instance type of the instance when the instance is migrated.
        # 
        # Default value: reboot.
        self.migration_type = migration_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # Specifies whether to remove the selected instance from the selected deployment set. Valid values:
        # 
        # *   true: removes the instance from the deployment set.
        # *   false: does not remove the instance from the deployment set.
        # 
        # Default value: false.
        # 
        # > If you set this parameter to true, you must specify the InstanceId and DeploymentSetId parameters and make sure that the specified instance belongs to the specified deployment set.
        self.remove_from_deployment_set = remove_from_deployment_set  # type: bool
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to deploy the instance on a dedicated host. Set the value to host to deploy the instance on a dedicated host.
        self.tenancy = tenancy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceDeploymentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.affinity is not None:
            result['Affinity'] = self.affinity
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.deployment_set_group_no is not None:
            result['DeploymentSetGroupNo'] = self.deployment_set_group_no
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.force is not None:
            result['Force'] = self.force
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.migration_type is not None:
            result['MigrationType'] = self.migration_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_from_deployment_set is not None:
            result['RemoveFromDeploymentSet'] = self.remove_from_deployment_set
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.tenancy is not None:
            result['Tenancy'] = self.tenancy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Affinity') is not None:
            self.affinity = m.get('Affinity')
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DeploymentSetGroupNo') is not None:
            self.deployment_set_group_no = m.get('DeploymentSetGroupNo')
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MigrationType') is not None:
            self.migration_type = m.get('MigrationType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveFromDeploymentSet') is not None:
            self.remove_from_deployment_set = m.get('RemoveFromDeploymentSet')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Tenancy') is not None:
            self.tenancy = m.get('Tenancy')
        return self


class ModifyInstanceDeploymentResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceDeploymentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceDeploymentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceDeploymentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceDeploymentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceDeploymentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow(TeaModel):
    def __init__(self, end_time=None, start_time=None):
        # The end time of maintenance window.
        # 
        # The time must be on the hour at exactly 0 minute and 0 second. The StartTime and EndTime parameters must be specified at the same time. The Endtime value must be 1 to 23 hours later than the StartTime value. Specify the time in the `HH:mm:ss` format.
        # 
        # The time must be in UTC+8.
        self.end_time = end_time  # type: str
        # The start time of maintenance window.
        # 
        # The time must be on the hour at exactly 0 minute and 0 second. The StartTime and EndTime parameters must be specified at the same time. The Endtime value must be 1 to 23 hours later than the StartTime value. Specify the time in the `HH:mm:ss` format.
        # 
        # The time must be in UTC+8.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifyInstanceMaintenanceAttributesRequest(TeaModel):
    def __init__(self, action_on_maintenance=None, instance_id=None, maintenance_window=None,
                 notify_on_maintenance=None, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        # The maintenance action. Valid values:
        # 
        # *   Stop: stops the instance.
        # *   AutoRecover: automatically recovers the instance.
        # *   AutoRedeploy: fails the instance over, which may cause damage to the data disks attached to the instance.
        self.action_on_maintenance = action_on_maintenance  # type: str
        # The IDs of the instances. You can specify up to 100 IDs.
        self.instance_id = instance_id  # type: list[str]
        # The list of maintenance windows.
        self.maintenance_window = maintenance_window  # type: list[ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow]
        # Specifies whether to send an event notification before instance shutdown. Valid values:
        # 
        # *   True: sends an event notification.
        # *   False: does not send an event notification.
        # 
        # Default value: false.
        self.notify_on_maintenance = notify_on_maintenance  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.maintenance_window:
            for k in self.maintenance_window:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyInstanceMaintenanceAttributesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_on_maintenance is not None:
            result['ActionOnMaintenance'] = self.action_on_maintenance
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        result['MaintenanceWindow'] = []
        if self.maintenance_window is not None:
            for k in self.maintenance_window:
                result['MaintenanceWindow'].append(k.to_map() if k else None)
        if self.notify_on_maintenance is not None:
            result['NotifyOnMaintenance'] = self.notify_on_maintenance
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionOnMaintenance') is not None:
            self.action_on_maintenance = m.get('ActionOnMaintenance')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        self.maintenance_window = []
        if m.get('MaintenanceWindow') is not None:
            for k in m.get('MaintenanceWindow'):
                temp_model = ModifyInstanceMaintenanceAttributesRequestMaintenanceWindow()
                self.maintenance_window.append(temp_model.from_map(k))
        if m.get('NotifyOnMaintenance') is not None:
            self.notify_on_maintenance = m.get('NotifyOnMaintenance')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceMaintenanceAttributesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceMaintenanceAttributesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceMaintenanceAttributesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceMaintenanceAttributesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceMaintenanceAttributesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceMaintenanceAttributesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceMetadataOptionsRequest(TeaModel):
    def __init__(self, http_endpoint=None, http_put_response_hop_limit=None, http_tokens=None, instance_id=None,
                 instance_metadata_tags=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable the access channel for instance metadata. Valid values:
        # 
        # *   enabled: enables the access channel for instance metadata.
        # *   disabled: disables the access channel for instance metadata.
        # 
        # Default value: enabled.
        # 
        # > For more information about instance metadata, see [Overview of ECS instance metadata](~~49122~~).
        self.http_endpoint = http_endpoint  # type: str
        # > This parameter is in invitational preview and is unavailable to general users.
        self.http_put_response_hop_limit = http_put_response_hop_limit  # type: int
        # Specifies whether to forcefully use the security-enhanced mode (IMDSv2) to access instance metadata. Valid values:
        # 
        # *   optional: does not forcefully use the security-enhanced mode (IMDSv2).
        # *   required: forcefully uses the security-enhanced mode (IMDSv2). After you set this parameter to required, you cannot access instance metadata in normal mode.
        # 
        # Default value: optional.
        # 
        # > For more information about the modes of accessing instance metadata, see [Access mode of instance metadata](~~150575~~).
        self.http_tokens = http_tokens  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.instance_metadata_tags = instance_metadata_tags  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceMetadataOptionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_endpoint is not None:
            result['HttpEndpoint'] = self.http_endpoint
        if self.http_put_response_hop_limit is not None:
            result['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit
        if self.http_tokens is not None:
            result['HttpTokens'] = self.http_tokens
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_metadata_tags is not None:
            result['InstanceMetadataTags'] = self.instance_metadata_tags
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpEndpoint') is not None:
            self.http_endpoint = m.get('HttpEndpoint')
        if m.get('HttpPutResponseHopLimit') is not None:
            self.http_put_response_hop_limit = m.get('HttpPutResponseHopLimit')
        if m.get('HttpTokens') is not None:
            self.http_tokens = m.get('HttpTokens')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceMetadataTags') is not None:
            self.instance_metadata_tags = m.get('InstanceMetadataTags')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceMetadataOptionsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceMetadataOptionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceMetadataOptionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceMetadataOptionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceMetadataOptionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceMetadataOptionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceNetworkSpecRequest(TeaModel):
    def __init__(self, allocate_public_ip=None, auto_pay=None, client_token=None, end_time=None, isp=None,
                 instance_id=None, internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, network_charge_type=None,
                 owner_account=None, owner_id=None, resource_owner_account=None, resource_owner_id=None, start_time=None):
        # Specifies whether to assign a public IP address.
        # 
        # Default value: false.
        self.allocate_public_ip = allocate_public_ip  # type: bool
        # Specifies whether to enable automatic payment. Valid values:
        # 
        # *   true: enables automatic payment. After bandwidth configurations are upgraded, the payment is automatically made. Make sure that you have sufficient balance in your account when you set AutoPay to true. If your account balance is insufficient, your order cannot be paid in the ECS console and becomes invalid. You must cancel the order.
        # *   false: does not enable automatic payment. After bandwidth configurations are upgraded, an order is generated but is not paid. If your account balance is insufficient, you can set AutoPay to false. In this case, when you call the ModifyInstanceNetworkSpec operation, an unpaid order is generated. You can then log on to the [ECS console](https://ecs.console.aliyun.com) to pay for the order.
        # 
        # Default value: true.
        self.auto_pay = auto_pay  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but make sure that it is unique among different requests. The **ClientToken** value can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The end time of the temporary bandwidth upgrade. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddThhZ format. The time must be in UTC and accurate to **hours** (hh).
        # 
        # >  The interval between the end time and the start time of the temporary bandwidth upgrade must be greater than or equal to 3 hours.
        self.end_time = end_time  # type: str
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.isp = isp  # type: str
        # The ID of the instance for which you want to modify bandwidth configurations.
        self.instance_id = instance_id  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of InternetMaxBandwidthIn are 1 to 10, and the default value is 10.
        # *   When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of InternetMaxBandwidthIn are 1 to the `InternetMaxBandwidthOut` value, and the default value is the `InternetMaxBandwidthOut` value.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # >  When the **pay-by-traffic** billing method is used, the maximum inbound and outbound bandwidths are both the upper limits of bandwidths instead of guaranteed performance. When demands exceed resource supplies, these maximum bandwidths may be limited. If you want guaranteed bandwidths for your instances, use the **pay-by-bandwidth** billing method.
        self.network_charge_type = network_charge_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start time of the temporary bandwidth upgrade. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddThh:mmZ format. The time must be in UTC and accurate to the **minute** (mm).
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNetworkSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocate_public_ip is not None:
            result['AllocatePublicIp'] = self.allocate_public_ip
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.isp is not None:
            result['ISP'] = self.isp
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.network_charge_type is not None:
            result['NetworkChargeType'] = self.network_charge_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocatePublicIp') is not None:
            self.allocate_public_ip = m.get('AllocatePublicIp')
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('ISP') is not None:
            self.isp = m.get('ISP')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('NetworkChargeType') is not None:
            self.network_charge_type = m.get('NetworkChargeType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifyInstanceNetworkSpecResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the generated order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceNetworkSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceNetworkSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceNetworkSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceNetworkSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceNetworkSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceSpecRequestSystemDisk(TeaModel):
    def __init__(self, category=None):
        # The new category of the system disk. This parameter is valid only when you upgrade an instance from a retired instance type to an available instance type or when you upgrade a non-I/O optimized instance to an I/O optimized instance. For more information, see [Retired instance types](~~55263~~) and [Instance families](~~25378~~). Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        self.category = category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceSpecRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class ModifyInstanceSpecRequestTemporary(TeaModel):
    def __init__(self, end_time=None, internet_max_bandwidth_out=None, start_time=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.end_time = end_time  # type: str
        # > This parameter is in invitational preview and is unavailable to general users.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # > This parameter is in invitational preview and is unavailable to general users.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceSpecRequestTemporary, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ModifyInstanceSpecRequest(TeaModel):
    def __init__(self, system_disk=None, temporary=None, allow_migrate_across_zone=None, async=None,
                 client_token=None, instance_id=None, instance_type=None, internet_max_bandwidth_in=None,
                 internet_max_bandwidth_out=None, owner_account=None, owner_id=None, resource_owner_account=None, resource_owner_id=None):
        self.system_disk = system_disk  # type: ModifyInstanceSpecRequestSystemDisk
        self.temporary = temporary  # type: ModifyInstanceSpecRequestTemporary
        # Specifies whether to support cross-cluster instance type upgrades.
        # 
        # Default value: false.
        # 
        # When `AllowMigrateAcrossZone` is set to true and you upgrade the instance configurations based on the returned information, take note of the following items:
        # 
        # Instances of the classic network type:
        # 
        # *   For retired instance types, when a non-I/O optimized instance is upgraded to an I/O optimized instance, the private IP address, disk device names, and software license codes of the instance are changed. For more information, see [Retired instance types](~~55263~~). For Linux instances, basic disks (`cloud`) are identified by the prefix **xvd** such as **xvda and xvdb**. Ultra disks (`cloud_efficiency`) and standard SSDs (`cloud_ssd`) are identified by the prefix **vd** such as **vda and vdb**.
        # *   For instance families that are available for purchase, when the instance type of an instance is changed, the private IP address of the instance is also changed. For more information, see [Instance families](~~25378~~).
        # 
        # Instances of the Virtual Private Cloud (VPC) type: For [retired instance types](~~55263~~), when a non-I/O optimized instance is upgraded to an I/O optimized instance, the disk device names and software license codes of the instance are changed. For Linux instances, basic disks (`cloud`) are identified by the prefix **xvd** such as **xvda and xvdb**. Ultra disks (`cloud_efficiency`) and standard SSDs (`cloud_ssd`) are identified by the prefix **vd** such as **vda and vdb**.
        self.allow_migrate_across_zone = allow_migrate_across_zone  # type: bool
        # Specifies whether to submit an asynchronous request.
        # 
        # Default value: false.
        self.async = async  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The new instance type. For more information, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the most recent list of instance types.
        self.instance_type = instance_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of this parameter are 1 to 10 and the default value is 10.
        # *   When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the `InternetMaxBandwidthOut` value and the default value is the `InternetMaxBandwidthOut` value.
        # 
        # > When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidths are used as the upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # > When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidths are used as the upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()
        if self.temporary:
            self.temporary.validate()

    def to_map(self):
        _map = super(ModifyInstanceSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.temporary is not None:
            result['Temporary'] = self.temporary.to_map()
        if self.allow_migrate_across_zone is not None:
            result['AllowMigrateAcrossZone'] = self.allow_migrate_across_zone
        if self.async is not None:
            result['Async'] = self.async
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = ModifyInstanceSpecRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Temporary') is not None:
            temp_model = ModifyInstanceSpecRequestTemporary()
            self.temporary = temp_model.from_map(m['Temporary'])
        if m.get('AllowMigrateAcrossZone') is not None:
            self.allow_migrate_across_zone = m.get('AllowMigrateAcrossZone')
        if m.get('Async') is not None:
            self.async = m.get('Async')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyInstanceSpecResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceVncPasswdRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, vnc_password=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The new VNC password of the instance.
        self.vnc_password = vnc_password  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceVncPasswdRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vnc_password is not None:
            result['VncPassword'] = self.vnc_password
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VncPassword') is not None:
            self.vnc_password = m.get('VncPassword')
        return self


class ModifyInstanceVncPasswdResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceVncPasswdResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceVncPasswdResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceVncPasswdResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceVncPasswdResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceVncPasswdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyInstanceVpcAttributeRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, private_ip_address=None,
                 resource_owner_account=None, resource_owner_id=None, security_group_id=None, v_switch_id=None, vpc_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The new private IP address of the instance.
        # 
        # >  The `PrivateIpAddress` value depends on the `VSwitchId` value. The specified IP address must be within the CIDR block of the specified vSwitch.
        # 
        # By default, if this parameter is not specified, a private IP address is randomly assigned from the CIDR block of the specified vSwitch.
        self.private_ip_address = private_ip_address  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The IDs of security groups to which the instance belongs after the VPC is changed. This parameter is required only when the `VpcId` parameter is specified.
        # 
        # - The specified security groups must be of the same type.
        # - The security group list can contain one or more security groups to which the instance belongs after the modification. The valid values of N depend on the maximum number of security groups to which an instance can belong. For more information, see the "Security group limits" section in [Limits](~~25412~~).
        # - The specified security groups must belong to the VPC specified by the `VpcId` parameter.
        self.security_group_id = security_group_id  # type: list[str]
        # The ID of the vSwitch.
        # 
        # *   If this parameter is set to the ID of the current vSwitch, the vSwitch of the instance remains unchanged.
        # *   If this parameter is set to the ID of a new vSwitch, and the `VpcId` parameter is not specified, the new vSwitch must belong to the same zone and VPC as the original vSwitch.
        # *   If the `VpcId` parameter is specified, the vSwitch specified by this parameter must belong to the VPC specified by the VpcId parameter and must belong to the same zone as the original vSwitch.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the new VPC.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceVpcAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class ModifyInstanceVpcAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyInstanceVpcAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyInstanceVpcAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyInstanceVpcAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyInstanceVpcAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyInstanceVpcAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyLaunchTemplateDefaultVersionRequest(TeaModel):
    def __init__(self, default_version_number=None, launch_template_id=None, launch_template_name=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The default version number of the instance launch template.
        self.default_version_number = default_version_number  # type: long
        # The ID of the launch template. You must set LaunchTemplateId or LaunchTemplateName to specify a launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template. You must set LaunchTemplateId or LaunchTemplateName to specify a launch template.
        self.launch_template_name = launch_template_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the launch template. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLaunchTemplateDefaultVersionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.default_version_number is not None:
            result['DefaultVersionNumber'] = self.default_version_number
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DefaultVersionNumber') is not None:
            self.default_version_number = m.get('DefaultVersionNumber')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyLaunchTemplateDefaultVersionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyLaunchTemplateDefaultVersionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyLaunchTemplateDefaultVersionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyLaunchTemplateDefaultVersionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyLaunchTemplateDefaultVersionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyLaunchTemplateDefaultVersionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyManagedInstanceRequest(TeaModel):
    def __init__(self, instance_id=None, instance_name=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the managed instance.
        self.instance_id = instance_id  # type: str
        # The new name of the managed instance. The name must be 1 to 128 characters in length. It must start with a letter and cannot start with a special character or a digit. The name can contain letters, digits, periods (.), underscores (\_), hyphens (-), and colons (:) and cannot start with `http://` or `https://`.
        self.instance_name = instance_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the managed instance. The following regions are supported: China (Qingdao), China (Beijing), China (Zhangjiakou), China (Hohhot), China (Hangzhou), China (Shanghai), China (Shenzhen), China (Heyuan), and China (Hong Kong).
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyManagedInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyManagedInstanceResponseBodyInstance(TeaModel):
    def __init__(self, instance_id=None, instance_name=None):
        # The ID of the managed instance.
        self.instance_id = instance_id  # type: str
        # The name of the managed instance.
        self.instance_name = instance_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyManagedInstanceResponseBodyInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        return self


class ModifyManagedInstanceResponseBody(TeaModel):
    def __init__(self, instance=None, request_id=None):
        # Details about the managed instance.
        self.instance = instance  # type: ModifyManagedInstanceResponseBodyInstance
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance:
            self.instance.validate()

    def to_map(self):
        _map = super(ModifyManagedInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance is not None:
            result['Instance'] = self.instance.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instance') is not None:
            temp_model = ModifyManagedInstanceResponseBodyInstance()
            self.instance = temp_model.from_map(m['Instance'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyManagedInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyManagedInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyManagedInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyManagedInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNetworkInterfaceAttributeRequest(TeaModel):
    def __init__(self, description=None, network_interface_id=None, network_interface_name=None,
                 owner_account=None, owner_id=None, queue_number=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None):
        # The description of the ENI. The description must be 2 to 255 characters in length and cannot start with http:// or https://.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        # The name of the ENI. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.network_interface_name = network_interface_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The number of queues per ENI. Valid values: 1 to 2048.
        # 
        # *   You can modify the number of queues supported only by the secondary ENI.
        # *   You can modify the number of queues supported by the secondary ENI only when the ENI is in the `Available` state, or the secondary ENI is bound (`InUse`) to an instance that is in the `Stopped` state.
        # *   The number of queues supported by the secondary ENI cannot exceed the maximum number of queues that the instance allows for each ENI. The total number of queues for all ENIs on the instance cannot exceed the queue quota that the instance allows. To obtain information about the maximum number of queues per ENI and the queue quota for an instance type, you can call the [DescribeInstanceTypes](~~25620~~) operation to query the `MaximumQueueNumberPerEni` and `TotalEniQueueQuantity` values.
        self.queue_number = queue_number  # type: int
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query thecurrent list of regions.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The list of security group IDs. You can specify up to 5 security group IDs.
        # 
        # - You can modify only the security groups to which the secondary ENI is added.
        # - After you specify a security group, the secondary ENI is added to the specified security group and removed from the existing security group.
        # 
        # >  After you modify the security group, the modification takes effect after a short delay.
        self.security_group_id = security_group_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkInterfaceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.queue_number is not None:
            result['QueueNumber'] = self.queue_number
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('QueueNumber') is not None:
            self.queue_number = m.get('QueueNumber')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class ModifyNetworkInterfaceAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkInterfaceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNetworkInterfaceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyNetworkInterfaceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyNetworkInterfaceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNetworkInterfaceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPhysicalConnectionAttributeRequest(TeaModel):
    def __init__(self, circuit_code=None, client_token=None, description=None, line_operator=None, name=None,
                 owner_account=None, owner_id=None, peer_location=None, physical_connection_id=None, port_type=None,
                 redundant_physical_connection_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None,
                 bandwidth=None):
        self.circuit_code = circuit_code  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.line_operator = line_operator  # type: str
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.peer_location = peer_location  # type: str
        self.physical_connection_id = physical_connection_id  # type: str
        self.port_type = port_type  # type: str
        self.redundant_physical_connection_id = redundant_physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.bandwidth = bandwidth  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPhysicalConnectionAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.line_operator is not None:
            result['LineOperator'] = self.line_operator
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.peer_location is not None:
            result['PeerLocation'] = self.peer_location
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.port_type is not None:
            result['PortType'] = self.port_type
        if self.redundant_physical_connection_id is not None:
            result['RedundantPhysicalConnectionId'] = self.redundant_physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.bandwidth is not None:
            result['bandwidth'] = self.bandwidth
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LineOperator') is not None:
            self.line_operator = m.get('LineOperator')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeerLocation') is not None:
            self.peer_location = m.get('PeerLocation')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('PortType') is not None:
            self.port_type = m.get('PortType')
        if m.get('RedundantPhysicalConnectionId') is not None:
            self.redundant_physical_connection_id = m.get('RedundantPhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('bandwidth') is not None:
            self.bandwidth = m.get('bandwidth')
        return self


class ModifyPhysicalConnectionAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPhysicalConnectionAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPhysicalConnectionAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPhysicalConnectionAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPhysicalConnectionAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPhysicalConnectionAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPrefixListRequestAddEntry(TeaModel):
    def __init__(self, cidr=None, description=None):
        # The CIDR block of entry N to be added to the prefix list. Valid values of N: 0 to 200.
        # 
        # Take note of the following items when you add the entries:
        # 
        # *   The number of entries in the prefix list cannot be greater than the maximum number of entries allowed for the prefix list. You can call the [DescribePrefixListAttributes](~~205872~~) operation to query the maximum number of entries in a specific prefix list.
        # *   You cannot specify duplicate CIDR blocks.
        # *   The CIDR blocks cannot be the same as the `RemoveEntry.N.Cidr` values.
        self.cidr = cidr  # type: str
        # The description in entry N. The description must be 2 to 32 characters in length and cannot start with `http://` or `https://`. Valid values of N: 0 to 200.
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPrefixListRequestAddEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr is not None:
            result['Cidr'] = self.cidr
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cidr') is not None:
            self.cidr = m.get('Cidr')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class ModifyPrefixListRequestRemoveEntry(TeaModel):
    def __init__(self, cidr=None):
        # The CIDR block of entry N to be deleted from the prefix list. Valid values of N: 0 to 200.
        # 
        # Take note of the following items when you delete the entries:
        # 
        # *   You cannot specify duplicate CIDR blocks.
        # *   The CIDR blocks cannot be the same as the `AddEntry.N.Cidr` values.
        self.cidr = cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPrefixListRequestRemoveEntry, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr is not None:
            result['Cidr'] = self.cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cidr') is not None:
            self.cidr = m.get('Cidr')
        return self


class ModifyPrefixListRequest(TeaModel):
    def __init__(self, add_entry=None, description=None, owner_account=None, owner_id=None, prefix_list_id=None,
                 prefix_list_name=None, region_id=None, remove_entry=None, resource_owner_account=None, resource_owner_id=None):
        # The entries that to be added to the prefix list.
        self.add_entry = add_entry  # type: list[ModifyPrefixListRequestAddEntry]
        # The description of the prefix list. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the prefix list.
        self.prefix_list_id = prefix_list_id  # type: str
        # The name of the prefix list. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://`, `https://`, `com.aliyun`, or `com.alibabacloud`. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
        self.prefix_list_name = prefix_list_name  # type: str
        # The region ID of the prefix list. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The entries that to be deleted from the prefix list.
        self.remove_entry = remove_entry  # type: list[ModifyPrefixListRequestRemoveEntry]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.add_entry:
            for k in self.add_entry:
                if k:
                    k.validate()
        if self.remove_entry:
            for k in self.remove_entry:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyPrefixListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AddEntry'] = []
        if self.add_entry is not None:
            for k in self.add_entry:
                result['AddEntry'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.prefix_list_id is not None:
            result['PrefixListId'] = self.prefix_list_id
        if self.prefix_list_name is not None:
            result['PrefixListName'] = self.prefix_list_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['RemoveEntry'] = []
        if self.remove_entry is not None:
            for k in self.remove_entry:
                result['RemoveEntry'].append(k.to_map() if k else None)
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.add_entry = []
        if m.get('AddEntry') is not None:
            for k in m.get('AddEntry'):
                temp_model = ModifyPrefixListRequestAddEntry()
                self.add_entry.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrefixListId') is not None:
            self.prefix_list_id = m.get('PrefixListId')
        if m.get('PrefixListName') is not None:
            self.prefix_list_name = m.get('PrefixListName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.remove_entry = []
        if m.get('RemoveEntry') is not None:
            for k in m.get('RemoveEntry'):
                temp_model = ModifyPrefixListRequestRemoveEntry()
                self.remove_entry.append(temp_model.from_map(k))
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyPrefixListResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPrefixListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPrefixListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPrefixListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPrefixListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPrefixListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPrepayInstanceSpecRequestSystemDisk(TeaModel):
    def __init__(self, category=None):
        # The new category of the system disk. This parameter is valid only when you upgrade an instance from a retired instance type to an available instance type or upgrade a non-I/O optimized instance to an I/O optimized instance. For more information, see [Retired instance types](~~55263~~) and [Instance families](~~25378~~). Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        self.category = category  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPrepayInstanceSpecRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        return self


class ModifyPrepayInstanceSpecRequest(TeaModel):
    def __init__(self, system_disk=None, auto_pay=None, client_token=None, end_time=None, instance_id=None,
                 instance_type=None, migrate_across_zone=None, operator_type=None, owner_account=None, owner_id=None,
                 reboot_time=None, reboot_when_finished=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None):
        self.system_disk = system_disk  # type: ModifyPrepayInstanceSpecRequestSystemDisk
        # Specifies whether to enable automatic payment when you upgrade the instance type. Valid values:
        # 
        # *   true: enables automatic payment.
        #     > Make sure that your account balance is sufficient. Otherwise, your order becomes invalid. If your account balance is insufficient, you can set the `AutoPay` parameter to `false` to generate an unpaid order. Then, you can log on to the ECS console to pay for the order.
        # 
        # *   false: An order is generated but no payment is made.
        # 
        # Default value: true.
        # 
        # When `OperatorType` is set to `downgrade`, `AutoPay` is ignored.
        self.auto_pay = auto_pay  # type: bool
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The ClientToken value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The end time of the temporary change. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time  # type: str
        # The ID of instance.
        self.instance_id = instance_id  # type: str
        # The new instance type. For information about available instance types, see [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation.
        self.instance_type = instance_type  # type: str
        # Specifies whether to support cross-cluster instance type upgrades.
        # 
        # Default value: false.
        # 
        # When the `MigrateAcrossZone` parameter is set to `true` and you upgrade the instance based on the returned information, take note of the following items:
        # 
        # Instances of the classic network type:
        # 
        # *   For retired instance types, when a non-I/O optimized instance is upgraded to an I/O optimized instance, the private IP address, disk device names, and software license codes of the instance are changed. For more information, see [Retired instance types](~~55263~~). For Linux instances, basic disks (cloud) are identified as xvd\* such as xvda and xvdb. Ultra disks (cloud_efficiency) and standard SSDs (cloud_ssd) are identified as vd\* such as vda and vdb.
        # *   For instance families available for purchase, when the instance type of an instance is changed, the private IP address of the instance is also changed. For more information, see [Instance families](~~25378~~).
        # 
        # Instances of the Virtual Private Cloud (VPC) type: For retired instance types, when a non-I/O optimized instance is upgraded to an I/O optimized instance, the disk device names and software license codes of the instance are changed. For Linux instances, basic disks (cloud) are identified as xvd\* such as xvda and xvdb. Ultra disks (cloud_efficiency) and standard SSDs (cloud_ssd) are identified as vd\* such as vda and vdb.
        self.migrate_across_zone = migrate_across_zone  # type: bool
        # The operation type. Valid values:
        # 
        # >  This parameter is optional. The system can define the operation type. If you want to specify this parameter, take note of the following rules:
        # 
        # *   upgrade: upgrades the instance type. Make sure that the balance in your account is sufficient.
        # *   downgrade: downgrades the instance type. When the new instance type specified by the `InstanceType` parameter has lower specifications than the current instance type, set `OperatorType` to downgrade.
        # 
        # >  For more information about the precautions on upgrading or downgrading instance types, see the preceding "Description" section in this topic.
        self.operator_type = operator_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The restart time of the instance. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.reboot_time = reboot_time  # type: str
        # Specifies whether to restart the instance immediately after the instance type is changed. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        # 
        # >  If the instance is in the **Stopping** state, the instance state remains unchanged and no operations are performed regardless of whether the `RebootWhenFinished` parameter is set to true.
        self.reboot_when_finished = reboot_when_finished  # type: bool
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()

    def to_map(self):
        _map = super(ModifyPrepayInstanceSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.migrate_across_zone is not None:
            result['MigrateAcrossZone'] = self.migrate_across_zone
        if self.operator_type is not None:
            result['OperatorType'] = self.operator_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.reboot_time is not None:
            result['RebootTime'] = self.reboot_time
        if self.reboot_when_finished is not None:
            result['RebootWhenFinished'] = self.reboot_when_finished
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = ModifyPrepayInstanceSpecRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MigrateAcrossZone') is not None:
            self.migrate_across_zone = m.get('MigrateAcrossZone')
        if m.get('OperatorType') is not None:
            self.operator_type = m.get('OperatorType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RebootTime') is not None:
            self.reboot_time = m.get('RebootTime')
        if m.get('RebootWhenFinished') is not None:
            self.reboot_when_finished = m.get('RebootWhenFinished')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyPrepayInstanceSpecResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPrepayInstanceSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPrepayInstanceSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPrepayInstanceSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPrepayInstanceSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPrepayInstanceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyReservedInstanceAttributeRequest(TeaModel):
    def __init__(self, description=None, owner_account=None, owner_id=None, region_id=None,
                 reserved_instance_id=None, reserved_instance_name=None, resource_owner_account=None, resource_owner_id=None):
        # The new description of the reserved instance. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the reserved instance.
        self.region_id = region_id  # type: str
        # The ID of the reserved instance.
        self.reserved_instance_id = reserved_instance_id  # type: str
        # The new name of the reserved instance. The name must be 2 to 128 characters in length. It must start with a letter but cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.reserved_instance_name = reserved_instance_name  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstanceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.reserved_instance_name is not None:
            result['ReservedInstanceName'] = self.reserved_instance_name
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ReservedInstanceName') is not None:
            self.reserved_instance_name = m.get('ReservedInstanceName')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyReservedInstanceAttributeResponseBody(TeaModel):
    def __init__(self, code=None, http_status_code=None, message=None, request_id=None):
        # The error code.
        self.code = code  # type: str
        # The HTTP status code returned.
        self.http_status_code = http_status_code  # type: int
        # The error message for this instance operation. The return value Success indicates that this operation is successful. For more information, see the "Error codes" section in this topic.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstanceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.http_status_code is not None:
            result['HttpStatusCode'] = self.http_status_code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('HttpStatusCode') is not None:
            self.http_status_code = m.get('HttpStatusCode')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyReservedInstanceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyReservedInstanceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyReservedInstanceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyReservedInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyReservedInstanceAutoRenewAttributeRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, period=None, period_unit=None, region_id=None,
                 renewal_status=None, reserved_instance_id=None, resource_owner_account=None, resource_owner_id=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.period = period  # type: int
        self.period_unit = period_unit  # type: str
        self.region_id = region_id  # type: str
        self.renewal_status = renewal_status  # type: str
        self.reserved_instance_id = reserved_instance_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstanceAutoRenewAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.renewal_status is not None:
            result['RenewalStatus'] = self.renewal_status
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RenewalStatus') is not None:
            self.renewal_status = m.get('RenewalStatus')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyReservedInstanceAutoRenewAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstanceAutoRenewAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyReservedInstanceAutoRenewAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyReservedInstanceAutoRenewAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyReservedInstanceAutoRenewAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyReservedInstanceAutoRenewAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyReservedInstancesRequestConfiguration(TeaModel):
    def __init__(self, instance_amount=None, instance_type=None, reserved_instance_name=None, scope=None,
                 zone_id=None):
        # The number of pay-as-you-go instances of the same instance type that reserved instance N can match. The value must be greater than or equal to 1. Valid values of N: 1 to 100.
        self.instance_amount = instance_amount  # type: int
        # The instance type that reserved instance N can match. Valid values of N: 1 to 100.
        # 
        # > The supported instance types are regularly updated. For more information, see the "Attributes" section of [Overview](~~100370~~).
        self.instance_type = instance_type  # type: str
        # The name of reserved instance N. Valid values of N: 1 to 100.
        # 
        # The name must be 2 to 128 characters in length. It must start with a letter but cannot start with [http:// or https://. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).](http://https://。、（:）、（\_）（-）。)
        self.reserved_instance_name = reserved_instance_name  # type: str
        # The scope of reserved instance N. Valid values:
        # 
        # *   Region: regional
        # *   Zone: zonal
        # 
        # Valid values of N: 1 to 100.
        # 
        # Default value: Region.
        self.scope = scope  # type: str
        # The zone ID of reserved instance N. Valid values of N: 1 to 100.
        # 
        # This parameter is required when `Scope` is set to `Zone`.
        # 
        # You can call the [DescribeZones](~~25609~~) operation to query the most recent zone list.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstancesRequestConfiguration, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.reserved_instance_name is not None:
            result['ReservedInstanceName'] = self.reserved_instance_name
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('ReservedInstanceName') is not None:
            self.reserved_instance_name = m.get('ReservedInstanceName')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class ModifyReservedInstancesRequest(TeaModel):
    def __init__(self, configuration=None, owner_account=None, owner_id=None, region_id=None,
                 reserved_instance_id=None, resource_owner_account=None, resource_owner_id=None):
        # The configurations of reserved instances.
        self.configuration = configuration  # type: list[ModifyReservedInstancesRequestConfiguration]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the reserved instance.
        # 
        # You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The IDs of reserved instances. Valid values of N: 1 to 20.
        self.reserved_instance_id = reserved_instance_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.configuration:
            for k in self.configuration:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyReservedInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Configuration'] = []
        if self.configuration is not None:
            for k in self.configuration:
                result['Configuration'].append(k.to_map() if k else None)
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.configuration = []
        if m.get('Configuration') is not None:
            for k in m.get('Configuration'):
                temp_model = ModifyReservedInstancesRequestConfiguration()
                self.configuration.append(temp_model.from_map(k))
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ModifyReservedInstancesResponseBodyReservedInstanceIdSets(TeaModel):
    def __init__(self, reserved_instance_id=None):
        self.reserved_instance_id = reserved_instance_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyReservedInstancesResponseBodyReservedInstanceIdSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        return self


class ModifyReservedInstancesResponseBody(TeaModel):
    def __init__(self, request_id=None, reserved_instance_id_sets=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The IDs of the reserved instances.
        self.reserved_instance_id_sets = reserved_instance_id_sets  # type: ModifyReservedInstancesResponseBodyReservedInstanceIdSets

    def validate(self):
        if self.reserved_instance_id_sets:
            self.reserved_instance_id_sets.validate()

    def to_map(self):
        _map = super(ModifyReservedInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.reserved_instance_id_sets is not None:
            result['ReservedInstanceIdSets'] = self.reserved_instance_id_sets.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ReservedInstanceIdSets') is not None:
            temp_model = ModifyReservedInstancesResponseBodyReservedInstanceIdSets()
            self.reserved_instance_id_sets = temp_model.from_map(m['ReservedInstanceIdSets'])
        return self


class ModifyReservedInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyReservedInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyReservedInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyReservedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRouterInterfaceAttributeRequest(TeaModel):
    def __init__(self, description=None, health_check_source_ip=None, health_check_target_ip=None, name=None,
                 opposite_interface_id=None, opposite_interface_owner_id=None, opposite_router_id=None, opposite_router_type=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 router_interface_id=None):
        self.description = description  # type: str
        self.health_check_source_ip = health_check_source_ip  # type: str
        self.health_check_target_ip = health_check_target_ip  # type: str
        self.name = name  # type: str
        self.opposite_interface_id = opposite_interface_id  # type: str
        self.opposite_interface_owner_id = opposite_interface_owner_id  # type: long
        self.opposite_router_id = opposite_router_id  # type: str
        self.opposite_router_type = opposite_router_type  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRouterInterfaceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.health_check_source_ip is not None:
            result['HealthCheckSourceIp'] = self.health_check_source_ip
        if self.health_check_target_ip is not None:
            result['HealthCheckTargetIp'] = self.health_check_target_ip
        if self.name is not None:
            result['Name'] = self.name
        if self.opposite_interface_id is not None:
            result['OppositeInterfaceId'] = self.opposite_interface_id
        if self.opposite_interface_owner_id is not None:
            result['OppositeInterfaceOwnerId'] = self.opposite_interface_owner_id
        if self.opposite_router_id is not None:
            result['OppositeRouterId'] = self.opposite_router_id
        if self.opposite_router_type is not None:
            result['OppositeRouterType'] = self.opposite_router_type
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HealthCheckSourceIp') is not None:
            self.health_check_source_ip = m.get('HealthCheckSourceIp')
        if m.get('HealthCheckTargetIp') is not None:
            self.health_check_target_ip = m.get('HealthCheckTargetIp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OppositeInterfaceId') is not None:
            self.opposite_interface_id = m.get('OppositeInterfaceId')
        if m.get('OppositeInterfaceOwnerId') is not None:
            self.opposite_interface_owner_id = m.get('OppositeInterfaceOwnerId')
        if m.get('OppositeRouterId') is not None:
            self.opposite_router_id = m.get('OppositeRouterId')
        if m.get('OppositeRouterType') is not None:
            self.opposite_router_type = m.get('OppositeRouterType')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        return self


class ModifyRouterInterfaceAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRouterInterfaceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyRouterInterfaceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyRouterInterfaceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyRouterInterfaceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRouterInterfaceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyRouterInterfaceSpecRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, router_interface_id=None, spec=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.router_interface_id = router_interface_id  # type: str
        self.spec = spec  # type: str
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRouterInterfaceSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.router_interface_id is not None:
            result['RouterInterfaceId'] = self.router_interface_id
        if self.spec is not None:
            result['Spec'] = self.spec
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('RouterInterfaceId') is not None:
            self.router_interface_id = m.get('RouterInterfaceId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class ModifyRouterInterfaceSpecResponseBody(TeaModel):
    def __init__(self, request_id=None, spec=None):
        self.request_id = request_id  # type: str
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyRouterInterfaceSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class ModifyRouterInterfaceSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyRouterInterfaceSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyRouterInterfaceSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyRouterInterfaceSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityGroupAttributeRequest(TeaModel):
    def __init__(self, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, security_group_id=None, security_group_name=None):
        # The new description of the security group. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # The new name of the security group. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # This parameter is empty by default.
        self.security_group_name = security_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_name is not None:
            result['SecurityGroupName'] = self.security_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupName') is not None:
            self.security_group_name = m.get('SecurityGroupName')
        return self


class ModifySecurityGroupAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityGroupAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityGroupAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityGroupAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityGroupAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityGroupEgressRuleRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, dest_group_id=None,
                 dest_group_owner_account=None, dest_group_owner_id=None, dest_prefix_list_id=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, policy=None,
                 port_range=None, priority=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 security_group_id=None, security_group_rule_id=None, source_cidr_ip=None, source_port_range=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the security group rule. The description must be 1 to 512 characters in length.
        self.description = description  # type: str
        # The destination IPv4 CIDR block. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The ID of the destination security group. You must specify at least one of the `DestGroupId` and `DestCidrIp` parameters.
        # 
        # *   If `DestGroupId` is specified but `DestCidrIp` is not specified, the `NicType` parameter must be set to intranet.
        # *   If both `DestGroupId` and `DestCidrIp` are specified, `DestCidrIp` takes precedence.
        self.dest_group_id = dest_group_id  # type: str
        # The logon name of the Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # The ID of the Alibaba Cloud account (UID) that manages the destination security group.
        self.dest_group_owner_id = dest_group_owner_id  # type: long
        # The ID of the destination prefix list. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # If you specify `DestCidrIp`, `Ipv6DestCidrIp`, or `DestGroupId`, this parameter is ignored.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # The transport layer protocol. The values of this parameter are case-insensitive. Valid values:
        # 
        # *   icmp
        # *   gre
        # *   tcp
        # *   udp
        # *   all: All protocols are supported.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block. CIDR blocks and IPv6 addresses are supported.
        # 
        # >  Only the IP addresses of instances in virtual private clouds (VPCs) are supported. You cannot specify both the Ipv6DestCidrIp parameter and the `DestCidrIp` parameter.
        # 
        # This parameter is empty by default.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block. CIDR blocks and IPv6 addresses are supported.
        # 
        # >  Only the IP addresses of instances in VPCs are supported. You cannot specify both the Ipv6SourceCidrIp parameter and the `SourceCidrIp` parameter.
        # 
        # This parameter is empty by default.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of the security group rule when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # *   intranet: private NIC
        # 
        # Default value: internet.
        # 
        # The NicType parameter must be set to intranet in the following cases:
        # 
        # *   If the security group is in a VPC, this parameter is required and must be set to intranet.
        # *   If you specify only `DestGroupId` when you configure access between security groups, this parameter must be set to intranet.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The authorization policy. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses.
        # 
        # Default value: accept.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
        # *   When the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
        self.port_range = port_range  # type: str
        # The priority of the security group rule. Valid values: 1 to 100.
        # 
        # Default: 1.
        self.priority = priority  # type: str
        # The region ID of the source security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the source security group.
        self.security_group_id = security_group_id  # type: str
        self.security_group_rule_id = security_group_rule_id  # type: str
        # The source IPv4 CIDR block. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The range of source ports that correspond to the transport layer protocol. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
        # *   When the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
        self.source_port_range = source_port_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupEgressRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_group_owner_id is not None:
            result['DestGroupOwnerId'] = self.dest_group_owner_id
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_rule_id is not None:
            result['SecurityGroupRuleId'] = self.security_group_rule_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestGroupOwnerId') is not None:
            self.dest_group_owner_id = m.get('DestGroupOwnerId')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupRuleId') is not None:
            self.security_group_rule_id = m.get('SecurityGroupRuleId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class ModifySecurityGroupEgressRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupEgressRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityGroupEgressRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityGroupEgressRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityGroupEgressRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityGroupEgressRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityGroupPolicyRequest(TeaModel):
    def __init__(self, client_token=None, inner_access_policy=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, security_group_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The internal access policy of the security group. Valid values:
        # 
        # *   Accept: All instances in the security group can communicate with each other.
        # *   Drop: All instances in the security group are isolated from each other.
        # 
        # These values are case-insensitive.
        self.inner_access_policy = inner_access_policy  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.inner_access_policy is not None:
            result['InnerAccessPolicy'] = self.inner_access_policy
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('InnerAccessPolicy') is not None:
            self.inner_access_policy = m.get('InnerAccessPolicy')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        return self


class ModifySecurityGroupPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityGroupPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityGroupPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityGroupPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityGroupPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySecurityGroupRuleRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, policy=None,
                 port_range=None, priority=None, region_id=None, resource_owner_account=None, resource_owner_id=None,
                 security_group_id=None, security_group_rule_id=None, source_cidr_ip=None, source_group_id=None,
                 source_group_owner_account=None, source_group_owner_id=None, source_port_range=None, source_prefix_list_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the security group rule. The description must be 1 to 512 characters in length.
        self.description = description  # type: str
        # The destination IPv4 CIDR block. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The transport layer protocol. The values of this parameter are case-insensitive. Valid values:
        # 
        # *   icmp
        # *   gre
        # *   tcp
        # *   udp
        # *   all: All protocols are supported.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block. CIDR blocks and IPv6 addresses are supported.
        # 
        # >  Only the IP addresses of instances in VPCs are supported. You cannot specify both the Ipv6DestCidrIp parameter and the `DestCidrIp` parameter.
        # 
        # This parameter is empty by default.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block. CIDR blocks and IPv6 addresses are supported.
        # 
        # >  Only the IP addresses of instances in virtual private clouds (VPCs) are supported. You cannot specify both the Ipv6SourceCidrIp parameter and the `SourceCidrIp` parameter.
        # 
        # This parameter is empty by default.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of the security group rule when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # *   intranet: private NIC
        # 
        # Default value: internet.
        # 
        # The NicType parameter must be set to intranet in the following cases:
        # 
        # *   If the security group is in a VPC, this parameter is required and must be set to intranet.
        # *   If you specify only `DestGroupId` when you configure access between security groups, this parameter must be set to intranet.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The authorization policy. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses.
        # 
        # Default value: accept.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
        # *   When the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
        self.port_range = port_range  # type: str
        # The priority of the security group rule. Valid values: 1 to 100.
        # 
        # Default: 1.
        self.priority = priority  # type: str
        # The region ID of the destination security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the destination security group.
        self.security_group_id = security_group_id  # type: str
        self.security_group_rule_id = security_group_rule_id  # type: str
        # The source IPv4 CIDR block to which you want to control access. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is empty by default.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The ID of the source security group. At least one of `SourceGroupId` and `SourceCidrIp` must be specified.
        # 
        # *   If `SourceGroupId` is specified but `SourceCidrIp` is not specified, the `NicType` parameter must be set to intranet.
        # *   If both `SourceGroupId` and `SourceCidrIp` are specified, `SourceCidrIp` takes precedence.
        self.source_group_id = source_group_id  # type: str
        # The Alibaba Cloud account that manages the source security group when you set a security group rule across accounts.
        # 
        # *   If both `SourceGroupOwnerId` and `SourceGroupOwnerAccount` are empty, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerAccount` parameter is ignored.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # The ID of the Alibaba Cloud account that manages the source security group when you set a security group rule across accounts.
        # 
        # *   If both `SourceGroupOwnerId` and `SourceGroupOwnerAccount` are empty, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerId` parameter is ignored.
        self.source_group_owner_id = source_group_owner_id  # type: long
        # The range of source ports that correspond to the transport layer protocol. Valid values:
        # 
        # *   When the IpProtocol parameter is set to tcp or udp, the port number range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
        # *   When the IpProtocol parameter is set to icmp, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to gre, the port number range is -1/-1, which indicates all ports.
        # *   When the IpProtocol parameter is set to all, the port number range is -1/-1, which indicates all ports.
        self.source_port_range = source_port_range  # type: str
        # The ID of the source prefix list to which you want to control access. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # If you specify the `SourceCidrIp`, `Ipv6SourceCidrIp`, or `SourceGroupId` parameter, this parameter is ignored.
        self.source_prefix_list_id = source_prefix_list_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_rule_id is not None:
            result['SecurityGroupRuleId'] = self.security_group_rule_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_group_owner_id is not None:
            result['SourceGroupOwnerId'] = self.source_group_owner_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupRuleId') is not None:
            self.security_group_rule_id = m.get('SecurityGroupRuleId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourceGroupOwnerId') is not None:
            self.source_group_owner_id = m.get('SourceGroupOwnerId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        return self


class ModifySecurityGroupRuleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySecurityGroupRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySecurityGroupRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySecurityGroupRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySecurityGroupRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySecurityGroupRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySnapshotAttributeRequest(TeaModel):
    def __init__(self, description=None, disable_instant_access=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, snapshot_id=None, snapshot_name=None):
        # The description of the snapshot. The description must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description  # type: str
        # Specifies whether to disable the instant access feature. Valid values:
        # 
        # *   true: disables the instant access feature.
        # *   false: enables the instant access feature.
        # 
        # Default value: false.
        self.disable_instant_access = disable_instant_access  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The name of the snapshot. The name must be 2 to 128 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        # 
        # It cannot start with auto because snapshots whose names start with auto are recognized as automatic snapshots.
        self.snapshot_name = snapshot_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySnapshotAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.disable_instant_access is not None:
            result['DisableInstantAccess'] = self.disable_instant_access
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisableInstantAccess') is not None:
            self.disable_instant_access = m.get('DisableInstantAccess')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        return self


class ModifySnapshotAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySnapshotAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySnapshotAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySnapshotAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySnapshotAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySnapshotAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySnapshotGroupRequest(TeaModel):
    def __init__(self, description=None, name=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, snapshot_group_id=None):
        # The new description of the snapshot-consistent group. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The new name of the snapshot-consistent group. The name must be 2 to 128 characters in length. It can contain letters, digits, periods (.), underscores (\_), hyphens (-), and colons (:). It must start with a letter or a digit and cannot start with `http://` or `https://`.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the snapshot-consistent group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot-consistent group. You can call the [DescribeSnapshotGroups](~~210940~~) operation to query the IDs of one or more snapshot-consistent groups.
        self.snapshot_group_id = snapshot_group_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySnapshotGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_group_id is not None:
            result['SnapshotGroupId'] = self.snapshot_group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotGroupId') is not None:
            self.snapshot_group_id = m.get('SnapshotGroupId')
        return self


class ModifySnapshotGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySnapshotGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifySnapshotGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySnapshotGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySnapshotGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySnapshotGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStorageCapacityUnitAttributeRequest(TeaModel):
    def __init__(self, description=None, name=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, storage_capacity_unit_id=None):
        # The description of the SCU. It must be 2 to 256 characters in length and cannot start with http:// or https://.
        self.description = description  # type: str
        # The name of the SCU. It must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with http:// or https://.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the SCU. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the SCU.
        self.storage_capacity_unit_id = storage_capacity_unit_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStorageCapacityUnitAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_capacity_unit_id is not None:
            result['StorageCapacityUnitId'] = self.storage_capacity_unit_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageCapacityUnitId') is not None:
            self.storage_capacity_unit_id = m.get('StorageCapacityUnitId')
        return self


class ModifyStorageCapacityUnitAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStorageCapacityUnitAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStorageCapacityUnitAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyStorageCapacityUnitAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyStorageCapacityUnitAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStorageCapacityUnitAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyStorageSetAttributeRequest(TeaModel):
    def __init__(self, client_token=None, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, storage_set_id=None, storage_set_name=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The value of **ClientToken** can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the storage set.
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the storage set. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The name of the storage set.
        self.storage_set_name = storage_set_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStorageSetAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_name is not None:
            result['StorageSetName'] = self.storage_set_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetName') is not None:
            self.storage_set_name = m.get('StorageSetName')
        return self


class ModifyStorageSetAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyStorageSetAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyStorageSetAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyStorageSetAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyStorageSetAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyStorageSetAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUserBusinessBehaviorRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, status_key=None, status_value=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.status_key = status_key  # type: str
        self.status_value = status_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserBusinessBehaviorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.status_key is not None:
            result['statusKey'] = self.status_key
        if self.status_value is not None:
            result['statusValue'] = self.status_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('statusKey') is not None:
            self.status_key = m.get('statusKey')
        if m.get('statusValue') is not None:
            self.status_value = m.get('statusValue')
        return self


class ModifyUserBusinessBehaviorResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserBusinessBehaviorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUserBusinessBehaviorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyUserBusinessBehaviorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyUserBusinessBehaviorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUserBusinessBehaviorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVRouterAttributeRequest(TeaModel):
    def __init__(self, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, vrouter_id=None, vrouter_name=None):
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.vrouter_id = vrouter_id  # type: str
        self.vrouter_name = vrouter_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVRouterAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.vrouter_id is not None:
            result['VRouterId'] = self.vrouter_id
        if self.vrouter_name is not None:
            result['VRouterName'] = self.vrouter_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VRouterId') is not None:
            self.vrouter_id = m.get('VRouterId')
        if m.get('VRouterName') is not None:
            self.vrouter_name = m.get('VRouterName')
        return self


class ModifyVRouterAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVRouterAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVRouterAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVRouterAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVRouterAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVRouterAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVSwitchAttributeRequest(TeaModel):
    def __init__(self, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, v_switch_id=None, v_switch_name=None):
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.v_switch_id = v_switch_id  # type: str
        self.v_switch_name = v_switch_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVSwitchAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.v_switch_name is not None:
            result['VSwitchName'] = self.v_switch_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VSwitchName') is not None:
            self.v_switch_name = m.get('VSwitchName')
        return self


class ModifyVSwitchAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVSwitchAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVSwitchAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVSwitchAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVSwitchAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVSwitchAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVirtualBorderRouterAttributeRequest(TeaModel):
    def __init__(self, circuit_code=None, client_token=None, description=None, local_gateway_ip=None, name=None,
                 owner_account=None, owner_id=None, peer_gateway_ip=None, peering_subnet_mask=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, user_cidr=None, vbr_id=None, vlan_id=None):
        self.circuit_code = circuit_code  # type: str
        self.client_token = client_token  # type: str
        self.description = description  # type: str
        self.local_gateway_ip = local_gateway_ip  # type: str
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.peer_gateway_ip = peer_gateway_ip  # type: str
        self.peering_subnet_mask = peering_subnet_mask  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vbr_id = vbr_id  # type: str
        self.vlan_id = vlan_id  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVirtualBorderRouterAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.circuit_code is not None:
            result['CircuitCode'] = self.circuit_code
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.local_gateway_ip is not None:
            result['LocalGatewayIp'] = self.local_gateway_ip
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.peer_gateway_ip is not None:
            result['PeerGatewayIp'] = self.peer_gateway_ip
        if self.peering_subnet_mask is not None:
            result['PeeringSubnetMask'] = self.peering_subnet_mask
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        if self.vlan_id is not None:
            result['VlanId'] = self.vlan_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CircuitCode') is not None:
            self.circuit_code = m.get('CircuitCode')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('LocalGatewayIp') is not None:
            self.local_gateway_ip = m.get('LocalGatewayIp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PeerGatewayIp') is not None:
            self.peer_gateway_ip = m.get('PeerGatewayIp')
        if m.get('PeeringSubnetMask') is not None:
            self.peering_subnet_mask = m.get('PeeringSubnetMask')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        if m.get('VlanId') is not None:
            self.vlan_id = m.get('VlanId')
        return self


class ModifyVirtualBorderRouterAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVirtualBorderRouterAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVirtualBorderRouterAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVirtualBorderRouterAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVirtualBorderRouterAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVirtualBorderRouterAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyVpcAttributeRequest(TeaModel):
    def __init__(self, cidr_block=None, description=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, user_cidr=None, vpc_id=None, vpc_name=None):
        self.cidr_block = cidr_block  # type: str
        self.description = description  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vpc_id = vpc_id  # type: str
        self.vpc_name = vpc_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVpcAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.description is not None:
            result['Description'] = self.description
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_name is not None:
            result['VpcName'] = self.vpc_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcName') is not None:
            self.vpc_name = m.get('VpcName')
        return self


class ModifyVpcAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyVpcAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyVpcAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyVpcAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyVpcAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyVpcAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PurchaseReservedInstancesOfferingRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the reserved instance. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `acs:` or `aliyun`.
        self.key = key  # type: str
        # The value of tag N of the reserved instance. Valid values of N: 1 to 20. The tag value cannot be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. It cannot start with `acs:` or `aliyun`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PurchaseReservedInstancesOfferingRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PurchaseReservedInstancesOfferingRequest(TeaModel):
    def __init__(self, auto_renew=None, auto_renew_period=None, client_token=None, description=None,
                 instance_amount=None, instance_type=None, offering_type=None, owner_account=None, owner_id=None, period=None,
                 period_unit=None, platform=None, region_id=None, reserved_instance_name=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, scope=None, tag=None, zone_id=None):
        # Specifies whether to enable auto-renewal for the reserved instance. Default value: false. Valid values:
        # 
        # true: enables auto-renewal for the reserved instance. false: does not enable auto-renewal for the reserved instance.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal term of the reserved instance. Unit: months. This parameter takes effect only when AutoRenew is set to true.
        # 
        # Valid values: 1, 12, 36, and 60.
        # 
        # Default value when PeriodUnit is set to Month: 1.
        # 
        # Default value when PeriodUnit is set to Year: 12.
        self.auto_renew_period = auto_renew_period  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the reserved instance. The description must be 2 to 256 characters in length and cannot start with [http:// or https://](http://https://。).
        # 
        # This parameter is empty by default.
        self.description = description  # type: str
        # The number of pay-as-you-go instances of the same instance type that the reserved instance can be matched to at the same time. Valid values: 1 to 50.
        # 
        # For example, if InstanceAmount is set to 3 and InstanceType is set to ecs.g5.large, the reserved instance can be matched to three ecs.g5.large pay-as-you-go instances at the same time.
        self.instance_amount = instance_amount  # type: int
        # The instance type. For more information, see [Overview of instance families](~~25378~~).
        self.instance_type = instance_type  # type: str
        # The payment option of the reserved instance. Valid values:
        # 
        # *   No Upfront
        # *   Partial Upfront
        # *   All Upfront
        # 
        # Default value: All Upfront.
        self.offering_type = offering_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The term of the reserved instance.
        # 
        # *   Valid values when `PeriodUnit` is set to `Year`: 1, 3, and 5.
        # *   Valid values when `PeriodUnit` is set to `Month`: 1.
        # 
        # Default value: 1.
        self.period = period  # type: int
        # The unit of the term of the reserved instance.
        # 
        # Valid values: Year and Month.
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The operating system of the image used by the instance. Valid values:
        # 
        # *   Windows: Windows Server operating system
        # *   Linux: Linux and UNIX-like operating system
        # 
        # Default value: Linux.
        self.platform = platform  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        # The name of the reserved instance. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with http:// or https://.
        self.reserved_instance_name = reserved_instance_name  # type: str
        # The ID of the resource group to which to assign the instance.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The scope of the reserved instance. Valid values:
        # 
        # *   Region: regional
        # *   Zone: zonal
        # 
        # Default value: Region.
        self.scope = scope  # type: str
        # The tags to add to the instance.
        self.tag = tag  # type: list[PurchaseReservedInstancesOfferingRequestTag]
        # The zone ID of the instance. This parameter is required when `Scope` is set to `Zone`. You can call the [DescribeZones](~~25610~~) operation to query the most recent list of zones.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PurchaseReservedInstancesOfferingRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_amount is not None:
            result['InstanceAmount'] = self.instance_amount
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.offering_type is not None:
            result['OfferingType'] = self.offering_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_name is not None:
            result['ReservedInstanceName'] = self.reserved_instance_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.scope is not None:
            result['Scope'] = self.scope
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceAmount') is not None:
            self.instance_amount = m.get('InstanceAmount')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OfferingType') is not None:
            self.offering_type = m.get('OfferingType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceName') is not None:
            self.reserved_instance_name = m.get('ReservedInstanceName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = PurchaseReservedInstancesOfferingRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets(TeaModel):
    def __init__(self, reserved_instance_id=None):
        self.reserved_instance_id = reserved_instance_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        return self


class PurchaseReservedInstancesOfferingResponseBody(TeaModel):
    def __init__(self, request_id=None, reserved_instance_id_sets=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the reserved instance.
        self.reserved_instance_id_sets = reserved_instance_id_sets  # type: PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets

    def validate(self):
        if self.reserved_instance_id_sets:
            self.reserved_instance_id_sets.validate()

    def to_map(self):
        _map = super(PurchaseReservedInstancesOfferingResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.reserved_instance_id_sets is not None:
            result['ReservedInstanceIdSets'] = self.reserved_instance_id_sets.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ReservedInstanceIdSets') is not None:
            temp_model = PurchaseReservedInstancesOfferingResponseBodyReservedInstanceIdSets()
            self.reserved_instance_id_sets = temp_model.from_map(m['ReservedInstanceIdSets'])
        return self


class PurchaseReservedInstancesOfferingResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PurchaseReservedInstancesOfferingResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PurchaseReservedInstancesOfferingResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PurchaseReservedInstancesOfferingResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PurchaseStorageCapacityUnitRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N. N indicates the number of tag keys that can be specified. Valid values of N: 1 to 20. The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N. N indicates the number of tag values that can be specified and corresponds to the N in `Tag.N.Key`. Valid values: 1 to 20. The tag value can be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PurchaseStorageCapacityUnitRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PurchaseStorageCapacityUnitRequest(TeaModel):
    def __init__(self, amount=None, capacity=None, client_token=None, description=None, from_app=None, name=None,
                 owner_account=None, owner_id=None, period=None, period_unit=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, start_time=None, tag=None):
        # The number of SCUs that you want to purchase. Valid values: 1 to 20.
        # 
        # Default value: 1
        self.amount = amount  # type: int
        # The capacity of the SCU. Unit: GiB. Valid values: 20, 40, 100, 200, 500, 1024, 2048, 5210, 10240, 20480, and 52100.
        self.capacity = capacity  # type: int
        # The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The `ClientToken` value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The description of the SCU. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The source of the request. The value is automatically set to OpenAPI and does not need to be changed. Default value: OpenAPI.
        self.from_app = from_app  # type: str
        # The name of the SCU. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The validity period of the SCU. Valid values:
        # 
        # *   Valid values when PeriodUnit is set to Month: 1, 2, 3, and 6.
        # *   Valid values when PeriodUnit is set to Year: 1, 3, and 5.
        # 
        # Default value: 1.
        self.period = period  # type: int
        # The unit of the validity period of the SCU. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The ID of the region in which to purchase the SCU. After this parameter is specified, the purchased SCU can offset bills of only pay-as-you-go disks that reside in the specified region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The time when the SCU takes effect. It can be up to six months later than the time when the SCU is created. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        # 
        # This parameter is empty by default. If this parameter is left empty, the SCU takes effect immediately after it is created.
        self.start_time = start_time  # type: str
        # The tags to add to the SCU.
        self.tag = tag  # type: list[PurchaseStorageCapacityUnitRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PurchaseStorageCapacityUnitRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.from_app is not None:
            result['FromApp'] = self.from_app
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FromApp') is not None:
            self.from_app = m.get('FromApp')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = PurchaseStorageCapacityUnitRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds(TeaModel):
    def __init__(self, storage_capacity_unit_id=None):
        self.storage_capacity_unit_id = storage_capacity_unit_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.storage_capacity_unit_id is not None:
            result['StorageCapacityUnitId'] = self.storage_capacity_unit_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('StorageCapacityUnitId') is not None:
            self.storage_capacity_unit_id = m.get('StorageCapacityUnitId')
        return self


class PurchaseStorageCapacityUnitResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None, storage_capacity_unit_ids=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The IDs of the SCUs.
        self.storage_capacity_unit_ids = storage_capacity_unit_ids  # type: PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds

    def validate(self):
        if self.storage_capacity_unit_ids:
            self.storage_capacity_unit_ids.validate()

    def to_map(self):
        _map = super(PurchaseStorageCapacityUnitResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.storage_capacity_unit_ids is not None:
            result['StorageCapacityUnitIds'] = self.storage_capacity_unit_ids.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StorageCapacityUnitIds') is not None:
            temp_model = PurchaseStorageCapacityUnitResponseBodyStorageCapacityUnitIds()
            self.storage_capacity_unit_ids = temp_model.from_map(m['StorageCapacityUnitIds'])
        return self


class PurchaseStorageCapacityUnitResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PurchaseStorageCapacityUnitResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PurchaseStorageCapacityUnitResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PurchaseStorageCapacityUnitResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReActivateInstancesRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the instance that you want to reactivate.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReActivateInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ReActivateInstancesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReActivateInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReActivateInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReActivateInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReActivateInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReActivateInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReInitDiskRequest(TeaModel):
    def __init__(self, auto_start_instance=None, disk_id=None, key_pair_name=None, owner_account=None,
                 owner_id=None, password=None, resource_owner_account=None, resource_owner_id=None,
                 security_enhancement_strategy=None):
        # Specifies whether to automatically start the instance after the disk is re-initialized.
        # 
        # Default value: false.
        self.auto_start_instance = auto_start_instance  # type: bool
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The name of the key pair.
        # 
        # > The parameter is applicable only to Linux instances. You can bind an SSH key pair to an instance as the logon credential when you re-initialize the system disk of the instance. After the SSH key pair is bound, the username and password-based logon method is disabled for the instance.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Specifies whether to reset the password of the instance when you re-initialize its system disk. The password must be 8 to 30 characters in length and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        #     ()`~!@#$%^&*-_+=|{}[]:;\"<>,.?/\
        # 
        # For Windows instances, passwords cannot start with a forward slash (/).
        # 
        # > If the `Password` parameter is specified, we recommend that you send requests over HTTPS to prevent password leaks.
        self.password = password  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to use Security Center for free after the system disk is re-initialized. Valid values:
        # 
        # *   Active: uses Security Center for free after the system disk is re-initialized. This value is applicable only to public images.
        # *   Deactive: does not use Security Center for free after the system disk is re-initialized. This value is applicable to all images.
        # 
        # Default value: Deactive.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReInitDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_start_instance is not None:
            result['AutoStartInstance'] = self.auto_start_instance
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoStartInstance') is not None:
            self.auto_start_instance = m.get('AutoStartInstance')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        return self


class ReInitDiskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReInitDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReInitDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReInitDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReInitDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReInitDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootInstanceRequest(TeaModel):
    def __init__(self, dry_run=None, force_stop=None, instance_id=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to perform a dry run. Valid values:
        # 
        # *   true: performs a dry run. The system checks the required parameters, the request format, service limits, and available ECS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
        # *   false: performs a dry run and sends the request. If the request passes the dry run, the instance is restarted.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to forcibly stop the instance to restart it. Valid values:
        # 
        # *   true: stops the instance in a forceful manner. This operation is equivalent to the power-off operation in common scenarios. Cache data that is not written to storage in the instance will be lost.
        # *   false: normally stops the instance. This is the default value.
        self.force_stop = force_stop  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RebootInstanceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RebootInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RebootInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootInstancesRequest(TeaModel):
    def __init__(self, batch_optimization=None, dry_run=None, force_reboot=None, instance_id=None,
                 owner_account=None, owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The batch operation mode. Valid values:
        # 
        # *   AllTogether: In this mode, if all instances are restarted, a success message is returned. If an instance fails the verification, all instances fail to restart and an error message is returned.
        # *   SuccessFirst: In this mode, each instance is restarted separately. The response contains the operation results for each instance.
        # 
        # Default value: AllTogether.
        self.batch_optimization = batch_optimization  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # - true: The validity of the request is checked but the request is not made. Check items include the request format, instance status, and whether the required parameters are specified. If the check fails, the corresponding error message is returned. If the check succeeds, `DRYRUN.SUCCESS` is returned.
        #     > If you set `BatchOptimization` to `SuccessFirst` and `DryRun` to true, only `DRYRUN.SUCCESS` is returned regardless of whether the check succeeds.
        # 
        # - false: The validity of the request is checked, and the request is made if the check succeeds.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to forcibly restart the instance. Valid values:
        # 
        # *   true: forcibly restarts the instance. This operation is equivalent to the typical power-off operation. Cache data that is not written to storage in the instance will be lost.
        # *   false: normally restarts the instance.
        # 
        # Default value: false.
        self.force_reboot = force_reboot  # type: bool
        # The list of instance ID. The list items up to 100.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_optimization is not None:
            result['BatchOptimization'] = self.batch_optimization
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.force_reboot is not None:
            result['ForceReboot'] = self.force_reboot
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BatchOptimization') is not None:
            self.batch_optimization = m.get('BatchOptimization')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('ForceReboot') is not None:
            self.force_reboot = m.get('ForceReboot')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RebootInstancesResponseBodyInstanceResponsesInstanceResponse(TeaModel):
    def __init__(self, code=None, current_status=None, instance_id=None, message=None, previous_status=None):
        # The error code of the operation result. The return value 200 indicates success. For more information, see the "Error codes" section in this topic.
        self.code = code  # type: str
        # The current status of the instance.
        self.current_status = current_status  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The error message for an instance operation. The return value Success indicates operation success. For more information, see the "Error codes" section in this topic.
        self.message = message  # type: str
        # The status of the instance before the operation is called.
        self.previous_status = previous_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootInstancesResponseBodyInstanceResponsesInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_status is not None:
            result['CurrentStatus'] = self.current_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.previous_status is not None:
            result['PreviousStatus'] = self.previous_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentStatus') is not None:
            self.current_status = m.get('CurrentStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PreviousStatus') is not None:
            self.previous_status = m.get('PreviousStatus')
        return self


class RebootInstancesResponseBodyInstanceResponses(TeaModel):
    def __init__(self, instance_response=None):
        self.instance_response = instance_response  # type: list[RebootInstancesResponseBodyInstanceResponsesInstanceResponse]

    def validate(self):
        if self.instance_response:
            for k in self.instance_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RebootInstancesResponseBodyInstanceResponses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponse'] = []
        if self.instance_response is not None:
            for k in self.instance_response:
                result['InstanceResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_response = []
        if m.get('InstanceResponse') is not None:
            for k in m.get('InstanceResponse'):
                temp_model = RebootInstancesResponseBodyInstanceResponsesInstanceResponse()
                self.instance_response.append(temp_model.from_map(k))
        return self


class RebootInstancesResponseBody(TeaModel):
    def __init__(self, instance_responses=None, request_id=None):
        # Details about the instance responses, which contain the status of each instance before and after the operation is called and the result of the operation.
        self.instance_responses = instance_responses  # type: RebootInstancesResponseBodyInstanceResponses
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_responses:
            self.instance_responses.validate()

    def to_map(self):
        _map = super(RebootInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_responses is not None:
            result['InstanceResponses'] = self.instance_responses.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceResponses') is not None:
            temp_model = RebootInstancesResponseBodyInstanceResponses()
            self.instance_responses = temp_model.from_map(m['InstanceResponses'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RebootInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RebootInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RecoverVirtualBorderRouterRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, user_cidr=None, vbr_id=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vbr_id = vbr_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RecoverVirtualBorderRouterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        return self


class RecoverVirtualBorderRouterResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RecoverVirtualBorderRouterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RecoverVirtualBorderRouterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RecoverVirtualBorderRouterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RecoverVirtualBorderRouterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RecoverVirtualBorderRouterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RedeployDedicatedHostRequest(TeaModel):
    def __init__(self, dedicated_host_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RedeployDedicatedHostRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RedeployDedicatedHostResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RedeployDedicatedHostResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RedeployDedicatedHostResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RedeployDedicatedHostResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RedeployDedicatedHostResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RedeployDedicatedHostResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RedeployInstanceRequest(TeaModel):
    def __init__(self, force_stop=None, instance_id=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to force stop the instance that is in the Running state.
        # 
        # Default value: false.
        # 
        # > A forced stop is equivalent to a power outage and can result in loss of unsaved data. We recommend that you redeploy instances when they are in the Stopped state.
        self.force_stop = force_stop  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RedeployInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RedeployInstanceResponseBody(TeaModel):
    def __init__(self, request_id=None, task_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the redeployment task.
        # 
        # You can call the [DescribeTasks](~~25622~~) operation to query the migration result.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RedeployInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class RedeployInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RedeployInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RedeployInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RedeployInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseCapacityReservationRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None):
        # The ID of the capacity reservation.
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseCapacityReservationRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class ReleaseCapacityReservationRequest(TeaModel):
    def __init__(self, private_pool_options=None, dry_run=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: ReleaseCapacityReservationRequestPrivatePoolOptions
        # Specifies whether to check the validity of the request. Set the value to false. The validity of the request is not checked. Capacity reservations are directly released.
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the capacity reservation. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(ReleaseCapacityReservationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = ReleaseCapacityReservationRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ReleaseCapacityReservationResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseCapacityReservationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseCapacityReservationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleaseCapacityReservationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleaseCapacityReservationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseCapacityReservationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseDedicatedHostRequest(TeaModel):
    def __init__(self, dedicated_host_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of the dedicated host.
        self.dedicated_host_id = dedicated_host_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseDedicatedHostRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ReleaseDedicatedHostResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseDedicatedHostResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseDedicatedHostResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleaseDedicatedHostResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleaseDedicatedHostResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseDedicatedHostResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleaseEipAddressRequest(TeaModel):
    def __init__(self, allocation_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.allocation_id = allocation_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseEipAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ReleaseEipAddressResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleaseEipAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleaseEipAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleaseEipAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleaseEipAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleaseEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReleasePublicIpAddressRequest(TeaModel):
    def __init__(self, dry_run=None, instance_id=None, public_ip_address=None, region_id=None):
        # > This parameter is unavailable.
        self.dry_run = dry_run  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The public IP address of the instance.
        self.public_ip_address = public_ip_address  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleasePublicIpAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.public_ip_address is not None:
            result['PublicIpAddress'] = self.public_ip_address
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('PublicIpAddress') is not None:
            self.public_ip_address = m.get('PublicIpAddress')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ReleasePublicIpAddressResponseBody(TeaModel):
    def __init__(self, remain_times=None, request_id=None):
        # > This parameter is unavailable.
        self.remain_times = remain_times  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReleasePublicIpAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remain_times is not None:
            result['RemainTimes'] = self.remain_times
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RemainTimes') is not None:
            self.remain_times = m.get('RemainTimes')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReleasePublicIpAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReleasePublicIpAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReleasePublicIpAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReleasePublicIpAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveBandwidthPackageIpsRequest(TeaModel):
    def __init__(self, bandwidth_package_id=None, client_token=None, owner_account=None, owner_id=None,
                 region_id=None, removed_ip_addresses=None, resource_owner_account=None, resource_owner_id=None):
        self.bandwidth_package_id = bandwidth_package_id  # type: str
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.removed_ip_addresses = removed_ip_addresses  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveBandwidthPackageIpsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth_package_id is not None:
            result['BandwidthPackageId'] = self.bandwidth_package_id
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.removed_ip_addresses is not None:
            result['RemovedIpAddresses'] = self.removed_ip_addresses
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BandwidthPackageId') is not None:
            self.bandwidth_package_id = m.get('BandwidthPackageId')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemovedIpAddresses') is not None:
            self.removed_ip_addresses = m.get('RemovedIpAddresses')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RemoveBandwidthPackageIpsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveBandwidthPackageIpsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveBandwidthPackageIpsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveBandwidthPackageIpsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveBandwidthPackageIpsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveBandwidthPackageIpsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the resource. Valid values of N: 1 to 20. It cannot be an empty string. The tag key can be up to 64 characters in length and cannot contain http:// or https://. It cannot start with acs: or aliyun.
        self.key = key  # type: str
        # The value of tag N of the resource. Valid values of N: 1 to 20. It can be an empty string. The tag value can be up to 128 characters in length and cannot contain http:// or https://. It cannot start with acs: or aliyun.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RemoveTagsRequest(TeaModel):
    def __init__(self, owner_id=None, region_id=None, resource_id=None, resource_owner_account=None,
                 resource_owner_id=None, resource_type=None, tag=None):
        self.owner_id = owner_id  # type: long
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource from which you want to unbind the tags. When the retrieved resources are instances, this parameter can be interpreted as InstanceId.
        self.resource_id = resource_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   disk
        # *   instance
        # *   image
        # *   securitygroup
        # *   snapshot
        # 
        # All the preceding values must be in lowercase.
        self.resource_type = resource_type  # type: str
        # The tags.
        self.tag = tag  # type: list[RemoveTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RemoveTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RemoveTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class RemoveTagsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewDedicatedHostsRequest(TeaModel):
    def __init__(self, client_token=None, dedicated_host_ids=None, owner_account=None, owner_id=None, period=None,
                 period_unit=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The IDs of dedicated hosts. You can specify the IDs of up to 100 subscription dedicated hosts. Specify dedicated host IDs as a JSON array and separate the IDs with commas (,). Example: `["dh-xxxxxxxxx", "dh-yyyyyyyyy", ... "dh-zzzzzzzzz"]`.
        self.dedicated_host_ids = dedicated_host_ids  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The renewal duration of the dedicated host. Valid values:
        # 
        # *   Valid values when the PeriodUnit parameter is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        # *   Valid values when the PeriodUnit parameter is set to Year: 1, 2, 3, 4, and 5.
        self.period = period  # type: int
        # The unit of the renewal duration. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The region ID of the dedicated host. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewDedicatedHostsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.dedicated_host_ids is not None:
            result['DedicatedHostIds'] = self.dedicated_host_ids
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DedicatedHostIds') is not None:
            self.dedicated_host_ids = m.get('DedicatedHostIds')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RenewDedicatedHostsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewDedicatedHostsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewDedicatedHostsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RenewDedicatedHostsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RenewDedicatedHostsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewDedicatedHostsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewInstanceRequest(TeaModel):
    def __init__(self, client_token=None, expected_renew_day=None, instance_id=None, owner_account=None,
                 owner_id=None, period=None, period_unit=None, resource_owner_account=None, resource_owner_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The synchronized expiration date. Set the value to a synchronized expiration date that you specified. Otherwise, the call fails. If you set this parameter, your instance will be renewed to the specified synchronized expiration date. Valid values: 1 to 28.
        # 
        # For information about how to synchronize the expiration dates of instances, see [Synchronize the expiration dates of subscription instances](~~108486~~).
        # 
        # >  The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the `ExpectedRenewDay` parameter are mutually exclusive.
        self.expected_renew_day = expected_renew_day  # type: int
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The renewal period of the subscription instance. If the `DedicatedHostId` parameter is specified, the value of Period must not exceed the subscription period of the specified dedicated host. Valid values:
        # 
        # Valid values when PeriodUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, and 12.
        # 
        # >  The renewal period-related parameter pair (`Period` and `PeriodUnit`) and the `ExpectedRenewDay` parameter are mutually exclusive.
        self.period = period  # type: int
        # The unit of the renewal period. Valid value:
        # 
        # Month
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.expected_renew_day is not None:
            result['ExpectedRenewDay'] = self.expected_renew_day
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ExpectedRenewDay') is not None:
            self.expected_renew_day = m.get('ExpectedRenewDay')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RenewInstanceResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RenewInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RenewInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewReservedInstancesRequest(TeaModel):
    def __init__(self, auto_renew=None, auto_renew_period=None, client_token=None, owner_account=None,
                 owner_id=None, period=None, period_unit=None, region_id=None, reserved_instance_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # Specifies whether to enable auto-renewal for the reserved instance. Valid values:
        # 
        # *   true: enables auto-renewal for the reserved instance.
        # *   false: does not enable auto-renewal for the reserved instance.
        # 
        # Default value: false.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal term of the reserved instance. Unit: months. This parameter takes effect only when AutoRenew is set to true.
        # 
        # *   Valid values when PeriodUnit is set to Month: 1, 12, 36, and 60. Default value: 1.
        # *   Valid values when PeriodUnit is set to Year: 12, 36, and 60. Default value: 12.
        self.auto_renew_period = auto_renew_period  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The term of the reserved instance.
        # 
        # *   Valid values when `PeriodUnit` is set to `Year`: 1, 3, and 5.
        # *   Valid values when `PeriodUnit` is set to `Month`: 1.
        # 
        # Default value: 1.
        self.period = period  # type: int
        # The unit of the term of the reserved instance.
        # 
        # Valid values: Year and Month.
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the reserved instance.
        self.reserved_instance_id = reserved_instance_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewReservedInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class RenewReservedInstancesResponseBodyReservedInstanceIdSets(TeaModel):
    def __init__(self, reserved_instance_id=None):
        self.reserved_instance_id = reserved_instance_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewReservedInstancesResponseBodyReservedInstanceIdSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.reserved_instance_id is not None:
            result['ReservedInstanceId'] = self.reserved_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ReservedInstanceId') is not None:
            self.reserved_instance_id = m.get('ReservedInstanceId')
        return self


class RenewReservedInstancesResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None, reserved_instance_id_sets=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The IDs of the reserved instances.
        self.reserved_instance_id_sets = reserved_instance_id_sets  # type: RenewReservedInstancesResponseBodyReservedInstanceIdSets

    def validate(self):
        if self.reserved_instance_id_sets:
            self.reserved_instance_id_sets.validate()

    def to_map(self):
        _map = super(RenewReservedInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.reserved_instance_id_sets is not None:
            result['ReservedInstanceIdSets'] = self.reserved_instance_id_sets.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ReservedInstanceIdSets') is not None:
            temp_model = RenewReservedInstancesResponseBodyReservedInstanceIdSets()
            self.reserved_instance_id_sets = temp_model.from_map(m['ReservedInstanceIdSets'])
        return self


class RenewReservedInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RenewReservedInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RenewReservedInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewReservedInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReplaceSystemDiskRequestSystemDisk(TeaModel):
    def __init__(self, size=None):
        # The capacity of the new system disk. Unit: GiB. Valid values: Max{20, Size of the image specified by ImageId} to 500.
        # 
        # Default value: Max{40, Size of the image specified by ImageId}.
        # 
        # > If the capacity of the new system disk exceeds `Max{20, Capacity of the original system disk}`, you are charged for excess capacity.
        self.size = size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReplaceSystemDiskRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class ReplaceSystemDiskRequestArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # > This parameter is unavailable.
        self.assume_role_for = assume_role_for  # type: long
        # > This parameter is unavailable.
        self.role_type = role_type  # type: str
        # > This parameter is unavailable.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReplaceSystemDiskRequestArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class ReplaceSystemDiskRequest(TeaModel):
    def __init__(self, system_disk=None, architecture=None, arn=None, client_token=None, disk_id=None,
                 encrypt_algorithm=None, encrypted=None, image_id=None, instance_id=None, kmskey_id=None, key_pair_name=None,
                 owner_account=None, owner_id=None, password=None, password_inherit=None, platform=None,
                 resource_owner_account=None, resource_owner_id=None, security_enhancement_strategy=None, use_additional_service=None):
        self.system_disk = system_disk  # type: ReplaceSystemDiskRequestSystemDisk
        # The system architecture. Valid values:
        # 
        # *   i386
        # *   x86\_64
        self.architecture = architecture  # type: str
        # This parameter is unavailable.
        self.arn = arn  # type: list[ReplaceSystemDiskRequestArn]
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the disk.
        # 
        # If the `ImageId` parameter is not specified, this parameter is required.
        # 
        # If the DiskId parameter is specified, the `Platform` and `Architecture` parameters are required. The specified values of `Platform` and `Architecture` must be consistent with those of `Platform` and `Architecture` of the instance.
        # 
        # > This feature is in invitational preview. To use this feature, [submit a ticket](https://selfservice.console.aliyun.com/ticket/createIndex).
        self.disk_id = disk_id  # type: str
        # > This parameter is unavailable.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt the disk. Valid values:
        # 
        # *   true: encrypts the disk.
        # *   false: does not encrypt the disk.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: bool
        # The ID of the image.
        # 
        # If the `DiskId` parameter is not specified, this parameter is required.
        self.image_id = image_id  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the Key Management Service (KMS) key to use for the system disk.
        self.kmskey_id = kmskey_id  # type: str
        # The name of the key pair.
        # 
        # > This parameter is applicable only to Linux instances. You can bind an SSH key pair to the instance as a logon credential. After the SSH key pair is bound, the username and password-based logon method is disabled for the instance.
        self.key_pair_name = key_pair_name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Specifies whether to reset the password for the instance. The password must be 8 to 30 characters in length and must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        #     ( ) ` ~ ! @ # $ % ^ & * - _ + = | { } [ ] : ; \" < > , . ? /\
        # 
        # The password of a Windows instance cannot start with a forward slash (/).
        # 
        # This parameter is empty by default, which indicates that the current password remains unchanged.
        # 
        # > If the `Password` parameter is specified, we recommend that you send requests over HTTPS to prevent password leaks.
        self.password = password  # type: str
        # Specifies whether to use the password preset in the image.
        # 
        # Default value: false.
        # 
        # > If the PasswordInherit parameter is specified, you must leave the Password parameter empty and make sure that the selected image has a password preset.
        self.password_inherit = password_inherit  # type: bool
        # The operating system distribution. Valid values:
        # 
        # *   CentOS
        # *   Ubuntu
        self.platform = platform  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to activate Security Center for free after the system disk is replaced. Valid values:
        # 
        # *   Active: Security Center is activated for free after the system disk is replaced. This value supports only public images.
        # *   Deactive: Security Center is not activated for free after the system disk is replaced. This value supports all images.
        # 
        # Default value: Deactive.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # Specifies whether to use the system configurations for virtual machines provided by Alibaba Cloud (Windows: NTP and KMS. Linux: NTP and YUM).
        # 
        # > This parameter takes effect only when you attach a system disk whose device name is /dev/xvda.
        self.use_additional_service = use_additional_service  # type: bool

    def validate(self):
        if self.system_disk:
            self.system_disk.validate()
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ReplaceSystemDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.architecture is not None:
            result['Architecture'] = self.architecture
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.use_additional_service is not None:
            result['UseAdditionalService'] = self.use_additional_service
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SystemDisk') is not None:
            temp_model = ReplaceSystemDiskRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Architecture') is not None:
            self.architecture = m.get('Architecture')
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = ReplaceSystemDiskRequestArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('UseAdditionalService') is not None:
            self.use_additional_service = m.get('UseAdditionalService')
        return self


class ReplaceSystemDiskResponseBody(TeaModel):
    def __init__(self, disk_id=None, request_id=None):
        # The ID of the new system disk.
        self.disk_id = disk_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReplaceSystemDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReplaceSystemDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReplaceSystemDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReplaceSystemDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReplaceSystemDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ReportInstancesStatusRequest(TeaModel):
    def __init__(self, description=None, device=None, disk_id=None, end_time=None, instance_id=None,
                 issue_category=None, owner_account=None, owner_id=None, reason=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, start_time=None):
        # The detailed description of the exception.
        self.description = description  # type: str
        self.device = device  # type: list[str]
        self.disk_id = disk_id  # type: list[str]
        # The end time of the instance exception. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.end_time = end_time  # type: str
        self.instance_id = instance_id  # type: list[str]
        # The category of the exception. This parameter is applicable only to ECS bare metal instances. Valid values:
        # 
        # *   hardware-cpu-error: CPU failure
        # *   hardware-motherboard-error: motherboard failure
        # *   hardware-mem-error: memory failure
        # *   hardware-power-error: power failure
        # *   hardware-disk-error: disk failure
        # *   hardware-networkcard-error: network interface controller (NIC) failure
        # *   hardware-raidcard-error: SAS/RAID card failure
        # *   hardware-fan-error: fan failure
        # *   others: other failures
        self.issue_category = issue_category  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The reason why the exception occurs to the ECS instance. Valid values:
        # 
        # *   instance-hang: The instance is unavailable or cannot be connected.
        # *   instance-stuck-in-status: The instance is stuck in a state such as Starting or Stopping.
        # *   abnormal-network: The instance has a network exception.
        # *   abnormal-local-disk: A local disk attached to the instance has an exception.
        # *   abnormal-cloud-disk: A disk or a Shared Block Storage device attached to the instance has an exception.
        # *   others: other exception types. If the exception is not of the preceding types, you can set `Reason` to others and specify the `Description` parameter.
        self.reason = reason  # type: str
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The start time of the instance exception. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReportInstancesStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.issue_category is not None:
            result['IssueCategory'] = self.issue_category
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('IssueCategory') is not None:
            self.issue_category = m.get('IssueCategory')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ReportInstancesStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ReportInstancesStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ReportInstancesStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ReportInstancesStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ReportInstancesStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ReportInstancesStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetDiskRequest(TeaModel):
    def __init__(self, disk_id=None, dry_run=None, owner_account=None, owner_id=None, resource_owner_account=None,
                 resource_owner_id=None, snapshot_id=None):
        # The ID of the disk that you want to restore.
        self.disk_id = disk_id  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include the required parameters, request format, and resource state limits. If the check fails, the corresponding error message is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the snapshot that you want to use to restore the disk.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class ResetDiskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetDisksRequestDisk(TeaModel):
    def __init__(self, disk_id=None, snapshot_id=None):
        # The ID of disk N to be rolled back. Valid values of N: 1 to 10.
        self.disk_id = disk_id  # type: str
        # The ID of the snapshot contained in the instance snapshot for disk N. Valid values of N: 1 to 10.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDisksRequestDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class ResetDisksRequest(TeaModel):
    def __init__(self, disk=None, dry_run=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # 云盘列表。
        self.disk = disk  # type: list[ResetDisksRequestDisk]
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include the required parameters, request format, and resource status limits. If the check fails, the corresponding error message is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.disk:
            for k in self.disk:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ResetDisksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Disk'] = []
        if self.disk is not None:
            for k in self.disk:
                result['Disk'].append(k.to_map() if k else None)
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.disk = []
        if m.get('Disk') is not None:
            for k in m.get('Disk'):
                temp_model = ResetDisksRequestDisk()
                self.disk.append(temp_model.from_map(k))
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem(TeaModel):
    def __init__(self, name=None, value=None):
        # The name of the resource.
        self.name = name  # type: str
        # The ID of the resource.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet(TeaModel):
    def __init__(self, related_item=None):
        self.related_item = related_item  # type: list[ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem]

    def validate(self):
        if self.related_item:
            for k in self.related_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RelatedItem'] = []
        if self.related_item is not None:
            for k in self.related_item:
                result['RelatedItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.related_item = []
        if m.get('RelatedItem') is not None:
            for k in m.get('RelatedItem'):
                temp_model = ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSetRelatedItem()
                self.related_item.append(temp_model.from_map(k))
        return self


class ResetDisksResponseBodyOperationProgressSetOperationProgress(TeaModel):
    def __init__(self, error_code=None, error_msg=None, operation_status=None, related_item_set=None):
        # The error code. This parameter is empty when the operation was successful.
        # 
        # For information about error codes and error messages, visit the [API error center](https://error-center.alibabacloud.com/status/product/Ecs).
        self.error_code = error_code  # type: str
        # The error message. This parameter is empty when the operation was successful.
        # 
        # For information about error codes and error messages, visit the [API error center](https://error-center.alibabacloud.com/status/product/Ecs).
        self.error_msg = error_msg  # type: str
        # Indicates whether the operation was successful.
        # 
        # If the operation was successful, a value of Success is returned. If the operation failed, an error code and an error message are returned.
        self.operation_status = operation_status  # type: str
        # Detail about the resources.
        self.related_item_set = related_item_set  # type: ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet

    def validate(self):
        if self.related_item_set:
            self.related_item_set.validate()

    def to_map(self):
        _map = super(ResetDisksResponseBodyOperationProgressSetOperationProgress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_msg is not None:
            result['ErrorMsg'] = self.error_msg
        if self.operation_status is not None:
            result['OperationStatus'] = self.operation_status
        if self.related_item_set is not None:
            result['RelatedItemSet'] = self.related_item_set.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorMsg') is not None:
            self.error_msg = m.get('ErrorMsg')
        if m.get('OperationStatus') is not None:
            self.operation_status = m.get('OperationStatus')
        if m.get('RelatedItemSet') is not None:
            temp_model = ResetDisksResponseBodyOperationProgressSetOperationProgressRelatedItemSet()
            self.related_item_set = temp_model.from_map(m['RelatedItemSet'])
        return self


class ResetDisksResponseBodyOperationProgressSet(TeaModel):
    def __init__(self, operation_progress=None):
        self.operation_progress = operation_progress  # type: list[ResetDisksResponseBodyOperationProgressSetOperationProgress]

    def validate(self):
        if self.operation_progress:
            for k in self.operation_progress:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ResetDisksResponseBodyOperationProgressSet, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OperationProgress'] = []
        if self.operation_progress is not None:
            for k in self.operation_progress:
                result['OperationProgress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.operation_progress = []
        if m.get('OperationProgress') is not None:
            for k in m.get('OperationProgress'):
                temp_model = ResetDisksResponseBodyOperationProgressSetOperationProgress()
                self.operation_progress.append(temp_model.from_map(k))
        return self


class ResetDisksResponseBody(TeaModel):
    def __init__(self, operation_progress_set=None, request_id=None):
        # Details about the rollback operation.
        self.operation_progress_set = operation_progress_set  # type: ResetDisksResponseBodyOperationProgressSet
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.operation_progress_set:
            self.operation_progress_set.validate()

    def to_map(self):
        _map = super(ResetDisksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_progress_set is not None:
            result['OperationProgressSet'] = self.operation_progress_set.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationProgressSet') is not None:
            temp_model = ResetDisksResponseBodyOperationProgressSet()
            self.operation_progress_set = temp_model.from_map(m['OperationProgressSet'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetDisksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetDisksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetDisksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetDisksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResizeDiskRequest(TeaModel):
    def __init__(self, client_token=None, disk_id=None, new_size=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, type=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the disk. You can call the [DescribeDisks](~~25514~~) operation to query available disk IDs.
        self.disk_id = disk_id  # type: str
        # The new disk capacity. Unit: GiB. Valid values:
        # 
        # *   System disk: 20 to 500.
        # 
        # *   Data disk:
        # 
        #     *   Ultra disk (cloud_efficiency): 20 to 32768.
        # 
        #     *   Standard SSD (cloud_ssd): 20 to 32768.
        # 
        #     *   ESSD (cloud_essd): Valid values when the NewSize parameter is set to cloud_essd depend on the `PerformanceLevel` value. You can call the [DescribeDisks](~~25514~~) operation to query disk information and check the `PerformanceLevel` parameter in the response.
        # 
        #         *   Valid values when the PerformanceLevel parameter is set to PL0: 40 to 32768.
        #         *   Valid values when the PerformanceLevel parameter is set to PL1: 20 to 32768.
        #         *   Valid values when the PerformanceLevel parameter is set to PL2: 461 to 32768.
        #         *   Valid values when the PerformanceLevel parameter is set to PL3: 1261 to 32768.
        # 
        #     *   Basic disk (cloud): 5 to 2000.
        # 
        # The new disk capacity must be greater than the original disk capacity.
        self.new_size = new_size  # type: int
        self.owner_account = owner_account  # type: str
        # RAM用户的虚拟账号ID。
        self.owner_id = owner_id  # type: long
        # 资源主账号的账号名称。
        self.resource_owner_account = resource_owner_account  # type: str
        # 资源主账号的ID，亦即UID。
        self.resource_owner_id = resource_owner_id  # type: long
        # The method to use to resize the disk. Default value: offline. Valid values:
        # 
        # *   offline: resizes the disk offline. After you resize a disk offline, you must restart its associated instance by using the ECS console or by calling the [RebootInstance](~~25502~~) operation to make the resizing operation take effect. For information about how to restart an ECS instance in the ECS console, see [Restart an instance](~~25440~~).
        # *   online: resizes the disk online. After you resize a disk online, the resizing operation takes effect immediately and you do not need to restart the instance. You can resize ultra disks, standard SSDs, and ESSDs online.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResizeDiskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.new_size is not None:
            result['NewSize'] = self.new_size
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('NewSize') is not None:
            self.new_size = m.get('NewSize')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ResizeDiskResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        # 
        # >  This parameter is returned only when subscription disks are resized.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResizeDiskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResizeDiskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResizeDiskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResizeDiskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResizeDiskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeSecurityGroupRequestPermissions(TeaModel):
    def __init__(self, description=None, dest_cidr_ip=None, ip_protocol=None, ipv_6dest_cidr_ip=None,
                 ipv_6source_cidr_ip=None, nic_type=None, policy=None, port_range=None, priority=None, source_cidr_ip=None,
                 source_group_id=None, source_group_owner_account=None, source_group_owner_id=None, source_port_range=None,
                 source_prefix_list_id=None):
        # The description of security group rule N. The description must be 1 to 512 characters in length.
        # 
        # Valid values of N: 1 to 100.
        self.description = description  # type: str
        # The destination IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The transport layer protocol of security group rule N. The value of this parameter is case-insensitive. Valid values:
        # 
        # *   TCP
        # *   UDP
        # *   ICMP
        # *   ICMPv6
        # *   GRE
        # *   ALL: All protocols are supported.
        # 
        # Valid values of N: 1 to 100.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6DestCidrIp parameter is valid only when the destination is ECS instances that reside in VPCs and support IPv6 CIDR blocks. You cannot specify both this parameter and the `DestCidrIp` parameter.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6SourceCidrIp parameter is valid only when the source is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `SourceCidrIp` parameter.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of security group rule N when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # *   intranet: internal NIC
        # 
        # If the security group is in a VPC, this parameter is set to intranet by default and cannot be modified.
        # 
        # If you specify only `SourceGroupId` when you configure access between security groups, this parameter must be set to intranet.
        # 
        # Default value: internet.
        # 
        # Valid values of N: 1 to 100.
        self.nic_type = nic_type  # type: str
        # The action of security group rule N that determines whether to allow inbound access. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses. In this case, the request times out or the connection cannot be established.
        # 
        # Default value: accept.
        # 
        # Valid values of N: 1 to 100.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # Valid values of N: 1 to 100.
        self.port_range = port_range  # type: str
        # The priority of security group rule N. A smaller value indicates a higher priority. Valid values: 1 to 100.
        # 
        # Default value: 1.
        # 
        # Valid values of N: 1 to 100.
        self.priority = priority  # type: str
        # The source IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The ID of the source security group that is referenced in security group rule N.
        # 
        # *   At lease one of `SourceGroupId`, `SourceCidrIp`, `Ipv6SourceCidrIp`, and `SourcePrefixListId` must be specified.
        # *   If `SourceGroupId` is specified but `SourceCidrIp` or `Ipv6SourceCidrIp` is not specified, the NicType parameter must be set to intranet.
        # *   If both `SourceGroupId` and `SourceCidrIp` are specified, `SourceCidrIp` takes precedence.
        # 
        # Take note of the following items:
        # 
        # *   For advanced security groups, security groups cannot be used as authorization objects.
        # *   For each basic security group, a maximum of 20 security groups can be used as authorization objects.
        # 
        # Valid values of N: 1 to 100.
        self.source_group_id = source_group_id  # type: str
        # The Alibaba Cloud account that manages the source security group when you delete security group rule N across accounts.
        # 
        # *   If both `SourceGroupOwnerAccount` and `SourceGroupOwnerId` are not specified, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerAccount` parameter is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # The ID of the Alibaba Cloud account that manages the source security group when you delete security group rule N across accounts.
        # 
        # *   If both `SourceGroupOwnerId` and `SourceGroupOwnerAccount` are not specified, access permissions are configured for another security group managed by your account.
        # *   If `SourceCidrIp` is specified, the `SourceGroupOwnerId` parameter is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.source_group_owner_id = source_group_owner_id  # type: long
        # The range of source ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_port_range = source_port_range  # type: str
        # The ID of the source prefix list that is referenced in security group rule N. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # Take note of the following items:
        # 
        # *   If a security group is in the classic network, you cannot reference prefix lists in the security group rules. For information about the limits on security groups and prefix lists, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # *   If you specify the `SourceCidrIp`, `Ipv6SourceCidrIp`, or `SourceGroupId` parameter, this parameter is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.source_prefix_list_id = source_prefix_list_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeSecurityGroupRequestPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_group_owner_id is not None:
            result['SourceGroupOwnerId'] = self.source_group_owner_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourceGroupOwnerId') is not None:
            self.source_group_owner_id = m.get('SourceGroupOwnerId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        return self


class RevokeSecurityGroupRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, permissions=None,
                 policy=None, port_range=None, priority=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None, security_group_rule_id=None, source_cidr_ip=None,
                 source_group_id=None, source_group_owner_account=None, source_group_owner_id=None, source_port_range=None,
                 source_prefix_list_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # This parameter is discontinued. Use `Permissions.N.Description` to specify the description of security group rule N.
        self.description = description  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestCidrIp` to specify the destination IPv4 CIDR block.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.IpProtocol` to specify the transport layer protocol.
        self.ip_protocol = ip_protocol  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6DestCidrIp` to specify the destination IPv6 CIDR block.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6SourceCidrIp` to specify the source IPv6 CIDR block.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.NicType` to specify the NIC type.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.permissions = permissions  # type: list[RevokeSecurityGroupRequestPermissions]
        # This parameter is discontinued. Use `Permissions.N.Policy` to specify whether to accept inbound access.
        self.policy = policy  # type: str
        # This parameter is discontinued. Use `Permissions.N.PortRange` to specify the range of destination ports.
        self.port_range = port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.Priority` to specify the rule priority.
        self.priority = priority  # type: str
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        self.security_group_rule_id = security_group_rule_id  # type: list[str]
        # This parameter is discontinued. Use `Permissions.N.SourceCidrIp` to specify the source IPv4 CIDR block.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupId` to specify the ID of the source security group.
        self.source_group_id = source_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupOwnerAccount` to specify the Alibaba Cloud account that manages the source security group.
        self.source_group_owner_account = source_group_owner_account  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourceGroupOwnerId` to specify the ID of the Alibaba Cloud account that manages the source security group.
        self.source_group_owner_id = source_group_owner_id  # type: long
        # This parameter is discontinued. Use `Permissions.N.SourcePortRange` to specify the range of source ports.
        self.source_port_range = source_port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourcePrefixListId`to specify the ID of the source prefix list.
        self.source_prefix_list_id = source_prefix_list_id  # type: str

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RevokeSecurityGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['Permissions'].append(k.to_map() if k else None)
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_rule_id is not None:
            result['SecurityGroupRuleId'] = self.security_group_rule_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_group_id is not None:
            result['SourceGroupId'] = self.source_group_id
        if self.source_group_owner_account is not None:
            result['SourceGroupOwnerAccount'] = self.source_group_owner_account
        if self.source_group_owner_id is not None:
            result['SourceGroupOwnerId'] = self.source_group_owner_id
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        if self.source_prefix_list_id is not None:
            result['SourcePrefixListId'] = self.source_prefix_list_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.permissions = []
        if m.get('Permissions') is not None:
            for k in m.get('Permissions'):
                temp_model = RevokeSecurityGroupRequestPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupRuleId') is not None:
            self.security_group_rule_id = m.get('SecurityGroupRuleId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourceGroupId') is not None:
            self.source_group_id = m.get('SourceGroupId')
        if m.get('SourceGroupOwnerAccount') is not None:
            self.source_group_owner_account = m.get('SourceGroupOwnerAccount')
        if m.get('SourceGroupOwnerId') is not None:
            self.source_group_owner_id = m.get('SourceGroupOwnerId')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        if m.get('SourcePrefixListId') is not None:
            self.source_prefix_list_id = m.get('SourcePrefixListId')
        return self


class RevokeSecurityGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeSecurityGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeSecurityGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RevokeSecurityGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RevokeSecurityGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeSecurityGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeSecurityGroupEgressRequestPermissions(TeaModel):
    def __init__(self, description=None, dest_cidr_ip=None, dest_group_id=None, dest_group_owner_account=None,
                 dest_group_owner_id=None, dest_prefix_list_id=None, ip_protocol=None, ipv_6dest_cidr_ip=None,
                 ipv_6source_cidr_ip=None, nic_type=None, policy=None, port_range=None, priority=None, source_cidr_ip=None,
                 source_port_range=None):
        # The description of security group rule N. The description must be 1 to 512 characters in length.
        # 
        # Valid values of N: 1 to 100.
        self.description = description  # type: str
        # The destination IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # The ID of the source security group that is referenced in security group rule N.
        # 
        # *   At least one of `DestGroupId`, `DestCidrIp`, `Ipv6DestCidrIp`, and `DestPrefixListId` must be specified.
        # *   If `DestGroupId` is specified but `DestCidrIp` is not specified, the `NicType` parameter must be set to intranet.
        # *   If both `DestGroupId` and `DestCidrIp` are specified, `DestCidrIp` takes precedence.
        # 
        # Take note of the following items:
        # 
        # *   For advanced security groups, security groups cannot be used as authorization objects.
        # *   For each basic security group, a maximum of 20 security groups can be used as authorization objects.
        # 
        # Valid values of N: 1 to 100.
        self.dest_group_id = dest_group_id  # type: str
        # The Alibaba Cloud account that manages the destination security group when you delete security group rules N across accounts.
        # 
        # *   If both `DestGroupOwnerAccount` and `DestGroupOwnerId` are not specified, the access control is revoked from another security group managed by your account.
        # *   If `DestCidrIp` is specified, `DestGroupOwnerAccount` is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # The Alibaba Cloud account that manages the destination security group when you delete security group rule N across accounts.
        # 
        # *   If both `DestGroupOwnerId` and `DestGroupOwnerAccount` are not specified, the access control is revoked from another security group managed by your account.
        # *   If `DestCidrIp` is specified, `DestGroupOwnerId` is invalid.
        # 
        # Valid values of N: 1 to 100.
        self.dest_group_owner_id = dest_group_owner_id  # type: str
        # The ID of the destination prefix list that is referenced in security group rule N. You can call the [DescribePrefixLists](~~205046~~) operation to query the IDs of available prefix lists.
        # 
        # Take note of the following items:
        # 
        # *   If a security group is in the classic network, you cannot reference prefix lists in the security group rules. For information about the limits on security groups and prefix lists, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # *   If you specify `DestCidrIp`, `Ipv6DestCidrIp`, or `DestGroupId`, Permissions.N.DestPrefixListId is ignored.
        # 
        # Valid values of N: 1 to 100.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # The transport layer protocol of security group rule N. The value of this parameter is case-insensitive. Valid values:
        # 
        # *   TCP
        # *   UDP
        # *   ICMP
        # *   ICMPv6
        # *   GRE
        # *   ALL: All protocols are supported.
        # 
        # Valid values of N: 1 to 100.
        self.ip_protocol = ip_protocol  # type: str
        # The destination IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6DestCidrIp parameter is valid only when the destination is ECS instances that reside in virtual private clouds (VPCs) and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `DestCidrIp` parameter.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # The source IPv6 CIDR block for security group rule N. CIDR blocks and IPv6 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  The Permissions.N.Ipv6SourceCidrIp parameter is valid only when the source is ECS instances that reside in VPCs and that support IPv6 CIDR blocks. You cannot specify both this parameter and the `DestCidrIp` parameter.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # The network interface controller (NIC) type of security group rule N when the security group is in the classic network. Valid values:
        # 
        # *   internet: public NIC
        # *   intranet: internal NIC
        # 
        # If the security group is in a VPC, this parameter is set to intranet by default and cannot be modified.
        # 
        # If you specify only `SourceGroupId` when you configure access between security groups, this parameter must be set to intranet.
        # 
        # Default value: internet.
        # 
        # Valid values of N: 1 to 100.
        self.nic_type = nic_type  # type: str
        # The action of security group rule N that determines whether to allow outbound access. Valid values:
        # 
        # *   accept: allows access.
        # *   drop: denies access and returns no responses. In this case, the request times out or the connection cannot be established.
        # 
        # Default value: accept.
        # 
        # Valid values of N: 1 to 100.
        self.policy = policy  # type: str
        # The range of destination ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # Valid values of N: 1 to 100.
        self.port_range = port_range  # type: str
        # The priority of security group rule N. A smaller value indicates a higher priority. Valid values: 1 to 100.
        # 
        # Default value: 1.
        # 
        # Valid values of N: 1 to 100.
        self.priority = priority  # type: str
        # The source IPv4 CIDR block for security group rule N. CIDR blocks and IPv4 addresses are supported.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # The range of source ports that correspond to the transport layer protocol for security group rule N. Valid values:
        # 
        # *   When the Permissions.N.IpProtocol parameter is set to TCP or UDP, the port number range is 1 to 65535. Specify a port range in the format of \<Start port number>/\<End port number>. Example: 1/200.
        # *   When the Permissions.N.IpProtocol parameter is set to ICMP, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to GRE, the port number range is -1/-1, which indicates all ports.
        # *   When the Permissions.N.IpProtocol parameter is set to ALL, the port number range is -1/-1, which indicates all ports.
        # 
        # This parameter is specified to meet quintuple rules. For more information, see [Security group quintuple rules](~~97439~~).
        # 
        # Valid values of N: 1 to 100.
        self.source_port_range = source_port_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeSecurityGroupEgressRequestPermissions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_group_owner_id is not None:
            result['DestGroupOwnerId'] = self.dest_group_owner_id
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestGroupOwnerId') is not None:
            self.dest_group_owner_id = m.get('DestGroupOwnerId')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class RevokeSecurityGroupEgressRequest(TeaModel):
    def __init__(self, client_token=None, description=None, dest_cidr_ip=None, dest_group_id=None,
                 dest_group_owner_account=None, dest_group_owner_id=None, dest_prefix_list_id=None, ip_protocol=None,
                 ipv_6dest_cidr_ip=None, ipv_6source_cidr_ip=None, nic_type=None, owner_account=None, owner_id=None, permissions=None,
                 policy=None, port_range=None, priority=None, region_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_group_id=None, security_group_rule_id=None, source_cidr_ip=None,
                 source_port_range=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # This parameter is discontinued. Use `Permissions.N.Description` to specify the description of security group rule N.
        self.description = description  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestCidrIp` to specify the destination IPv4 CIDR block.
        self.dest_cidr_ip = dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupId` to specify the ID of the destination security group.
        self.dest_group_id = dest_group_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupOwnerAccount` to specify the Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_account = dest_group_owner_account  # type: str
        # This parameter is discontinued. Use `Permissions.N.DestGroupOwnerId` to specify the ID of the Alibaba Cloud account that manages the destination security group.
        self.dest_group_owner_id = dest_group_owner_id  # type: long
        # This parameter is discontinued. Use `Permissions.N.DestPrefixListId` to specify the ID of the destination prefix list.
        self.dest_prefix_list_id = dest_prefix_list_id  # type: str
        # This parameter is discontinued. Use `Permissions.N.IpProtocol` to specify the transport layer protocol.
        self.ip_protocol = ip_protocol  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6DestCidrIp` to specify the destination IPv6 CIDR block.
        self.ipv_6dest_cidr_ip = ipv_6dest_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.Ipv6SourceCidrIp` to specify the source IPv6 CIDR block.
        self.ipv_6source_cidr_ip = ipv_6source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.NicType` to specify the NIC type.
        self.nic_type = nic_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # Details about the security group rules.
        self.permissions = permissions  # type: list[RevokeSecurityGroupEgressRequestPermissions]
        # This parameter is discontinued. Use `Permissions.N.Policy` to specify whether to allow outbound access.
        self.policy = policy  # type: str
        # This parameter is discontinued. Use `Permissions.N.PortRange` to specify the range of destination ports.
        self.port_range = port_range  # type: str
        # This parameter is discontinued. Use `Permissions.N.Priority` to specify the rule priority.
        self.priority = priority  # type: str
        # The region ID of the security group. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the security group.
        self.security_group_id = security_group_id  # type: str
        # The IDs of security group rules. You can specify up to 100 rule IDs.
        # 
        # When you revoke security group egress by security group rule ID, the parameter is required.
        self.security_group_rule_id = security_group_rule_id  # type: list[str]
        # This parameter is discontinued. Use `Permissions.N.SourceCidrIp` to specify the source IPv4 CIDR block.
        self.source_cidr_ip = source_cidr_ip  # type: str
        # This parameter is discontinued. Use `Permissions.N.SourcePortRange` to specify the range of source ports.
        self.source_port_range = source_port_range  # type: str

    def validate(self):
        if self.permissions:
            for k in self.permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RevokeSecurityGroupEgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.description is not None:
            result['Description'] = self.description
        if self.dest_cidr_ip is not None:
            result['DestCidrIp'] = self.dest_cidr_ip
        if self.dest_group_id is not None:
            result['DestGroupId'] = self.dest_group_id
        if self.dest_group_owner_account is not None:
            result['DestGroupOwnerAccount'] = self.dest_group_owner_account
        if self.dest_group_owner_id is not None:
            result['DestGroupOwnerId'] = self.dest_group_owner_id
        if self.dest_prefix_list_id is not None:
            result['DestPrefixListId'] = self.dest_prefix_list_id
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.ipv_6dest_cidr_ip is not None:
            result['Ipv6DestCidrIp'] = self.ipv_6dest_cidr_ip
        if self.ipv_6source_cidr_ip is not None:
            result['Ipv6SourceCidrIp'] = self.ipv_6source_cidr_ip
        if self.nic_type is not None:
            result['NicType'] = self.nic_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        result['Permissions'] = []
        if self.permissions is not None:
            for k in self.permissions:
                result['Permissions'].append(k.to_map() if k else None)
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_rule_id is not None:
            result['SecurityGroupRuleId'] = self.security_group_rule_id
        if self.source_cidr_ip is not None:
            result['SourceCidrIp'] = self.source_cidr_ip
        if self.source_port_range is not None:
            result['SourcePortRange'] = self.source_port_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DestCidrIp') is not None:
            self.dest_cidr_ip = m.get('DestCidrIp')
        if m.get('DestGroupId') is not None:
            self.dest_group_id = m.get('DestGroupId')
        if m.get('DestGroupOwnerAccount') is not None:
            self.dest_group_owner_account = m.get('DestGroupOwnerAccount')
        if m.get('DestGroupOwnerId') is not None:
            self.dest_group_owner_id = m.get('DestGroupOwnerId')
        if m.get('DestPrefixListId') is not None:
            self.dest_prefix_list_id = m.get('DestPrefixListId')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Ipv6DestCidrIp') is not None:
            self.ipv_6dest_cidr_ip = m.get('Ipv6DestCidrIp')
        if m.get('Ipv6SourceCidrIp') is not None:
            self.ipv_6source_cidr_ip = m.get('Ipv6SourceCidrIp')
        if m.get('NicType') is not None:
            self.nic_type = m.get('NicType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        self.permissions = []
        if m.get('Permissions') is not None:
            for k in m.get('Permissions'):
                temp_model = RevokeSecurityGroupEgressRequestPermissions()
                self.permissions.append(temp_model.from_map(k))
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupRuleId') is not None:
            self.security_group_rule_id = m.get('SecurityGroupRuleId')
        if m.get('SourceCidrIp') is not None:
            self.source_cidr_ip = m.get('SourceCidrIp')
        if m.get('SourcePortRange') is not None:
            self.source_port_range = m.get('SourcePortRange')
        return self


class RevokeSecurityGroupEgressResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeSecurityGroupEgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeSecurityGroupEgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RevokeSecurityGroupEgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RevokeSecurityGroupEgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeSecurityGroupEgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunCommandRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the command. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the command. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunCommandRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RunCommandRequest(TeaModel):
    def __init__(self, command_content=None, container_id=None, container_name=None, content_encoding=None,
                 description=None, enable_parameter=None, frequency=None, instance_id=None, keep_command=None, name=None,
                 owner_account=None, owner_id=None, parameters=None, region_id=None, repeat_mode=None, resource_group_id=None,
                 resource_owner_account=None, resource_owner_id=None, tag=None, timed=None, timeout=None, type=None, username=None,
                 windows_password_name=None, working_dir=None):
        # The content of the command. The command content can be plaintext or Base64-encoded. Take note of the following items:
        # 
        # *   If you want to retain the command, make sure that the Base64-encoded command content does not exceed 18 KB in size. If you do not want to retain the command, make sure that the Base64-encoded command content does not exceed 24 KB in size. You can set `KeepCommand` to specify whether to retain the command.
        # 
        # *   If the command content is Base64-encoded, set `ContentEncoding` to Base64.
        # 
        # *   When `EnableParameter` is set to true, the custom parameter feature is enabled and you can configure custom parameters based on the following rules:
        # 
        #     *   Define custom parameters in the `{{}}` format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
        #     *   The number of custom parameters cannot exceed 20.
        #     *   A custom parameter name can contain only letters, digits, underscores (\_), and hyphens (-). The name is case-insensitive.
        #     *   Each custom parameter name cannot exceed 64 bytes in length.
        # 
        # *   You can specify built-in environment parameters as custom parameters. Then, when you run the command, the parameters are automatically specified by Cloud Assistant. You can specify the following built-in environment parameters:
        # 
        #     *   `{{ACS::RegionId}}`: the ID of the region.
        # 
        #     *   `{{ACS::AccountId}}`: the UID of the Alibaba Cloud account.
        # 
        #     *   `{{ACS::InstanceId}}`: the ID of the instance. If you want to run the command on multiple instances and specify `{{ACS::InstanceId}}` as a built-in environment parameter, make sure that the Cloud Assistant client is not earlier than the following version:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::InstanceName}}`: the name of the instance. If you want to run the command on multiple instances and specify `{{ACS::InstanceName}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.344
        #         *   Windows: 2.1.3.344
        # 
        #     *   `{{ACS::InvokeId}}`: the ID of the command task. If you want to specify `{{ACS::InvokeId}}` as a built-in environment parameter, make sure that the Cloud Assistant client is not earlier than the following version:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::CommandId}}`: the ID of the command. If you want to specify `{{ACS::CommandId}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        self.command_content = command_content  # type: str
        # The ID of the container. Only 64-bit hexadecimal strings are supported. Container IDs that are prefixed with `docker://`, `containerd://`, or `cri-o://` are allowed to specify container runtimes.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # *   If this parameter is specified, the specified `Username` and `WorkingDir` parameters do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_id = container_id  # type: str
        # The name of the container.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # *   If this parameter is specified, the specified `Username` and `WorkingDir` parameters do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_name = container_name  # type: str
        # The encoding mode of command content (`CommandContent`). The valid values are case-insensitive. Valid values:
        # 
        # *   PlainText: The command content is not encoded.
        # *   Base64: The command content is encoded in Base64.
        # 
        # Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        self.content_encoding = content_encoding  # type: str
        # The description of the command. The description supports all character sets and can be up to 512 characters in length.
        self.description = description  # type: str
        # Specifies whether to include custom parameters in the command.
        # 
        # Default value: false.
        self.enable_parameter = enable_parameter  # type: bool
        # The schedule on which to run the command. You must specify this parameter when you set `Timed` to `true`. You can specify a schedule to run the command at a fixed interval based on a rate expression, only once at a specified time, or at designated times based on a cron expression.
        # 
        # *   Run at Fixed Interval: To run the command at a fixed interval, use a rate expression to specify the interval. You can specify the interval in seconds, minutes, hours, or days. This option is applicable when tasks need to be executed at a fixed interval. Specify the interval in the following format: `rate(<Execution interval value><Execution interval unit>)`. For example, specify `rate(5m)` to run the command every 5 minutes. Take note of the following limits when you set an interval:
        # 
        #     *   The specified interval can be anywhere from 60 seconds to 7 days and must be longer than the timeout period of the scheduled task.
        #     *   The interval is the duration between two consecutive executions. The interval is irrelevant to the amount of time required to run the command once. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. Each time the command is run, the system waits 3 minutes before it runs the command again.
        #     *   A task is not executed immediately after it is created. For example, assume that you set the interval to 5 minutes for a task. The task begins to be executed 5 minutes after it is created.
        # 
        # *   Run Only Once at Specified Time: To run the command only once at a specified time, specify a point in time and a time zone. Specify the time in the following format: `at(yyyy-MM-dd HH:mm:ss <Time zone>)`, which indicates `at(Year-Month-Day Hour:Minute:Second <Time zone>)`. If you do not specify a time zone, the UTC time zone is used by default. The time zone supports the following forms:
        # 
        #     *   The time zone name. Example: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from Greenwich Mean Time (GMT). Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         To specify a command to run only once at 13:15:30 on June 06, 2022 (Shanghai time), set the time to `at(2022-06-06 13:15:30 Asia/Shanghai)`. To specify a command to run only once at 13:15:30 on June 06, 2022 (UTC-7), set the time to `at(2022-06-06 13:15:30 GMT-7:00)`.
        # 
        # *   Run on Clock-based Schedule: To run the command at designated times, specify a cron expression. Specify the time in the following format: `<Cron expression> <Time zone>`, where the cron expression is in the format of `<seconds> <minutes> <hours> <day of the month> <month> <day of the week> <year (optional)> <time zone>`. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance on which to run the command is used by default. For more information about cron expressions, see [Cron expressions](~~64769~~). The time zone supports the following forms:
        # 
        #     *   The time zone name. Example: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from GMT. Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         For example, to specify a command to run at 10:15:00 every day in 2022 (Shanghai time), set the time to `0 15 10 ? * * 2022 Asia/Shanghai`. To specify a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the time to `0 0/30 10-11 * ? 2022 GMT +8:00`. To specify a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years since 2022 (UTC), set the time to `0 0/5 14 * 10 ? 2022/2 UTC`.
        # 
        #         > The minimum interval must be 10 seconds or more and cannot be shorter than the timeout period of scheduled executions.
        self.frequency = frequency  # type: str
        # The list of instance ID.
        self.instance_id = instance_id  # type: list[str]
        # Specifies whether to retain the command after it is run. Valid values:
        # 
        # *   true: The command is retained. You can call the InvokeCommand operation to run the command again. The retained command counts against the quota of Cloud Assistant commands.
        # *   false: The command is not retained. The command is automatically deleted after it is run and is not included in the quota of Cloud Assistant commands.
        # 
        # Default value: false.
        self.keep_command = keep_command  # type: bool
        # The name of the command. The name supports all character sets and can be up to 128 characters in length.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The key-value pairs of custom parameters to be passed in when the command includes custom parameters. For example, assume that the command content is `echo {{name}}`. You can use the `Parameter` parameter to pass in the `{"name":"Jack"}` key-value pair. The `name` key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is actually run.
        # 
        # Number of custom parameters: 0 to 10. Take note of the following items:
        # 
        # *   The key cannot be an empty string. It can be up to 64 characters in length.
        # *   The value can be an empty string.
        # *   If you want to retain the command, make sure that the size of the command (including custom parameters and original command content) after Base64 encoding does not exceed 18 KB. If you do not want to retain the command, make sure that the size of the command after Base64-encoding does not exceed 24 KB. You can set `KeepCommand` to specify whether to retain the command.
        # *   The custom parameter names specified in the value of Parameters must be included in the custom parameters specified when you created the command. You can use empty strings to represent the parameters that are not passed in.
        # 
        # This parameter is empty by default. You can leave this parameter empty to disable the custom parameter feature.
        self.parameters = parameters  # type: dict[str, any]
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: runs the command instantly.
        # *   Period: runs the command on a schedule. If you set this parameter to `Period`, you must set `Timed` to true and specify `Frequency`.
        # *   NextRebootOnly: automatically runs the command the next time the instance starts.
        # *   EveryReboot: automatically runs the command every time the instance starts.
        # 
        # Default value:
        # 
        # *   When `Timed` is set to false and `Frequency` is not specified, the default value of RepeatMode is `Once`.
        # *   When `Timed` is set to true and `Frequency` is specified, `Period` is used as the value of RepeatMode regardless of whether RepeatMode is specified.
        # 
        # Take note of the following items:
        # 
        # *   When this parameter is set to `Period`, `NextRebootOnly`, or `EveryReboot`, you can call the [StopInvocation](~~64838~~) operation to stop the pending or scheduled executions of the command.
        # *   When this parameter is set to `Period` or `EveryReboot`, you can call the [DescribeInvocationResults](~~64845~~) operation and set `IncludeHistory` to true to view the results of historical scheduled executions.
        self.repeat_mode = repeat_mode  # type: str
        # The ID of the resource group to which the elasticity assurance belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[RunCommandRequestTag]
        # Specifies whether to run the command on a schedule. Valid values:
        # 
        # *   true: runs the command on the schedule specified by `Frequency`. The results of each execution of a command do not affect the next execution of the command.
        # *   false: runs the command only once.
        # 
        # Default value: false.
        self.timed = timed  # type: bool
        # The timeout period for the command execution. Unit: seconds.
        # 
        # A timeout error occurs when a command cannot be run because the process slows down or because a specific module or the Cloud Assistant client does not exist. When an execution times out, the command process is forcefully terminated.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long
        # The language type of the command. Valid values:
        # 
        # *   RunBatScript: batch command (applicable to Windows instances).
        # *   RunPowerShellScript: PowerShell command (applicable to Windows instances).
        # *   RunShellScript: shell command (applicable to Linux instances).
        self.type = type  # type: str
        # The username to use to run the command on ECS instances.
        # 
        # *   For Linux instances, the root username is used.
        # *   For Windows instances, the System user is used.
        # 
        # You can also specify other usernames that already exist in the ECS instance to run the command. For security purposes, we recommend that you run Cloud Assistant commands as a regular user. For more information, see [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        self.username = username  # type: str
        # The name of the password to use to run the command on a Windows instance.
        # 
        # If you want to use a username other than the default System username to run the command on the Windows instance, you must specify both the WindowsPasswordName and `Username` parameter. The password is hosted in plaintext in the parameter repository of Operation Orchestration Service (OOS) to reduce the risk of password leaks. Only the name of the password is passed in by using the WindowsPasswordName parameter. For more information, see [Encrypt parameters](~~186828~~) and [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        # 
        # >  When you use the root username for Linux instances or the System username for Windows instances to run the command, you do not need to specify the WindowsPasswordName parameter.
        self.windows_password_name = windows_password_name  # type: str
        # The working directory of the command on the ECS instance.
        # 
        # Default value:
        # 
        # *   Linux instances: the home directory of the administrator (the root user), which is `/root`.
        # *   Windows instances: the directory where the Cloud Assistant client process resides, such as `C:\Windows\System32`.
        self.working_dir = working_dir  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RunCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_parameter is not None:
            result['EnableParameter'] = self.enable_parameter
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.keep_command is not None:
            result['KeepCommand'] = self.keep_command
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.parameters is not None:
            result['Parameters'] = self.parameters
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        if self.username is not None:
            result['Username'] = self.username
        if self.windows_password_name is not None:
            result['WindowsPasswordName'] = self.windows_password_name
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableParameter') is not None:
            self.enable_parameter = m.get('EnableParameter')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KeepCommand') is not None:
            self.keep_command = m.get('KeepCommand')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Parameters') is not None:
            self.parameters = m.get('Parameters')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RunCommandRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('WindowsPasswordName') is not None:
            self.windows_password_name = m.get('WindowsPasswordName')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class RunCommandShrinkRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N of the command. Valid values of N: 1 to 20. The tag key cannot be an empty string.
        # 
        # If a single tag is specified to query resources, up to 1,000 resources that have this tag added can be displayed in the response. If multiple tags are specified to query resources, up to 1,000 resources that have all these tags added can be displayed in the response. To query more than 1,000 resources that have specified tags added, call the [ListTagResources](~~110425~~) operation.
        # 
        # The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag N of the command. Valid values of N: 1 to 20. The tag value can be an empty string.
        # 
        # The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunCommandShrinkRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RunCommandShrinkRequest(TeaModel):
    def __init__(self, command_content=None, container_id=None, container_name=None, content_encoding=None,
                 description=None, enable_parameter=None, frequency=None, instance_id=None, keep_command=None, name=None,
                 owner_account=None, owner_id=None, parameters_shrink=None, region_id=None, repeat_mode=None,
                 resource_group_id=None, resource_owner_account=None, resource_owner_id=None, tag=None, timed=None, timeout=None,
                 type=None, username=None, windows_password_name=None, working_dir=None):
        # The content of the command. The command content can be plaintext or Base64-encoded. Take note of the following items:
        # 
        # *   If you want to retain the command, make sure that the Base64-encoded command content does not exceed 18 KB in size. If you do not want to retain the command, make sure that the Base64-encoded command content does not exceed 24 KB in size. You can set `KeepCommand` to specify whether to retain the command.
        # 
        # *   If the command content is Base64-encoded, set `ContentEncoding` to Base64.
        # 
        # *   When `EnableParameter` is set to true, the custom parameter feature is enabled and you can configure custom parameters based on the following rules:
        # 
        #     *   Define custom parameters in the `{{}}` format. Within `{{}}`, the spaces and line feeds before and after the parameter names are ignored.
        #     *   The number of custom parameters cannot exceed 20.
        #     *   A custom parameter name can contain only letters, digits, underscores (\_), and hyphens (-). The name is case-insensitive.
        #     *   Each custom parameter name cannot exceed 64 bytes in length.
        # 
        # *   You can specify built-in environment parameters as custom parameters. Then, when you run the command, the parameters are automatically specified by Cloud Assistant. You can specify the following built-in environment parameters:
        # 
        #     *   `{{ACS::RegionId}}`: the ID of the region.
        # 
        #     *   `{{ACS::AccountId}}`: the UID of the Alibaba Cloud account.
        # 
        #     *   `{{ACS::InstanceId}}`: the ID of the instance. If you want to run the command on multiple instances and specify `{{ACS::InstanceId}}` as a built-in environment parameter, make sure that the Cloud Assistant client is not earlier than the following version:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::InstanceName}}`: the name of the instance. If you want to run the command on multiple instances and specify `{{ACS::InstanceName}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.344
        #         *   Windows: 2.1.3.344
        # 
        #     *   `{{ACS::InvokeId}}`: the ID of the command task. If you want to specify `{{ACS::InvokeId}}` as a built-in environment parameter, make sure that the Cloud Assistant client is not earlier than the following version:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        # 
        #     *   `{{ACS::CommandId}}`: the ID of the command. If you want to specify `{{ACS::CommandId}}` as a built-in environment parameter, make sure that the version of the Cloud Assistant client is not earlier than the following ones:
        # 
        #         *   Linux: 2.2.3.309
        #         *   Windows: 2.1.3.309
        self.command_content = command_content  # type: str
        # The ID of the container. Only 64-bit hexadecimal strings are supported. Container IDs that are prefixed with `docker://`, `containerd://`, or `cri-o://` are allowed to specify container runtimes.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # *   If this parameter is specified, the specified `Username` and `WorkingDir` parameters do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_id = container_id  # type: str
        # The name of the container.
        # 
        # Take note of the following items:
        # 
        # *   If this parameter is specified, Cloud Assistant runs scripts in the specified container of the instance.
        # *   If this parameter is specified, scripts can be run only on Linux instances on which Cloud Assistant client versions not earlier than 2.2.3.44 are installed.
        # *   If this parameter is specified, the specified `Username` and `WorkingDir` parameters do not take effect. You can run the command in the default working directory of the container only by using the default user of the container. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        # *   If this parameter is specified, only shell scripts can be run in Linux containers. You cannot add a command in the format similar to `#!/usr/bin/python` at the beginning of a script to specify a script interpreter. For more information, see [Use Cloud Assistant to run commands in containers](~~456641~~).
        self.container_name = container_name  # type: str
        # The encoding mode of command content (`CommandContent`). The valid values are case-insensitive. Valid values:
        # 
        # *   PlainText: The command content is not encoded.
        # *   Base64: The command content is encoded in Base64.
        # 
        # Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        self.content_encoding = content_encoding  # type: str
        # The description of the command. The description supports all character sets and can be up to 512 characters in length.
        self.description = description  # type: str
        # Specifies whether to include custom parameters in the command.
        # 
        # Default value: false.
        self.enable_parameter = enable_parameter  # type: bool
        # The schedule on which to run the command. You must specify this parameter when you set `Timed` to `true`. You can specify a schedule to run the command at a fixed interval based on a rate expression, only once at a specified time, or at designated times based on a cron expression.
        # 
        # *   Run at Fixed Interval: To run the command at a fixed interval, use a rate expression to specify the interval. You can specify the interval in seconds, minutes, hours, or days. This option is applicable when tasks need to be executed at a fixed interval. Specify the interval in the following format: `rate(<Execution interval value><Execution interval unit>)`. For example, specify `rate(5m)` to run the command every 5 minutes. Take note of the following limits when you set an interval:
        # 
        #     *   The specified interval can be anywhere from 60 seconds to 7 days and must be longer than the timeout period of the scheduled task.
        #     *   The interval is the duration between two consecutive executions. The interval is irrelevant to the amount of time required to run the command once. For example, assume that you set the interval to 5 minutes and that it takes 2 minutes to run the command each time. Each time the command is run, the system waits 3 minutes before it runs the command again.
        #     *   A task is not executed immediately after it is created. For example, assume that you set the interval to 5 minutes for a task. The task begins to be executed 5 minutes after it is created.
        # 
        # *   Run Only Once at Specified Time: To run the command only once at a specified time, specify a point in time and a time zone. Specify the time in the following format: `at(yyyy-MM-dd HH:mm:ss <Time zone>)`, which indicates `at(Year-Month-Day Hour:Minute:Second <Time zone>)`. If you do not specify a time zone, the UTC time zone is used by default. The time zone supports the following forms:
        # 
        #     *   The time zone name. Example: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from Greenwich Mean Time (GMT). Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         To specify a command to run only once at 13:15:30 on June 06, 2022 (Shanghai time), set the time to `at(2022-06-06 13:15:30 Asia/Shanghai)`. To specify a command to run only once at 13:15:30 on June 06, 2022 (UTC-7), set the time to `at(2022-06-06 13:15:30 GMT-7:00)`.
        # 
        # *   Run on Clock-based Schedule: To run the command at designated times, specify a cron expression. Specify the time in the following format: `<Cron expression> <Time zone>`, where the cron expression is in the format of `<seconds> <minutes> <hours> <day of the month> <month> <day of the week> <year (optional)> <time zone>`. The system calculates the execution times of the command based on the specified cron expression and time zone and runs the command as scheduled. If you do not specify a time zone, the system time zone of the instance on which to run the command is used by default. For more information about cron expressions, see [Cron expressions](~~64769~~). The time zone supports the following forms:
        # 
        #     *   The time zone name. Example: `Asia/Shanghai` and `America/Los_Angeles`.
        # 
        #     *   The time offset from GMT. Example: `GMT+8:00` (UTC+8) and `GMT-7:00` (UTC-7). If you use the GMT format, do not pad leading zeros to the hour value.
        # 
        #     *   The time zone abbreviation: Only UTC is supported.
        # 
        #         For example, to specify a command to run at 10:15:00 every day in 2022 (Shanghai time), set the time to `0 15 10 ? * * 2022 Asia/Shanghai`. To specify a command to run every half an hour from 10:00:00 to 11:30:00 every day in 2022 (UTC+8), set the time to `0 0/30 10-11 * ? 2022 GMT +8:00`. To specify a command to run every 5 minutes from 14:00:00 to 14:55:00 every October every two years since 2022 (UTC), set the time to `0 0/5 14 * 10 ? 2022/2 UTC`.
        # 
        #         > The minimum interval must be 10 seconds or more and cannot be shorter than the timeout period of scheduled executions.
        self.frequency = frequency  # type: str
        # The list of instance ID.
        self.instance_id = instance_id  # type: list[str]
        # Specifies whether to retain the command after it is run. Valid values:
        # 
        # *   true: The command is retained. You can call the InvokeCommand operation to run the command again. The retained command counts against the quota of Cloud Assistant commands.
        # *   false: The command is not retained. The command is automatically deleted after it is run and is not included in the quota of Cloud Assistant commands.
        # 
        # Default value: false.
        self.keep_command = keep_command  # type: bool
        # The name of the command. The name supports all character sets and can be up to 128 characters in length.
        self.name = name  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The key-value pairs of custom parameters to be passed in when the command includes custom parameters. For example, assume that the command content is `echo {{name}}`. You can use the `Parameter` parameter to pass in the `{"name":"Jack"}` key-value pair. The `name` key of the custom parameter is automatically replaced by the paired Jack value to generate a new command. As a result, the `echo Jack` command is actually run.
        # 
        # Number of custom parameters: 0 to 10. Take note of the following items:
        # 
        # *   The key cannot be an empty string. It can be up to 64 characters in length.
        # *   The value can be an empty string.
        # *   If you want to retain the command, make sure that the size of the command (including custom parameters and original command content) after Base64 encoding does not exceed 18 KB. If you do not want to retain the command, make sure that the size of the command after Base64-encoding does not exceed 24 KB. You can set `KeepCommand` to specify whether to retain the command.
        # *   The custom parameter names specified in the value of Parameters must be included in the custom parameters specified when you created the command. You can use empty strings to represent the parameters that are not passed in.
        # 
        # This parameter is empty by default. You can leave this parameter empty to disable the custom parameter feature.
        self.parameters_shrink = parameters_shrink  # type: str
        # The region ID of the command. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The execution mode of the command. Valid values:
        # 
        # *   Once: runs the command instantly.
        # *   Period: runs the command on a schedule. If you set this parameter to `Period`, you must set `Timed` to true and specify `Frequency`.
        # *   NextRebootOnly: automatically runs the command the next time the instance starts.
        # *   EveryReboot: automatically runs the command every time the instance starts.
        # 
        # Default value:
        # 
        # *   When `Timed` is set to false and `Frequency` is not specified, the default value of RepeatMode is `Once`.
        # *   When `Timed` is set to true and `Frequency` is specified, `Period` is used as the value of RepeatMode regardless of whether RepeatMode is specified.
        # 
        # Take note of the following items:
        # 
        # *   When this parameter is set to `Period`, `NextRebootOnly`, or `EveryReboot`, you can call the [StopInvocation](~~64838~~) operation to stop the pending or scheduled executions of the command.
        # *   When this parameter is set to `Period` or `EveryReboot`, you can call the [DescribeInvocationResults](~~64845~~) operation and set `IncludeHistory` to true to view the results of historical scheduled executions.
        self.repeat_mode = repeat_mode  # type: str
        # The ID of the resource group to which the elasticity assurance belongs. If this parameter is specified to query resources, up to 1,000 resources that belong to the specified resource group can be displayed in the response.  
        # 
        # >  Resources in the default resource group are displayed in the response regardless of how this parameter is set.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The tags.
        self.tag = tag  # type: list[RunCommandShrinkRequestTag]
        # Specifies whether to run the command on a schedule. Valid values:
        # 
        # *   true: runs the command on the schedule specified by `Frequency`. The results of each execution of a command do not affect the next execution of the command.
        # *   false: runs the command only once.
        # 
        # Default value: false.
        self.timed = timed  # type: bool
        # The timeout period for the command execution. Unit: seconds.
        # 
        # A timeout error occurs when a command cannot be run because the process slows down or because a specific module or the Cloud Assistant client does not exist. When an execution times out, the command process is forcefully terminated.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long
        # The language type of the command. Valid values:
        # 
        # *   RunBatScript: batch command (applicable to Windows instances).
        # *   RunPowerShellScript: PowerShell command (applicable to Windows instances).
        # *   RunShellScript: shell command (applicable to Linux instances).
        self.type = type  # type: str
        # The username to use to run the command on ECS instances.
        # 
        # *   For Linux instances, the root username is used.
        # *   For Windows instances, the System user is used.
        # 
        # You can also specify other usernames that already exist in the ECS instance to run the command. For security purposes, we recommend that you run Cloud Assistant commands as a regular user. For more information, see [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        self.username = username  # type: str
        # The name of the password to use to run the command on a Windows instance.
        # 
        # If you want to use a username other than the default System username to run the command on the Windows instance, you must specify both the WindowsPasswordName and `Username` parameter. The password is hosted in plaintext in the parameter repository of Operation Orchestration Service (OOS) to reduce the risk of password leaks. Only the name of the password is passed in by using the WindowsPasswordName parameter. For more information, see [Encrypt parameters](~~186828~~) and [Configure a regular user to run Cloud Assistant commands](~~203771~~).
        # 
        # >  When you use the root username for Linux instances or the System username for Windows instances to run the command, you do not need to specify the WindowsPasswordName parameter.
        self.windows_password_name = windows_password_name  # type: str
        # The working directory of the command on the ECS instance.
        # 
        # Default value:
        # 
        # *   Linux instances: the home directory of the administrator (the root user), which is `/root`.
        # *   Windows instances: the directory where the Cloud Assistant client process resides, such as `C:\Windows\System32`.
        self.working_dir = working_dir  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RunCommandShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.container_id is not None:
            result['ContainerId'] = self.container_id
        if self.container_name is not None:
            result['ContainerName'] = self.container_name
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_parameter is not None:
            result['EnableParameter'] = self.enable_parameter
        if self.frequency is not None:
            result['Frequency'] = self.frequency
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.keep_command is not None:
            result['KeepCommand'] = self.keep_command
        if self.name is not None:
            result['Name'] = self.name
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.parameters_shrink is not None:
            result['Parameters'] = self.parameters_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.repeat_mode is not None:
            result['RepeatMode'] = self.repeat_mode
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.timed is not None:
            result['Timed'] = self.timed
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        if self.username is not None:
            result['Username'] = self.username
        if self.windows_password_name is not None:
            result['WindowsPasswordName'] = self.windows_password_name
        if self.working_dir is not None:
            result['WorkingDir'] = self.working_dir
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('ContainerId') is not None:
            self.container_id = m.get('ContainerId')
        if m.get('ContainerName') is not None:
            self.container_name = m.get('ContainerName')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableParameter') is not None:
            self.enable_parameter = m.get('EnableParameter')
        if m.get('Frequency') is not None:
            self.frequency = m.get('Frequency')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('KeepCommand') is not None:
            self.keep_command = m.get('KeepCommand')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Parameters') is not None:
            self.parameters_shrink = m.get('Parameters')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RepeatMode') is not None:
            self.repeat_mode = m.get('RepeatMode')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RunCommandShrinkRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Timed') is not None:
            self.timed = m.get('Timed')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Username') is not None:
            self.username = m.get('Username')
        if m.get('WindowsPasswordName') is not None:
            self.windows_password_name = m.get('WindowsPasswordName')
        if m.get('WorkingDir') is not None:
            self.working_dir = m.get('WorkingDir')
        return self


class RunCommandResponseBody(TeaModel):
    def __init__(self, command_id=None, invoke_id=None, request_id=None):
        # The ID of the command.
        self.command_id = command_id  # type: str
        # The ID of the command task.
        self.invoke_id = invoke_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_id is not None:
            result['CommandId'] = self.command_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandId') is not None:
            self.command_id = m.get('CommandId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RunCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RunCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunInstancesRequestCpuOptions(TeaModel):
    def __init__(self, core=None, numa=None, threads_per_core=None):
        # The number of CPU cores. This parameter cannot be specified but only uses its default value.
        # 
        # For information about the default value, see [Customize CPU options](~~145895~~).
        self.core = core  # type: int
        # This parameter is no longer used.
        self.numa = numa  # type: str
        # The number of threads per CPU core. The following formula is used to calculate the number of vCPUs of the instance: `CpuOptions.Core` value × `CpuOptions.ThreadPerCore` value.
        # 
        # *   The following formula is used to calculate the number of vCPUs of the instance: `CpuOptions.Core` value × CpuOptions.ThreadPerCore value.
        # *   This parameter is applicable only to specific instance types.
        # 
        # For information about valid values and the default value, see [Customize CPU options](~~145895~~).
        self.threads_per_core = threads_per_core  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestCpuOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.core is not None:
            result['Core'] = self.core
        if self.numa is not None:
            result['Numa'] = self.numa
        if self.threads_per_core is not None:
            result['ThreadsPerCore'] = self.threads_per_core
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Core') is not None:
            self.core = m.get('Core')
        if m.get('Numa') is not None:
            self.numa = m.get('Numa')
        if m.get('ThreadsPerCore') is not None:
            self.threads_per_core = m.get('ThreadsPerCore')
        return self


class RunInstancesRequestHibernationOptions(TeaModel):
    def __init__(self, configured=None):
        # > This parameter is in invitational preview and is unavailable.
        self.configured = configured  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestHibernationOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.configured is not None:
            result['Configured'] = self.configured
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Configured') is not None:
            self.configured = m.get('Configured')
        return self


class RunInstancesRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None, match_criteria=None):
        # The ID of the private pool. The ID of a private pool is the same as that of the elasticity assurance or capacity reservation for which the private pool is generated.
        self.id = id  # type: str
        # The type of the private pool to use to create the instance. A private pool is generated after an elasticity assurance or a capacity reservation takes effect. You can select the private pool when you start an instance. Valid values:
        # 
        # *   Open: open private pool. The system selects a matching open private pool to create the instance. If no matching open private pools are found, resources in the public pool are used. When you set this parameter to Open, you can leave the `PrivatePoolOptions.Id` parameter empty.
        # *   Target: specified private pool. The system uses the capacity in a specified private pool to create the instance. If the specified private pool is unavailable, the instance cannot be created. If you set this parameter to Target, you must specify the `PrivatePoolOptions.Id` parameter.
        # *   None: no private pool. The capacity in private pools is not used.
        # 
        # Default value: None.
        # 
        # In the following scenarios, the PrivatePoolOptions.MatchCriteria parameter can be set only to `None` or left empty:
        # 
        # *   A preemptible instance is created.
        # *   The instance is created in the classic network.
        # *   The instance is created on a dedicated host.
        self.match_criteria = match_criteria  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.match_criteria is not None:
            result['MatchCriteria'] = self.match_criteria
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchCriteria') is not None:
            self.match_criteria = m.get('MatchCriteria')
        return self


class RunInstancesRequestSchedulerOptions(TeaModel):
    def __init__(self, dedicated_host_cluster_id=None):
        # The ID of the dedicated host cluster in which to create the instance. After this parameter is specified, the system selects one dedicated host from the specified cluster to create the instance.
        # 
        # > This parameter is valid only when the `Tenancy` parameter is set to `host`.
        # 
        # When you specify both the `DedicatedHostId` and `SchedulerOptions.DedicatedHostClusterId` parameters, take note of the following items:
        # 
        # *   If the specified dedicated host belongs to the specified dedicated host cluster, the instance is preferentially deployed on the specified dedicated host.
        # *   If the specified dedicated host does not belong to the specified dedicated host cluster, the instance cannot be created.
        # 
        # You can call the [DescribeDedicatedHostClusters](~~184145~~) operation to query the list of dedicated host cluster IDs.
        self.dedicated_host_cluster_id = dedicated_host_cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestSchedulerOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dedicated_host_cluster_id is not None:
            result['DedicatedHostClusterId'] = self.dedicated_host_cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DedicatedHostClusterId') is not None:
            self.dedicated_host_cluster_id = m.get('DedicatedHostClusterId')
        return self


class RunInstancesRequestSecurityOptions(TeaModel):
    def __init__(self, confidential_computing_mode=None, trusted_system_mode=None):
        # The confidential computing mode. Set the value to Enclave.
        # 
        # A value of Enclave indicates that an enclave-based confidential computing environment is built on the instance. When you call the `RunInstances` operation, you can set this parameter only for c7, g7, or r7 instances to use enclave-based confidential computing. Take note of the following items:
        # 
        # *   The confidential computing feature is in invitational preview. To use this feature, submit a ticket.
        # *   When you use the ECS API to create instances that support enclave-based confidential computing, you can call only the `RunInstances` operation. The `CreateInstance` operation does not support the `SecurityOptions.ConfidentialComputingMode` parameter.
        # *   Enclave-based confidential computing is implemented based on the Alibaba Cloud trusted system (vTPM). When you build a confidential computing environment on an instance by using Enclave, the Alibaba Cloud trusted system is enabled for the instance. Therefore, if you set `SecurityOptions.ConfidentialComputingMode` to Enclave when you call this operation, the created instances use enclave-based confidential computing and the Alibaba Cloud trusted system regardless of whether `SecurityOptions.TrustedSystemMode` is set to vTPM.
        # 
        # For more information about confidential computing, see [Build a confidential computing environment by using Enclave](~~203433~~).
        self.confidential_computing_mode = confidential_computing_mode  # type: str
        # The trusted system mode. Set the value to vTPM.
        # 
        # The trusted system mode supports the following instance families:
        # 
        # *   g7, c7, and r7
        # *   Security-enhanced instance families: g7t, c7t, and r7t
        # 
        # When you create instances of the preceding instance families, you must set this parameter. Take note of the following items:
        # 
        # *   To use the Alibaba Cloud trusted system, set this parameter to vTPM. Then, the Alibaba Cloud trusted system performs trust verifications when the instances start.
        # *   If you do not want to use the Alibaba Cloud trusted system, leave this parameter empty. Note that if your created instances use an enclave-based confidential computing environment (with `SecurityOptions.ConfidentialComputingMode` set to Enclave), the Alibaba Cloud trusted system is enabled for the instances.
        # *   When you use the ECS API to create instances that use the trusted system, you can call only the `RunInstances` operation. The `CreateInstance` operation does not support the `SecurityOptions.TrustedSystemMode` parameter.
        # 
        # > If you have configured an instance as a trusted one when you created the instance, you can use only an image that support the trusted system to replace the system disk of the instance.
        # 
        # For more information about the trusted system, see [Overview](~~201394~~).
        self.trusted_system_mode = trusted_system_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestSecurityOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confidential_computing_mode is not None:
            result['ConfidentialComputingMode'] = self.confidential_computing_mode
        if self.trusted_system_mode is not None:
            result['TrustedSystemMode'] = self.trusted_system_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfidentialComputingMode') is not None:
            self.confidential_computing_mode = m.get('ConfidentialComputingMode')
        if m.get('TrustedSystemMode') is not None:
            self.trusted_system_mode = m.get('TrustedSystemMode')
        return self


class RunInstancesRequestSystemDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, category=None, description=None, disk_name=None,
                 performance_level=None, size=None, bursting_enabled=None, encrypt_algorithm=None, encrypted=None, kmskey_id=None,
                 provisioned_iops=None, storage_cluster_id=None):
        # The ID of the automatic snapshot policy to apply to the system disk.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # The category of the system disk. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: enhanced SSD (ESSD)
        # *   cloud: basic disk
        # *   cloud_auto: ESSD AutoPL disk
        # 
        # For non-I/O optimized instances of retired instance types, the default value is cloud. For other instances, the default value is cloud_efficiency.
        self.category = category  # type: str
        # The description of the system disk. The description must be 2 to 256 characters in length. The description can contain letters but cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The name of the system disk. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # The performance level of the ESSD to use as the system disk. Default value: PL1. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # The size of the system disk. Unit: GiB. Valid values: 20 to 500.
        # 
        # The value of this parameter must be at least 20 and greater than or equal to the image size.
        # 
        # Default value: 40 or the image size, whichever is greater.
        self.size = size  # type: str
        self.bursting_enabled = bursting_enabled  # type: bool
        # The algorithm to use to encrypt the system disk. Valid values:
        # 
        # *   ase-256
        # *   sm4-128
        # 
        # Default value: ase-256.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt the system disk. Valid values:
        # 
        # *   true: encrypts the data disk.
        # *   false: does not encrypt the data disk.
        # 
        # Default value: false.
        # 
        # > The system disks of instances cannot be encrypted during instance creation in Hong Kong Zone D or Singapore Zone A.
        self.encrypted = encrypted  # type: str
        # The ID of the KMS key to use for the system disk.
        self.kmskey_id = kmskey_id  # type: str
        self.provisioned_iops = provisioned_iops  # type: long
        # The ID of the dedicated block storage cluster. If you want to use disks in a dedicated block storage cluster as system disks when you create instances, you must specify this parameter. For more information about dedicated block storage clusters, see [What is Dedicated Block Storage Cluster?](~~208883~~)
        self.storage_cluster_id = storage_cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestSystemDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.category is not None:
            result['Category'] = self.category
        if self.description is not None:
            result['Description'] = self.description
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.size is not None:
            result['Size'] = self.size
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        return self


class RunInstancesRequestArn(TeaModel):
    def __init__(self, assume_role_for=None, role_type=None, rolearn=None):
        # > This parameter is in invitational preview and is unavailable.
        self.assume_role_for = assume_role_for  # type: long
        # > This parameter is in invitational preview and is unavailable.
        self.role_type = role_type  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.rolearn = rolearn  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestArn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assume_role_for is not None:
            result['AssumeRoleFor'] = self.assume_role_for
        if self.role_type is not None:
            result['RoleType'] = self.role_type
        if self.rolearn is not None:
            result['Rolearn'] = self.rolearn
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AssumeRoleFor') is not None:
            self.assume_role_for = m.get('AssumeRoleFor')
        if m.get('RoleType') is not None:
            self.role_type = m.get('RoleType')
        if m.get('Rolearn') is not None:
            self.rolearn = m.get('Rolearn')
        return self


class RunInstancesRequestDataDisk(TeaModel):
    def __init__(self, auto_snapshot_policy_id=None, bursting_enabled=None, category=None,
                 delete_with_instance=None, description=None, device=None, disk_name=None, encrypt_algorithm=None, encrypted=None,
                 kmskey_id=None, performance_level=None, provisioned_iops=None, size=None, snapshot_id=None,
                 storage_cluster_id=None):
        # The ID of the automatic snapshot policy to apply to data disk N.
        self.auto_snapshot_policy_id = auto_snapshot_policy_id  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.bursting_enabled = bursting_enabled  # type: bool
        # The category of data disk N. Valid values:
        # 
        # *   cloud_efficiency: ultra disk
        # *   cloud_ssd: standard SSD
        # *   cloud_essd: ESSD
        # *   cloud: basic disk
        # *   cloud_auto: ESSD AutoPL disk
        # 
        # For I/O optimized instances, the default value is cloud_efficiency. For non-I/O optimized instances, the default value is cloud.
        self.category = category  # type: str
        # Specifies whether to release data disk N when the instance is released. Valid values:
        # 
        # *   true: releases data disk N when the instance is released.
        # *   false: does not release data disk N when the instance is released.
        # 
        # Default value: true.
        self.delete_with_instance = delete_with_instance  # type: bool
        # The description of data disk N. The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The mount point of data disk N.
        # 
        # > This parameter is applicable to scenarios in which a full image is used to create instances. A full image is an image that contains an operating system, application software, and business data. For these scenarios, you can set this parameter to the mount point of data disk N contained in the full image and modify the `DataDisk.N.Size` and `DataDisk.N.Category` parameters to change the category and size of data disk N created based on the image.
        self.device = device  # type: str
        # The name of data disk N. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, periods (.), colons (:), underscores (\_), and hyphens (-).
        self.disk_name = disk_name  # type: str
        # The algorithm to use to encrypt data disk N. Valid values:
        # 
        # *   aes-256
        # *   sm4-128
        # 
        # Default value: aes-256.
        self.encrypt_algorithm = encrypt_algorithm  # type: str
        # Specifies whether to encrypt data disk N. Valid values:
        # 
        # *   true: encrypts the data disk.
        # *   false: does not encrypt the data disk.
        # 
        # Default value: false.
        self.encrypted = encrypted  # type: str
        # The ID of the Key Management Service (KMS) key that is used for the data disk.
        self.kmskey_id = kmskey_id  # type: str
        # The performance level of the ESSD to use as data disk N. The value of N must be the same as that in `DataDisk.N.Category` when DataDisk.N.Category is set to cloud_essd. Default value: PL1. Valid values:
        # 
        # *   PL0: A single ESSD can deliver up to 10,000 random read/write IOPS.
        # *   PL1: A single ESSD can deliver up to 50,000 random read/write IOPS.
        # *   PL2: A single ESSD can deliver up to 100,000 random read/write IOPS.
        # *   PL3: A single ESSD can deliver up to 1,000,000 random read/write IOPS.
        # 
        # For more information about ESSD performance levels, see [ESSDs](~~122389~~).
        self.performance_level = performance_level  # type: str
        # > This parameter is in invitational preview and is unavailable.
        self.provisioned_iops = provisioned_iops  # type: long
        # The size of data disk N. Valid values of N: 1 to 16. Unit: GiB. Valid values of this parameter:
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_efficiency: 20 to 32768.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_ssd: 20 to 32768.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_essd: depend on the `DataDisk.N.PerformanceLevel` value.
        # 
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL0: 40 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL1: 20 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL2: 461 to 32768.
        #     *   Valid values when DataDisk.N.PerformanceLevel is set to PL3: 1261 to 32768.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud: 5 to 2000.
        # 
        # *   Valid values when DataDisk.N.Category is set to cloud_auto: 40 to 32768.
        # 
        # The value of this parameter must be greater than or equal to the size of the snapshot specified by the `SnapshotId` parameter.
        self.size = size  # type: int
        # The ID of the snapshot to use to create data disk N. Valid values of N: 1 to 16.
        # 
        # If the `DataDisk.N.SnapshotId` parameter is specified, the `DataDisk.N.Size` parameter is ignored. The data disk is created with the size of the specified snapshot. Use snapshots created after July 15, 2013. Otherwise, an error is returned and your request is rejected.
        self.snapshot_id = snapshot_id  # type: str
        # The ID of the dedicated block storage cluster. If you want to use a disk in a dedicated block storage cluster as data disk N when you create instances, you must specify this parameter.
        self.storage_cluster_id = storage_cluster_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestDataDisk, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_snapshot_policy_id is not None:
            result['AutoSnapshotPolicyId'] = self.auto_snapshot_policy_id
        if self.bursting_enabled is not None:
            result['BurstingEnabled'] = self.bursting_enabled
        if self.category is not None:
            result['Category'] = self.category
        if self.delete_with_instance is not None:
            result['DeleteWithInstance'] = self.delete_with_instance
        if self.description is not None:
            result['Description'] = self.description
        if self.device is not None:
            result['Device'] = self.device
        if self.disk_name is not None:
            result['DiskName'] = self.disk_name
        if self.encrypt_algorithm is not None:
            result['EncryptAlgorithm'] = self.encrypt_algorithm
        if self.encrypted is not None:
            result['Encrypted'] = self.encrypted
        if self.kmskey_id is not None:
            result['KMSKeyId'] = self.kmskey_id
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        if self.provisioned_iops is not None:
            result['ProvisionedIops'] = self.provisioned_iops
        if self.size is not None:
            result['Size'] = self.size
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.storage_cluster_id is not None:
            result['StorageClusterId'] = self.storage_cluster_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoSnapshotPolicyId') is not None:
            self.auto_snapshot_policy_id = m.get('AutoSnapshotPolicyId')
        if m.get('BurstingEnabled') is not None:
            self.bursting_enabled = m.get('BurstingEnabled')
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('DeleteWithInstance') is not None:
            self.delete_with_instance = m.get('DeleteWithInstance')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('DiskName') is not None:
            self.disk_name = m.get('DiskName')
        if m.get('EncryptAlgorithm') is not None:
            self.encrypt_algorithm = m.get('EncryptAlgorithm')
        if m.get('Encrypted') is not None:
            self.encrypted = m.get('Encrypted')
        if m.get('KMSKeyId') is not None:
            self.kmskey_id = m.get('KMSKeyId')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        if m.get('ProvisionedIops') is not None:
            self.provisioned_iops = m.get('ProvisionedIops')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('StorageClusterId') is not None:
            self.storage_cluster_id = m.get('StorageClusterId')
        return self


class RunInstancesRequestNetworkInterface(TeaModel):
    def __init__(self, description=None, instance_type=None, ipv_6address=None, ipv_6address_count=None,
                 network_card_index=None, network_interface_name=None, network_interface_traffic_mode=None, primary_ip_address=None,
                 queue_number=None, queue_pair_number=None, security_group_id=None, security_group_ids=None, v_switch_id=None):
        # The description of ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # *   The description must be 2 to 256 characters in length and cannot start with `http://` or `https://`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you do not need to set this parameter.
        self.description = description  # type: str
        # The type of ENI N. Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # 
        # Valid values:
        # 
        # *   Primary
        # *   Secondary
        # 
        # Default value: Secondary.
        self.instance_type = instance_type  # type: str
        # IPv6 address N to assign to the primary ENI. Up to 10 IPv6 addresses can be assigned to the primary ENI. Valid values of the second N: 1 to 10.
        # 
        # Example: `Ipv6Address.1=2001:db8:1234:1a00::***`.
        # 
        # Take note of the following items:
        # 
        # *   This parameter is valid only when `NetworkInterface.N.InstanceType` is set to `Primary`. If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, you cannot set this parameter.
        # *   If you specify this parameter, you must set `Amount` to 1. You cannot specify `Ipv6AddressCount`, `Ipv6Address.N`, or `NetworkInterface.N.Ipv6AddressCount`.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The number of IPv6 addresses that the system randomly generates for the primary ENI. Valid values: 1 to 10.
        # 
        # Take note of the following items:
        # 
        # *   This parameter is valid only when `NetworkInterface.N.InstanceType` is set to `Primary`. If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, you cannot set this parameter.
        # *   If you specify this parameter, you cannot specify `Ipv6AddressCount`, `Ipv6Address.N`, or `NetworkInterface.N.Ipv6Address.N`.
        self.ipv_6address_count = ipv_6address_count  # type: long
        self.network_card_index = network_card_index  # type: int
        # The name of ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you do not need to set this parameter.
        self.network_interface_name = network_interface_name  # type: str
        # The communication mode of primary ENI N. Valid values:
        # 
        # *   Standard: uses the TCP communication mode.
        # *   HighPerformance: enables the Elastic RDMA Interface (ERI) and uses the remote direct memory access (RDMA) communication mode.
        # 
        # Take note of the following items:
        # 
        # *   This parameter is valid only when `NetworkInterface.N.InstanceType` is set to `Primary`. If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, you cannot set this parameter.
        # *   If you set this parameter to HighPerformance, you can create instances only of the c7re RDMA-enhanced instance family. The maximum number of ENIs in RDMA mode that can be bound to a c7re instance is determined based on the instance type. The c7re instance family is in invitational preview in Beijing Zone K. For more information, see [Instance family](~~25378~~).
        self.network_interface_traffic_mode = network_interface_traffic_mode  # type: str
        # The primary IP address to assign to ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2.
        # 
        #     *   If the value of N is 1, you can configure a primary or secondary ENI. If this parameter is specified, `Amount` is set to a numeric value greater than 1, and NetworkInterface.N.InstanceType is set to Primary, the specified number of instances are created and consecutive primary IP addresses starting from the specified one are assigned to the instances. In this case, you cannot bind secondary ENIs to the instances.
        #     *   If the value of N is 2, you can configure a primary ENI and a secondary ENI. If this parameter is specified, `Amount` is set to a numeric value greater than 1, and NetworkInterface.N.InstanceType is set to Primary, you cannot specify `NetworkInterface.2.InstanceType` to Secondary to bind a secondary ENI.
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, this parameter is equivalent to `PrivateIpAddress` and you cannot specify both NetworkInterface.N.PrimaryIpAddress and `PrivateIpAddress`.
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, the specified primary IP address is assigned to the secondary ENI. The default value is an IP address that is randomly selected from within the CIDR block of the vSwitch to which to connect the secondary ENI.
        # 
        # > You can bind only a single secondary ENI when you create an instance. After the instance is created, you can call the [CreateNetworkInterface](~~58504~~) and [AttachNetworkInterface](~~58515~~) operations to bind more secondary ENIs.
        self.primary_ip_address = primary_ip_address  # type: str
        # The number of queues supported by ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can set a primary or secondary ENI. If the value of N is 2, you can set a primary ENI and a secondary ENI.
        # *   The value of this parameter cannot exceed the maximum number of queues per ENI allowed for the specified instance type.
        # *   The total number of queues for all ENIs on the instance cannot exceed the queue quota for the instance type. To query the maximum number of queues per ENI and the queue quota for an instance type, you can call the [DescribeInstanceTypes](~~25620~~) operation to query the `MaximumQueueNumberPerEni` and `TotalEniQueueQuantity` values.
        # *   If this parameter is set and `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot set the `NetworkInterfaceQueueNumber` parameter.
        self.queue_number = queue_number  # type: int
        # > This parameter is in invitational preview and is unavailable.
        self.queue_pair_number = queue_pair_number  # type: long
        # The ID of the security group to which to assign secondary ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you must set this parameter. In this case, this parameter is equivalent to `SecurityGroupId` and you cannot specify `SecurityGroupId`, `SecurityGroupIds.N`, or `NetworkInterface.N.SecurityGroupIds.N`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, this parameter is optional. The default value is the ID of the security group to which to assign the ECS instance.
        self.security_group_id = security_group_id  # type: str
        # The ID of security group N to which to assign ENI N.
        # 
        # *   Valid values of the first N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # *   The second N indicates that one or more security group IDs can be specified. The valid values of N vary based on the maximum number of security groups to which an instance can belong. For more information, see the "Security group limits" section in [Limits](~~25412#SecurityGroupQuota1~~).
        # 
        # Take note of the following items:
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you must set this parameter or `NetworkInterface.N.SecurityGroupId`. In this case, this parameter is equivalent to `SecurityGroupIds.N` and you cannot specify `SecurityGroupId`, `SecurityGroupIds.N`, or `NetworkInterface.N.SecurityGroupId`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, this parameter is optional. The default value is the ID of the security group to which to assign the ECS instance.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The ID of the vSwitch to which to connect to ENI N.
        # 
        # Take note of the following items:
        # 
        # *   Valid values of N: 1 and 2. If the value of N is 1, you can configure a primary or secondary ENI. If the value of N is 2, you must configure a primary ENI and a secondary ENI.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you must set this parameter. In this case, this parameter is equivalent to `VSwitchId` and you cannot specify `VSwitchId`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Secondary` or left empty, this parameter is optional. The default value is the ID of the vSwitch to which to connect to the instance.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestNetworkInterface, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.network_card_index is not None:
            result['NetworkCardIndex'] = self.network_card_index
        if self.network_interface_name is not None:
            result['NetworkInterfaceName'] = self.network_interface_name
        if self.network_interface_traffic_mode is not None:
            result['NetworkInterfaceTrafficMode'] = self.network_interface_traffic_mode
        if self.primary_ip_address is not None:
            result['PrimaryIpAddress'] = self.primary_ip_address
        if self.queue_number is not None:
            result['QueueNumber'] = self.queue_number
        if self.queue_pair_number is not None:
            result['QueuePairNumber'] = self.queue_pair_number
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('NetworkCardIndex') is not None:
            self.network_card_index = m.get('NetworkCardIndex')
        if m.get('NetworkInterfaceName') is not None:
            self.network_interface_name = m.get('NetworkInterfaceName')
        if m.get('NetworkInterfaceTrafficMode') is not None:
            self.network_interface_traffic_mode = m.get('NetworkInterfaceTrafficMode')
        if m.get('PrimaryIpAddress') is not None:
            self.primary_ip_address = m.get('PrimaryIpAddress')
        if m.get('QueueNumber') is not None:
            self.queue_number = m.get('QueueNumber')
        if m.get('QueuePairNumber') is not None:
            self.queue_pair_number = m.get('QueuePairNumber')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class RunInstancesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag of the instance, disks, and primary ENI.
        # 
        # The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag of the instance, disks, and primary ENI.
        # 
        # The tag value can be an empty string. It can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RunInstancesRequest(TeaModel):
    def __init__(self, cpu_options=None, hibernation_options=None, private_pool_options=None,
                 scheduler_options=None, security_options=None, system_disk=None, affinity=None, amount=None, arn=None,
                 auto_release_time=None, auto_renew=None, auto_renew_period=None, client_token=None, credit_specification=None,
                 data_disk=None, dedicated_host_id=None, deletion_protection=None, deployment_set_group_no=None,
                 deployment_set_id=None, description=None, dry_run=None, host_name=None, host_names=None, hpc_cluster_id=None,
                 http_endpoint=None, http_put_response_hop_limit=None, http_tokens=None, image_family=None, image_id=None,
                 instance_charge_type=None, instance_name=None, instance_type=None, internet_charge_type=None,
                 internet_max_bandwidth_in=None, internet_max_bandwidth_out=None, io_optimized=None, ipv_6address=None,
                 ipv_6address_count=None, isp=None, key_pair_name=None, launch_template_id=None, launch_template_name=None,
                 launch_template_version=None, min_amount=None, network_interface=None, network_interface_queue_number=None,
                 owner_account=None, owner_id=None, password=None, password_inherit=None, period=None, period_unit=None,
                 private_ip_address=None, ram_role_name=None, region_id=None, resource_group_id=None, resource_owner_account=None,
                 resource_owner_id=None, security_enhancement_strategy=None, security_group_id=None, security_group_ids=None,
                 spot_duration=None, spot_interruption_behavior=None, spot_price_limit=None, spot_strategy=None,
                 storage_set_id=None, storage_set_partition_number=None, tag=None, tenancy=None, unique_suffix=None,
                 user_data=None, v_switch_id=None, zone_id=None):
        self.cpu_options = cpu_options  # type: RunInstancesRequestCpuOptions
        self.hibernation_options = hibernation_options  # type: RunInstancesRequestHibernationOptions
        self.private_pool_options = private_pool_options  # type: RunInstancesRequestPrivatePoolOptions
        self.scheduler_options = scheduler_options  # type: RunInstancesRequestSchedulerOptions
        self.security_options = security_options  # type: RunInstancesRequestSecurityOptions
        self.system_disk = system_disk  # type: RunInstancesRequestSystemDisk
        # Specifies whether to associate an instance on a dedicated host with the dedicated host. Valid values:
        # 
        # *   default: does not associate the instance with the dedicated host. When you start an instance that was stopped in economical mode, the instance is automatically deployed to another dedicated host in the automatic deployment resource pool if the available resources of the original dedicated host are insufficient.
        # *   host: associates the instance with the dedicated host. When you start an instance that was stopped in economical mode, the instance remains on the original dedicated host. If the available resources of the original dedicated host are insufficient, the instance cannot be started.
        # 
        # Default value: default.
        self.affinity = affinity  # type: str
        # The number of instances that you want to create. Valid values: 1 to 100.
        # 
        # Default value: 1.
        self.amount = amount  # type: int
        # > This parameter is in invitational preview and is unavailable.
        self.arn = arn  # type: list[RunInstancesRequestArn]
        # The time when to automatically release the pay-as-you-go instance. Specify the time in the [ISO 8601](~~25696~~) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
        # 
        # *   If the value of seconds (`ss`) is not `00`, the time is automatically rounded to the nearest minute based on the value of minutes (`mm`).
        # *   The specified time must be at least 30 minutes later than the current time.
        # *   The specified time can be at most three years from the current time.
        self.auto_release_time = auto_release_time  # type: str
        # Specifies whether to enable auto-renewal for the instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PrePaid`. Valid values:
        # 
        # *   true: enables auto-renewal.
        # *   false: does not enable auto-renewal.
        # 
        # Default value: false.
        self.auto_renew = auto_renew  # type: bool
        # The auto-renewal period of the instance. Valid values:
        # 
        # *   Valid values when PeriodUnit is set to Week: 1, 2, and 3.
        # *   Valid values when PeriodUnit is set to Month: 1, 2, 3, 6, 12, 24, 36, 48, and 60.
        # 
        # Default value: 1.
        self.auto_renew_period = auto_renew_period  # type: int
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The **ClientToken** value can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The performance mode of the burstable instance. Valid values:
        # 
        # *   Standard: the standard mode. For more information, see the "Standard mode" section in [Burstable instances](~~59977~~).
        # *   Unlimited: the unlimited mode. For more information, see the "Unlimited mode" section in [Burstable instances](~~59977~~).
        self.credit_specification = credit_specification  # type: str
        # Details about the data disks.
        self.data_disk = data_disk  # type: list[RunInstancesRequestDataDisk]
        # The ID of the dedicated host on which to create the instance. If you set the `DedicatedHostId` parameter, the `SpotStrategy` and `SpotPriceLimit` parameters are ignored. This is because preemptible instances cannot be created on dedicated hosts.
        # 
        # You can call the [DescribeDedicatedHosts](~~134242~~) operation to query the list of dedicated host IDs.
        self.dedicated_host_id = dedicated_host_id  # type: str
        # Specifies whether to enable release protection for the instance. This parameter determines whether you can use the ECS console or call the [DeleteInstance](~~25507~~) operation to release the instance. Valid values:
        # 
        # *   true: enables release protection for the instance.
        # *   false: disables release protection for the instance.
        # 
        # Default value: false.
        # 
        # > This parameter is applicable to only pay-as-you-go instances. It can protect instances against manual releases, but not against automatic releases.
        self.deletion_protection = deletion_protection  # type: bool
        # The number of the deployment set group to which to deploy the instance. If the deployment set specified by the DeploymentSetId parameter uses the high availability group strategy (AvailabilityGroup), you can use the DeploymentSetGroupNo parameter to specify a deployment set group in the deployment set. Valid values: 1 to 7.
        self.deployment_set_group_no = deployment_set_group_no  # type: int
        # The ID of the deployment set to which to deploy the instance.
        self.deployment_set_id = deployment_set_id  # type: str
        # The description of the instance. The description must be 2 to 256 characters in length, and cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Default value: false. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether required parameters are specified, the request format, service limits, and available ECS resources. If the check fails, the corresponding error code is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked, and the request is made if the check succeeds.
        self.dry_run = dry_run  # type: bool
        # The hostname of the instance. Take note of the following items:
        # 
        # *   The hostname cannot start or end with a period (.) or hyphen (-). It cannot contain consecutive periods (.) or hyphens (-).
        # 
        # *   For Windows instances, the hostname must be 2 to 15 characters in length and cannot contain periods (.) or contain only digits. It can contain letters, digits, and hyphens (-).
        # 
        # *   For instances that run other operating systems such as Linux, take note of the following items:
        # 
        #     *   The hostname must be 2 to 64 characters in length. You can use periods (.) to separate a hostname into multiple segments. Each segment can contain letters, digits, and hyphens (-).
        #     *   You can use the `${instance_id}` placeholder to pass instance IDs into the hostname specified by `HostName`. For example, if you set `HostName` to k8s-${instance_id} and the instance is assigned an ID of `i-123abc****`, the hostname of the instance is `k8s-i-123abc****`.
        # 
        # When you create multiple instances, you can perform the following operations:
        # 
        # *   Batch configure sequential hostnames for the instances. For more information, see [Batch configure sequential names or hostnames for multiple instances](~~196048~~).
        # *   Use the `HostNames.N` parameter to configure different hostnames for instances. You cannot specify both the `HostName` and `HostNames.N` parameters.
        self.host_name = host_name  # type: str
        # The hostname of instance N. You can use this parameter to specify different hostnames for multiple instances.
        self.host_names = host_names  # type: list[str]
        # The ID of the Elastic High Performance Computing (E-HPC) cluster to which to assign the instance.
        self.hpc_cluster_id = hpc_cluster_id  # type: str
        # Specifies whether to enable the access channel for instance metadata. Valid values:
        # 
        # *   enabled
        # *   disabled
        # 
        # Default value: enabled.
        # 
        # > For more information about instance metadata, see [Overview of ECS instance metadata](~~49122~~).
        self.http_endpoint = http_endpoint  # type: str
        # The HTTP PUT response hop limit for accessing instance metadata. Valid values: 1 to 64.
        # 
        # Default value: 1.
        self.http_put_response_hop_limit = http_put_response_hop_limit  # type: int
        # Specifies whether to forcefully use the security-enhanced mode (IMDSv2) to access instance metadata. Valid values:
        # 
        # *   optional: does not forcefully use the security-enhanced mode (IMDSv2).
        # *   required: forcefully uses the security-enhanced mode (IMDSv2). After you set this parameter to required, you cannot access instance metadata in normal mode.
        # 
        # Default value: optional.
        # 
        # > For more information about the modes of accessing instance metadata, see [Access mode of instance metadata](~~150575~~).
        self.http_tokens = http_tokens  # type: str
        # The name of the image family. You can set this parameter to obtain the latest available custom image from the specified image family to create instances.
        # 
        # *   If you set the `ImageId` parameter, you cannot set the ImageFamily parameter.
        # *   If you do not set the `ImageId` parameter but use the `LaunchTemplateId` or `LaunchTemplateName` parameter to specify a launch template that has the `ImageId` parameter set, you cannot set the ImageFamily parameter.
        # *   If you do not set the `ImageId` parameter but use the `LaunchTemplateId` or `LaunchTemplateName` parameter to specify a launch template that does not have the `ImageId` parameter set, you can set the ImageFamily parameter.
        # *   If you do not set the `ImageId`, `LaunchTemplateId`, or `LaunchTemplateName` parameter, you can set the ImageFamily parameter.
        self.image_family = image_family  # type: str
        # The ID of the image to use to create the instance. You can call the [DescribeImages](~~25534~~) operation to query available images. If you do not use the `LaunchTemplateId` or `LaunchTemplateName` parameter to specify a launch template and do not set the `ImageFamily` parameter to obtain the latest available custom image from the specified image family, you must specify the `ImageId` parameter.
        self.image_id = image_id  # type: str
        # The billing method of the instance. Valid values:
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        # 
        # Default value: PostPaid.
        # 
        # If you set this parameter to PrePaid, make sure that your account has sufficient balance or credit. Otherwise, an `InvalidPayMethod` error is returned.
        self.instance_charge_type = instance_charge_type  # type: str
        # The name of the instance. The name must be 2 to 128 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). The default value of this parameter is the `InstanceId` value.
        # 
        # When you batch create instances, you can batch configure sequential names for the instances. For more information, see [Batch configure sequential names or hostnames for multiple instances](~~196048~~).
        self.instance_name = instance_name  # type: str
        # The instance type. If you do not use `LaunchTemplateId` or `LaunchTemplateName` to specify a launch template, you must set the `InstanceType` parameter.
        # 
        # *   Select an instance type. See [Instance families](~~25378~~) or call the [DescribeInstanceTypes](~~25620~~) operation to query the performance data of an instance type, or see [Best practices for instance type selection](~~58291~~) to learn about how to select instance types.
        # *   Query available resources. Call the [DescribeAvailableResource](~~66186~~) operation to query available resources in a specific region or zone.
        self.instance_type = instance_type  # type: str
        # The billing method for network usage. Valid values:
        # 
        # *   PayByBandwidth: pay-by-bandwidth
        # *   PayByTraffic: pay-by-traffic
        # 
        # Default value: PayByTraffic.
        # 
        # > When the **pay-by-traffic** billing method for network usage is used, the maximum inbound and outbound bandwidths are used as the upper limits of bandwidths instead of guaranteed performance specifications. In scenarios where demand outstrips resource supplies, these maximum bandwidth values may not be reached. If you want guaranteed bandwidths for your instance, use the **pay-by-bandwidth** billing method for network usage.
        self.internet_charge_type = internet_charge_type  # type: str
        # The maximum inbound public bandwidth. Unit: Mbit/s. Valid values:
        # 
        # *   When the purchased outbound public bandwidth is less than or equal to 10 Mbit/s, the valid values of InternetMaxBandwidthIn are 1 to 10, and the default value is 10.
        # *   When the purchased outbound public bandwidth is greater than 10 Mbit/s, the valid values of this parameter are 1 to the `InternetMaxBandwidthOut` value and the default value is the `InternetMaxBandwidthOut` value.
        self.internet_max_bandwidth_in = internet_max_bandwidth_in  # type: int
        # The maximum outbound public bandwidth. Unit: Mbit/s. Valid values: 0 to 100.
        # 
        # Default value: 0.
        self.internet_max_bandwidth_out = internet_max_bandwidth_out  # type: int
        # Specifies whether the instance is I/O optimized. For instances of [retired instance types](~~55263~~), the default value is none. For instances of other instance types, the default value is optimized. Valid values:
        # 
        # *   none: The instance is not I/O optimized.
        # *   optimized: The instance is I/O optimized.
        self.io_optimized = io_optimized  # type: str
        # IPv6 address N to be assigned to the primary ENI. Valid values of N: 1 to 10.
        # 
        # Example: `Ipv6Address.1=2001:db8:1234:1a00::***`.
        # 
        # Take note of the following items:
        # 
        # *   If the `Ipv6Address.N` parameter is specified, you must set the `Amount` parameter to 1 and leave the `Ipv6AddressCount` parameter empty.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot set `Ipv6Addresses.N` or `Ipv6AddressCount` and must set `NetworkInterface.N.Ipv6Addresses.N` or `NetworkInterface.N.Ipv6AddressCount`.
        self.ipv_6address = ipv_6address  # type: list[str]
        # The number of IPv6 addresses to randomly generate for the primary ENI. Valid values: 1 to 10.
        # 
        # Take note of the following items:
        # 
        # *   You cannot specify both the `Ipv6Addresses.N` and `Ipv6AddressCount` parameters.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `Ipv6Address.N` or `Ipv6AddressCount` but can specify `NetworkInterface.N.Ipv6Address.N` or `NetworkInterface.N.Ipv6AddressCount`.
        self.ipv_6address_count = ipv_6address_count  # type: int
        # > This parameter is in invitational preview and is unavailable.
        self.isp = isp  # type: str
        # The name of the key pair.
        # 
        # > For Windows instances, this parameter is ignored. This parameter is empty by default. The `Password` parameter takes effect even if the KeyPairName parameter is specified.
        self.key_pair_name = key_pair_name  # type: str
        # The ID of the launch template. For more information, see [DescribeLaunchTemplates](~~73759~~).
        # 
        # To use a launch template to create an instance, you must use the `LaunchTemplateId` or `LaunchTemplateName` parameter to specify the launch template.
        self.launch_template_id = launch_template_id  # type: str
        # The name of the launch template.
        # 
        # To use a launch template to create an instance, you must use the `LaunchTemplateId` or `LaunchTemplateName` parameter to specify the launch template.
        self.launch_template_name = launch_template_name  # type: str
        # The version of the launch template. If you set the `LaunchTemplateId` or `LaunchTemplateName` parameter but do not set the version number of the launch template, the default template version is used.
        self.launch_template_version = launch_template_version  # type: long
        # The minimum number of instances that can be created. Valid values: 1 to 100.
        # 
        # *   If the number of instances that available resources are sufficient to create is smaller than the MinAmount value, instances cannot be created.
        # *   If the number of ECS instances that available resources are sufficient to create is greater than or equal to the MinAmount value, instances are created based on the number of available resources.
        self.min_amount = min_amount  # type: int
        # The information of the ENI.
        self.network_interface = network_interface  # type: list[RunInstancesRequestNetworkInterface]
        # The number of queues supported by the primary ENI. Take note of the following items:
        # 
        # *   The value of this parameter cannot exceed the maximum number of queues per ENI allowed for the instance type.
        # *   The total number of queues for all ENIs on the instance cannot exceed the queue quota for the instance type. To query the maximum number of queues per ENI and the queue quota for an instance type, you can call the [DescribeInstanceTypes](~~25620~~) operation to query the `MaximumQueueNumberPerEni` and `TotalEniQueueQuantity` values.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `NetworkInterfaceQueueNumber` but can specify `NetworkInterface.N.QueueNumber`.
        self.network_interface_queue_number = network_interface_queue_number  # type: int
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The password of the instance. The password must be 8 to 30 characters in length and contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters. Special characters include:
        # 
        #     ()`~!@#$%^&*-_+=|{}[]:;\"<>,.?/\
        # 
        # For Windows instances, the password cannot start with a forward slash (/).
        # 
        # > If the `Password` parameter is specified, we recommend that you send requests over HTTPS to prevent password leaks.
        self.password = password  # type: str
        # Specifies whether to use the password preset in the image. Valid values:
        # 
        # *   true: uses the preset password.
        # *   false: does not use the preset password.
        # 
        # Default value: false.
        # 
        # > If you set this parameter to true, make sure that you leave the Password parameter empty and the selected image has a preset password.
        self.password_inherit = password_inherit  # type: bool
        # The subscription period of the instance. The unit is specified by the `PeriodUnit` parameter. This parameter is valid and required only when `InstanceChargeType` is set to `PrePaid`. If the `DedicatedHostId` parameter is specified, the value of Period must not exceed the subscription period of the specified dedicated host. Valid values:
        # 
        # *   Valid values when PeriodUnit is set to Week: 1, 2, 3, and 4.
        # *   Valid values when PeriodUnit is set to Month: 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
        self.period = period  # type: int
        # The unit of the subscription period. Default value: Month. Valid values:
        # 
        # *   Week
        # *   Month
        self.period_unit = period_unit  # type: str
        # The private IP address to assign to the instance. To assign a private IP address to an instance of the VPC type, make sure that the IP address is an idle IP address within the CIDR block of the vSwitch specified by the `VSwitchId` parameter.
        # 
        # Take note of the following items:
        # 
        # *   If the `PrivateIpAddress` parameter is specified, take note of the following items:
        # 
        #     *   If `Amount` is set to 1, a single instance is created and the specified private IP address is assigned to the instance.
        #     *   If `Amount` is set to a numeric value greater than 1, the specified number of instances are created and consecutive private IP addresses starting from the specified one are assigned to the instances. In this case, you cannot specify parameters that start with `NetworkInterface.N` to bind secondary ENIs to the instances.
        # 
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `PrivateIpAddress` but can specify `NetworkInterface.N.PrimaryIpAddress`.
        self.private_ip_address = private_ip_address  # type: str
        # The name of the Resource Access Management (RAM) role. You can call the [ListRoles](~~28713~~) operation provided by RAM to query the instance RAM roles that you created.
        self.ram_role_name = ram_role_name  # type: str
        # The ID of the region in which to create the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group to which to assign the instance.
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # Specifies whether to enable security hardening. Valid values:
        # 
        # *   Active: enables security hardening. This value is applicable only to public images.
        # *   Deactive: does not enable security hardening. This value is applicable to all images.
        self.security_enhancement_strategy = security_enhancement_strategy  # type: str
        # The ID of the security group to which to assign the instance. Instances in the same security group can communicate with each other. The maximum number of instances that a security group can contain depends on the type of the security group. For more information, see the "Security group limits" section in [Limits](~~25412~~).
        # 
        # > The network type of the new instance must be the same as that of the security group specified by the `SecurityGroupId` parameter. For example, if the specified security group is of the VPC type, the new instance is also of the VPC type and you must specify the `VSwitchId` parameter.
        # 
        # If you do not use `LaunchTemplateId` or `LaunchTemplateName` to specify a launch template, you must set the SecurityGroupId parameter. Take note of the following items:
        # 
        # *   You can set `SecurityGroupId` to specify a single security group or set `SecurityGroupIds.N` to specify one or more security groups. However, you cannot specify both `SecurityGroupId` and `SecurityGroupIds.N`.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `SecurityGroupId` or `SecurityGroupIds.N` but can specify only `NetworkInterface.N.SecurityGroupId` or `NetworkInterface.N.SecurityGroupIds.N`.
        self.security_group_id = security_group_id  # type: str
        # The ID of security group N to which to assign the instance. The valid values of N vary based on the maximum number of security groups to which an instance can belong. For more information, see the "Security group limits" section in [Limits](~~101348~~).
        # 
        # Take note of the following items:
        # 
        # *   You cannot specify both the `SecurityGroupId` and `SecurityGroupIds.N` parameters.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `SecurityGroupId` or `SecurityGroupIds.N` but can specify `NetworkInterface.N.SecurityGroupId` or `NetworkInterface.N.SecurityGroupIds.N`.
        self.security_group_ids = security_group_ids  # type: list[str]
        # The protection period of the preemptible instance. Unit: hours. Valid values: 0, 1, 2, 3, 4, 5, and 6.
        # 
        # *   Protection periods of 2, 3, 4, 5, and 6 hours are in invitational preview. If you want to set this parameter to one of these values, submit a ticket.
        # *   If this parameter is set to 0, no protection period is configured for the preemptible instance.
        # 
        # Default value: 1.
        self.spot_duration = spot_duration  # type: int
        # The interruption mode of the preemptible instance. Default value: Terminate. Set the value to Terminate, which specifies to release the instance.
        self.spot_interruption_behavior = spot_interruption_behavior  # type: str
        # The maximum hourly price of the instance. The value is accurate to three decimal places. This parameter is valid only when the `SpotStrategy` parameter is set to `SpotWithPriceLimit`.
        self.spot_price_limit = spot_price_limit  # type: float
        # The bidding policy for the pay-as-you-go instance. This parameter is valid only when the `InstanceChargeType` parameter is set to `PostPaid`. Valid values:
        # 
        # *   NoSpot: The instance is created as a pay-as-you-go instance.
        # *   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
        # *   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.
        # 
        # Default value: NoSpot.
        self.spot_strategy = spot_strategy  # type: str
        # The ID of the storage set.
        self.storage_set_id = storage_set_id  # type: str
        # The maximum number of partitions in the storage set. Valid values: greater than or equal to 2.
        self.storage_set_partition_number = storage_set_partition_number  # type: int
        # The tags to add to the instance, disks, and primary ENI. You can specify up to 20 tags.
        self.tag = tag  # type: list[RunInstancesRequestTag]
        # Specifies whether to create the instance on a dedicated host. Valid values:
        # 
        # *   default: creates the instance on a non-dedicated host.
        # *   host: creates the instance on a dedicated host. If you do not set the `DedicatedHostId` parameter, Alibaba Cloud selects a dedicated host for the instance.
        # 
        # Default value: default.
        self.tenancy = tenancy  # type: str
        # Specifies whether to automatically append incremental suffixes to the hostname specified by the `HostName` parameter and to the instance name specified by the `InstanceName` parameter when you batch create instances. The incremental suffixes can range from 001 to 999. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        # 
        # When the `HostName` or `InstanceName` value is set in the `name_prefix[begin_number,bits]` format without `name_suffix`, the `UniqueSuffix` parameter does not take effect. The names are sorted in the specified sequence.
        # 
        # For more information, see [Batch configure sequential names or hostnames for multiple instances](~~196048~~).
        self.unique_suffix = unique_suffix  # type: bool
        # The user data of the instance. The user data must be encoded in Base64. The raw data can be up to 16 KB in size.
        # 
        # > If the instance type supports [user data](~~~49121~), you can use the UserData parameter to pass in user data. We recommend that you do not pass in confidential information (such as passwords or private keys) in plaintext as user data. This is because the system does not encrypt UserData values when API requests are transmitted. If you must pass in confidential information, we recommend that you encrypt and encode the information in Base64, and then decode and decrypt the information in the same way within the instance.
        self.user_data = user_data  # type: str
        # The ID of the vSwitch to which to connect to the instance. You must set this parameter when you create an instance of the VPC type. The specified vSwitch and security group must belong to the same VPC. You can call the [DescribeVSwitches](~~35748~~) operation to query available vSwitches.
        # 
        # Take note of the following items:
        # 
        # *   If you specify the `VSwitchId` parameter, the zone specified by the `ZoneId` parameter must be the zone where the specified vSwitch is located. You can also leave the `ZoneId` parameter empty. Then, the system selects the zone where the specified vSwitch resides.
        # *   If `NetworkInterface.N.InstanceType` is set to `Primary`, you cannot specify `VSwitchId` but can specify `NetworkInterface.N.VSwitchId`.
        self.v_switch_id = v_switch_id  # type: str
        # The ID of the zone in which to create the instance. You can call the [DescribeZones](~~25610~~) operation to query the most recent zone list.
        # 
        # > If you specify the `VSwitchId` parameter, the zone specified by the `ZoneId` parameter must be the zone where the vSwitch is located. You can also leave the `ZoneId` parameter empty. Then, the system selects the zone where the specified vSwitch is located.
        # 
        # This parameter is empty by default.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.cpu_options:
            self.cpu_options.validate()
        if self.hibernation_options:
            self.hibernation_options.validate()
        if self.private_pool_options:
            self.private_pool_options.validate()
        if self.scheduler_options:
            self.scheduler_options.validate()
        if self.security_options:
            self.security_options.validate()
        if self.system_disk:
            self.system_disk.validate()
        if self.arn:
            for k in self.arn:
                if k:
                    k.validate()
        if self.data_disk:
            for k in self.data_disk:
                if k:
                    k.validate()
        if self.network_interface:
            for k in self.network_interface:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RunInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_options is not None:
            result['CpuOptions'] = self.cpu_options.to_map()
        if self.hibernation_options is not None:
            result['HibernationOptions'] = self.hibernation_options.to_map()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.scheduler_options is not None:
            result['SchedulerOptions'] = self.scheduler_options.to_map()
        if self.security_options is not None:
            result['SecurityOptions'] = self.security_options.to_map()
        if self.system_disk is not None:
            result['SystemDisk'] = self.system_disk.to_map()
        if self.affinity is not None:
            result['Affinity'] = self.affinity
        if self.amount is not None:
            result['Amount'] = self.amount
        result['Arn'] = []
        if self.arn is not None:
            for k in self.arn:
                result['Arn'].append(k.to_map() if k else None)
        if self.auto_release_time is not None:
            result['AutoReleaseTime'] = self.auto_release_time
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.credit_specification is not None:
            result['CreditSpecification'] = self.credit_specification
        result['DataDisk'] = []
        if self.data_disk is not None:
            for k in self.data_disk:
                result['DataDisk'].append(k.to_map() if k else None)
        if self.dedicated_host_id is not None:
            result['DedicatedHostId'] = self.dedicated_host_id
        if self.deletion_protection is not None:
            result['DeletionProtection'] = self.deletion_protection
        if self.deployment_set_group_no is not None:
            result['DeploymentSetGroupNo'] = self.deployment_set_group_no
        if self.deployment_set_id is not None:
            result['DeploymentSetId'] = self.deployment_set_id
        if self.description is not None:
            result['Description'] = self.description
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.host_names is not None:
            result['HostNames'] = self.host_names
        if self.hpc_cluster_id is not None:
            result['HpcClusterId'] = self.hpc_cluster_id
        if self.http_endpoint is not None:
            result['HttpEndpoint'] = self.http_endpoint
        if self.http_put_response_hop_limit is not None:
            result['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit
        if self.http_tokens is not None:
            result['HttpTokens'] = self.http_tokens
        if self.image_family is not None:
            result['ImageFamily'] = self.image_family
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.instance_charge_type is not None:
            result['InstanceChargeType'] = self.instance_charge_type
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.internet_max_bandwidth_in is not None:
            result['InternetMaxBandwidthIn'] = self.internet_max_bandwidth_in
        if self.internet_max_bandwidth_out is not None:
            result['InternetMaxBandwidthOut'] = self.internet_max_bandwidth_out
        if self.io_optimized is not None:
            result['IoOptimized'] = self.io_optimized
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.ipv_6address_count is not None:
            result['Ipv6AddressCount'] = self.ipv_6address_count
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.key_pair_name is not None:
            result['KeyPairName'] = self.key_pair_name
        if self.launch_template_id is not None:
            result['LaunchTemplateId'] = self.launch_template_id
        if self.launch_template_name is not None:
            result['LaunchTemplateName'] = self.launch_template_name
        if self.launch_template_version is not None:
            result['LaunchTemplateVersion'] = self.launch_template_version
        if self.min_amount is not None:
            result['MinAmount'] = self.min_amount
        result['NetworkInterface'] = []
        if self.network_interface is not None:
            for k in self.network_interface:
                result['NetworkInterface'].append(k.to_map() if k else None)
        if self.network_interface_queue_number is not None:
            result['NetworkInterfaceQueueNumber'] = self.network_interface_queue_number
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.password_inherit is not None:
            result['PasswordInherit'] = self.password_inherit
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.ram_role_name is not None:
            result['RamRoleName'] = self.ram_role_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.security_enhancement_strategy is not None:
            result['SecurityEnhancementStrategy'] = self.security_enhancement_strategy
        if self.security_group_id is not None:
            result['SecurityGroupId'] = self.security_group_id
        if self.security_group_ids is not None:
            result['SecurityGroupIds'] = self.security_group_ids
        if self.spot_duration is not None:
            result['SpotDuration'] = self.spot_duration
        if self.spot_interruption_behavior is not None:
            result['SpotInterruptionBehavior'] = self.spot_interruption_behavior
        if self.spot_price_limit is not None:
            result['SpotPriceLimit'] = self.spot_price_limit
        if self.spot_strategy is not None:
            result['SpotStrategy'] = self.spot_strategy
        if self.storage_set_id is not None:
            result['StorageSetId'] = self.storage_set_id
        if self.storage_set_partition_number is not None:
            result['StorageSetPartitionNumber'] = self.storage_set_partition_number
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.tenancy is not None:
            result['Tenancy'] = self.tenancy
        if self.unique_suffix is not None:
            result['UniqueSuffix'] = self.unique_suffix
        if self.user_data is not None:
            result['UserData'] = self.user_data
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuOptions') is not None:
            temp_model = RunInstancesRequestCpuOptions()
            self.cpu_options = temp_model.from_map(m['CpuOptions'])
        if m.get('HibernationOptions') is not None:
            temp_model = RunInstancesRequestHibernationOptions()
            self.hibernation_options = temp_model.from_map(m['HibernationOptions'])
        if m.get('PrivatePoolOptions') is not None:
            temp_model = RunInstancesRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('SchedulerOptions') is not None:
            temp_model = RunInstancesRequestSchedulerOptions()
            self.scheduler_options = temp_model.from_map(m['SchedulerOptions'])
        if m.get('SecurityOptions') is not None:
            temp_model = RunInstancesRequestSecurityOptions()
            self.security_options = temp_model.from_map(m['SecurityOptions'])
        if m.get('SystemDisk') is not None:
            temp_model = RunInstancesRequestSystemDisk()
            self.system_disk = temp_model.from_map(m['SystemDisk'])
        if m.get('Affinity') is not None:
            self.affinity = m.get('Affinity')
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        self.arn = []
        if m.get('Arn') is not None:
            for k in m.get('Arn'):
                temp_model = RunInstancesRequestArn()
                self.arn.append(temp_model.from_map(k))
        if m.get('AutoReleaseTime') is not None:
            self.auto_release_time = m.get('AutoReleaseTime')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('CreditSpecification') is not None:
            self.credit_specification = m.get('CreditSpecification')
        self.data_disk = []
        if m.get('DataDisk') is not None:
            for k in m.get('DataDisk'):
                temp_model = RunInstancesRequestDataDisk()
                self.data_disk.append(temp_model.from_map(k))
        if m.get('DedicatedHostId') is not None:
            self.dedicated_host_id = m.get('DedicatedHostId')
        if m.get('DeletionProtection') is not None:
            self.deletion_protection = m.get('DeletionProtection')
        if m.get('DeploymentSetGroupNo') is not None:
            self.deployment_set_group_no = m.get('DeploymentSetGroupNo')
        if m.get('DeploymentSetId') is not None:
            self.deployment_set_id = m.get('DeploymentSetId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('HostNames') is not None:
            self.host_names = m.get('HostNames')
        if m.get('HpcClusterId') is not None:
            self.hpc_cluster_id = m.get('HpcClusterId')
        if m.get('HttpEndpoint') is not None:
            self.http_endpoint = m.get('HttpEndpoint')
        if m.get('HttpPutResponseHopLimit') is not None:
            self.http_put_response_hop_limit = m.get('HttpPutResponseHopLimit')
        if m.get('HttpTokens') is not None:
            self.http_tokens = m.get('HttpTokens')
        if m.get('ImageFamily') is not None:
            self.image_family = m.get('ImageFamily')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('InstanceChargeType') is not None:
            self.instance_charge_type = m.get('InstanceChargeType')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('InternetMaxBandwidthIn') is not None:
            self.internet_max_bandwidth_in = m.get('InternetMaxBandwidthIn')
        if m.get('InternetMaxBandwidthOut') is not None:
            self.internet_max_bandwidth_out = m.get('InternetMaxBandwidthOut')
        if m.get('IoOptimized') is not None:
            self.io_optimized = m.get('IoOptimized')
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('Ipv6AddressCount') is not None:
            self.ipv_6address_count = m.get('Ipv6AddressCount')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('KeyPairName') is not None:
            self.key_pair_name = m.get('KeyPairName')
        if m.get('LaunchTemplateId') is not None:
            self.launch_template_id = m.get('LaunchTemplateId')
        if m.get('LaunchTemplateName') is not None:
            self.launch_template_name = m.get('LaunchTemplateName')
        if m.get('LaunchTemplateVersion') is not None:
            self.launch_template_version = m.get('LaunchTemplateVersion')
        if m.get('MinAmount') is not None:
            self.min_amount = m.get('MinAmount')
        self.network_interface = []
        if m.get('NetworkInterface') is not None:
            for k in m.get('NetworkInterface'):
                temp_model = RunInstancesRequestNetworkInterface()
                self.network_interface.append(temp_model.from_map(k))
        if m.get('NetworkInterfaceQueueNumber') is not None:
            self.network_interface_queue_number = m.get('NetworkInterfaceQueueNumber')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('PasswordInherit') is not None:
            self.password_inherit = m.get('PasswordInherit')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RamRoleName') is not None:
            self.ram_role_name = m.get('RamRoleName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SecurityEnhancementStrategy') is not None:
            self.security_enhancement_strategy = m.get('SecurityEnhancementStrategy')
        if m.get('SecurityGroupId') is not None:
            self.security_group_id = m.get('SecurityGroupId')
        if m.get('SecurityGroupIds') is not None:
            self.security_group_ids = m.get('SecurityGroupIds')
        if m.get('SpotDuration') is not None:
            self.spot_duration = m.get('SpotDuration')
        if m.get('SpotInterruptionBehavior') is not None:
            self.spot_interruption_behavior = m.get('SpotInterruptionBehavior')
        if m.get('SpotPriceLimit') is not None:
            self.spot_price_limit = m.get('SpotPriceLimit')
        if m.get('SpotStrategy') is not None:
            self.spot_strategy = m.get('SpotStrategy')
        if m.get('StorageSetId') is not None:
            self.storage_set_id = m.get('StorageSetId')
        if m.get('StorageSetPartitionNumber') is not None:
            self.storage_set_partition_number = m.get('StorageSetPartitionNumber')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RunInstancesRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Tenancy') is not None:
            self.tenancy = m.get('Tenancy')
        if m.get('UniqueSuffix') is not None:
            self.unique_suffix = m.get('UniqueSuffix')
        if m.get('UserData') is not None:
            self.user_data = m.get('UserData')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class RunInstancesResponseBodyInstanceIdSets(TeaModel):
    def __init__(self, instance_id_set=None):
        self.instance_id_set = instance_id_set  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunInstancesResponseBodyInstanceIdSets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id_set is not None:
            result['InstanceIdSet'] = self.instance_id_set
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIdSet') is not None:
            self.instance_id_set = m.get('InstanceIdSet')
        return self


class RunInstancesResponseBody(TeaModel):
    def __init__(self, instance_id_sets=None, order_id=None, request_id=None, trade_price=None):
        # The IDs of the instances (`InstanceIdSet`).
        self.instance_id_sets = instance_id_sets  # type: RunInstancesResponseBodyInstanceIdSets
        # The ID of the order. This parameter is returned only when `InstanceChargeType` is set to PrePaid.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The transaction price.
        self.trade_price = trade_price  # type: float

    def validate(self):
        if self.instance_id_sets:
            self.instance_id_sets.validate()

    def to_map(self):
        _map = super(RunInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id_sets is not None:
            result['InstanceIdSets'] = self.instance_id_sets.to_map()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trade_price is not None:
            result['TradePrice'] = self.trade_price
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceIdSets') is not None:
            temp_model = RunInstancesResponseBodyInstanceIdSets()
            self.instance_id_sets = temp_model.from_map(m['InstanceIdSets'])
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TradePrice') is not None:
            self.trade_price = m.get('TradePrice')
        return self


class RunInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RunInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RunInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendFileRequest(TeaModel):
    def __init__(self, content=None, content_type=None, description=None, file_group=None, file_mode=None,
                 file_owner=None, instance_id=None, name=None, overwrite=None, owner_account=None, owner_id=None,
                 region_id=None, resource_group_id=None, resource_owner_account=None, resource_owner_id=None,
                 target_dir=None, timeout=None):
        # The content of the file. The content must not exceed 32 KB in size after it is encoded in Base64.
        # 
        # *   If `ContentType` is set to `PlainText`, the Content value is in plaintext.
        # *   If `ContentType` is set to `Base64`, the Content value is Base64-encoded.
        self.content = content  # type: str
        # The content type of the file. Valid values:
        # 
        # *   PlainText: The command content is not encoded.
        # *   Base64: The command content is Base64-encoded.
        # 
        # Default value: PlainText.
        self.content_type = content_type  # type: str
        # The description of the file. The description supports all character sets and can be up to 512 characters in length.
        self.description = description  # type: str
        # The user group of the file. This parameter takes effect only on Linux instances. Default value: root.
        self.file_group = file_group  # type: str
        # The permissions on the file. This parameter takes effect only on Linux instances. You can configure this parameter in the same way as you configure the chmod command.
        # 
        # Default value: 0644, which indicates that the owner of the file has the read and write permissions on the file and that the user group of the file and other users have only the read permissions on the file.
        self.file_mode = file_mode  # type: str
        # The owner of the file. This parameter takes effect only on Linux instances. Default value: root.
        self.file_owner = file_owner  # type: str
        # The IDs of instances to which to send the file. A maximum of 50 instance IDs can be specified.
        self.instance_id = instance_id  # type: list[str]
        # The name of the file. The name supports all character sets and can be up to 255 characters in length.
        self.name = name  # type: str
        # Specifies whether to overwrite a file in the destination directory if the file has the same name as the sent file.
        # 
        # *   true: overwrites the file.
        # *   false: does not overwrite the file.
        # 
        # Default value: false.
        self.overwrite = overwrite  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance to which to send the file. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the resource group for send files. When specify this parameter:
        # 
        # - The InstanceId of the ECS instance must belongs to the resource group.
        # - Support via the parameter to filter out results of send file(via Call [DescribeSendFileResults](~~184117~~)).
        self.resource_group_id = resource_group_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The destination directory on the instance to which to send the file. If the specified directory does not exist, the system creates the directory on the instance.
        self.target_dir = target_dir  # type: str
        # The timeout period for sending the file. Unit: seconds.
        # 
        # *   A timeout error occurs when a file cannot be sent because the process slows down or because a specific module or the Cloud Assistant client does not exist.
        # *   If the specified timeout period is less than 10 seconds, the system automatically sets the timeout period to 10 seconds to ensure that the file is sent to the instances.
        # 
        # Default value: 60.
        self.timeout = timeout  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.description is not None:
            result['Description'] = self.description
        if self.file_group is not None:
            result['FileGroup'] = self.file_group
        if self.file_mode is not None:
            result['FileMode'] = self.file_mode
        if self.file_owner is not None:
            result['FileOwner'] = self.file_owner
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.name is not None:
            result['Name'] = self.name
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.target_dir is not None:
            result['TargetDir'] = self.target_dir
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('FileGroup') is not None:
            self.file_group = m.get('FileGroup')
        if m.get('FileMode') is not None:
            self.file_mode = m.get('FileMode')
        if m.get('FileOwner') is not None:
            self.file_owner = m.get('FileOwner')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TargetDir') is not None:
            self.target_dir = m.get('TargetDir')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        return self


class SendFileResponseBody(TeaModel):
    def __init__(self, invoke_id=None, request_id=None):
        # The ID of the execution.
        self.invoke_id = invoke_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SendFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SendFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartElasticityAssuranceRequestPrivatePoolOptions(TeaModel):
    def __init__(self, id=None):
        self.id = id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartElasticityAssuranceRequestPrivatePoolOptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        return self


class StartElasticityAssuranceRequest(TeaModel):
    def __init__(self, private_pool_options=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        self.private_pool_options = private_pool_options  # type: StartElasticityAssuranceRequestPrivatePoolOptions
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        if self.private_pool_options:
            self.private_pool_options.validate()

    def to_map(self):
        _map = super(StartElasticityAssuranceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.private_pool_options is not None:
            result['PrivatePoolOptions'] = self.private_pool_options.to_map()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PrivatePoolOptions') is not None:
            temp_model = StartElasticityAssuranceRequestPrivatePoolOptions()
            self.private_pool_options = temp_model.from_map(m['PrivatePoolOptions'])
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class StartElasticityAssuranceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartElasticityAssuranceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartElasticityAssuranceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartElasticityAssuranceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartElasticityAssuranceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartElasticityAssuranceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartImagePipelineExecutionRequestTemplateTag(TeaModel):
    def __init__(self, key=None, value=None):
        # >  This parameter is deprecated.
        self.key = key  # type: str
        # >  This parameter is deprecated.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartImagePipelineExecutionRequestTemplateTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class StartImagePipelineExecutionRequest(TeaModel):
    def __init__(self, client_token=None, image_pipeline_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, template_tag=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The value of the **ClientToken** parameter can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the image template.
        self.image_pipeline_id = image_pipeline_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the image creation task. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # > This parameter is deprecated.
        self.template_tag = template_tag  # type: list[StartImagePipelineExecutionRequestTemplateTag]

    def validate(self):
        if self.template_tag:
            for k in self.template_tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(StartImagePipelineExecutionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.image_pipeline_id is not None:
            result['ImagePipelineId'] = self.image_pipeline_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        result['TemplateTag'] = []
        if self.template_tag is not None:
            for k in self.template_tag:
                result['TemplateTag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('ImagePipelineId') is not None:
            self.image_pipeline_id = m.get('ImagePipelineId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        self.template_tag = []
        if m.get('TemplateTag') is not None:
            for k in m.get('TemplateTag'):
                temp_model = StartImagePipelineExecutionRequestTemplateTag()
                self.template_tag.append(temp_model.from_map(k))
        return self


class StartImagePipelineExecutionResponseBody(TeaModel):
    def __init__(self, execution_id=None, request_id=None):
        # The ID of the image creation task.
        self.execution_id = execution_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartImagePipelineExecutionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.execution_id is not None:
            result['ExecutionId'] = self.execution_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExecutionId') is not None:
            self.execution_id = m.get('ExecutionId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartImagePipelineExecutionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartImagePipelineExecutionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartImagePipelineExecutionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartImagePipelineExecutionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartInstanceRequest(TeaModel):
    def __init__(self, dry_run=None, init_local_disk=None, instance_id=None, owner_account=None, owner_id=None,
                 resource_owner_account=None, resource_owner_id=None, source_region_id=None):
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include whether your AccessKey pair is valid, whether Resource Access Management (RAM) users are granted required permissions, and whether the required parameters are specified. If the check fails, the corresponding error is returned. If the check succeeds, the DryRunOperation error code is returned.
        # *   false: The validity of the request is checked. If the check succeeds, a 2XX HTTP status code is returned and the request is made.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to restore the instance to its initial health state. This parameter is applicable to instances of instance families that are equipped with local disks, such as d1, i1, and i2 instances. If a local disk of a d1, i1, or i2 instance fails, you can use this parameter to specify whether to restore the instance to its initial health state on startup. Valid values:
        # 
        # *   true: restores the instance to its initial health state on startup. After the instance is restored to its initial health state, data stored on the local disks of the instance is lost.
        # *   false: does not perform operations and keeps the instance in the current state.
        # 
        # Default value: false.
        self.init_local_disk = init_local_disk  # type: bool
        # The ID of the instance that you want to start.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the source region.
        self.source_region_id = source_region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.init_local_disk is not None:
            result['InitLocalDisk'] = self.init_local_disk
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.source_region_id is not None:
            result['SourceRegionId'] = self.source_region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InitLocalDisk') is not None:
            self.init_local_disk = m.get('InitLocalDisk')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('SourceRegionId') is not None:
            self.source_region_id = m.get('SourceRegionId')
        return self


class StartInstanceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartInstancesRequest(TeaModel):
    def __init__(self, batch_optimization=None, dry_run=None, instance_id=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The batch operation mode. Valid values:
        # 
        # *   AllTogether: In this mode, if all instances are started, a success message is returned. If an instance fails the check when DryRun is set to false, all the specified instances cannot be started and an error message is returned.
        # *   SuccessFirst: In this mode, each instance is started separately. The response contains the operation results of each instance.
        # 
        # Default value: AllTogether.
        self.batch_optimization = batch_optimization  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked but the request is not made. Check items include the request format, instance status, and whether the required parameters are specified. If the check fails, the corresponding error message is returned. If the check succeeds, `DRYRUN.SUCCESS` is returned.
        # 
        #     > If you set `BatchOptimization` to `SuccessFirst` and `DryRun` to true, only `DRYRUN.SUCCESS` is returned regardless of whether the check succeeds.
        # 
        # *   false: The validity of the request is checked, and the instances are started if the check succeeds.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # The instance IDs. Up to 100.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_optimization is not None:
            result['BatchOptimization'] = self.batch_optimization
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BatchOptimization') is not None:
            self.batch_optimization = m.get('BatchOptimization')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class StartInstancesResponseBodyInstanceResponsesInstanceResponse(TeaModel):
    def __init__(self, code=None, current_status=None, instance_id=None, message=None, previous_status=None):
        # The error code returned for the instance. A return value of 200 indicates success. For more information, see the "Error codes" section in this topic.
        self.code = code  # type: str
        # The current state of the instance.
        self.current_status = current_status  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The error message returned for the instance. A return value of success indicates operation success. For more information, see the "Error codes" section in this topic.
        self.message = message  # type: str
        # The state of the instance before the operation is called.
        self.previous_status = previous_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartInstancesResponseBodyInstanceResponsesInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_status is not None:
            result['CurrentStatus'] = self.current_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.previous_status is not None:
            result['PreviousStatus'] = self.previous_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentStatus') is not None:
            self.current_status = m.get('CurrentStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PreviousStatus') is not None:
            self.previous_status = m.get('PreviousStatus')
        return self


class StartInstancesResponseBodyInstanceResponses(TeaModel):
    def __init__(self, instance_response=None):
        self.instance_response = instance_response  # type: list[StartInstancesResponseBodyInstanceResponsesInstanceResponse]

    def validate(self):
        if self.instance_response:
            for k in self.instance_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(StartInstancesResponseBodyInstanceResponses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponse'] = []
        if self.instance_response is not None:
            for k in self.instance_response:
                result['InstanceResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_response = []
        if m.get('InstanceResponse') is not None:
            for k in m.get('InstanceResponse'):
                temp_model = StartInstancesResponseBodyInstanceResponsesInstanceResponse()
                self.instance_response.append(temp_model.from_map(k))
        return self


class StartInstancesResponseBody(TeaModel):
    def __init__(self, instance_responses=None, request_id=None):
        # Details about the responses returned for the instances, which contains the state of each instance before and after the operation is called and the operation results.
        self.instance_responses = instance_responses  # type: StartInstancesResponseBodyInstanceResponses
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_responses:
            self.instance_responses.validate()

    def to_map(self):
        _map = super(StartInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_responses is not None:
            result['InstanceResponses'] = self.instance_responses.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceResponses') is not None:
            temp_model = StartInstancesResponseBodyInstanceResponses()
            self.instance_responses = temp_model.from_map(m['InstanceResponses'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartTerminalSessionRequest(TeaModel):
    def __init__(self, instance_id=None, owner_account=None, owner_id=None, port_number=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The list of the instance ID.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The port number of the ECS instance, which is used to forward data. After this parameter is specified, the Cloud Assistant client forwards data to the specified port for port forwarding. Example: 22.  
        # 
        # This parameter is empty by default, which indicates that no port number is configured to forward data.
        self.port_number = port_number  # type: int
        # The region ID of the ECS instance. You can call the [DescribeRegions](~~DescribeRegions~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartTerminalSessionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.port_number is not None:
            result['PortNumber'] = self.port_number
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PortNumber') is not None:
            self.port_number = m.get('PortNumber')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class StartTerminalSessionResponseBody(TeaModel):
    def __init__(self, request_id=None, security_token=None, session_id=None, web_socket_url=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The security token included in the WebSocket request header. The system uses this token to authenticate the request.
        self.security_token = security_token  # type: str
        # The ID of the session.
        self.session_id = session_id  # type: str
        # The URL of the WebSocket session that is used to connect to the instance. The URL includes the session ID (`SessionId`) and the authentication token (`SecurityToken`).
        self.web_socket_url = web_socket_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartTerminalSessionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.security_token is not None:
            result['SecurityToken'] = self.security_token
        if self.session_id is not None:
            result['SessionId'] = self.session_id
        if self.web_socket_url is not None:
            result['WebSocketUrl'] = self.web_socket_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecurityToken') is not None:
            self.security_token = m.get('SecurityToken')
        if m.get('SessionId') is not None:
            self.session_id = m.get('SessionId')
        if m.get('WebSocketUrl') is not None:
            self.web_socket_url = m.get('WebSocketUrl')
        return self


class StartTerminalSessionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartTerminalSessionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartTerminalSessionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartTerminalSessionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInstanceRequest(TeaModel):
    def __init__(self, confirm_stop=None, dry_run=None, force_stop=None, hibernate=None, instance_id=None,
                 owner_account=None, owner_id=None, resource_owner_account=None, resource_owner_id=None, stopped_mode=None):
        # >  This parameter will be removed in the future and is retained only to ensure compatibility. We recommend that you ignore this parameter.
        self.confirm_stop = confirm_stop  # type: bool
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked, but the request is not made. Check items include the required parameters, service limits, available ECS resources, and the request format. If the check fails, the corresponding error message is returned. If the check succeeds, the `DryRunOperation` error code is returned.
        # *   false: The validity of the request is checked, and the request is made if the check succeeds.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to forcibly stop the instance. Valid values:
        # 
        # *   true: forcibly stops the instance.
        # *   false: normally stops the instance.
        # 
        # Default value: false.
        self.force_stop = force_stop  # type: bool
        # >  This parameter is currently in invitational preview and unavailable for general users.
        self.hibernate = hibernate  # type: bool
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The stop mode of the pay-as-you-go instance. Valid values:
        # 
        # *   StopCharging: economical mode. For information about how `StopCharging` takes effect, see the "Prerequisites" section in [Economical mode](~~63353~~).
        # *   KeepCharging: standard mode. After the instance is stopped in standard mode, you continue to be charged for it.
        # 
        # Default value: If the prerequisites required for enabling economical mode are met and you have enabled this mode in the ECS console, the default value is [StopCharging](~~63353#default~~). For more information, see the "Enable economical mode" section in `Economical mode`. Otherwise, the default value is `KeepCharging`.
        self.stopped_mode = stopped_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInstanceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.confirm_stop is not None:
            result['ConfirmStop'] = self.confirm_stop
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.hibernate is not None:
            result['Hibernate'] = self.hibernate
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.stopped_mode is not None:
            result['StoppedMode'] = self.stopped_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfirmStop') is not None:
            self.confirm_stop = m.get('ConfirmStop')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('Hibernate') is not None:
            self.hibernate = m.get('Hibernate')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StoppedMode') is not None:
            self.stopped_mode = m.get('StoppedMode')
        return self


class StopInstanceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInstanceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInstanceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopInstanceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInstanceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInstancesRequest(TeaModel):
    def __init__(self, batch_optimization=None, dry_run=None, force_stop=None, instance_id=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None, stopped_mode=None):
        # The batch operation mode. Valid values:
        # 
        # *   AllTogether: In this mode, if all instances are stopped, a success message is returned. If an instance fails the verification, all instances fail to stop and an error message is returned.
        # *   SuccessFirst: In this mode, each instance is separately stopped. The response contains the operation results for each instance.
        # 
        # Default value: AllTogether.
        self.batch_optimization = batch_optimization  # type: str
        # Specifies whether to check the validity of the request without actually making the request. Valid values:
        # 
        # *   true: The validity of the request is checked, but the request is not made. Check items include the request format, instance status, and whether the required parameters are specified. If the check fails, the corresponding error message is returned. If the check succeeds, `DRYRUN.SUCCESS` is returned.
        # 
        #     > If you set `BatchOptimization` to `SuccessFirst` and `DryRun` to true, only `DRYRUN.SUCCESS` is returned regardless of whether the check succeeds.
        # 
        # *   false: The validity of the request is checked, and the request is made if the check succeeds.
        # 
        # Default value: false.
        self.dry_run = dry_run  # type: bool
        # Specifies whether to forcibly stop the instance. Valid values:
        # 
        # *   true: forcibly stops the instance. This operation is equivalent to the typical power-off operation. Cache data that is not written to storage in the instance will be lost.
        # *   false: normally stops the instance.
        # 
        # Default value: false.
        self.force_stop = force_stop  # type: bool
        # The list of instance ID.
        self.instance_id = instance_id  # type: list[str]
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the instance. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The stop mode of the pay-as-you-go instance. Valid values:
        # 
        # *   StopCharging: economical mode. For information about how `StopCharging` takes effect, see the "Prerequisites" section in [Economical mode](~~63353~~).
        # *   KeepCharging: standard mode. After the instances are stopped in standard mode, you continue to be charged for them.
        # 
        # Default value: If the prerequisites required for enabling the economical mode are met and you have enabled this mode in the ECS console, the default value is `StopCharging`. For more information, see "Enable the economical mode" in [Economical mode](~~63353#default~~). Otherwise, the default value is `KeepCharging`.
        self.stopped_mode = stopped_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.batch_optimization is not None:
            result['BatchOptimization'] = self.batch_optimization
        if self.dry_run is not None:
            result['DryRun'] = self.dry_run
        if self.force_stop is not None:
            result['ForceStop'] = self.force_stop
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.stopped_mode is not None:
            result['StoppedMode'] = self.stopped_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BatchOptimization') is not None:
            self.batch_optimization = m.get('BatchOptimization')
        if m.get('DryRun') is not None:
            self.dry_run = m.get('DryRun')
        if m.get('ForceStop') is not None:
            self.force_stop = m.get('ForceStop')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('StoppedMode') is not None:
            self.stopped_mode = m.get('StoppedMode')
        return self


class StopInstancesResponseBodyInstanceResponsesInstanceResponse(TeaModel):
    def __init__(self, code=None, current_status=None, instance_id=None, message=None, previous_status=None):
        # The error code of the instance operation result. The return value 200 indicates success. For more information, see the "Error codes" section in this topic.
        self.code = code  # type: str
        # The current state of the instance.
        self.current_status = current_status  # type: str
        # The ID of instance N.
        self.instance_id = instance_id  # type: str
        # The error message for instance operation. The return value Success indicates operation success. For more information, see the "Error codes" section in this topic.
        self.message = message  # type: str
        # The state of the instance before the operation is called.
        self.previous_status = previous_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInstancesResponseBodyInstanceResponsesInstanceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.current_status is not None:
            result['CurrentStatus'] = self.current_status
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.message is not None:
            result['Message'] = self.message
        if self.previous_status is not None:
            result['PreviousStatus'] = self.previous_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CurrentStatus') is not None:
            self.current_status = m.get('CurrentStatus')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PreviousStatus') is not None:
            self.previous_status = m.get('PreviousStatus')
        return self


class StopInstancesResponseBodyInstanceResponses(TeaModel):
    def __init__(self, instance_response=None):
        self.instance_response = instance_response  # type: list[StopInstancesResponseBodyInstanceResponsesInstanceResponse]

    def validate(self):
        if self.instance_response:
            for k in self.instance_response:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(StopInstancesResponseBodyInstanceResponses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['InstanceResponse'] = []
        if self.instance_response is not None:
            for k in self.instance_response:
                result['InstanceResponse'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.instance_response = []
        if m.get('InstanceResponse') is not None:
            for k in m.get('InstanceResponse'):
                temp_model = StopInstancesResponseBodyInstanceResponsesInstanceResponse()
                self.instance_response.append(temp_model.from_map(k))
        return self


class StopInstancesResponseBody(TeaModel):
    def __init__(self, instance_responses=None, request_id=None):
        # Details about instance-specific responses, which contain the states of each instance before and after the operation is called and the results of the operation.
        self.instance_responses = instance_responses  # type: StopInstancesResponseBodyInstanceResponses
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.instance_responses:
            self.instance_responses.validate()

    def to_map(self):
        _map = super(StopInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_responses is not None:
            result['InstanceResponses'] = self.instance_responses.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceResponses') is not None:
            temp_model = StopInstancesResponseBodyInstanceResponses()
            self.instance_responses = temp_model.from_map(m['InstanceResponses'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInvocationRequest(TeaModel):
    def __init__(self, instance_id=None, invoke_id=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None):
        # The ID of instance N where the command needs to be stopped. You can specify up to 50 instance IDs in each request. Valid values of N: 1 to 50.
        self.instance_id = instance_id  # type: list[str]
        # The ID of the execution. You can call the [DescribeInvocations](~~64840~~) operation to query all execution IDs.
        self.invoke_id = invoke_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The ID of the region. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInvocationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class StopInvocationResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInvocationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInvocationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopInvocationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopInvocationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInvocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N to add to the resource. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `acs:` or `aliyun`.
        self.key = key  # type: str
        # The value of tag N to add to the resource. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TagResourcesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagResourcesRequest(TeaModel):
    def __init__(self, owner_account=None, owner_id=None, region_id=None, resource_id=None,
                 resource_owner_account=None, resource_type=None, tag=None):
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent list of regions.
        self.region_id = region_id  # type: str
        # The ID of resource N. Valid values of N: 1 to 50.
        self.resource_id = resource_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: elastic network interface (ENI)
        # *   ddh: dedicated host
        # *   ddhcluster: dedicated host cluster
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # *   reservedinstance: reserved instance
        # *   snapshotpolicy: automatic snapshot policy
        # *   elasticityassurance: elasticity assurance
        # *   capacityreservation: capacity reservation
        # *   command: Cloud Assistant command
        # *   invocation: Cloud Assistant command execution result
        self.resource_type = resource_type  # type: str
        # The tags to add to the resource.
        self.tag = tag  # type: list[TagResourcesRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(TagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: TagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(TagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TerminatePhysicalConnectionRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, physical_connection_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, user_cidr=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.physical_connection_id = physical_connection_id  # type: str
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TerminatePhysicalConnectionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.physical_connection_id is not None:
            result['PhysicalConnectionId'] = self.physical_connection_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PhysicalConnectionId') is not None:
            self.physical_connection_id = m.get('PhysicalConnectionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        return self


class TerminatePhysicalConnectionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TerminatePhysicalConnectionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TerminatePhysicalConnectionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: TerminatePhysicalConnectionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(TerminatePhysicalConnectionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TerminatePhysicalConnectionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TerminateVirtualBorderRouterRequest(TeaModel):
    def __init__(self, client_token=None, owner_account=None, owner_id=None, region_id=None,
                 resource_owner_account=None, resource_owner_id=None, user_cidr=None, vbr_id=None):
        self.client_token = client_token  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        self.user_cidr = user_cidr  # type: str
        self.vbr_id = vbr_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TerminateVirtualBorderRouterRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.user_cidr is not None:
            result['UserCidr'] = self.user_cidr
        if self.vbr_id is not None:
            result['VbrId'] = self.vbr_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('UserCidr') is not None:
            self.user_cidr = m.get('UserCidr')
        if m.get('VbrId') is not None:
            self.vbr_id = m.get('VbrId')
        return self


class TerminateVirtualBorderRouterResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TerminateVirtualBorderRouterResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TerminateVirtualBorderRouterResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: TerminateVirtualBorderRouterResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(TerminateVirtualBorderRouterResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TerminateVirtualBorderRouterResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassignIpv6AddressesRequest(TeaModel):
    def __init__(self, ipv_6address=None, ipv_6prefix=None, network_interface_id=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # The IPv6 addresses to unassign. You can specify up to 10 IPv6 addresses in a single request.
        self.ipv_6address = ipv_6address  # type: list[str]
        # > This parameter is in invitational preview and is unavailable for general users.
        self.ipv_6prefix = ipv_6prefix  # type: list[str]
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassignIpv6AddressesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_6address is not None:
            result['Ipv6Address'] = self.ipv_6address
        if self.ipv_6prefix is not None:
            result['Ipv6Prefix'] = self.ipv_6prefix
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv6Address') is not None:
            self.ipv_6address = m.get('Ipv6Address')
        if m.get('Ipv6Prefix') is not None:
            self.ipv_6prefix = m.get('Ipv6Prefix')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnassignIpv6AddressesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassignIpv6AddressesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassignIpv6AddressesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnassignIpv6AddressesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnassignIpv6AddressesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassignIpv6AddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassignPrivateIpAddressesRequest(TeaModel):
    def __init__(self, ipv_4prefix=None, network_interface_id=None, owner_account=None, owner_id=None,
                 private_ip_address=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        # > This parameter is in invitational preview and is unavailable to general users.
        self.ipv_4prefix = ipv_4prefix  # type: list[str]
        # The ID of the ENI.
        self.network_interface_id = network_interface_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The secondary private IP addresses to unassign.
        self.private_ip_address = private_ip_address  # type: list[str]
        # The region ID of the ENI. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassignPrivateIpAddressesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ipv_4prefix is not None:
            result['Ipv4Prefix'] = self.ipv_4prefix
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.private_ip_address is not None:
            result['PrivateIpAddress'] = self.private_ip_address
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ipv4Prefix') is not None:
            self.ipv_4prefix = m.get('Ipv4Prefix')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('PrivateIpAddress') is not None:
            self.private_ip_address = m.get('PrivateIpAddress')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnassignPrivateIpAddressesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassignPrivateIpAddressesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassignPrivateIpAddressesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnassignPrivateIpAddressesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnassignPrivateIpAddressesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassignPrivateIpAddressesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassociateEipAddressRequest(TeaModel):
    def __init__(self, allocation_id=None, instance_id=None, instance_type=None, owner_account=None, owner_id=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.allocation_id = allocation_id  # type: str
        self.instance_id = instance_id  # type: str
        self.instance_type = instance_type  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassociateEipAddressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allocation_id is not None:
            result['AllocationId'] = self.allocation_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllocationId') is not None:
            self.allocation_id = m.get('AllocationId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnassociateEipAddressResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassociateEipAddressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassociateEipAddressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnassociateEipAddressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnassociateEipAddressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassociateEipAddressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnassociateHaVipRequest(TeaModel):
    def __init__(self, client_token=None, force=None, ha_vip_id=None, instance_id=None, owner_account=None,
                 owner_id=None, region_id=None, resource_owner_account=None, resource_owner_id=None):
        self.client_token = client_token  # type: str
        self.force = force  # type: str
        self.ha_vip_id = ha_vip_id  # type: str
        self.instance_id = instance_id  # type: str
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassociateHaVipRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.force is not None:
            result['Force'] = self.force
        if self.ha_vip_id is not None:
            result['HaVipId'] = self.ha_vip_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('HaVipId') is not None:
            self.ha_vip_id = m.get('HaVipId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        return self


class UnassociateHaVipResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnassociateHaVipResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnassociateHaVipResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnassociateHaVipResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnassociateHaVipResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnassociateHaVipResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(self, all=None, owner_account=None, owner_id=None, region_id=None, resource_id=None,
                 resource_owner_account=None, resource_owner_id=None, resource_type=None, tag_key=None):
        # Specifies whether to remove all tags from the resource. This parameter is valid only when the TagKey.N parameter is not specified. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        self.all = all  # type: bool
        self.owner_account = owner_account  # type: str
        self.owner_id = owner_id  # type: long
        # The region ID of the resource. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The resource IDs.
        self.resource_id = resource_id  # type: list[str]
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The type of the resource. Valid values:
        # 
        # *   instance: ECS instance
        # *   disk: disk
        # *   snapshot: snapshot
        # *   image: image
        # *   securitygroup: security group
        # *   volume: storage volume
        # *   eni: elastic network interface (ENI)
        # *   ddh: dedicated host
        # *   ddhcluster: dedicated host cluster
        # *   keypair: SSH key pair
        # *   launchtemplate: launch template
        # *   reservedinstance: reserved instance
        # *   snapshotpolicy: automatic snapshot policy
        # *   elasticityassurance: elasticity assurance
        # *   capacityreservation: capacity reservation
        self.resource_type = resource_type  # type: str
        # The tag keys of the resource.
        self.tag_key = tag_key  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UntagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.owner_account is not None:
            result['OwnerAccount'] = self.owner_account
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('OwnerAccount') is not None:
            self.owner_account = m.get('OwnerAccount')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UntagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UntagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UntagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


