# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class AlertEventMetrics(TeaModel):
    def __init__(self, cur_value=None, metric_name=None, metric_name_en=None, metric_name_zh=None, operator=None,
                 statistics=None, threshold=None, unit=None, unit_factor=None):
        self.cur_value = cur_value  # type: str
        self.metric_name = metric_name  # type: str
        self.metric_name_en = metric_name_en  # type: str
        self.metric_name_zh = metric_name_zh  # type: str
        self.operator = operator  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.unit = unit  # type: str
        self.unit_factor = unit_factor  # type: float

    def validate(self):
        pass

    def to_map(self):
        _map = super(AlertEventMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cur_value is not None:
            result['CurValue'] = self.cur_value
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.metric_name_en is not None:
            result['MetricNameEn'] = self.metric_name_en
        if self.metric_name_zh is not None:
            result['MetricNameZh'] = self.metric_name_zh
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.unit is not None:
            result['Unit'] = self.unit
        if self.unit_factor is not None:
            result['UnitFactor'] = self.unit_factor
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurValue') is not None:
            self.cur_value = m.get('CurValue')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('MetricNameEn') is not None:
            self.metric_name_en = m.get('MetricNameEn')
        if m.get('MetricNameZh') is not None:
            self.metric_name_zh = m.get('MetricNameZh')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        if m.get('UnitFactor') is not None:
            self.unit_factor = m.get('UnitFactor')
        return self


class AlertEvent(TeaModel):
    def __init__(self, alert_name=None, alert_status=None, custom_labels=None, de_dup_id=None, details=None,
                 event_name=None, expression=None, metrics=None, resource_info=None, rule_name=None, severity=None, source=None,
                 summary=None, timestamp=None, trace_id=None, user_id=None):
        self.alert_name = alert_name  # type: str
        self.alert_status = alert_status  # type: str
        self.custom_labels = custom_labels  # type: dict[str, any]
        self.de_dup_id = de_dup_id  # type: str
        self.details = details  # type: str
        self.event_name = event_name  # type: str
        self.expression = expression  # type: str
        self.metrics = metrics  # type: list[AlertEventMetrics]
        self.resource_info = resource_info  # type: dict[str, any]
        self.rule_name = rule_name  # type: str
        self.severity = severity  # type: str
        self.source = source  # type: str
        self.summary = summary  # type: str
        self.timestamp = timestamp  # type: long
        self.trace_id = trace_id  # type: str
        self.user_id = user_id  # type: str

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AlertEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.alert_status is not None:
            result['AlertStatus'] = self.alert_status
        if self.custom_labels is not None:
            result['CustomLabels'] = self.custom_labels
        if self.de_dup_id is not None:
            result['DeDupId'] = self.de_dup_id
        if self.details is not None:
            result['Details'] = self.details
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.expression is not None:
            result['Expression'] = self.expression
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.resource_info is not None:
            result['ResourceInfo'] = self.resource_info
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.source is not None:
            result['Source'] = self.source
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        if self.trace_id is not None:
            result['TraceId'] = self.trace_id
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('AlertStatus') is not None:
            self.alert_status = m.get('AlertStatus')
        if m.get('CustomLabels') is not None:
            self.custom_labels = m.get('CustomLabels')
        if m.get('DeDupId') is not None:
            self.de_dup_id = m.get('DeDupId')
        if m.get('Details') is not None:
            self.details = m.get('Details')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = AlertEventMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('ResourceInfo') is not None:
            self.resource_info = m.get('ResourceInfo')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('Source') is not None:
            self.source = m.get('Source')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        if m.get('TraceId') is not None:
            self.trace_id = m.get('TraceId')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class AlertStrategyRelation(TeaModel):
    def __init__(self, alert_name=None, strategy_uuid=None):
        self.alert_name = alert_name  # type: str
        self.strategy_uuid = strategy_uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AlertStrategyRelation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_name is not None:
            result['AlertName'] = self.alert_name
        if self.strategy_uuid is not None:
            result['StrategyUuid'] = self.strategy_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertName') is not None:
            self.alert_name = m.get('AlertName')
        if m.get('StrategyUuid') is not None:
            self.strategy_uuid = m.get('StrategyUuid')
        return self


class Dimension(TeaModel):
    def __init__(self, label=None, value=None):
        self.label = label  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(Dimension, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class EscalationRuleEscalationsContactGroupsByLevel(TeaModel):
    def __init__(self, critical=None, error=None, info=None, resolve=None, warning=None):
        self.critical = critical  # type: list[str]
        self.error = error  # type: list[str]
        self.info = info  # type: list[str]
        self.resolve = resolve  # type: list[str]
        self.warning = warning  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(EscalationRuleEscalationsContactGroupsByLevel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical
        if self.error is not None:
            result['Error'] = self.error
        if self.info is not None:
            result['Info'] = self.info
        if self.resolve is not None:
            result['Resolve'] = self.resolve
        if self.warning is not None:
            result['Warning'] = self.warning
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            self.critical = m.get('Critical')
        if m.get('Error') is not None:
            self.error = m.get('Error')
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Resolve') is not None:
            self.resolve = m.get('Resolve')
        if m.get('Warning') is not None:
            self.warning = m.get('Warning')
        return self


class EscalationRuleEscalations(TeaModel):
    def __init__(self, contact_groups=None, contact_groups_by_level=None, escalate_min=None):
        self.contact_groups = contact_groups  # type: list[str]
        self.contact_groups_by_level = contact_groups_by_level  # type: EscalationRuleEscalationsContactGroupsByLevel
        self.escalate_min = escalate_min  # type: long

    def validate(self):
        if self.contact_groups_by_level:
            self.contact_groups_by_level.validate()

    def to_map(self):
        _map = super(EscalationRuleEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.contact_groups_by_level is not None:
            result['ContactGroupsByLevel'] = self.contact_groups_by_level.to_map()
        if self.escalate_min is not None:
            result['EscalateMin'] = self.escalate_min
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('ContactGroupsByLevel') is not None:
            temp_model = EscalationRuleEscalationsContactGroupsByLevel()
            self.contact_groups_by_level = temp_model.from_map(m['ContactGroupsByLevel'])
        if m.get('EscalateMin') is not None:
            self.escalate_min = m.get('EscalateMin')
        return self


class EscalationRule(TeaModel):
    def __init__(self, create_time=None, description=None, escalations=None, name=None, update_time=None,
                 user_id=None, uuid=None):
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.escalations = escalations  # type: list[EscalationRuleEscalations]
        self.name = name  # type: str
        self.update_time = update_time  # type: str
        self.user_id = user_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(EscalationRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['Escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['Escalations'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.escalations = []
        if m.get('Escalations') is not None:
            for k in m.get('Escalations'):
                temp_model = EscalationRuleEscalations()
                self.escalations.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class Incident(TeaModel):
    def __init__(self, action_time=None, alert_count=None, end_time=None, grouping_data=None, grouping_id=None,
                 grouping_key=None, incident_id=None, incident_status=None, severity=None, start_time=None, strategy_uuid=None,
                 user_id=None):
        self.action_time = action_time  # type: long
        self.alert_count = alert_count  # type: long
        self.end_time = end_time  # type: long
        self.grouping_data = grouping_data  # type: dict[str, any]
        self.grouping_id = grouping_id  # type: str
        self.grouping_key = grouping_key  # type: str
        self.incident_id = incident_id  # type: str
        self.incident_status = incident_status  # type: str
        self.severity = severity  # type: str
        self.start_time = start_time  # type: long
        self.strategy_uuid = strategy_uuid  # type: str
        self.user_id = user_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(Incident, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_time is not None:
            result['ActionTime'] = self.action_time
        if self.alert_count is not None:
            result['AlertCount'] = self.alert_count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.grouping_data is not None:
            result['GroupingData'] = self.grouping_data
        if self.grouping_id is not None:
            result['GroupingId'] = self.grouping_id
        if self.grouping_key is not None:
            result['GroupingKey'] = self.grouping_key
        if self.incident_id is not None:
            result['IncidentId'] = self.incident_id
        if self.incident_status is not None:
            result['IncidentStatus'] = self.incident_status
        if self.severity is not None:
            result['Severity'] = self.severity
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.strategy_uuid is not None:
            result['StrategyUuid'] = self.strategy_uuid
        if self.user_id is not None:
            result['UserId'] = self.user_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionTime') is not None:
            self.action_time = m.get('ActionTime')
        if m.get('AlertCount') is not None:
            self.alert_count = m.get('AlertCount')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupingData') is not None:
            self.grouping_data = m.get('GroupingData')
        if m.get('GroupingId') is not None:
            self.grouping_id = m.get('GroupingId')
        if m.get('GroupingKey') is not None:
            self.grouping_key = m.get('GroupingKey')
        if m.get('IncidentId') is not None:
            self.incident_id = m.get('IncidentId')
        if m.get('IncidentStatus') is not None:
            self.incident_status = m.get('IncidentStatus')
        if m.get('Severity') is not None:
            self.severity = m.get('Severity')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StrategyUuid') is not None:
            self.strategy_uuid = m.get('StrategyUuid')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        return self


class Matcher(TeaModel):
    def __init__(self, label=None, operator=None, value=None):
        self.label = label  # type: str
        self.operator = operator  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(Matcher, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.label is not None:
            result['Label'] = self.label
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Label') is not None:
            self.label = m.get('Label')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class MetricStat(TeaModel):
    def __init__(self, associated=None, dimensions=None, log_time=None, measurements=None, metric=None,
                 namespace=None, period=None, timestamp=None):
        self.associated = associated  # type: dict[str, str]
        self.dimensions = dimensions  # type: list[Dimension]
        self.log_time = log_time  # type: long
        self.measurements = measurements  # type: dict[str, any]
        self.metric = metric  # type: str
        self.namespace = namespace  # type: str
        self.period = period  # type: int
        self.timestamp = timestamp  # type: long

    def validate(self):
        if self.dimensions:
            for k in self.dimensions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MetricStat, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.associated is not None:
            result['Associated'] = self.associated
        result['Dimensions'] = []
        if self.dimensions is not None:
            for k in self.dimensions:
                result['Dimensions'].append(k.to_map() if k else None)
        if self.log_time is not None:
            result['LogTime'] = self.log_time
        if self.measurements is not None:
            result['Measurements'] = self.measurements
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.timestamp is not None:
            result['Timestamp'] = self.timestamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Associated') is not None:
            self.associated = m.get('Associated')
        self.dimensions = []
        if m.get('Dimensions') is not None:
            for k in m.get('Dimensions'):
                temp_model = Dimension()
                self.dimensions.append(temp_model.from_map(k))
        if m.get('LogTime') is not None:
            self.log_time = m.get('LogTime')
        if m.get('Measurements') is not None:
            self.measurements = m.get('Measurements')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Timestamp') is not None:
            self.timestamp = m.get('Timestamp')
        return self


class MigrationJobPlanContactsChannels(TeaModel):
    def __init__(self, level=None, type=None, value=None):
        self.level = level  # type: long
        self.type = type  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanContactsChannels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class MigrationJobPlanContacts(TeaModel):
    def __init__(self, channels=None, name=None):
        self.channels = channels  # type: list[MigrationJobPlanContactsChannels]
        self.name = name  # type: str

    def validate(self):
        if self.channels:
            for k in self.channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobPlanContacts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Channels'] = []
        if self.channels is not None:
            for k in self.channels:
                result['Channels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.channels = []
        if m.get('Channels') is not None:
            for k in m.get('Channels'):
                temp_model = MigrationJobPlanContactsChannels()
                self.channels.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class MigrationJobPlanEscalationsEscalationsLevelGroups(TeaModel):
    def __init__(self, critical=None, info=None, resolved=None, warning=None):
        self.critical = critical  # type: list[str]
        self.info = info  # type: list[str]
        self.resolved = resolved  # type: list[str]
        self.warning = warning  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanEscalationsEscalationsLevelGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical
        if self.info is not None:
            result['Info'] = self.info
        if self.resolved is not None:
            result['Resolved'] = self.resolved
        if self.warning is not None:
            result['Warning'] = self.warning
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            self.critical = m.get('Critical')
        if m.get('Info') is not None:
            self.info = m.get('Info')
        if m.get('Resolved') is not None:
            self.resolved = m.get('Resolved')
        if m.get('Warning') is not None:
            self.warning = m.get('Warning')
        return self


class MigrationJobPlanEscalationsEscalations(TeaModel):
    def __init__(self, groups=None, level_groups=None):
        self.groups = groups  # type: list[str]
        self.level_groups = level_groups  # type: MigrationJobPlanEscalationsEscalationsLevelGroups

    def validate(self):
        if self.level_groups:
            self.level_groups.validate()

    def to_map(self):
        _map = super(MigrationJobPlanEscalationsEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.groups is not None:
            result['Groups'] = self.groups
        if self.level_groups is not None:
            result['LevelGroups'] = self.level_groups.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Groups') is not None:
            self.groups = m.get('Groups')
        if m.get('LevelGroups') is not None:
            temp_model = MigrationJobPlanEscalationsEscalationsLevelGroups()
            self.level_groups = temp_model.from_map(m['LevelGroups'])
        return self


class MigrationJobPlanEscalations(TeaModel):
    def __init__(self, escalations=None, name=None, uuid=None):
        self.escalations = escalations  # type: list[MigrationJobPlanEscalationsEscalations]
        self.name = name  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobPlanEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['Escalations'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.escalations = []
        if m.get('Escalations') is not None:
            for k in m.get('Escalations'):
                temp_model = MigrationJobPlanEscalationsEscalations()
                self.escalations.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class MigrationJobPlanGroups(TeaModel):
    def __init__(self, contacts=None, name=None):
        self.contacts = contacts  # type: list[str]
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contacts is not None:
            result['Contacts'] = self.contacts
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Contacts') is not None:
            self.contacts = m.get('Contacts')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class MigrationJobPlanStrategiesEscalationSetting(TeaModel):
    def __init__(self, escalation_uuid=None):
        self.escalation_uuid = escalation_uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanStrategiesEscalationSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalation_uuid is not None:
            result['escalationUuid'] = self.escalation_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('escalationUuid') is not None:
            self.escalation_uuid = m.get('escalationUuid')
        return self


class MigrationJobPlanStrategiesPushingSetting(TeaModel):
    def __init__(self, target_uuids=None):
        self.target_uuids = target_uuids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanStrategiesPushingSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_uuids is not None:
            result['TargetUuids'] = self.target_uuids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetUuids') is not None:
            self.target_uuids = m.get('TargetUuids')
        return self


class MigrationJobPlanStrategies(TeaModel):
    def __init__(self, escalation_setting=None, name=None, pushing_setting=None):
        self.escalation_setting = escalation_setting  # type: MigrationJobPlanStrategiesEscalationSetting
        self.name = name  # type: str
        self.pushing_setting = pushing_setting  # type: MigrationJobPlanStrategiesPushingSetting

    def validate(self):
        if self.escalation_setting:
            self.escalation_setting.validate()
        if self.pushing_setting:
            self.pushing_setting.validate()

    def to_map(self):
        _map = super(MigrationJobPlanStrategies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalation_setting is not None:
            result['EscalationSetting'] = self.escalation_setting.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.pushing_setting is not None:
            result['PushingSetting'] = self.pushing_setting.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EscalationSetting') is not None:
            temp_model = MigrationJobPlanStrategiesEscalationSetting()
            self.escalation_setting = temp_model.from_map(m['EscalationSetting'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PushingSetting') is not None:
            temp_model = MigrationJobPlanStrategiesPushingSetting()
            self.pushing_setting = temp_model.from_map(m['PushingSetting'])
        return self


class MigrationJobPlanSubscriptionsConditions(TeaModel):
    def __init__(self, field=None, op=None, value=None):
        self.field = field  # type: str
        self.op = op  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanSubscriptionsConditions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.op is not None:
            result['Op'] = self.op
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Op') is not None:
            self.op = m.get('Op')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class MigrationJobPlanSubscriptions(TeaModel):
    def __init__(self, conditions=None, name=None, strategy_uuid=None):
        self.conditions = conditions  # type: list[MigrationJobPlanSubscriptionsConditions]
        self.name = name  # type: str
        self.strategy_uuid = strategy_uuid  # type: str

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobPlanSubscriptions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.strategy_uuid is not None:
            result['StrategyUuid'] = self.strategy_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = MigrationJobPlanSubscriptionsConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('StrategyUuid') is not None:
            self.strategy_uuid = m.get('StrategyUuid')
        return self


class MigrationJobPlanTargetsHttpRequestTarget(TeaModel):
    def __init__(self, content_type=None, method=None, url=None):
        self.content_type = content_type  # type: str
        self.method = method  # type: str
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobPlanTargetsHttpRequestTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.method is not None:
            result['Method'] = self.method
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class MigrationJobPlanTargets(TeaModel):
    def __init__(self, arn=None, http_request_target=None, name=None, type=None, uuid=None):
        self.arn = arn  # type: str
        self.http_request_target = http_request_target  # type: MigrationJobPlanTargetsHttpRequestTarget
        self.name = name  # type: str
        self.type = type  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.http_request_target:
            self.http_request_target.validate()

    def to_map(self):
        _map = super(MigrationJobPlanTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.http_request_target is not None:
            result['HttpRequestTarget'] = self.http_request_target.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('HttpRequestTarget') is not None:
            temp_model = MigrationJobPlanTargetsHttpRequestTarget()
            self.http_request_target = temp_model.from_map(m['HttpRequestTarget'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class MigrationJobPlan(TeaModel):
    def __init__(self, contacts=None, escalations=None, groups=None, rule_names=None, strategies=None,
                 subscriptions=None, targets=None):
        self.contacts = contacts  # type: list[MigrationJobPlanContacts]
        self.escalations = escalations  # type: list[MigrationJobPlanEscalations]
        self.groups = groups  # type: list[MigrationJobPlanGroups]
        self.rule_names = rule_names  # type: list[str]
        self.strategies = strategies  # type: list[MigrationJobPlanStrategies]
        self.subscriptions = subscriptions  # type: list[MigrationJobPlanSubscriptions]
        self.targets = targets  # type: list[MigrationJobPlanTargets]

    def validate(self):
        if self.contacts:
            for k in self.contacts:
                if k:
                    k.validate()
        if self.escalations:
            for k in self.escalations:
                if k:
                    k.validate()
        if self.groups:
            for k in self.groups:
                if k:
                    k.validate()
        if self.strategies:
            for k in self.strategies:
                if k:
                    k.validate()
        if self.subscriptions:
            for k in self.subscriptions:
                if k:
                    k.validate()
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobPlan, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contacts'] = []
        if self.contacts is not None:
            for k in self.contacts:
                result['Contacts'].append(k.to_map() if k else None)
        result['Escalations'] = []
        if self.escalations is not None:
            for k in self.escalations:
                result['Escalations'].append(k.to_map() if k else None)
        result['Groups'] = []
        if self.groups is not None:
            for k in self.groups:
                result['Groups'].append(k.to_map() if k else None)
        if self.rule_names is not None:
            result['RuleNames'] = self.rule_names
        result['Strategies'] = []
        if self.strategies is not None:
            for k in self.strategies:
                result['Strategies'].append(k.to_map() if k else None)
        result['Subscriptions'] = []
        if self.subscriptions is not None:
            for k in self.subscriptions:
                result['Subscriptions'].append(k.to_map() if k else None)
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contacts = []
        if m.get('Contacts') is not None:
            for k in m.get('Contacts'):
                temp_model = MigrationJobPlanContacts()
                self.contacts.append(temp_model.from_map(k))
        self.escalations = []
        if m.get('Escalations') is not None:
            for k in m.get('Escalations'):
                temp_model = MigrationJobPlanEscalations()
                self.escalations.append(temp_model.from_map(k))
        self.groups = []
        if m.get('Groups') is not None:
            for k in m.get('Groups'):
                temp_model = MigrationJobPlanGroups()
                self.groups.append(temp_model.from_map(k))
        if m.get('RuleNames') is not None:
            self.rule_names = m.get('RuleNames')
        self.strategies = []
        if m.get('Strategies') is not None:
            for k in m.get('Strategies'):
                temp_model = MigrationJobPlanStrategies()
                self.strategies.append(temp_model.from_map(k))
        self.subscriptions = []
        if m.get('Subscriptions') is not None:
            for k in m.get('Subscriptions'):
                temp_model = MigrationJobPlanSubscriptions()
                self.subscriptions.append(temp_model.from_map(k))
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = MigrationJobPlanTargets()
                self.targets.append(temp_model.from_map(k))
        return self


class MigrationJobSourceRuleKeywordFilter(TeaModel):
    def __init__(self, keywords=None, relation=None):
        self.keywords = keywords  # type: list[str]
        self.relation = relation  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobSourceRuleKeywordFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class MigrationJobSourceRulePrimaryFilters(TeaModel):
    def __init__(self, field=None, op_type=None, value=None):
        self.field = field  # type: str
        self.op_type = op_type  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobSourceRulePrimaryFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.op_type is not None:
            result['OpType'] = self.op_type
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('OpType') is not None:
            self.op_type = m.get('OpType')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class MigrationJobSourceRule(TeaModel):
    def __init__(self, keyword_filter=None, name=None, primary_filters=None):
        self.keyword_filter = keyword_filter  # type: MigrationJobSourceRuleKeywordFilter
        self.name = name  # type: str
        self.primary_filters = primary_filters  # type: list[MigrationJobSourceRulePrimaryFilters]

    def validate(self):
        if self.keyword_filter:
            self.keyword_filter.validate()
        if self.primary_filters:
            for k in self.primary_filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobSourceRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword_filter is not None:
            result['KeywordFilter'] = self.keyword_filter.to_map()
        if self.name is not None:
            result['Name'] = self.name
        result['PrimaryFilters'] = []
        if self.primary_filters is not None:
            for k in self.primary_filters:
                result['PrimaryFilters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('KeywordFilter') is not None:
            temp_model = MigrationJobSourceRuleKeywordFilter()
            self.keyword_filter = temp_model.from_map(m['KeywordFilter'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.primary_filters = []
        if m.get('PrimaryFilters') is not None:
            for k in m.get('PrimaryFilters'):
                temp_model = MigrationJobSourceRulePrimaryFilters()
                self.primary_filters.append(temp_model.from_map(k))
        return self


class MigrationJobSourceTargetsContent(TeaModel):
    def __init__(self, group=None, level=None, method=None, region=None, resource_path=None, url=None):
        self.group = group  # type: str
        self.level = level  # type: str
        self.method = method  # type: str
        self.region = region  # type: str
        self.resource_path = resource_path  # type: str
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrationJobSourceTargetsContent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group is not None:
            result['Group'] = self.group
        if self.level is not None:
            result['Level'] = self.level
        if self.method is not None:
            result['Method'] = self.method
        if self.region is not None:
            result['Region'] = self.region
        if self.resource_path is not None:
            result['ResourcePath'] = self.resource_path
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Group') is not None:
            self.group = m.get('Group')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ResourcePath') is not None:
            self.resource_path = m.get('ResourcePath')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class MigrationJobSourceTargets(TeaModel):
    def __init__(self, content=None, type=None):
        self.content = content  # type: MigrationJobSourceTargetsContent
        self.type = type  # type: str

    def validate(self):
        if self.content:
            self.content.validate()

    def to_map(self):
        _map = super(MigrationJobSourceTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            temp_model = MigrationJobSourceTargetsContent()
            self.content = temp_model.from_map(m['Content'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class MigrationJobSource(TeaModel):
    def __init__(self, rule=None, targets=None):
        self.rule = rule  # type: MigrationJobSourceRule
        self.targets = targets  # type: list[MigrationJobSourceTargets]

    def validate(self):
        if self.rule:
            self.rule.validate()
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJobSource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule is not None:
            result['Rule'] = self.rule.to_map()
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Rule') is not None:
            temp_model = MigrationJobSourceRule()
            self.rule = temp_model.from_map(m['Rule'])
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = MigrationJobSourceTargets()
                self.targets.append(temp_model.from_map(k))
        return self


class MigrationJob(TeaModel):
    def __init__(self, create_time=None, detail=None, job_status=None, plan=None, rule_names=None, source=None,
                 update_time=None, uuid=None):
        self.create_time = create_time  # type: str
        self.detail = detail  # type: str
        self.job_status = job_status  # type: str
        self.plan = plan  # type: MigrationJobPlan
        self.rule_names = rule_names  # type: list[str]
        self.source = source  # type: list[MigrationJobSource]
        self.update_time = update_time  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.plan:
            self.plan.validate()
        if self.source:
            for k in self.source:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(MigrationJob, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.job_status is not None:
            result['JobStatus'] = self.job_status
        if self.plan is not None:
            result['Plan'] = self.plan.to_map()
        if self.rule_names is not None:
            result['RuleNames'] = self.rule_names
        result['Source'] = []
        if self.source is not None:
            for k in self.source:
                result['Source'].append(k.to_map() if k else None)
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('JobStatus') is not None:
            self.job_status = m.get('JobStatus')
        if m.get('Plan') is not None:
            temp_model = MigrationJobPlan()
            self.plan = temp_model.from_map(m['Plan'])
        if m.get('RuleNames') is not None:
            self.rule_names = m.get('RuleNames')
        self.source = []
        if m.get('Source') is not None:
            for k in m.get('Source'):
                temp_model = MigrationJobSource()
                self.source.append(temp_model.from_map(k))
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class NotificationStrategyEscalationSettingCustomChannels(TeaModel):
    def __init__(self, channel_type=None, severities=None, template_uuid=None):
        self.channel_type = channel_type  # type: str
        self.severities = severities  # type: list[str]
        self.template_uuid = template_uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationStrategyEscalationSettingCustomChannels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel_type is not None:
            result['ChannelType'] = self.channel_type
        if self.severities is not None:
            result['Severities'] = self.severities
        if self.template_uuid is not None:
            result['TemplateUuid'] = self.template_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ChannelType') is not None:
            self.channel_type = m.get('ChannelType')
        if m.get('Severities') is not None:
            self.severities = m.get('Severities')
        if m.get('TemplateUuid') is not None:
            self.template_uuid = m.get('TemplateUuid')
        return self


class NotificationStrategyEscalationSetting(TeaModel):
    def __init__(self, auto_resolve_min=None, custom_channels=None, escalation_level=None, escalation_uuid=None,
                 range=None, retrigger_min=None):
        self.auto_resolve_min = auto_resolve_min  # type: long
        self.custom_channels = custom_channels  # type: list[NotificationStrategyEscalationSettingCustomChannels]
        self.escalation_level = escalation_level  # type: str
        self.escalation_uuid = escalation_uuid  # type: str
        self.range = range  # type: str
        self.retrigger_min = retrigger_min  # type: long

    def validate(self):
        if self.custom_channels:
            for k in self.custom_channels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(NotificationStrategyEscalationSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_resolve_min is not None:
            result['AutoResolveMin'] = self.auto_resolve_min
        result['CustomChannels'] = []
        if self.custom_channels is not None:
            for k in self.custom_channels:
                result['CustomChannels'].append(k.to_map() if k else None)
        if self.escalation_level is not None:
            result['EscalationLevel'] = self.escalation_level
        if self.escalation_uuid is not None:
            result['EscalationUuid'] = self.escalation_uuid
        if self.range is not None:
            result['Range'] = self.range
        if self.retrigger_min is not None:
            result['RetriggerMin'] = self.retrigger_min
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoResolveMin') is not None:
            self.auto_resolve_min = m.get('AutoResolveMin')
        self.custom_channels = []
        if m.get('CustomChannels') is not None:
            for k in m.get('CustomChannels'):
                temp_model = NotificationStrategyEscalationSettingCustomChannels()
                self.custom_channels.append(temp_model.from_map(k))
        if m.get('EscalationLevel') is not None:
            self.escalation_level = m.get('EscalationLevel')
        if m.get('EscalationUuid') is not None:
            self.escalation_uuid = m.get('EscalationUuid')
        if m.get('Range') is not None:
            self.range = m.get('Range')
        if m.get('RetriggerMin') is not None:
            self.retrigger_min = m.get('RetriggerMin')
        return self


class NotificationStrategyFilterSettingBlackList(TeaModel):
    def __init__(self, field=None, op=None, value=None):
        self.field = field  # type: str
        self.op = op  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationStrategyFilterSettingBlackList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.op is not None:
            result['Op'] = self.op
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Op') is not None:
            self.op = m.get('Op')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class NotificationStrategyFilterSettingWhiteList(TeaModel):
    def __init__(self, field=None, op=None, value=None):
        self.field = field  # type: str
        self.op = op  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationStrategyFilterSettingWhiteList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.op is not None:
            result['Op'] = self.op
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Op') is not None:
            self.op = m.get('Op')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class NotificationStrategyFilterSetting(TeaModel):
    def __init__(self, black_list=None, white_list=None):
        self.black_list = black_list  # type: list[list[NotificationStrategyFilterSettingBlackList]]
        self.white_list = white_list  # type: list[list[NotificationStrategyFilterSettingWhiteList]]

    def validate(self):
        if self.black_list:
            for k in self.black_list:
                for k1 in k:
                    if k1:
                        k1.validate()
        if self.white_list:
            for k in self.white_list:
                for k1 in k:
                    if k1:
                        k1.validate()

    def to_map(self):
        _map = super(NotificationStrategyFilterSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['BlackList'] = []
        if self.black_list is not None:
            for k in self.black_list:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['blackList'].append(l1)
        result['WhiteList'] = []
        if self.white_list is not None:
            for k in self.white_list:
                l1 = []
                for k1 in k:
                    l1.append(k1.to_map() if k1 else None)
                result['whiteList'].append(l1)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.black_list = []
        if m.get('BlackList') is not None:
            for k in m.get('BlackList'):
                l1 = []
                for k1 in k:
                    temp_model = NotificationStrategyFilterSettingBlackList()
                    l1.append(temp_model.from_map(k1))
                self.black_list.append(l1)
        self.white_list = []
        if m.get('WhiteList') is not None:
            for k in m.get('WhiteList'):
                l1 = []
                for k1 in k:
                    temp_model = NotificationStrategyFilterSettingWhiteList()
                    l1.append(temp_model.from_map(k1))
                self.white_list.append(l1)
        return self


class NotificationStrategyGroupingSettingGroupingItems(TeaModel):
    def __init__(self, keys=None, type=None):
        self.keys = keys  # type: list[str]
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationStrategyGroupingSettingGroupingItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keys is not None:
            result['Keys'] = self.keys
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keys') is not None:
            self.keys = m.get('Keys')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class NotificationStrategyGroupingSetting(TeaModel):
    def __init__(self, enable_raw_alert_dispatching=None, grouping_items=None, period_min=None, silence_sec=None,
                 times=None):
        self.enable_raw_alert_dispatching = enable_raw_alert_dispatching  # type: bool
        self.grouping_items = grouping_items  # type: list[NotificationStrategyGroupingSettingGroupingItems]
        self.period_min = period_min  # type: int
        self.silence_sec = silence_sec  # type: int
        self.times = times  # type: int

    def validate(self):
        if self.grouping_items:
            for k in self.grouping_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(NotificationStrategyGroupingSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_raw_alert_dispatching is not None:
            result['EnableRawAlertDispatching'] = self.enable_raw_alert_dispatching
        result['GroupingItems'] = []
        if self.grouping_items is not None:
            for k in self.grouping_items:
                result['GroupingItems'].append(k.to_map() if k else None)
        if self.period_min is not None:
            result['PeriodMin'] = self.period_min
        if self.silence_sec is not None:
            result['SilenceSec'] = self.silence_sec
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableRawAlertDispatching') is not None:
            self.enable_raw_alert_dispatching = m.get('EnableRawAlertDispatching')
        self.grouping_items = []
        if m.get('GroupingItems') is not None:
            for k in m.get('GroupingItems'):
                temp_model = NotificationStrategyGroupingSettingGroupingItems()
                self.grouping_items.append(temp_model.from_map(k))
        if m.get('PeriodMin') is not None:
            self.period_min = m.get('PeriodMin')
        if m.get('SilenceSec') is not None:
            self.silence_sec = m.get('SilenceSec')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class NotificationStrategyPushingSetting(TeaModel):
    def __init__(self, pushing_data_format=None, range=None, target_uuids=None, template_uuid=None):
        self.pushing_data_format = pushing_data_format  # type: str
        self.range = range  # type: str
        self.target_uuids = target_uuids  # type: list[str]
        self.template_uuid = template_uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationStrategyPushingSetting, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.pushing_data_format is not None:
            result['PushingDataFormat'] = self.pushing_data_format
        if self.range is not None:
            result['Range'] = self.range
        if self.target_uuids is not None:
            result['TargetUuids'] = self.target_uuids
        if self.template_uuid is not None:
            result['TemplateUuid'] = self.template_uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PushingDataFormat') is not None:
            self.pushing_data_format = m.get('PushingDataFormat')
        if m.get('Range') is not None:
            self.range = m.get('Range')
        if m.get('TargetUuids') is not None:
            self.target_uuids = m.get('TargetUuids')
        if m.get('TemplateUuid') is not None:
            self.template_uuid = m.get('TemplateUuid')
        return self


class NotificationStrategy(TeaModel):
    def __init__(self, create_time=None, description=None, escalation_setting=None, filter_setting=None,
                 grouping_setting=None, name=None, pushing_setting=None, update_time=None, user_id=None, uuid=None):
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.escalation_setting = escalation_setting  # type: NotificationStrategyEscalationSetting
        self.filter_setting = filter_setting  # type: NotificationStrategyFilterSetting
        self.grouping_setting = grouping_setting  # type: NotificationStrategyGroupingSetting
        self.name = name  # type: str
        self.pushing_setting = pushing_setting  # type: NotificationStrategyPushingSetting
        self.update_time = update_time  # type: str
        self.user_id = user_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.escalation_setting:
            self.escalation_setting.validate()
        if self.filter_setting:
            self.filter_setting.validate()
        if self.grouping_setting:
            self.grouping_setting.validate()
        if self.pushing_setting:
            self.pushing_setting.validate()

    def to_map(self):
        _map = super(NotificationStrategy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.escalation_setting is not None:
            result['EscalationSetting'] = self.escalation_setting.to_map()
        if self.filter_setting is not None:
            result['FilterSetting'] = self.filter_setting.to_map()
        if self.grouping_setting is not None:
            result['GroupingSetting'] = self.grouping_setting.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.pushing_setting is not None:
            result['PushingSetting'] = self.pushing_setting.to_map()
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EscalationSetting') is not None:
            temp_model = NotificationStrategyEscalationSetting()
            self.escalation_setting = temp_model.from_map(m['EscalationSetting'])
        if m.get('FilterSetting') is not None:
            temp_model = NotificationStrategyFilterSetting()
            self.filter_setting = temp_model.from_map(m['FilterSetting'])
        if m.get('GroupingSetting') is not None:
            temp_model = NotificationStrategyGroupingSetting()
            self.grouping_setting = temp_model.from_map(m['GroupingSetting'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PushingSetting') is not None:
            temp_model = NotificationStrategyPushingSetting()
            self.pushing_setting = temp_model.from_map(m['PushingSetting'])
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class NotificationTemplate(TeaModel):
    def __init__(self, create_time=None, description=None, en_content=None, en_item_content=None, en_title=None,
                 name=None, type=None, update_time=None, user_id=None, uuid=None, wraper_type=None, zh_content=None,
                 zh_item_content=None, zh_title=None):
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.en_content = en_content  # type: str
        self.en_item_content = en_item_content  # type: str
        self.en_title = en_title  # type: str
        self.name = name  # type: str
        self.type = type  # type: str
        self.update_time = update_time  # type: str
        self.user_id = user_id  # type: str
        self.uuid = uuid  # type: str
        self.wraper_type = wraper_type  # type: str
        self.zh_content = zh_content  # type: str
        self.zh_item_content = zh_item_content  # type: str
        self.zh_title = zh_title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(NotificationTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.en_content is not None:
            result['EnContent'] = self.en_content
        if self.en_item_content is not None:
            result['EnItemContent'] = self.en_item_content
        if self.en_title is not None:
            result['EnTitle'] = self.en_title
        if self.name is not None:
            result['Name'] = self.name
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        if self.wraper_type is not None:
            result['WraperType'] = self.wraper_type
        if self.zh_content is not None:
            result['ZhContent'] = self.zh_content
        if self.zh_item_content is not None:
            result['ZhItemContent'] = self.zh_item_content
        if self.zh_title is not None:
            result['ZhTitle'] = self.zh_title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnContent') is not None:
            self.en_content = m.get('EnContent')
        if m.get('EnItemContent') is not None:
            self.en_item_content = m.get('EnItemContent')
        if m.get('EnTitle') is not None:
            self.en_title = m.get('EnTitle')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        if m.get('WraperType') is not None:
            self.wraper_type = m.get('WraperType')
        if m.get('ZhContent') is not None:
            self.zh_content = m.get('ZhContent')
        if m.get('ZhItemContent') is not None:
            self.zh_item_content = m.get('ZhItemContent')
        if m.get('ZhTitle') is not None:
            self.zh_title = m.get('ZhTitle')
        return self


class PushingTargetHttpRequestTargetHeaders(TeaModel):
    def __init__(self, key=None, value=None):
        self.key = key  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PushingTargetHttpRequestTargetHeaders, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PushingTargetHttpRequestTarget(TeaModel):
    def __init__(self, content_type=None, encrypt_string=None, headers=None, method=None, url=None):
        self.content_type = content_type  # type: str
        self.encrypt_string = encrypt_string  # type: str
        self.headers = headers  # type: list[PushingTargetHttpRequestTargetHeaders]
        self.method = method  # type: str
        self.url = url  # type: str

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PushingTargetHttpRequestTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.encrypt_string is not None:
            result['EncryptString'] = self.encrypt_string
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.method is not None:
            result['Method'] = self.method
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('EncryptString') is not None:
            self.encrypt_string = m.get('EncryptString')
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = PushingTargetHttpRequestTargetHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class PushingTarget(TeaModel):
    def __init__(self, arn=None, create_time=None, description=None, http_request_target=None, name=None, range=None,
                 template_uuid=None, type=None, update_time=None, user_id=None, uuid=None):
        self.arn = arn  # type: str
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.http_request_target = http_request_target  # type: PushingTargetHttpRequestTarget
        self.name = name  # type: str
        self.range = range  # type: str
        self.template_uuid = template_uuid  # type: str
        self.type = type  # type: str
        self.update_time = update_time  # type: str
        self.user_id = user_id  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.http_request_target:
            self.http_request_target.validate()

    def to_map(self):
        _map = super(PushingTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.http_request_target is not None:
            result['HttpRequestTarget'] = self.http_request_target.to_map()
        if self.name is not None:
            result['Name'] = self.name
        if self.range is not None:
            result['Range'] = self.range
        if self.template_uuid is not None:
            result['TemplateUuid'] = self.template_uuid
        if self.type is not None:
            result['Type'] = self.type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('HttpRequestTarget') is not None:
            temp_model = PushingTargetHttpRequestTarget()
            self.http_request_target = temp_model.from_map(m['HttpRequestTarget'])
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Range') is not None:
            self.range = m.get('Range')
        if m.get('TemplateUuid') is not None:
            self.template_uuid = m.get('TemplateUuid')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class SubscriptionConditions(TeaModel):
    def __init__(self, field=None, operator=None, value=None):
        self.field = field  # type: str
        self.operator = operator  # type: str
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SubscriptionConditions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.field is not None:
            result['Field'] = self.field
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Field') is not None:
            self.field = m.get('Field')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class Subscription(TeaModel):
    def __init__(self, conditions=None, create_time=None, description=None, name=None, relation=None,
                 strategy_uuid=None, update_time=None, uuid=None):
        self.conditions = conditions  # type: list[SubscriptionConditions]
        self.create_time = create_time  # type: str
        self.description = description  # type: str
        self.name = name  # type: str
        self.relation = relation  # type: str
        self.strategy_uuid = strategy_uuid  # type: str
        self.update_time = update_time  # type: str
        self.uuid = uuid  # type: str

    def validate(self):
        if self.conditions:
            for k in self.conditions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(Subscription, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Conditions'] = []
        if self.conditions is not None:
            for k in self.conditions:
                result['Conditions'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.relation is not None:
            result['Relation'] = self.relation
        if self.strategy_uuid is not None:
            result['StrategyUuid'] = self.strategy_uuid
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.conditions = []
        if m.get('Conditions') is not None:
            for k in m.get('Conditions'):
                temp_model = SubscriptionConditions()
                self.conditions.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        if m.get('StrategyUuid') is not None:
            self.strategy_uuid = m.get('StrategyUuid')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class AddTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N.
        # 
        # Valid values of N: 1 to 3. A tag key can be 1 to 64 characters in length.
        # 
        # You can create a tag key or specify an existing tag key. For more information about how to obtain a tag key, see [DescribeTagKeyList](~~145558~~).
        # 
        # > The tag key cannot start with `aliyun` or `acs:`. The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
        self.key = key  # type: str
        # The value of tag N.
        # 
        # Valid values of N: 1 to 3. A tag value can be 1 to 64 characters in length.
        # 
        # You can create a tag value or specify an existing tag value. For more information about how to obtain a tag value, see [DescribeTagKeyList](~~145557~~).
        # 
        # > The tag value cannot start with `aliyun` or `acs:`. The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class AddTagsRequest(TeaModel):
    def __init__(self, group_ids=None, region_id=None, tag=None):
        # The ID of the application group.
        # 
        # Valid values of N: 1 to 20.
        # 
        # For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_ids = group_ids  # type: list[str]
        self.region_id = region_id  # type: str
        # The tags.
        self.tag = tag  # type: list[AddTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_ids is not None:
            result['GroupIds'] = self.group_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupIds') is not None:
            self.group_ids = m.get('GroupIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = AddTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class AddTagsResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class AddTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyMetricRuleTemplateRequest(TeaModel):
    def __init__(self, apply_mode=None, enable_end_time=None, enable_start_time=None, group_id=None,
                 notify_level=None, silence_time=None, template_ids=None, webhook=None):
        # The mode in which the alert template is applied. Valid values:
        # 
        # *   GROUP_INSTANCE_FIRST: The metrics in the application group take precedence. If a metric specified in the alert template does not exist in the application group, the system does not generate an alert rule for the metric based on the alert template.
        # *   ALARM_TEMPLATE_FIRST: The metrics specified in the alert template take precedence. If a metric specified in the alert template does not exist in the application group, the system still generates an alert rule for the metric based on the alert template.
        self.apply_mode = apply_mode  # type: str
        # The end of the time period during which the alert rule is effective. Valid values: 00 to 23. A value of 00 indicates 00:59 and a value of 23 indicates 23:59.
        self.enable_end_time = enable_end_time  # type: long
        # The beginning of the time period during which the alert rule is effective. Valid values: 00 to 23. A value of 00 indicates 00:00 and a value of 23 indicates 23:00.
        self.enable_start_time = enable_start_time  # type: long
        # The ID of the application group to which the alert template is applied.
        # 
        # For more information about how to query the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: long
        # The alert notification method. Valid values:
        # 
        # Set the value to 4. A value of 4 indicates that alert notifications are sent by using TradeManager and DingTalk chatbots.
        self.notify_level = notify_level  # type: long
        # The mute period during which notifications are not repeatedly sent for an alert. Unit: seconds. Default value: 86400.
        # 
        # >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
        self.silence_time = silence_time  # type: long
        # The ID of the alert template.
        # 
        # For more information about how to query the IDs of alert templates, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.template_ids = template_ids  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyMetricRuleTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_mode is not None:
            result['ApplyMode'] = self.apply_mode
        if self.enable_end_time is not None:
            result['EnableEndTime'] = self.enable_end_time
        if self.enable_start_time is not None:
            result['EnableStartTime'] = self.enable_start_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.notify_level is not None:
            result['NotifyLevel'] = self.notify_level
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApplyMode') is not None:
            self.apply_mode = m.get('ApplyMode')
        if m.get('EnableEndTime') is not None:
            self.enable_end_time = m.get('EnableEndTime')
        if m.get('EnableStartTime') is not None:
            self.enable_start_time = m.get('EnableStartTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('NotifyLevel') is not None:
            self.notify_level = m.get('NotifyLevel')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('TemplateIds') is not None:
            self.template_ids = m.get('TemplateIds')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ApplyMetricRuleTemplateResponseBodyResourceAlertResults(TeaModel):
    def __init__(self, code=None, message=None, rule_id=None, rule_name=None, success=None):
        # The response code.
        # 
        # >  The HTTP status code 200 indicates that the call succeeds.
        self.code = code  # type: str
        # The returned information.
        self.message = message  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # Indicates whether the call succeeds. Valid values:
        # 
        # *   true: The call succeeds.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyMetricRuleTemplateResponseBodyResourceAlertResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ApplyMetricRuleTemplateResponseBodyResource(TeaModel):
    def __init__(self, alert_results=None, group_id=None):
        # The details of the generated alert rule.
        self.alert_results = alert_results  # type: list[ApplyMetricRuleTemplateResponseBodyResourceAlertResults]
        # The ID of the application group to which the alert template is applied.
        self.group_id = group_id  # type: long

    def validate(self):
        if self.alert_results:
            for k in self.alert_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ApplyMetricRuleTemplateResponseBodyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertResults'] = []
        if self.alert_results is not None:
            for k in self.alert_results:
                result['AlertResults'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_results = []
        if m.get('AlertResults') is not None:
            for k in m.get('AlertResults'):
                temp_model = ApplyMetricRuleTemplateResponseBodyResourceAlertResults()
                self.alert_results.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        return self


class ApplyMetricRuleTemplateResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource=None, success=None):
        # The response code.
        # 
        # >  The HTTP status code 200 indicates that the call succeeds.
        self.code = code  # type: int
        # The error message returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The resources that are affected by the alert rule.
        self.resource = resource  # type: ApplyMetricRuleTemplateResponseBodyResource
        # Indicates whether the call succeeds. Valid values:
        # 
        # *   true: The call succeeds.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(ApplyMetricRuleTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = ApplyMetricRuleTemplateResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ApplyMetricRuleTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApplyMetricRuleTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApplyMetricRuleTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyMetricRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateInstantSiteMonitorRequestTaskList(TeaModel):
    def __init__(self, address=None, isp_cities=None, options_json=None, task_name=None, task_type=None):
        # The URL or IP address that is monitored by the task.
        # 
        # >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
        self.address = address  # type: str
        # The detection points. If you leave this parameter empty, the system randomly selects three detection points.
        # 
        # The value is a `JSON array`. Example: `{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}`. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
        # 
        # For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](~~115045~~).
        self.isp_cities = isp_cities  # type: str
        # The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
        self.options_json = options_json  # type: str
        # The name of the site monitoring task.
        # 
        # The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (\_).
        # 
        # >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
        self.task_name = task_name  # type: str
        # The type of the site monitoring task.
        # 
        # Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
        # 
        # >  You must create at least one site monitoring task. You must specify all of the `Address`, `TaskName`, and `TaskType` parameters in each request.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchCreateInstantSiteMonitorRequestTaskList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('IspCities') is not None:
            self.isp_cities = m.get('IspCities')
        if m.get('OptionsJson') is not None:
            self.options_json = m.get('OptionsJson')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class BatchCreateInstantSiteMonitorRequest(TeaModel):
    def __init__(self, region_id=None, task_list=None):
        self.region_id = region_id  # type: str
        self.task_list = task_list  # type: list[BatchCreateInstantSiteMonitorRequestTaskList]

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(BatchCreateInstantSiteMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = BatchCreateInstantSiteMonitorRequestTaskList()
                self.task_list.append(temp_model.from_map(k))
        return self


class BatchCreateInstantSiteMonitorResponseBodyData(TeaModel):
    def __init__(self, task_id=None, task_name=None):
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The name of the site monitoring task.
        self.task_name = task_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchCreateInstantSiteMonitorResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class BatchCreateInstantSiteMonitorResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The information about the site monitoring task.
        self.data = data  # type: list[BatchCreateInstantSiteMonitorResponseBodyData]
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(BatchCreateInstantSiteMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = BatchCreateInstantSiteMonitorResponseBodyData()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCreateInstantSiteMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BatchCreateInstantSiteMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BatchCreateInstantSiteMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateInstantSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchCreateIntantSiteMonitorRequestTaskList(TeaModel):
    def __init__(self, address=None, isp_cities=None, options_json=None, task_name=None, task_type=None):
        self.address = address  # type: str
        self.isp_cities = isp_cities  # type: str
        self.options_json = options_json  # type: str
        self.task_name = task_name  # type: str
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchCreateIntantSiteMonitorRequestTaskList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('IspCities') is not None:
            self.isp_cities = m.get('IspCities')
        if m.get('OptionsJson') is not None:
            self.options_json = m.get('OptionsJson')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class BatchCreateIntantSiteMonitorRequest(TeaModel):
    def __init__(self, region_id=None, task_list=None):
        self.region_id = region_id  # type: str
        self.task_list = task_list  # type: list[BatchCreateIntantSiteMonitorRequestTaskList]

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(BatchCreateIntantSiteMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = BatchCreateIntantSiteMonitorRequestTaskList()
                self.task_list.append(temp_model.from_map(k))
        return self


class BatchCreateIntantSiteMonitorResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchCreateIntantSiteMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchCreateIntantSiteMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BatchCreateIntantSiteMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BatchCreateIntantSiteMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchCreateIntantSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class BatchExportRequest(TeaModel):
    def __init__(self, cursor=None, length=None, measurements=None, metric=None, namespace=None):
        # When you call this operation to export data, you must specify the `Cursor` parameter. You can obtain the value of the `Cursor` parameter by using one of the following methods:
        # 
        # *   When you call this operation for the first time, you must call the Cursor operation to obtain the `Cursor` value. For more information, see [Cursor](~~2330730~~).
        # *   When you call this operation again, you can obtain the `Cursor` value from the returned data of the last call.
        self.cursor = cursor  # type: str
        # The maximum number of data entries that can be returned in each response.
        # 
        # Valid values: 1 to 10000.
        self.length = length  # type: int
        # The statistical methods used to customize the returned data. By default, the measurements based on all statistical methods are returned.
        # 
        # For example, the `cpu_idle` metric of ECS (`acs_ecs_dashboard`) has three statistical methods: `Average`, `Maximum`, and `Minimum`. If you want to return only the measurements based on the `Average` and `Maximum` statistical methods, set this parameter to `["Average", "Maximum"]`.
        # 
        # The statistical methods of metrics are displayed in the `Statistics` column on the Metrics page of each cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.measurements = measurements  # type: list[str]
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about the metrics of cloud services, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  The value of this parameter must be the same as the value of the request parameter `Metric` in the Cursor operation.
        self.metric = metric  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  The value of this parameter must be the same as the value of the request parameter `Namespace` in the Cursor operation.
        self.namespace = namespace  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchExportRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.length is not None:
            result['Length'] = self.length
        if self.measurements is not None:
            result['Measurements'] = self.measurements
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('Measurements') is not None:
            self.measurements = m.get('Measurements')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class BatchExportShrinkRequest(TeaModel):
    def __init__(self, cursor=None, length=None, measurements_shrink=None, metric=None, namespace=None):
        # When you call this operation to export data, you must specify the `Cursor` parameter. You can obtain the value of the `Cursor` parameter by using one of the following methods:
        # 
        # *   When you call this operation for the first time, you must call the Cursor operation to obtain the `Cursor` value. For more information, see [Cursor](~~2330730~~).
        # *   When you call this operation again, you can obtain the `Cursor` value from the returned data of the last call.
        self.cursor = cursor  # type: str
        # The maximum number of data entries that can be returned in each response.
        # 
        # Valid values: 1 to 10000.
        self.length = length  # type: int
        # The statistical methods used to customize the returned data. By default, the measurements based on all statistical methods are returned.
        # 
        # For example, the `cpu_idle` metric of ECS (`acs_ecs_dashboard`) has three statistical methods: `Average`, `Maximum`, and `Minimum`. If you want to return only the measurements based on the `Average` and `Maximum` statistical methods, set this parameter to `["Average", "Maximum"]`.
        # 
        # The statistical methods of metrics are displayed in the `Statistics` column on the Metrics page of each cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.measurements_shrink = measurements_shrink  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about the metrics of cloud services, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  The value of this parameter must be the same as the value of the request parameter `Metric` in the Cursor operation.
        self.metric = metric  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  The value of this parameter must be the same as the value of the request parameter `Namespace` in the Cursor operation.
        self.namespace = namespace  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(BatchExportShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.length is not None:
            result['Length'] = self.length
        if self.measurements_shrink is not None:
            result['Measurements'] = self.measurements_shrink
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('Measurements') is not None:
            self.measurements_shrink = m.get('Measurements')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class BatchExportResponseBody(TeaModel):
    def __init__(self, anchor=None, code=None, cursor=None, data_results=None, has_next=None, length=None,
                 message=None, request_id=None, success=None):
        # The timestamp of the data requested by the backend. A larger timestamp indicates that the data export time is closer to the current time.
        self.anchor = anchor  # type: long
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The Cursor information that is used to call this operation again.
        # 
        # >  If `null` is returned, the monitoring data is exported.
        self.cursor = cursor  # type: str
        # The data returned in this call.
        self.data_results = data_results  # type: list[MetricStat]
        # Indicates whether the data has been exported. Valid values:
        # 
        # *   true: Some data is not exported.
        # *   false: All the data is exported.
        self.has_next = has_next  # type: bool
        # The number of data entries returned in this call.
        self.length = length  # type: int
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.data_results:
            for k in self.data_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(BatchExportResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.anchor is not None:
            result['Anchor'] = self.anchor
        if self.code is not None:
            result['Code'] = self.code
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        result['DataResults'] = []
        if self.data_results is not None:
            for k in self.data_results:
                result['DataResults'].append(k.to_map() if k else None)
        if self.has_next is not None:
            result['HasNext'] = self.has_next
        if self.length is not None:
            result['Length'] = self.length
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Anchor') is not None:
            self.anchor = m.get('Anchor')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        self.data_results = []
        if m.get('DataResults') is not None:
            for k in m.get('DataResults'):
                temp_model = MetricStat()
                self.data_results.append(temp_model.from_map(k))
        if m.get('HasNext') is not None:
            self.has_next = m.get('HasNext')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class BatchExportResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: BatchExportResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(BatchExportResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = BatchExportResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCmsCallNumOrderRequest(TeaModel):
    def __init__(self, auto_pay=None, auto_renew_period=None, auto_use_coupon=None, period=None, period_unit=None,
                 phone_count=None):
        self.auto_pay = auto_pay  # type: bool
        self.auto_renew_period = auto_renew_period  # type: int
        self.auto_use_coupon = auto_use_coupon  # type: bool
        self.period = period  # type: int
        self.period_unit = period_unit  # type: str
        self.phone_count = phone_count  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsCallNumOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.phone_count is not None:
            result['PhoneCount'] = self.phone_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PhoneCount') is not None:
            self.phone_count = m.get('PhoneCount')
        return self


class CreateCmsCallNumOrderResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        self.order_id = order_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsCallNumOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCmsCallNumOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCmsCallNumOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCmsCallNumOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCmsCallNumOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCmsOrderRequest(TeaModel):
    def __init__(self, api_count=None, auto_pay=None, auto_renew_period=None, auto_use_coupon=None,
                 custom_time_series=None, event_store_num=None, event_store_time=None, log_monitor_stream=None, pay_type=None,
                 period=None, period_unit=None, phone_count=None, site_ecs_num=None, site_operator_num=None,
                 site_task_num=None, sms_count=None, suggest_type=None):
        self.api_count = api_count  # type: str
        self.auto_pay = auto_pay  # type: bool
        self.auto_renew_period = auto_renew_period  # type: int
        self.auto_use_coupon = auto_use_coupon  # type: bool
        self.custom_time_series = custom_time_series  # type: str
        self.event_store_num = event_store_num  # type: str
        self.event_store_time = event_store_time  # type: str
        self.log_monitor_stream = log_monitor_stream  # type: str
        self.pay_type = pay_type  # type: str
        self.period = period  # type: int
        self.period_unit = period_unit  # type: str
        self.phone_count = phone_count  # type: str
        self.site_ecs_num = site_ecs_num  # type: str
        self.site_operator_num = site_operator_num  # type: str
        self.site_task_num = site_task_num  # type: str
        self.sms_count = sms_count  # type: str
        self.suggest_type = suggest_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api_count is not None:
            result['ApiCount'] = self.api_count
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.custom_time_series is not None:
            result['CustomTimeSeries'] = self.custom_time_series
        if self.event_store_num is not None:
            result['EventStoreNum'] = self.event_store_num
        if self.event_store_time is not None:
            result['EventStoreTime'] = self.event_store_time
        if self.log_monitor_stream is not None:
            result['LogMonitorStream'] = self.log_monitor_stream
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.phone_count is not None:
            result['PhoneCount'] = self.phone_count
        if self.site_ecs_num is not None:
            result['SiteEcsNum'] = self.site_ecs_num
        if self.site_operator_num is not None:
            result['SiteOperatorNum'] = self.site_operator_num
        if self.site_task_num is not None:
            result['SiteTaskNum'] = self.site_task_num
        if self.sms_count is not None:
            result['SmsCount'] = self.sms_count
        if self.suggest_type is not None:
            result['SuggestType'] = self.suggest_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApiCount') is not None:
            self.api_count = m.get('ApiCount')
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('CustomTimeSeries') is not None:
            self.custom_time_series = m.get('CustomTimeSeries')
        if m.get('EventStoreNum') is not None:
            self.event_store_num = m.get('EventStoreNum')
        if m.get('EventStoreTime') is not None:
            self.event_store_time = m.get('EventStoreTime')
        if m.get('LogMonitorStream') is not None:
            self.log_monitor_stream = m.get('LogMonitorStream')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PhoneCount') is not None:
            self.phone_count = m.get('PhoneCount')
        if m.get('SiteEcsNum') is not None:
            self.site_ecs_num = m.get('SiteEcsNum')
        if m.get('SiteOperatorNum') is not None:
            self.site_operator_num = m.get('SiteOperatorNum')
        if m.get('SiteTaskNum') is not None:
            self.site_task_num = m.get('SiteTaskNum')
        if m.get('SmsCount') is not None:
            self.sms_count = m.get('SmsCount')
        if m.get('SuggestType') is not None:
            self.suggest_type = m.get('SuggestType')
        return self


class CreateCmsOrderResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        self.order_id = order_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCmsOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCmsOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCmsOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCmsOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCmsSmspackageOrderRequest(TeaModel):
    def __init__(self, auto_pay=None, auto_renew_period=None, auto_use_coupon=None, period=None, period_unit=None,
                 sms_count=None):
        self.auto_pay = auto_pay  # type: bool
        self.auto_renew_period = auto_renew_period  # type: int
        self.auto_use_coupon = auto_use_coupon  # type: bool
        self.period = period  # type: int
        self.period_unit = period_unit  # type: str
        self.sms_count = sms_count  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsSmspackageOrderRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew_period is not None:
            result['AutoRenewPeriod'] = self.auto_renew_period
        if self.auto_use_coupon is not None:
            result['AutoUseCoupon'] = self.auto_use_coupon
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.sms_count is not None:
            result['SmsCount'] = self.sms_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenewPeriod') is not None:
            self.auto_renew_period = m.get('AutoRenewPeriod')
        if m.get('AutoUseCoupon') is not None:
            self.auto_use_coupon = m.get('AutoUseCoupon')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('SmsCount') is not None:
            self.sms_count = m.get('SmsCount')
        return self


class CreateCmsSmspackageOrderResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        self.order_id = order_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCmsSmspackageOrderResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCmsSmspackageOrderResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCmsSmspackageOrderResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCmsSmspackageOrderResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCmsSmspackageOrderResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDynamicTagGroupRequestMatchExpress(TeaModel):
    def __init__(self, tag_name=None, tag_value=None, tag_value_match_function=None):
        # The tag values of the cloud resources. In this example, set the value of N to 1.
        # 
        # >  If you set the `MatchExpress.N.TagValueMatchFunction` parameter, you must also set the `MatchExpress.N.TagValue` parameter.
        self.tag_name = tag_name  # type: str
        # The ID of the region to which the tags belong.
        self.tag_value = tag_value  # type: str
        # The error message.
        self.tag_value_match_function = tag_value_match_function  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDynamicTagGroupRequestMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_name is not None:
            result['TagName'] = self.tag_name
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.tag_value_match_function is not None:
            result['TagValueMatchFunction'] = self.tag_value_match_function
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagName') is not None:
            self.tag_name = m.get('TagName')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('TagValueMatchFunction') is not None:
            self.tag_value_match_function = m.get('TagValueMatchFunction')
        return self


class CreateDynamicTagGroupRequest(TeaModel):
    def __init__(self, contact_group_list=None, enable_install_agent=None, enable_subscribe_event=None,
                 match_express=None, match_express_filter_relation=None, region_id=None, tag_key=None, tag_region_id=None,
                 template_id_list=None):
        # The relationship between the conditional expressions for the tag values of the cloud resources. Valid values:
        # 
        # *   and (default)
        # *   or
        self.contact_group_list = contact_group_list  # type: list[str]
        # The ID of the region to which the tags belong.
        self.enable_install_agent = enable_install_agent  # type: bool
        # The keys of the tags that are used to create the application group. If a specified key is attached to multiple resources, the resources that have the same key-value pair are added to the same group.
        self.enable_subscribe_event = enable_subscribe_event  # type: bool
        # Specifies whether the CloudMonitor agent is automatically installed for the application group. CloudMonitor determines whether to automatically install the CloudMonitor agent for the hosts in an application group based on the value of this parameter. Valid values:
        # 
        # *   true: The CloudMonitor agent is automatically installed.
        # *   false (default): The CloudMonitor agent is not automatically installed.
        self.match_express = match_express  # type: list[CreateDynamicTagGroupRequestMatchExpress]
        # Specifies whether the application group automatically subscribes to event notifications. If events whose severity level is critical or warning occur on resources in an application group, CloudMonitor sends alert notifications. Valid values:
        # 
        # *   true: The application group automatically subscribes to event notifications.
        # *   false (default): The application group does not automatically subscribe to event notifications.
        self.match_express_filter_relation = match_express_filter_relation  # type: str
        self.region_id = region_id  # type: str
        # The alert contact groups. Valid values of N: 1 to 100. The alert notifications of the application group are sent to the alert contacts that belong to the specified alert contact groups.
        # 
        # An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~). For information about how to obtain alert contact groups, see [DescribeContactGroupList](~~114922~~).
        self.tag_key = tag_key  # type: str
        # The tag keys of the cloud resources.
        # 
        # For more information about how to obtain tag keys, see [DescribeTagKeyList](~~145558~~).
        self.tag_region_id = tag_region_id  # type: str
        # The IDs of the alert templates.
        # 
        # For more information about how to query alert template IDs, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.template_id_list = template_id_list  # type: list[str]

    def validate(self):
        if self.match_express:
            for k in self.match_express:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDynamicTagGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_list is not None:
            result['ContactGroupList'] = self.contact_group_list
        if self.enable_install_agent is not None:
            result['EnableInstallAgent'] = self.enable_install_agent
        if self.enable_subscribe_event is not None:
            result['EnableSubscribeEvent'] = self.enable_subscribe_event
        result['MatchExpress'] = []
        if self.match_express is not None:
            for k in self.match_express:
                result['MatchExpress'].append(k.to_map() if k else None)
        if self.match_express_filter_relation is not None:
            result['MatchExpressFilterRelation'] = self.match_express_filter_relation
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_region_id is not None:
            result['TagRegionId'] = self.tag_region_id
        if self.template_id_list is not None:
            result['TemplateIdList'] = self.template_id_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupList') is not None:
            self.contact_group_list = m.get('ContactGroupList')
        if m.get('EnableInstallAgent') is not None:
            self.enable_install_agent = m.get('EnableInstallAgent')
        if m.get('EnableSubscribeEvent') is not None:
            self.enable_subscribe_event = m.get('EnableSubscribeEvent')
        self.match_express = []
        if m.get('MatchExpress') is not None:
            for k in m.get('MatchExpress'):
                temp_model = CreateDynamicTagGroupRequestMatchExpress()
                self.match_express.append(temp_model.from_map(k))
        if m.get('MatchExpressFilterRelation') is not None:
            self.match_express_filter_relation = m.get('MatchExpressFilterRelation')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagRegionId') is not None:
            self.tag_region_id = m.get('TagRegionId')
        if m.get('TemplateIdList') is not None:
            self.template_id_list = m.get('TemplateIdList')
        return self


class CreateDynamicTagGroupResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The ID of the tag matching rule.
        self.id = id  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDynamicTagGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDynamicTagGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDynamicTagGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDynamicTagGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDynamicTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: str
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: str
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: str
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateGroupMetricRulesRequestGroupMetricRulesEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical
        self.info = info  # type: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo
        self.warn = warn  # type: CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRulesEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = CreateGroupMetricRulesRequestGroupMetricRulesEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = CreateGroupMetricRulesRequestGroupMetricRulesEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = CreateGroupMetricRulesRequestGroupMetricRulesEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class CreateGroupMetricRulesRequestGroupMetricRulesLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the alert rule. The specified tag is contained in alert notifications.
        # 
        # Valid values of N: 1 to 200.
        self.key = key  # type: str
        # The tag value of the alert rule. The specified tag is contained in alert notifications.
        # 
        # Valid values of N: 1 to 200.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRulesLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateGroupMetricRulesRequestGroupMetricRules(TeaModel):
    def __init__(self, escalations=None, category=None, contact_groups=None, dimensions=None,
                 effective_interval=None, email_subject=None, interval=None, labels=None, metric_name=None, namespace=None,
                 no_data_policy=None, no_effective_interval=None, period=None, rule_id=None, rule_name=None, silence_time=None,
                 webhook=None):
        self.escalations = escalations  # type: CreateGroupMetricRulesRequestGroupMetricRulesEscalations
        # The name of the cloud service. Valid values of N: 1 to 200. Valid value:
        # 
        # *   PolarDB: PolarDB
        # *   NewBGPDDoS: Anti-DDoS Pro
        # *   IoTDevice: IoT Platform
        # *   DRDS: Distributed Relational Database Service (DRDS)
        # *   VS: Video Surveillance System
        # *   AMQP: Alibaba Cloud Message Queue for AMQP
        # *   ADS: AnalyticDB
        # *   APIGateway: API Gateway
        # *   InternetSharedBandwidth: EIP Bandwidth Plan
        # *   CDN: Alibaba Cloud Content Delivery Network (CDN)
        # *   CEN: Cloud Enterprise Network (CEN)
        # *   DCDN: Dynamic Route for CDN (DCDN)
        # *   DDoS: Anti-DDoS
        # *   ECS: Elastic Compute Service (ECS)
        # *   DirectMail: Direct Mail
        # *   Elasticsearch: Elasticsearch
        # *   EMR: E-MapReduce (EMR)
        # *   ESS: Auto Scaling
        # *   FunctionCompute: Function Compute
        # *   RealtimeCompute: Realtime Compute for Apache Flink
        # *   GlobalAcceleration: Global Accelerator (GA)
        # *   Hbase: ApsaraDB for HBase
        # *   TSDB: Time Series Database (TSDB)
        # *   IPv6trans: IPv6 Translation Service
        # *   Kafka: Message Queue for Apache Kafka
        # *   Kubernetes: Container Service for Kubernetes (ACK)
        # *   KVstore: ApsaraDB for Redis
        # *   MNS: Message Service (MNS)
        # *   MongoDB: ApsaraDB for MongoDB
        # *   MQ: Message Queue
        # *   NAT: NAT Gateway
        # *   OpenAd: Open Ad
        # *   OpenSearch: Open Search
        # *   OSS: Object Storage Service (OSS)
        # *   PCDN: P2P CDN
        # *   petadata: HybridDB for MySQL
        # *   RDS: ApsaraDB RDS
        # *   SCDN: Secure CDN
        # *   SLB: Server Load Balancer (SLB)
        # *   SLS: Log Service
        # *   VideoLive: ApsaraVideo Live
        # *   VOD: ApsaraVideo VOD
        # *   EIP: Elastic IP Address (EIP)
        # *   VPN: VPN Gateway
        # *   AIRec: Artificial Intelligence Recommendation
        # *   GPDB: AnalyticDB for PostgreSQL
        # *   DBS: Database Backup (DBS)
        # *   SAG: Smart Access Gateway (SAG)
        # *   Memcache: ApsaraDB for Memcache
        # *   IOT_EDGE: Link IoT Edge
        # *   OCS: ApsaraDB for Memcache (previous version)
        # *   VPC: Express Connect
        # *   EHPC: Elastic High Performance Computing (E-HPC)
        # *   MPS: ApsaraVideo Media Processing
        # *   ENS: Edge Node Service (ENS)
        # *   MaxCompute_Prepay: MaxCompute
        # *   IoT_Kubernetes: Edge Application Hosting
        # *   CMS: CloudMonitor
        # *   batchcomputenew: Batch Compute
        # *   HBaseUE: ApsaraDB for HBase Performance-enhanced Edition
        # *   UIS: Ultimate Internet Service (UIS)
        # *   nls: Intelligent Speech Interaction
        # *   ots: Tablestore
        # *   NAS: Apsara File Storage NAS
        # *   ECI: Elastic Container Instance (ECI)
        # *   OpenAPI: OpenAPI Explorer
        # *   pvtzpost: Alibaba Cloud DNS PrivateZone
        # *   blinkonk8s: Flink on Kubernetes
        # *   FunctionFlow: Serverless Workflow (SWF)
        # *   SMC: Server Migration Center (SMC)
        # *   ddosbgp: Anti-DDoS Origin
        # *   baas: Blockchain as a Service
        # *   privatelink: PrivateLink
        # *   cds: ApsaraDB for Cassandra
        # *   DDH: Dedicated Host
        # *   RocketMQ: Message Queue for Apache RocketMQ
        # *   ECC: Express Cloud Connect
        # *   hbaseserverless: ApsaraDB for HBase Serverless Edition
        # *   mns_tmp: Message Service
        # *   hdr: Hybrid Disaster Recovery (HDR)
        # *   hbr: Hybrid Backup Recovery (HBR)
        # *   ADB: AnalyticDB for MySQL V3.0
        # *   tag: Tag Service
        # *   GDB: Graph Database
        # *   WAF: Web Application Firewall (WAF)
        # *   hcs_sgw: Cloud Storage Gateway (CSG)
        # *   ipv6gateway: IPv6 Gateway
        # *   RDS_SAR: ApsaraDB Exclusive Host Group
        # *   learn: Machine Learning Platform for AI
        # *   ROS: Resource Orchestration Service (ROS)
        # *   OOS: Operation Orchestration Service (OOS)
        # *   bds: Data Synchronization for HBase
        # *   cfw: Cloud Firewall
        # *   ddosDip: Anti-DDoS Premium
        # *   datahub: DataHub
        # *   hologres: Hologres
        # *   ExpressConnect: Express Connect
        # *   dbfs: Database File System (DBFS)
        # *   clickhouse: ApsaraDB for ClickHouse
        # *   k8s: Container Service for Kubernetes (ACK)
        # *   DTS: Data Transmission Service (DTS)
        # *   AnycastEIP: Anycast Elastic IP Address
        # *   Lindorm: ApsaraDB for Lindorm
        # *   config: Cloud Config
        # *   spark: Databricks DataInsight (DDI)
        # *   serverless: Serverless App Engine (SAE)
        # *   alb: Application Load Balancer (ALB)
        # *   oceanbase: ApsaraDB for OceanBase
        # *   KMS: Key Management Service (KMS)
        # *   lvwang: Content Moderation
        # *   LinkVisual: LinkVisual
        # *   tair: ApsaraDB for Redis Enhanced Edition (Tair)
        # *   dlf: Data Lake Formation (DLF)
        # *   networkmonitor: Site Monitoring
        # *   pnc: Physical Network Change
        # *   AIS: Alibaba Cloud Infrastructure
        # *   cloudgame: Cloud Gaming Platform
        # *   RTC: Real-Time Communication
        # *   cloudbox: CloudBox
        # *   actiontrail: ActionTrail
        # *   cc: Cloud Connector
        # *   disk: Elastic Block Storage (EBS)
        # *   easygene: Genomics Computing Platform
        # *   cloudphone: Elastic Cloud Phone
        # *   BMS: Bare Metal Management Service
        # *   swas: Simple Application Server
        # *   AvailabilityMonitoring: Availability Monitoring of CloudMonitor
        self.category = category  # type: str
        # The alert contact groups. Valid values of N: 1 to 200.
        # 
        # For information about how to obtain alert contact groups, see [DescribeContactGroupList](~~114922~~).
        self.contact_groups = contact_groups  # type: str
        # The dimension of the alert rule. Valid values of N: 1 to 200.
        # 
        # Set the value to a set of key-value pairs, for example, `userId:120886317861****` or `instanceId:i-m5e1qg6uo38rztr4****`.
        self.dimensions = dimensions  # type: str
        # The time period during which the alert rule is effective. Valid values of N: 1 to 200.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email. Valid values of N: 1 to 200.
        self.email_subject = email_subject  # type: str
        # The interval at which CloudMonitor checks whether the alert rule is triggered. Valid values of N: 1 to 200.
        # 
        # Unit: seconds. The default value is the lowest frequency at which the metric is polled.
        # 
        # >  We recommend that you set the interval to the data aggregation period. If the interval is shorter than the data aggregation period, alerts cannot be triggered due to insufficient data.
        self.interval = interval  # type: str
        self.labels = labels  # type: list[CreateGroupMetricRulesRequestGroupMetricRulesLabels]
        # The name of the metric. Valid values of N: 1 to 200.
        # 
        # For information about how to obtain the name of a metric, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service. Valid values of N: 1 to 200.
        # 
        # For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The method that is used to handle alerts when no monitoring data is found. Valid values of N: 1 to 200. Valid value:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The alert rule has no active alerts.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective. Valid values of N: 1 to 200.
        self.no_effective_interval = no_effective_interval  # type: str
        # The aggregation period of the metric data. Valid values of N: 1 to 200.
        # 
        # Set the `Period` parameter to an integral multiple of 60. Unit: seconds. Default value: 300.
        self.period = period  # type: str
        # The ID of the alert rule. Valid values of N: 1 to 200.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule. Valid values of N: 1 to 200.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Valid values of N: 1 to 200.
        # 
        # Unit: seconds. Default value: 86400. Minimum value: 3600.
        self.silence_time = silence_time  # type: int
        # The callback URL. Valid values of N: 1 to 200.
        # 
        # The callback URL must be accessible over the Internet. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequestGroupMetricRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.category is not None:
            result['Category'] = self.category
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.interval is not None:
            result['Interval'] = self.interval
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = CreateGroupMetricRulesRequestGroupMetricRulesEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = CreateGroupMetricRulesRequestGroupMetricRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class CreateGroupMetricRulesRequest(TeaModel):
    def __init__(self, group_id=None, group_metric_rules=None, region_id=None):
        # The ID of the application group.
        # 
        # For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: long
        self.group_metric_rules = group_metric_rules  # type: list[CreateGroupMetricRulesRequestGroupMetricRules]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.group_metric_rules:
            for k in self.group_metric_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['GroupMetricRules'] = []
        if self.group_metric_rules is not None:
            for k in self.group_metric_rules:
                result['GroupMetricRules'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.group_metric_rules = []
        if m.get('GroupMetricRules') is not None:
            for k in m.get('GroupMetricRules'):
                temp_model = CreateGroupMetricRulesRequestGroupMetricRules()
                self.group_metric_rules.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateGroupMetricRulesResponseBodyResourcesAlertResult(TeaModel):
    def __init__(self, code=None, message=None, rule_id=None, rule_name=None, success=None):
        # The status code that is returned for the alert rule.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: int
        # The error message that is returned for the alert rule.
        self.message = message  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # Indicates whether the alert rule was created. Valid value:
        # 
        # - true: The alert rule was created.
        # - false: The alert rule failed to be created.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMetricRulesResponseBodyResourcesAlertResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateGroupMetricRulesResponseBodyResources(TeaModel):
    def __init__(self, alert_result=None):
        self.alert_result = alert_result  # type: list[CreateGroupMetricRulesResponseBodyResourcesAlertResult]

    def validate(self):
        if self.alert_result:
            for k in self.alert_result:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertResult'] = []
        if self.alert_result is not None:
            for k in self.alert_result:
                result['AlertResult'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_result = []
        if m.get('AlertResult') is not None:
            for k in m.get('AlertResult'):
                temp_model = CreateGroupMetricRulesResponseBodyResourcesAlertResult()
                self.alert_result.append(temp_model.from_map(k))
        return self


class CreateGroupMetricRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resources=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the alert rules.
        self.resources = resources  # type: CreateGroupMetricRulesResponseBodyResources
        # Indicates whether the call is successful. Valid value:
        # 
        # - true: The call is successful.
        # - false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = CreateGroupMetricRulesResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateGroupMetricRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateGroupMetricRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateGroupMetricRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGroupMetricRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The Alibaba Cloud Resource Name (ARN) of the resource.
        # 
        # For information about how to obtain the ARN of a resource, see [DescribeMetricRuleTargets](~~121592~~).
        # 
        # Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # 
        # *   {userId}: the ID of the Alibaba Cloud account.
        # 
        # *   {regionId}: the region ID of the message queue or topic.
        # 
        # *   {Resource type}: the type of the resource that triggers the alert. Valid values:
        # 
        #     *   **queues**\
        #     *   **topics**\
        # 
        # *   {Resource name}: the resource name.
        # 
        #     *   If the resource type is **queues**, the resource name is the queue name.
        #     *   If the resource type is **topics**, the resource name is the topic name.
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        # 
        # For information about how to obtain the ID of a resource for which alerts are triggered, see [DescribeMetricRuleTargets](~~121592~~).
        self.id = id  # type: str
        # The parameters of the alert callback. Specify the parameters in the JSON format.
        self.json_params = json_params  # type: str
        # The alert level. Valid values:
        # 
        # *   INFO
        # *   WARN
        # *   CRITICAL
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class CreateGroupMonitoringAgentProcessRequestAlertConfig(TeaModel):
    def __init__(self, comparison_operator=None, effective_interval=None, escalations_level=None,
                 no_effective_interval=None, silence_time=None, statistics=None, target_list=None, threshold=None, times=None,
                 webhook=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # Valid values of N: 1 to 3.
        self.comparison_operator = comparison_operator  # type: str
        # The time period during which the alert rule is effective.
        # 
        # Valid values of N: 1 to 3.
        self.effective_interval = effective_interval  # type: str
        # The alert level. Valid values:
        # 
        # *   critical (default)
        # *   warn
        # *   info
        # 
        # Valid values of N: 1 to 3.
        self.escalations_level = escalations_level  # type: str
        # The time period during which the alert rule is ineffective.
        # 
        # Valid values of N: 1 to 3.
        self.no_effective_interval = no_effective_interval  # type: str
        # The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Minimum value: 3600, which is equivalent to 1 hour. Default value: 86400, which is equivalent to one day.
        # 
        # Valid values of N: 1 to 3.
        # 
        # >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
        self.silence_time = silence_time  # type: str
        # The statistical method for alerts.
        # 
        # Valid values of N: 1 to 3.
        # 
        # >  Set the value to Average.
        self.statistics = statistics  # type: str
        # The alert triggers.
        self.target_list = target_list  # type: list[CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList]
        # The alert threshold.
        # 
        # Valid values of N: 1 to 3.
        self.threshold = threshold  # type: str
        # The number of times for which the threshold can be consecutively exceeded. Default value: 3.
        # 
        # Valid values of N: 1 to 3.
        # 
        # >  An alert is triggered only if the number of times for which the threshold can be consecutively exceeded is reached.
        self.times = times  # type: str
        # The callback URL.
        # 
        # Valid values of N: 1 to 3.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessRequestAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.escalations_level is not None:
            result['EscalationsLevel'] = self.escalations_level
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EscalationsLevel') is not None:
            self.escalations_level = m.get('EscalationsLevel')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = CreateGroupMonitoringAgentProcessRequestAlertConfigTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class CreateGroupMonitoringAgentProcessRequestMatchExpress(TeaModel):
    def __init__(self, function=None, name=None, value=None):
        # The matching condition. Valid values:
        # 
        # *   all (default value): matches all
        # *   startWith: starts with a prefix
        # *   endWith: ends with a suffix
        # *   contains: contains
        # *   notContains: does not contain
        # *   equals: equals
        # 
        # Valid values of N: 1 to 3.
        self.function = function  # type: str
        # The criteria based on which the instances are matched.
        # 
        # Valid values of N: 1 to 3.
        # 
        # > Set the value to name. The value name indicates that the instances are matched based on the instance name.
        self.name = name  # type: str
        # The keyword used to match the instance name.
        # 
        # Valid values of N: 1 to 3.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessRequestMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateGroupMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, alert_config=None, group_id=None, match_express=None, match_express_filter_relation=None,
                 process_name=None, region_id=None):
        # The alert rule configurations.
        # 
        # Valid values of N: 1 to 3.
        self.alert_config = alert_config  # type: list[CreateGroupMonitoringAgentProcessRequestAlertConfig]
        # The ID of the application group.
        # 
        # For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The expressions used to match instances.
        # 
        # Valid values of N: 1 to 3.
        self.match_express = match_express  # type: list[CreateGroupMonitoringAgentProcessRequestMatchExpress]
        # The logical operator used between conditional expressions that are used to match instances. Valid values:
        # 
        # *   all
        # *   and
        # *   or
        self.match_express_filter_relation = match_express_filter_relation  # type: str
        # The process name.
        self.process_name = process_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()
        if self.match_express:
            for k in self.match_express:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['MatchExpress'] = []
        if self.match_express is not None:
            for k in self.match_express:
                result['MatchExpress'].append(k.to_map() if k else None)
        if self.match_express_filter_relation is not None:
            result['MatchExpressFilterRelation'] = self.match_express_filter_relation
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = CreateGroupMonitoringAgentProcessRequestAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.match_express = []
        if m.get('MatchExpress') is not None:
            for k in m.get('MatchExpress'):
                temp_model = CreateGroupMonitoringAgentProcessRequestMatchExpress()
                self.match_express.append(temp_model.from_map(k))
        if m.get('MatchExpressFilterRelation') is not None:
            self.match_express_filter_relation = m.get('MatchExpressFilterRelation')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateGroupMonitoringAgentProcessResponseBodyResource(TeaModel):
    def __init__(self, group_process_id=None):
        # The ID of the group process.
        self.group_process_id = group_process_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessResponseBodyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_process_id is not None:
            result['GroupProcessId'] = self.group_process_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupProcessId') is not None:
            self.group_process_id = m.get('GroupProcessId')
        return self


class CreateGroupMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The group process information.
        self.resource = resource  # type: CreateGroupMonitoringAgentProcessResponseBodyResource
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = CreateGroupMonitoringAgentProcessResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateGroupMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateGroupMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateGroupMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateGroupMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHostAvailabilityRequestAlertConfig(TeaModel):
    def __init__(self, end_time=None, notify_type=None, silence_time=None, start_time=None, web_hook=None):
        # The end of the time range during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.end_time = end_time  # type: int
        # The alert notification methods. Valid values:
        # 
        # 0: Alert notifications are sent by using emails and DingTalk chatbots.
        self.notify_type = notify_type  # type: int
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. The default value indicates one day.
        self.silence_time = silence_time  # type: int
        # The beginning of the time range during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.start_time = start_time  # type: int
        # The callback URL.
        self.web_hook = web_hook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHostAvailabilityRequestAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.web_hook is not None:
            result['WebHook'] = self.web_hook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('WebHook') is not None:
            self.web_hook = m.get('WebHook')
        return self


class CreateHostAvailabilityRequestTaskOption(TeaModel):
    def __init__(self, http_header=None, http_method=None, http_negative=None, http_post_content=None,
                 http_response_charset=None, http_response_match_content=None, http_uri=None, interval=None, telnet_or_ping_host=None):
        # The header of the HTTP request. Format: `Parameter name:Parameter value`. Separate multiple parameters with carriage return characters. Example:
        # 
        #     params1:value1
        #     params2:value2
        self.http_header = http_header  # type: str
        # The HTTP request method. Valid values:
        # 
        # *   GET
        # *   POST
        # *   HEAD
        # 
        # > This parameter must be specified when TaskType is set to HTTP.
        self.http_method = http_method  # type: str
        # The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
        # 
        # *   true: If the HTTP response body includes the alert rule, an alert is triggered.
        # *   false: If the HTTP response does not include the alert rule, an alert is triggered.
        # 
        # > This parameter must be specified when TaskType is set to HTTP.
        self.http_negative = http_negative  # type: bool
        # The content of the HTTP POST request.
        self.http_post_content = http_post_content  # type: str
        # The character set that is used in the HTTP response.
        # 
        # > Only UTF-8 is supported.
        self.http_response_charset = http_response_charset  # type: str
        # The response to the HTTP request.
        self.http_response_match_content = http_response_match_content  # type: str
        # The URI that you want to monitor. This parameter must be specified when TaskType is set to HTTP.
        self.http_uri = http_uri  # type: str
        # The interval at which detection requests are sent. Unit: seconds. Valid values: 15, 30, 60, 120, 300, 900, 1800, and 3600.
        # 
        # > This parameter is available only for the CloudMonitor agent V3.5.1 or later.
        self.interval = interval  # type: int
        # The domain name or IP address that you want to monitor.
        # 
        # > This parameter must be specified when TaskType is set to PING or TELNET.
        self.telnet_or_ping_host = telnet_or_ping_host  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHostAvailabilityRequestTaskOption, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_header is not None:
            result['HttpHeader'] = self.http_header
        if self.http_method is not None:
            result['HttpMethod'] = self.http_method
        if self.http_negative is not None:
            result['HttpNegative'] = self.http_negative
        if self.http_post_content is not None:
            result['HttpPostContent'] = self.http_post_content
        if self.http_response_charset is not None:
            result['HttpResponseCharset'] = self.http_response_charset
        if self.http_response_match_content is not None:
            result['HttpResponseMatchContent'] = self.http_response_match_content
        if self.http_uri is not None:
            result['HttpURI'] = self.http_uri
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.telnet_or_ping_host is not None:
            result['TelnetOrPingHost'] = self.telnet_or_ping_host
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpHeader') is not None:
            self.http_header = m.get('HttpHeader')
        if m.get('HttpMethod') is not None:
            self.http_method = m.get('HttpMethod')
        if m.get('HttpNegative') is not None:
            self.http_negative = m.get('HttpNegative')
        if m.get('HttpPostContent') is not None:
            self.http_post_content = m.get('HttpPostContent')
        if m.get('HttpResponseCharset') is not None:
            self.http_response_charset = m.get('HttpResponseCharset')
        if m.get('HttpResponseMatchContent') is not None:
            self.http_response_match_content = m.get('HttpResponseMatchContent')
        if m.get('HttpURI') is not None:
            self.http_uri = m.get('HttpURI')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TelnetOrPingHost') is not None:
            self.telnet_or_ping_host = m.get('TelnetOrPingHost')
        return self


class CreateHostAvailabilityRequestAlertConfigEscalationList(TeaModel):
    def __init__(self, aggregate=None, metric_name=None, operator=None, times=None, value=None):
        # The method used to calculate the metric values that trigger alerts. Valid values of N: 1 to 21. Valid values:
        # 
        # *   HttpStatus: Value
        # *   HttpLatency: Average
        # *   TelnetStatus: Value
        # *   TelnetLatency: Average
        # *   PingLostRate: Average
        # 
        # > The value Value indicates the original value and is used for metrics such as status codes. The value Average indicates the average value and is used for metrics such as the latency and packet loss rate.
        self.aggregate = aggregate  # type: str
        # The metric for which the alert feature is enabled. Valid values of N: 1 to 21. Valid values:
        # 
        # *   HttpStatus: HTTP status code
        # *   HttpLatency: HTTP response time
        # *   TelnetStatus: Telnet status code
        # *   TelnetLatency: Telnet response time
        # *   PingLostRate: Ping packet loss rate
        self.metric_name = metric_name  # type: str
        # The comparison operator that is used in the alert rule. Valid values of N: 1 to 21. Valid values:
        # 
        # *   `>`
        # *   `>=`
        # *   `<`
        # *   `<=`
        # *   `=`
        self.operator = operator  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered. Valid values of N: 1 to 21.
        self.times = times  # type: int
        # The alert threshold. Valid values of N: 1 to 21.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHostAvailabilityRequestAlertConfigEscalationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['Aggregate'] = self.aggregate
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.times is not None:
            result['Times'] = self.times
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Aggregate') is not None:
            self.aggregate = m.get('Aggregate')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateHostAvailabilityRequestAlertConfigTargetList(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The Alibaba Cloud Resource Name (ARN) of the resource. Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # 
        # *   {userId}: the ID of the Alibaba Cloud account.
        # 
        # *   {regionId}: the region ID of the message queue or topic.
        # 
        # *   {Resource type}: the type of the resource that triggers the alert. Valid values:
        # 
        #     *   **queues**\
        #     *   **topics**\
        # 
        # *   {Resource name}: the resource name.
        # 
        #     *   If the resource type is **queues**, the resource name is the queue name.
        #     *   If the resource type is **topics**, the resource name is the topic name.
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        self.id = id  # type: str
        # The parameters of the alert callback. The parameters are in the JSON format.
        self.json_params = json_params  # type: str
        # The alert level. Valid values:
        # 
        # *   INFO
        # *   WARN
        # *   CRITICAL
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHostAvailabilityRequestAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class CreateHostAvailabilityRequest(TeaModel):
    def __init__(self, alert_config=None, task_option=None, alert_config_escalation_list=None,
                 alert_config_target_list=None, group_id=None, instance_list=None, region_id=None, task_name=None, task_scope=None,
                 task_type=None):
        self.alert_config = alert_config  # type: CreateHostAvailabilityRequestAlertConfig
        self.task_option = task_option  # type: CreateHostAvailabilityRequestTaskOption
        # None
        self.alert_config_escalation_list = alert_config_escalation_list  # type: list[CreateHostAvailabilityRequestAlertConfigEscalationList]
        # The information about the resources for which alerts are triggered.
        self.alert_config_target_list = alert_config_target_list  # type: list[CreateHostAvailabilityRequestAlertConfigTargetList]
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ECS instances that are monitored. Valid values of N: 1 to 21.
        # 
        # > This parameter must be specified when `TaskScope` is set to `GROUP_SPEC_INSTANCE`.
        self.instance_list = instance_list  # type: list[str]
        self.region_id = region_id  # type: str
        # The name of the availability monitoring task. The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (\_).
        self.task_name = task_name  # type: str
        # The range of instances that are monitored by the availability monitoring task. Valid values:
        # 
        # *   GROUP: All Elastic Compute Service (ECS) instances in the application group are monitored.
        # *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored. The TaskScope parameter must be used in combination with the InstanceList.N parameter. The InstanceList.N parameter specifies the ECS instances to be monitored.
        self.task_scope = task_scope  # type: str
        # The monitoring type of the availability monitoring task. Valid values:
        # 
        # *   PING
        # *   TELNET
        # *   HTTP
        self.task_type = task_type  # type: str

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.task_option:
            self.task_option.validate()
        if self.alert_config_escalation_list:
            for k in self.alert_config_escalation_list:
                if k:
                    k.validate()
        if self.alert_config_target_list:
            for k in self.alert_config_target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.task_option is not None:
            result['TaskOption'] = self.task_option.to_map()
        result['AlertConfigEscalationList'] = []
        if self.alert_config_escalation_list is not None:
            for k in self.alert_config_escalation_list:
                result['AlertConfigEscalationList'].append(k.to_map() if k else None)
        result['AlertConfigTargetList'] = []
        if self.alert_config_target_list is not None:
            for k in self.alert_config_target_list:
                result['AlertConfigTargetList'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_scope is not None:
            result['TaskScope'] = self.task_scope
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = CreateHostAvailabilityRequestAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('TaskOption') is not None:
            temp_model = CreateHostAvailabilityRequestTaskOption()
            self.task_option = temp_model.from_map(m['TaskOption'])
        self.alert_config_escalation_list = []
        if m.get('AlertConfigEscalationList') is not None:
            for k in m.get('AlertConfigEscalationList'):
                temp_model = CreateHostAvailabilityRequestAlertConfigEscalationList()
                self.alert_config_escalation_list.append(temp_model.from_map(k))
        self.alert_config_target_list = []
        if m.get('AlertConfigTargetList') is not None:
            for k in m.get('AlertConfigTargetList'):
                temp_model = CreateHostAvailabilityRequestAlertConfigTargetList()
                self.alert_config_target_list.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceList') is not None:
            self.instance_list = m.get('InstanceList')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskScope') is not None:
            self.task_scope = m.get('TaskScope')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, task_id=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The ID of the availability monitoring task.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHybridMonitorNamespaceRequest(TeaModel):
    def __init__(self, description=None, namespace=None, region_id=None, spec=None):
        # The description of the namespace.
        self.description = description  # type: str
        # The name of the namespace.
        # 
        # The name can contain lowercase letters, digits, and hyphens (-).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The data retention period of the namespace. Valid values:
        # 
        # *   cms.s1.large: 15 days
        # *   cms.s1.xlarge: 32 days
        # *   cms.s1.2xlarge: 63 days
        # *   cms.s1.3xlarge (default value): 93 days
        # *   cms.s1.6xlarge: 185 days
        # *   cms.s1.12xlarge: 376 days
        # 
        # For information about the pricing for different retention periods, see the **Pricing** section in [Billing of the dashboard feature](~~223532~~).
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorNamespaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class CreateHybridMonitorNamespaceResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The returned message.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorNamespaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHybridMonitorNamespaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHybridMonitorNamespaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorNamespaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHybridMonitorNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHybridMonitorSLSGroupRequestSLSGroupConfig(TeaModel):
    def __init__(self, slslogstore=None, slsproject=None, slsregion=None, slsuser_id=None):
        # The Logstore.
        # 
        # Valid values of N: 1 to 25.
        self.slslogstore = slslogstore  # type: str
        # The Simple Log Service project.
        # 
        # Valid values of N: 1 to 25.
        self.slsproject = slsproject  # type: str
        # The region ID.
        # 
        # Valid values of N: 1 to 25.
        self.slsregion = slsregion  # type: str
        # The member ID.
        # 
        # Valid values of N: 1 to 25.
        # 
        # If you call this operation by using the management account of a resource directory, you can connect the Alibaba Cloud services that are activated for all members in the resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
        # 
        # > If a member uses CloudMonitor for the first time, you must make sure that the service-linked role AliyunServiceRoleForCloudMonitor is attached to the member. For more information, see [Manage the service-linked role for CloudMonitor](~~170423~~).
        self.slsuser_id = slsuser_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorSLSGroupRequestSLSGroupConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slslogstore is not None:
            result['SLSLogstore'] = self.slslogstore
        if self.slsproject is not None:
            result['SLSProject'] = self.slsproject
        if self.slsregion is not None:
            result['SLSRegion'] = self.slsregion
        if self.slsuser_id is not None:
            result['SLSUserId'] = self.slsuser_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SLSLogstore') is not None:
            self.slslogstore = m.get('SLSLogstore')
        if m.get('SLSProject') is not None:
            self.slsproject = m.get('SLSProject')
        if m.get('SLSRegion') is not None:
            self.slsregion = m.get('SLSRegion')
        if m.get('SLSUserId') is not None:
            self.slsuser_id = m.get('SLSUserId')
        return self


class CreateHybridMonitorSLSGroupRequest(TeaModel):
    def __init__(self, region_id=None, slsgroup_config=None, slsgroup_description=None, slsgroup_name=None):
        self.region_id = region_id  # type: str
        # The configurations of the Logstore group.
        # 
        # Valid values of N: 1 to 25.
        self.slsgroup_config = slsgroup_config  # type: list[CreateHybridMonitorSLSGroupRequestSLSGroupConfig]
        # The description of the Logstore group.
        self.slsgroup_description = slsgroup_description  # type: str
        # The name of the Logstore group.
        # 
        # The name must be 2 to 32 characters in length and can contain uppercase letters, lowercase letters, digits, and underscores (\_). The name must start with a letter.
        self.slsgroup_name = slsgroup_name  # type: str

    def validate(self):
        if self.slsgroup_config:
            for k in self.slsgroup_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorSLSGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['SLSGroupConfig'] = []
        if self.slsgroup_config is not None:
            for k in self.slsgroup_config:
                result['SLSGroupConfig'].append(k.to_map() if k else None)
        if self.slsgroup_description is not None:
            result['SLSGroupDescription'] = self.slsgroup_description
        if self.slsgroup_name is not None:
            result['SLSGroupName'] = self.slsgroup_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.slsgroup_config = []
        if m.get('SLSGroupConfig') is not None:
            for k in m.get('SLSGroupConfig'):
                temp_model = CreateHybridMonitorSLSGroupRequestSLSGroupConfig()
                self.slsgroup_config.append(temp_model.from_map(k))
        if m.get('SLSGroupDescription') is not None:
            self.slsgroup_description = m.get('SLSGroupDescription')
        if m.get('SLSGroupName') is not None:
            self.slsgroup_name = m.get('SLSGroupName')
        return self


class CreateHybridMonitorSLSGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorSLSGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateHybridMonitorSLSGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHybridMonitorSLSGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorSLSGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHybridMonitorSLSGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateHybridMonitorTaskRequestAttachLabels(TeaModel):
    def __init__(self, name=None, value=None):
        # The tag key of the metric.
        self.name = name  # type: str
        # The tag value of the metric.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestAttachLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfigExpress(TeaModel):
    def __init__(self, alias=None, express=None):
        # The alias of the extended field that specifies the result of basic operations that are performed on aggregation results.
        self.alias = alias  # type: str
        # The extended field that specifies the result of basic operations that are performed on aggregation results.
        self.express = express  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfigExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.express is not None:
            result['Express'] = self.express
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters(TeaModel):
    def __init__(self, operator=None, slskey_name=None, value=None):
        # The method that is used to filter logs imported from Log Service. Valid values:
        # 
        # *   `contain`: contains
        # *   `notContain`: does not contain
        # *   `>`: greater than
        # *   `<`: less than
        # *   `=`: equal to
        # *   `! =`: not equal to
        # *   `>=`: greater than or equal to
        # *   `<=`: less than or equal to
        self.operator = operator  # type: str
        # The name of the key that is used to filter logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str
        # The value of the key that is used to filter logs imported from Log Service.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfigFilter(TeaModel):
    def __init__(self, filters=None, relation=None):
        # The conditions that are used to filter logs imported from Log Service.
        self.filters = filters  # type: list[CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters]
        # The relationship between multiple filter conditions. Valid values:
        # 
        # *   and (default value): Logs are processed only if all filter conditions are met.
        # *   or: Logs are processed if one of the filter conditions is met.
        self.relation = relation  # type: str

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfigFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['Filters'].append(k.to_map() if k else None)
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filters = []
        if m.get('Filters') is not None:
            for k in m.get('Filters'):
                temp_model = CreateHybridMonitorTaskRequestSLSProcessConfigFilterFilters()
                self.filters.append(temp_model.from_map(k))
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy(TeaModel):
    def __init__(self, alias=None, slskey_name=None):
        # The alias of the aggregation result.
        self.alias = alias  # type: str
        # The name of the key that is used to aggregate logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfigStatistics(TeaModel):
    def __init__(self, alias=None, function=None, parameter_1=None, parameter_2=None, slskey_name=None):
        self.alias = alias  # type: str
        self.function = function  # type: str
        self.parameter_1 = parameter_1  # type: str
        self.parameter_2 = parameter_2  # type: str
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfigStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.function is not None:
            result['Function'] = self.function
        if self.parameter_1 is not None:
            result['Parameter1'] = self.parameter_1
        if self.parameter_2 is not None:
            result['Parameter2'] = self.parameter_2
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Parameter1') is not None:
            self.parameter_1 = m.get('Parameter1')
        if m.get('Parameter2') is not None:
            self.parameter_2 = m.get('Parameter2')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class CreateHybridMonitorTaskRequestSLSProcessConfig(TeaModel):
    def __init__(self, express=None, filter=None, group_by=None, statistics=None):
        # The extended fields that specify the results of basic operations that are performed on aggregation results.
        self.express = express  # type: list[CreateHybridMonitorTaskRequestSLSProcessConfigExpress]
        # The conditions that are used to filter logs imported from Log Service.
        self.filter = filter  # type: CreateHybridMonitorTaskRequestSLSProcessConfigFilter
        # The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        self.group_by = group_by  # type: list[CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy]
        self.statistics = statistics  # type: list[CreateHybridMonitorTaskRequestSLSProcessConfigStatistics]

    def validate(self):
        if self.express:
            for k in self.express:
                if k:
                    k.validate()
        if self.filter:
            self.filter.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequestSLSProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Express'] = []
        if self.express is not None:
            for k in self.express:
                result['Express'].append(k.to_map() if k else None)
        if self.filter is not None:
            result['Filter'] = self.filter.to_map()
        result['GroupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['GroupBy'].append(k.to_map() if k else None)
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.express = []
        if m.get('Express') is not None:
            for k in m.get('Express'):
                temp_model = CreateHybridMonitorTaskRequestSLSProcessConfigExpress()
                self.express.append(temp_model.from_map(k))
        if m.get('Filter') is not None:
            temp_model = CreateHybridMonitorTaskRequestSLSProcessConfigFilter()
            self.filter = temp_model.from_map(m['Filter'])
        self.group_by = []
        if m.get('GroupBy') is not None:
            for k in m.get('GroupBy'):
                temp_model = CreateHybridMonitorTaskRequestSLSProcessConfigGroupBy()
                self.group_by.append(temp_model.from_map(k))
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = CreateHybridMonitorTaskRequestSLSProcessConfigStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class CreateHybridMonitorTaskRequest(TeaModel):
    def __init__(self, attach_labels=None, collect_interval=None, collect_target_type=None, description=None,
                 group_id=None, namespace=None, region_id=None, slsprocess_config=None, target_user_id=None,
                 target_user_id_list=None, task_name=None, task_type=None, yarmconfig=None):
        self.attach_labels = attach_labels  # type: list[CreateHybridMonitorTaskRequestAttachLabels]
        # The interval at which metrics are collected. Valid values:
        # 
        # *   15
        # *   60 (default value)
        # 
        # Unit: seconds.
        # 
        # >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
        self.collect_interval = collect_interval  # type: str
        # The type of the collection target.
        # 
        # *   If the `TaskType` parameter is set to `aliyun_fc`, enter `aliyun_fc`.
        # *   If the `TaskType` parameter is set to `aliyun_sls`, enter the name of the Logstore group.
        self.collect_target_type = collect_target_type  # type: str
        # The description of the metric import task.
        self.description = description  # type: str
        # The ID of the application group.
        # 
        # For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        # 
        # >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
        self.group_id = group_id  # type: str
        # The name of the namespace.
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The configurations of the logs that are imported from Log Service.
        # 
        # >  This parameter is required only if the `TaskType` parameter is set to `aliyun_sls`.
        self.slsprocess_config = slsprocess_config  # type: CreateHybridMonitorTaskRequestSLSProcessConfig
        # The ID of the member account.
        # 
        # If you call API operations by using a management account, you can connect the Alibaba Cloud services that are activated for a member account in a resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
        # 
        # >  This parameter is required only if the `TaskType` parameter is set to `aliyun_fc`.
        self.target_user_id = target_user_id  # type: str
        # The IDs of the member accounts. Separate multiple member account IDs with commas (,).
        # 
        # >  This parameter is required only if you call this operation by using the management account.
        self.target_user_id_list = target_user_id_list  # type: str
        # The name of the metric import task.
        # 
        # *   If the `TaskType` parameter is set to `aliyun_fc`, enter the name of the metric import task.
        # *   If the `TaskType` parameter is set to `aliyun_sls`, enter the name of the metric for logs imported from Log Service.
        self.task_name = task_name  # type: str
        # Specifies whether to create a metric import task for an Alibaba Cloud service or create a metric for logs imported from Log Service. Valid values:
        # 
        # *   aliyun_fc: creates a metric import task for an Alibaba Cloud service
        # *   aliyun_sls: creates a metric for logs imported from Log Service
        self.task_type = task_type  # type: str
        # The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        # 
        # *   namespace: the namespace of the Alibaba Cloud service. For information about how to query the namespace of an Alibaba Cloud service, see [DescribeMetricMetaList](~~98846~~).
        # *   metric_list: the metrics of the Alibaba Cloud service. For information about how to query the metrics of an Alibaba Cloud service, see [DescribeMetricMetaList](~~98846~~).
        # 
        # The following code shows a sample configuration file:
        # 
        # ```
        # 
        # products:
        # - namespace: acs_ecs_dashboard
        #   metric_info:
        #   - metric_list:
        #     - cpu_total
        #     - cpu_idle
        #     - diskusage_utilization
        #     - CPUUtilization
        #     - DiskReadBPS
        #     - InternetOut
        #     - IntranetOut
        #     - cpu_system
        # - namespace: acs_rds_dashboard
        #   metric_info:
        #   - metric_list:
        #     - MySQL_QPS
        #     - MySQL_TPS
        # ```
        # 
        # >  This parameter is required only if the `TaskType` parameter is set to `aliyun_fc`.
        self.yarmconfig = yarmconfig  # type: str

    def validate(self):
        if self.attach_labels:
            for k in self.attach_labels:
                if k:
                    k.validate()
        if self.slsprocess_config:
            self.slsprocess_config.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttachLabels'] = []
        if self.attach_labels is not None:
            for k in self.attach_labels:
                result['AttachLabels'].append(k.to_map() if k else None)
        if self.collect_interval is not None:
            result['CollectInterval'] = self.collect_interval
        if self.collect_target_type is not None:
            result['CollectTargetType'] = self.collect_target_type
        if self.description is not None:
            result['Description'] = self.description
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slsprocess_config is not None:
            result['SLSProcessConfig'] = self.slsprocess_config.to_map()
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        if self.target_user_id_list is not None:
            result['TargetUserIdList'] = self.target_user_id_list
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.yarmconfig is not None:
            result['YARMConfig'] = self.yarmconfig
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.attach_labels = []
        if m.get('AttachLabels') is not None:
            for k in m.get('AttachLabels'):
                temp_model = CreateHybridMonitorTaskRequestAttachLabels()
                self.attach_labels.append(temp_model.from_map(k))
        if m.get('CollectInterval') is not None:
            self.collect_interval = m.get('CollectInterval')
        if m.get('CollectTargetType') is not None:
            self.collect_target_type = m.get('CollectTargetType')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SLSProcessConfig') is not None:
            temp_model = CreateHybridMonitorTaskRequestSLSProcessConfig()
            self.slsprocess_config = temp_model.from_map(m['SLSProcessConfig'])
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        if m.get('TargetUserIdList') is not None:
            self.target_user_id_list = m.get('TargetUserIdList')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('YARMConfig') is not None:
            self.yarmconfig = m.get('YARMConfig')
        return self


class CreateHybridMonitorTaskResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, task_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str
        # The ID of the metric import task.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateHybridMonitorTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class CreateHybridMonitorTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateHybridMonitorTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateHybridMonitorTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateHybridMonitorTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateInstantSiteMonitorRequest(TeaModel):
    def __init__(self, address=None, isp_cities=None, options_json=None, random_isp_city=None, region_id=None,
                 task_name=None, task_type=None):
        # The URL or IP address that you want to test.
        self.address = address  # type: str
        # The detection points. If you leave this parameter empty, the system randomly selects three detection points.
        # 
        # The value is a `JSON array`. Example: {"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
        # 
        # For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](~~115045~~).
        # 
        # > You must specify one of the `IspCities` and `RandomIspCity` parameters.
        self.isp_cities = isp_cities  # type: str
        # The extended options of the protocol that is used by the instant test task. The options vary based on the protocol.
        self.options_json = options_json  # type: str
        # The number of detection points.
        # 
        # > 
        # 
        # *   You must specify one of the `IspCities` and `RandomIspCity` parameters. If you specify the `RandomIspCity` parameter, the `IspCities` parameter automatically becomes invalid.
        self.random_isp_city = random_isp_city  # type: int
        self.region_id = region_id  # type: str
        # The name of the instant test task.
        # 
        # The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (\_).
        self.task_name = task_name  # type: str
        # The type of the instant test task. Valid values: HTTP, PING, TCP, UDP, and DNS.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstantSiteMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json
        if self.random_isp_city is not None:
            result['RandomIspCity'] = self.random_isp_city
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('IspCities') is not None:
            self.isp_cities = m.get('IspCities')
        if m.get('OptionsJson') is not None:
            self.options_json = m.get('OptionsJson')
        if m.get('RandomIspCity') is not None:
            self.random_isp_city = m.get('RandomIspCity')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateInstantSiteMonitorResponseBodyCreateResultList(TeaModel):
    def __init__(self, task_id=None, task_name=None):
        # The ID of the instant test task.
        self.task_id = task_id  # type: str
        # The name of the instant test task.
        self.task_name = task_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateInstantSiteMonitorResponseBodyCreateResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class CreateInstantSiteMonitorResponseBody(TeaModel):
    def __init__(self, code=None, create_result_list=None, message=None, request_id=None, success=None):
        # The error code.
        # 
        # > The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The results for creating the instant test task.
        self.create_result_list = create_result_list  # type: list[CreateInstantSiteMonitorResponseBodyCreateResultList]
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str

    def validate(self):
        if self.create_result_list:
            for k in self.create_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateInstantSiteMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['CreateResultList'] = []
        if self.create_result_list is not None:
            for k in self.create_result_list:
                result['CreateResultList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.create_result_list = []
        if m.get('CreateResultList') is not None:
            for k in m.get('CreateResultList'):
                temp_model = CreateInstantSiteMonitorResponseBodyCreateResultList()
                self.create_result_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateInstantSiteMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateInstantSiteMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateInstantSiteMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateInstantSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMetricRuleBlackListRequestMetrics(TeaModel):
    def __init__(self, metric_name=None, resource=None):
        # The metric name.
        # 
        # Valid values of N: 1 to 10.
        self.metric_name = metric_name  # type: str
        # The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
        # 
        # Valid values of N: 1 to 10.
        self.resource = resource  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleBlackListRequestMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.resource is not None:
            result['Resource'] = self.resource
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        return self


class CreateMetricRuleBlackListRequest(TeaModel):
    def __init__(self, category=None, effective_time=None, enable_end_time=None, enable_start_time=None,
                 instances=None, metrics=None, name=None, namespace=None, region_id=None, scope_type=None, scope_value=None):
        # The category of the cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
        self.category = category  # type: str
        # The time range within which the blacklist policy is effective.
        # 
        # *   If you do not configure this parameter, the blacklist policy is permanently effective.
        # 
        # *   If you configure this parameter, the blacklist policy is effective only within the specified time range. Examples:
        # 
        #     *   `03:00-04:59`: The blacklist policy is effective from 03:00 to 05:00 local time. 05:00 local time is excluded.
        #     *   `03:00-04:59 UTC+0700`: The blacklist policy is effective from 03:00 to 05:00 (UTC+7). 05:00 (UTC+7) is excluded.
        self.effective_time = effective_time  # type: str
        # The timestamp when the blacklist policy expires.
        # 
        # Unit: milliseconds.
        self.enable_end_time = enable_end_time  # type: str
        # The timestamp when the blacklist policy starts to take effect.
        # 
        # Unit: milliseconds.
        self.enable_start_time = enable_start_time  # type: str
        # The IDs of instances that belong to the specified cloud service.
        self.instances = instances  # type: list[str]
        # The metrics of the instance.
        # 
        # *   If you do not configure this parameter, the blacklist policy applies to all metrics of the specified cloud service.
        # *   If you configure this parameter, the blacklist policy applies only to the current metric.
        self.metrics = metrics  # type: list[CreateMetricRuleBlackListRequestMetrics]
        # The name of the blacklist policy.
        self.name = name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The effective scope of the blacklist policy. Valid values:
        # 
        # *   USER: The blacklist policy takes effect only for the current Alibaba Cloud account.
        # *   GROUP (default): The blacklist policy takes effect only for the specified application group. For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.scope_type = scope_type  # type: str
        # The ID of the application group. The value of this parameter is a JSON array.
        # 
        # > This parameter must be specified when `ScopeType` is set to `GROUP`.
        self.scope_value = scope_value  # type: str

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateMetricRuleBlackListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.effective_time is not None:
            result['EffectiveTime'] = self.effective_time
        if self.enable_end_time is not None:
            result['EnableEndTime'] = self.enable_end_time
        if self.enable_start_time is not None:
            result['EnableStartTime'] = self.enable_start_time
        if self.instances is not None:
            result['Instances'] = self.instances
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('EffectiveTime') is not None:
            self.effective_time = m.get('EffectiveTime')
        if m.get('EnableEndTime') is not None:
            self.enable_end_time = m.get('EnableEndTime')
        if m.get('EnableStartTime') is not None:
            self.enable_start_time = m.get('EnableStartTime')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = CreateMetricRuleBlackListRequestMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        return self


class CreateMetricRuleBlackListResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The ID of the blacklist policy.
        self.id = id  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleBlackListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMetricRuleBlackListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMetricRuleBlackListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMetricRuleBlackListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMetricRuleBlackListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMetricRuleResourcesRequest(TeaModel):
    def __init__(self, overwrite=None, resources=None, rule_id=None):
        # Specifies whether to overwrite the existing data. Valid values:
        # 
        # *   true: The resources submitted this time will overwrite the previous associated resources.
        # *   false: The resources submitted this time will not overwrite the previous associated resources. The associated resources after submission include the previous associated resources and the resources submitted this time.
        self.overwrite = overwrite  # type: str
        # The resources to be associated with the alert rule. The value is a JSON array.
        # 
        # >  You can add up to 100 resources each time. An alert rule can be associated with up to 3,000 resources.
        self.resources = resources  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.overwrite is not None:
            result['Overwrite'] = self.overwrite
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Overwrite') is not None:
            self.overwrite = m.get('Overwrite')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class CreateMetricRuleResourcesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMetricRuleResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMetricRuleResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMetricRuleResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMetricRuleResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class CreateMetricRuleTemplateRequestAlertTemplatesEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical
        self.info = info  # type: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo
        self.warn = warn  # type: CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequestAlertTemplatesEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = CreateMetricRuleTemplateRequestAlertTemplatesEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = CreateMetricRuleTemplateRequestAlertTemplatesEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = CreateMetricRuleTemplateRequestAlertTemplatesEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class CreateMetricRuleTemplateRequestAlertTemplates(TeaModel):
    def __init__(self, escalations=None, category=None, metric_name=None, namespace=None, period=None,
                 rule_name=None, selector=None, webhook=None):
        self.escalations = escalations  # type: CreateMetricRuleTemplateRequestAlertTemplatesEscalations
        # The abbreviation of the Alibaba Cloud service name.
        # 
        # To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](~~114916~~) operation. The `metricCategory` tag in the `Labels` response parameter indicates the abbreviation of the Alibaba Cloud service name.
        self.category = category  # type: str
        # The name of the metric. Valid values of N: 1 to 200.
        # 
        # >  For more information, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~28619~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service. Valid values of N: 1 to 200.
        # 
        # >  For more information, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~28619~~).
        self.namespace = namespace  # type: str
        # The aggregation period of monitoring data. Unit: seconds.
        # 
        # The default value is the minimum aggregation period. Generally, you do not need to specify the minimum aggregation period.
        # 
        # Valid values of N: 1 to 200.
        self.period = period  # type: int
        # The name of the alert rule. Valid values of N: 1 to 200.
        self.rule_name = rule_name  # type: str
        # The extended field selectors. Valid values of N: 1 to 200.
        self.selector = selector  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequestAlertTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.category is not None:
            result['Category'] = self.category
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.selector is not None:
            result['Selector'] = self.selector
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = CreateMetricRuleTemplateRequestAlertTemplatesEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Selector') is not None:
            self.selector = m.get('Selector')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class CreateMetricRuleTemplateRequest(TeaModel):
    def __init__(self, alert_templates=None, description=None, name=None, region_id=None):
        self.alert_templates = alert_templates  # type: list[CreateMetricRuleTemplateRequestAlertTemplates]
        # The description of the alert template.
        self.description = description  # type: str
        # The name of the alert template.
        self.name = name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        if self.alert_templates:
            for k in self.alert_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateMetricRuleTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertTemplates'] = []
        if self.alert_templates is not None:
            for k in self.alert_templates:
                result['AlertTemplates'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_templates = []
        if m.get('AlertTemplates') is not None:
            for k in m.get('AlertTemplates'):
                temp_model = CreateMetricRuleTemplateRequestAlertTemplates()
                self.alert_templates.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMetricRuleTemplateResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The ID of the alert template.
        self.id = id  # type: long
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMetricRuleTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMetricRuleTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMetricRuleTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMetricRuleTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMetricRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitorAgentProcessRequest(TeaModel):
    def __init__(self, instance_id=None, process_name=None, process_user=None, region_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the process.
        self.process_name = process_name  # type: str
        # The user who launches the process.
        self.process_user = process_user  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_user is not None:
            result['ProcessUser'] = self.process_user
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessUser') is not None:
            self.process_user = m.get('ProcessUser')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMonitorAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The ID of the process.
        self.id = id  # type: long
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitorAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitorAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitorAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitorAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitorGroupRequest(TeaModel):
    def __init__(self, contact_groups=None, group_name=None, region_id=None):
        # The alert groups that receive alert notifications for the application group. The alarm notifications for the application group are sent to the alert contacts in the alarm groups.
        # 
        # >  An alert group is a group of one or more alert contacts. For more information about how to create alert contacts and alert groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~).
        self.contact_groups = contact_groups  # type: str
        # The name of the application group.
        self.group_name = group_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMonitorGroupResponseBody(TeaModel):
    def __init__(self, code=None, group_id=None, message=None, request_id=None, success=None):
        # The response code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: int
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitorGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitorGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitorGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitorGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitorGroupByResourceGroupIdRequest(TeaModel):
    def __init__(self, contact_group_list=None, enable_install_agent=None, enable_subscribe_event=None,
                 region_id=None, resource_group_id=None, resource_group_name=None):
        # The alert contact groups. The alert notifications of the application group are sent to the alert contacts that belong to the specified alert contact groups.
        # 
        # An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~). For information about how to obtain alert contact groups, see [DescribeContactGroupList](~~114922~~).
        self.contact_group_list = contact_group_list  # type: list[str]
        # Specifies whether the CloudMonitor agent is automatically installed for the application group. CloudMonitor determines whether to automatically install the CloudMonitor agent for the hosts in an application group based on the value of this parameter. Valid values:
        # 
        # *   true: The CloudMonitor agent is automatically installed.
        # *   false (default): The CloudMonitor agent is not automatically installed.
        self.enable_install_agent = enable_install_agent  # type: bool
        # Specifies whether the application group automatically subscribes to event notifications. If events whose severity level is critical or warning occur on resources in an application group, CloudMonitor sends alert notifications. Valid values:
        # 
        # *   true: The application group automatically subscribes to event notifications.
        # *   false (default): The application group does not automatically subscribe to event notifications.
        self.enable_subscribe_event = enable_subscribe_event  # type: bool
        # The ID of the region where the resource group resides.
        # 
        # For information about how to obtain the ID of the region where a resource group resides, see [GetResourceGroup](~~158866~~).
        self.region_id = region_id  # type: str
        # The ID of the resource group.
        # 
        # For information about how to obtain the ID of a resource group, see [ListResourceGroups](~~158855~~).
        self.resource_group_id = resource_group_id  # type: str
        # The name of the resource group.
        # 
        # For information about how to obtain the name of a resource group, see [ListResourceGroups](~~158855~~).
        self.resource_group_name = resource_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupByResourceGroupIdRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_list is not None:
            result['ContactGroupList'] = self.contact_group_list
        if self.enable_install_agent is not None:
            result['EnableInstallAgent'] = self.enable_install_agent
        if self.enable_subscribe_event is not None:
            result['EnableSubscribeEvent'] = self.enable_subscribe_event
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.resource_group_name is not None:
            result['ResourceGroupName'] = self.resource_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupList') is not None:
            self.contact_group_list = m.get('ContactGroupList')
        if m.get('EnableInstallAgent') is not None:
            self.enable_install_agent = m.get('EnableInstallAgent')
        if m.get('EnableSubscribeEvent') is not None:
            self.enable_subscribe_event = m.get('EnableSubscribeEvent')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ResourceGroupName') is not None:
            self.resource_group_name = m.get('ResourceGroupName')
        return self


class CreateMonitorGroupByResourceGroupIdResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The ID of the application group.
        self.id = id  # type: long
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupByResourceGroupIdResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitorGroupByResourceGroupIdResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitorGroupByResourceGroupIdResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitorGroupByResourceGroupIdResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitorGroupByResourceGroupIdResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitorGroupInstancesRequestInstances(TeaModel):
    def __init__(self, category=None, instance_id=None, instance_name=None, region_id=None):
        # The abbreviation of the Alibaba Cloud service name.
        # 
        # To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](~~114916~~) operation. The `metricCategory` tag in the `Labels` response parameter indicates the abbreviation of the Alibaba Cloud service name.
        self.category = category  # type: str
        # The instance ID.
        self.instance_id = instance_id  # type: str
        # The instance name.
        self.instance_name = instance_name  # type: str
        # The region ID of the instance.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupInstancesRequestInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMonitorGroupInstancesRequest(TeaModel):
    def __init__(self, group_id=None, instances=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The instances that you want to add to the application group.
        self.instances = instances  # type: list[CreateMonitorGroupInstancesRequestInstances]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateMonitorGroupInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = CreateMonitorGroupInstancesRequestInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMonitorGroupInstancesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitorGroupInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitorGroupInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitorGroupInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitorGroupInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitorGroupNotifyPolicyRequest(TeaModel):
    def __init__(self, end_time=None, group_id=None, policy_type=None, region_id=None, start_time=None):
        # The timestamp that indicates the end time of the validity period for the policy.
        # 
        # This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: long
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The type of the policy. Valid value: PauseNotify.
        self.policy_type = policy_type  # type: str
        self.region_id = region_id  # type: str
        # The timestamp that indicates the start time of the validity period for the policy.
        # 
        # This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupNotifyPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CreateMonitorGroupNotifyPolicyResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, result=None, success=None):
        # The HTTP status code.
        # 
        # >  The HTTP status code 200 indicates that the call succeeds.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The number of entries that are returned.
        self.result = result  # type: int
        # Indicates whether the call succeeds. Valid values:
        # 
        # *   true: The call succeeds.
        # *   false: The call fails.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitorGroupNotifyPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitorGroupNotifyPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitorGroupNotifyPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitorGroupNotifyPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitorGroupNotifyPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, instance_id=None, process_name=None, process_user=None, region_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the process.
        self.process_name = process_name  # type: str
        # The user who launches the process.
        self.process_user = process_user  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_user is not None:
            result['ProcessUser'] = self.process_user
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessUser') is not None:
            self.process_user = m.get('ProcessUser')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, id=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The ID of the process.
        self.id = id  # type: long
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.id is not None:
            result['Id'] = self.id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSiteMonitorRequest(TeaModel):
    def __init__(self, address=None, alert_ids=None, custom_schedule=None, interval=None, isp_cities=None,
                 options_json=None, region_id=None, task_name=None, task_type=None):
        # The URL or IP address that is monitored by the task.
        self.address = address  # type: str
        # The ID of the alert rule.
        # 
        # For more information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.alert_ids = alert_ids  # type: str
        # The custom detection period. You can only select a time period from Monday to Sunday for detection.
        self.custom_schedule = custom_schedule  # type: str
        # The interval at which detection requests are sent.
        # 
        # Valid values: 1, 5, 15, 30, and 60. Unit: minutes.
        # 
        # Default value: 1.
        self.interval = interval  # type: str
        # The information of the detection points. If you leave this parameter empty, the system randomly selects three detection points.
        # 
        # The value is a JSON array. Example: `[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]`. The values of the city field indicate Beijing, Hangzhou, and Qingdao.
        # 
        # For information about how to obtain detection points, see [DescribeSiteMonitorISPCityList](~~115045~~).
        self.isp_cities = isp_cities  # type: str
        # The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
        self.options_json = options_json  # type: str
        self.region_id = region_id  # type: str
        # The name of the site monitoring task.
        # 
        # The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (\_).
        self.task_name = task_name  # type: str
        # The type of the site monitoring task.
        # 
        # Valid values: HTTP, HTTPS, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSiteMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.alert_ids is not None:
            result['AlertIds'] = self.alert_ids
        if self.custom_schedule is not None:
            result['CustomSchedule'] = self.custom_schedule
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AlertIds') is not None:
            self.alert_ids = m.get('AlertIds')
        if m.get('CustomSchedule') is not None:
            self.custom_schedule = m.get('CustomSchedule')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspCities') is not None:
            self.isp_cities = m.get('IspCities')
        if m.get('OptionsJson') is not None:
            self.options_json = m.get('OptionsJson')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class CreateSiteMonitorResponseBodyCreateResultListCreateResultList(TeaModel):
    def __init__(self, task_id=None, task_name=None):
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The name of the site monitoring task.
        self.task_name = task_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBodyCreateResultListCreateResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class CreateSiteMonitorResponseBodyCreateResultList(TeaModel):
    def __init__(self, create_result_list=None):
        self.create_result_list = create_result_list  # type: list[CreateSiteMonitorResponseBodyCreateResultListCreateResultList]

    def validate(self):
        if self.create_result_list:
            for k in self.create_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBodyCreateResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CreateResultList'] = []
        if self.create_result_list is not None:
            for k in self.create_result_list:
                result['CreateResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.create_result_list = []
        if m.get('CreateResultList') is not None:
            for k in m.get('CreateResultList'):
                temp_model = CreateSiteMonitorResponseBodyCreateResultListCreateResultList()
                self.create_result_list.append(temp_model.from_map(k))
        return self


class CreateSiteMonitorResponseBodyDataAttachAlertResultContact(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, rule_id=None, success=None):
        # The status code that is returned after you associate the existing alert rule with the site monitoring task.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The message that is returned after you associate the existing alert rule with the site monitoring task.
        self.message = message  # type: str
        # The ID of the request that was sent to associate the existing alert rule with the site monitoring task.
        self.request_id = request_id  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # Indicates whether the existing alert rule was associated with the site monitoring task. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBodyDataAttachAlertResultContact, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSiteMonitorResponseBodyDataAttachAlertResult(TeaModel):
    def __init__(self, contact=None):
        self.contact = contact  # type: list[CreateSiteMonitorResponseBodyDataAttachAlertResultContact]

    def validate(self):
        if self.contact:
            for k in self.contact:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBodyDataAttachAlertResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contact'] = []
        if self.contact is not None:
            for k in self.contact:
                result['Contact'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact = []
        if m.get('Contact') is not None:
            for k in m.get('Contact'):
                temp_model = CreateSiteMonitorResponseBodyDataAttachAlertResultContact()
                self.contact.append(temp_model.from_map(k))
        return self


class CreateSiteMonitorResponseBodyData(TeaModel):
    def __init__(self, attach_alert_result=None):
        # The result that is returned after you associate the existing alert rule with the site monitoring task.
        self.attach_alert_result = attach_alert_result  # type: CreateSiteMonitorResponseBodyDataAttachAlertResult

    def validate(self):
        if self.attach_alert_result:
            self.attach_alert_result.validate()

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.attach_alert_result is not None:
            result['AttachAlertResult'] = self.attach_alert_result.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AttachAlertResult') is not None:
            temp_model = CreateSiteMonitorResponseBodyDataAttachAlertResult()
            self.attach_alert_result = temp_model.from_map(m['AttachAlertResult'])
        return self


class CreateSiteMonitorResponseBody(TeaModel):
    def __init__(self, code=None, create_result_list=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned result.
        # 
        # If a site monitoring task is created, the result is returned. If a site monitoring task fails to be created, no result is returned.
        self.create_result_list = create_result_list  # type: CreateSiteMonitorResponseBodyCreateResultList
        # The result of the site monitoring task.
        self.data = data  # type: CreateSiteMonitorResponseBodyData
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        if self.create_result_list:
            self.create_result_list.validate()
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateSiteMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.create_result_list is not None:
            result['CreateResultList'] = self.create_result_list.to_map()
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CreateResultList') is not None:
            temp_model = CreateSiteMonitorResponseBodyCreateResultList()
            self.create_result_list = temp_model.from_map(m['CreateResultList'])
        if m.get('Data') is not None:
            temp_model = CreateSiteMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateSiteMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSiteMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSiteMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CursorRequest(TeaModel):
    def __init__(self, end_time=None, matchers=None, metric=None, namespace=None, period=None, start_time=None):
        # The end of the time range to query.
        # 
        # Unit: milliseconds.
        # 
        # > 
        # 
        # *   This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
        # 
        # *   If you do not set the end time, the end time is infinite. You can leave this parameter empty in real-time export scenarios.
        # *   In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
        self.end_time = end_time  # type: str
        # The dimension information of the metric.
        self.matchers = matchers  # type: list[Matcher]
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about the metrics of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric = metric  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The time interval based on which the metric value is measured.
        # 
        # Unit: seconds.
        # 
        # >  Generally, the time interval is 60 seconds. For more information about specific values, see the `Period` parameter in [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: int
        # The beginning of the time range to query.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
        # 
        # >  In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
        self.start_time = start_time  # type: str

    def validate(self):
        if self.matchers:
            for k in self.matchers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CursorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        result['Matchers'] = []
        if self.matchers is not None:
            for k in self.matchers:
                result['Matchers'].append(k.to_map() if k else None)
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        self.matchers = []
        if m.get('Matchers') is not None:
            for k in m.get('Matchers'):
                temp_model = Matcher()
                self.matchers.append(temp_model.from_map(k))
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CursorShrinkRequest(TeaModel):
    def __init__(self, end_time=None, matchers_shrink=None, metric=None, namespace=None, period=None,
                 start_time=None):
        # The end of the time range to query.
        # 
        # Unit: milliseconds.
        # 
        # > 
        # 
        # *   This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
        # 
        # *   If you do not set the end time, the end time is infinite. You can leave this parameter empty in real-time export scenarios.
        # *   In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
        self.end_time = end_time  # type: str
        # The dimension information of the metric.
        self.matchers_shrink = matchers_shrink  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about the metrics of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric = metric  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The time interval based on which the metric value is measured.
        # 
        # Unit: seconds.
        # 
        # >  Generally, the time interval is 60 seconds. For more information about specific values, see the `Period` parameter in [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: int
        # The beginning of the time range to query.
        # 
        # Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. For example, 2023-01-01T00:00:00Z indicates January 1, 2023, 00:00:00 UTC.
        # 
        # >  In CloudMonitor, the TTL of monitoring data varies with the time granularity. Specify a proper time interval based on the TTL corresponding to the value of the `Period` parameter.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CursorShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.matchers_shrink is not None:
            result['Matchers'] = self.matchers_shrink
        if self.metric is not None:
            result['Metric'] = self.metric
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Matchers') is not None:
            self.matchers_shrink = m.get('Matchers')
        if m.get('Metric') is not None:
            self.metric = m.get('Metric')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class CursorResponseBody(TeaModel):
    def __init__(self, code=None, cursor=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # Cursor is used as an input parameter for data export in the [BatchExport](~~2329847~~) operation.
        self.cursor = cursor  # type: str
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CursorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.cursor is not None:
            result['Cursor'] = self.cursor
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Cursor') is not None:
            self.cursor = m.get('Cursor')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CursorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CursorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CursorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CursorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactRequest(TeaModel):
    def __init__(self, contact_name=None):
        # The name of the alert contact.
        self.contact_name = contact_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteContactRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        return self


class DeleteContactResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteContactResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteContactResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteContactResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteContactResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteContactGroupRequest(TeaModel):
    def __init__(self, contact_group_name=None):
        # The name of the alert group.
        self.contact_group_name = contact_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteContactGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        return self


class DeleteContactGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteContactGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteContactGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteContactGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteContactGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCustomMetricRequest(TeaModel):
    def __init__(self, group_id=None, md_5=None, metric_name=None, region_id=None, uuid=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The MD5 value of the HTTP request body. The MD5 value is a 128-bit hash value used to verify the uniqueness of the reported monitoring data.
        # 
        # >  `Md5` is returned when you query the reported monitoring data of a metric.
        self.md_5 = md_5  # type: str
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        self.region_id = region_id  # type: str
        # The ID of the request for reporting monitoring data.
        # 
        # >  `UUID` is returned when you query the reported monitoring data of a metric. We recommend that you specify the `Md5` parameter.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomMetricRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.uuid is not None:
            result['UUID'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UUID') is not None:
            self.uuid = m.get('UUID')
        return self


class DeleteCustomMetricResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCustomMetricResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCustomMetricResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCustomMetricResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCustomMetricResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCustomMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDynamicTagGroupRequest(TeaModel):
    def __init__(self, dynamic_tag_rule_id=None, region_id=None):
        # The ID of the tag rule.
        # 
        # For information about how to obtain the ID of a tag rule, see [DescribeDynamicTagRuleList](~~150126~~).
        self.dynamic_tag_rule_id = dynamic_tag_rule_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDynamicTagGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_tag_rule_id is not None:
            result['DynamicTagRuleId'] = self.dynamic_tag_rule_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicTagRuleId') is not None:
            self.dynamic_tag_rule_id = m.get('DynamicTagRuleId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDynamicTagGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDynamicTagGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteDynamicTagGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDynamicTagGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDynamicTagGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDynamicTagGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventRuleTargetsRequest(TeaModel):
    def __init__(self, ids=None, region_id=None, rule_name=None):
        self.ids = ids  # type: list[str]
        self.region_id = region_id  # type: str
        # The name of the event-triggered alert rule.
        self.rule_name = rule_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEventRuleTargetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class DeleteEventRuleTargetsResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEventRuleTargetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEventRuleTargetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteEventRuleTargetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteEventRuleTargetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventRuleTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteEventRulesRequest(TeaModel):
    def __init__(self, rule_names=None):
        self.rule_names = rule_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEventRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_names is not None:
            result['RuleNames'] = self.rule_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RuleNames') is not None:
            self.rule_names = m.get('RuleNames')
        return self


class DeleteEventRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteEventRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteEventRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteEventRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteEventRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteEventRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteExporterOutputRequest(TeaModel):
    def __init__(self, dest_name=None, region_id=None):
        # The name of the configuration set.
        self.dest_name = dest_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteExporterOutputRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dest_name is not None:
            result['DestName'] = self.dest_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestName') is not None:
            self.dest_name = m.get('DestName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteExporterOutputResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteExporterOutputResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteExporterOutputResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteExporterOutputResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteExporterOutputResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteExporterOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteExporterRuleRequest(TeaModel):
    def __init__(self, region_id=None, rule_name=None):
        self.region_id = region_id  # type: str
        # The name of the data export rule.
        self.rule_name = rule_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteExporterRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class DeleteExporterRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteExporterRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteExporterRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteExporterRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteExporterRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteExporterRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteGroupMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, group_id=None, id=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The ID of the process monitoring task.
        self.id = id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteGroupMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteGroupMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteGroupMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteGroupMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteGroupMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteGroupMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteGroupMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHostAvailabilityRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        self.id = id  # type: list[long]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHybridMonitorNamespaceRequest(TeaModel):
    def __init__(self, namespace=None, region_id=None):
        # The name of the namespace.
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorNamespaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteHybridMonitorNamespaceResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The returned message.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorNamespaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHybridMonitorNamespaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHybridMonitorNamespaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHybridMonitorNamespaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHybridMonitorNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHybridMonitorSLSGroupRequest(TeaModel):
    def __init__(self, region_id=None, slsgroup_name=None):
        self.region_id = region_id  # type: str
        # The name of the Logstore group.
        # 
        # For information about how to obtain the name of a Logstore group, see [DescribeHybridMonitorSLSGroup](~~429526~~).
        self.slsgroup_name = slsgroup_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorSLSGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slsgroup_name is not None:
            result['SLSGroupName'] = self.slsgroup_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SLSGroupName') is not None:
            self.slsgroup_name = m.get('SLSGroupName')
        return self


class DeleteHybridMonitorSLSGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorSLSGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHybridMonitorSLSGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHybridMonitorSLSGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHybridMonitorSLSGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHybridMonitorSLSGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteHybridMonitorTaskRequest(TeaModel):
    def __init__(self, namespace=None, region_id=None, target_user_id=None, task_id=None):
        # The name of the namespace.
        # 
        # The name can contain uppercase letters, lowercase letters, digits, and hyphens (-).
        # 
        # > This parameter is required only if you call this operation to delete metric import tasks for Alibaba Cloud services. In this case, the `TaskType` parameter is set to `aliyun_fc`.
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The ID of the member account.
        # 
        # > This parameter is required only if you use a management account to call this operation to query metric import tasks that belong to a member in a resource directory. In this case, the `TaskType` parameter is set to `aliyun_fc`.
        self.target_user_id = target_user_id  # type: str
        # The ID of the metric import task.
        # 
        # For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](~~428624~~).
        # 
        # > This parameter is required only if you call this operation to delete metrics for the logs that are imported from Log Service. In this case, the `TaskType` parameter is set to `aliyun_sls`.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DeleteHybridMonitorTaskResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteHybridMonitorTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteHybridMonitorTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteHybridMonitorTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteHybridMonitorTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteHybridMonitorTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteLogMonitorRequest(TeaModel):
    def __init__(self, log_id=None, region_id=None):
        # The ID returned by Log Service.
        self.log_id = log_id  # type: long
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteLogMonitorResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteLogMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteLogMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteLogMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteLogMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteLogMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetricRuleBlackListRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        # The IDs of the blacklist policies. Separate multiple IDs with commas (,). You can specify up to 50 IDs.
        # 
        # For more information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](~~457257~~).
        # 
        # >  You can also set this parameter to a JSON array. Example: `["a9ad2ac2-3ed9-11ed-b878-0242ac12****","5cb8a9a4-198f-4651-a353-f8b28788****"]`.
        self.id = id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleBlackListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMetricRuleBlackListResponseBody(TeaModel):
    def __init__(self, code=None, count=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The number of blacklist policies that are deleted.
        self.count = count  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleBlackListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetricRuleBlackListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMetricRuleBlackListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleBlackListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetricRuleBlackListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetricRuleResourcesRequest(TeaModel):
    def __init__(self, resources=None, rule_id=None):
        # The resources to be disassociated from the alert rule.
        self.resources = resources  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DeleteMetricRuleResourcesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetricRuleResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMetricRuleResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetricRuleResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetricRuleTargetsRequest(TeaModel):
    def __init__(self, region_id=None, rule_id=None, target_ids=None):
        self.region_id = region_id  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The resource IDs.
        self.target_ids = target_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleTargetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.target_ids is not None:
            result['TargetIds'] = self.target_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('TargetIds') is not None:
            self.target_ids = m.get('TargetIds')
        return self


class DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds(TeaModel):
    def __init__(self, target_id=None):
        self.target_id = target_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_id is not None:
            result['TargetId'] = self.target_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetId') is not None:
            self.target_id = m.get('TargetId')
        return self


class DeleteMetricRuleTargetsResponseBodyFailIds(TeaModel):
    def __init__(self, target_ids=None):
        # The IDs of the resources that failed to be deleted.
        self.target_ids = target_ids  # type: DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds

    def validate(self):
        if self.target_ids:
            self.target_ids.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleTargetsResponseBodyFailIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.target_ids is not None:
            result['TargetIds'] = self.target_ids.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TargetIds') is not None:
            temp_model = DeleteMetricRuleTargetsResponseBodyFailIdsTargetIds()
            self.target_ids = temp_model.from_map(m['TargetIds'])
        return self


class DeleteMetricRuleTargetsResponseBody(TeaModel):
    def __init__(self, code=None, fail_ids=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # **\
        # 
        # **Description** The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The IDs of the resources that failed to be deleted.
        self.fail_ids = fail_ids  # type: DeleteMetricRuleTargetsResponseBodyFailIds
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.fail_ids:
            self.fail_ids.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleTargetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_ids is not None:
            result['FailIds'] = self.fail_ids.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailIds') is not None:
            temp_model = DeleteMetricRuleTargetsResponseBodyFailIds()
            self.fail_ids = temp_model.from_map(m['FailIds'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetricRuleTargetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMetricRuleTargetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleTargetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetricRuleTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetricRuleTemplateRequest(TeaModel):
    def __init__(self, region_id=None, template_id=None):
        self.region_id = region_id  # type: str
        # The ID of the alert template.
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteMetricRuleTemplateResponseBodyResource(TeaModel):
    def __init__(self, template_id=None):
        # The ID of the template.
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRuleTemplateResponseBodyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DeleteMetricRuleTemplateResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the alert template.
        self.resource = resource  # type: DeleteMetricRuleTemplateResponseBodyResource
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = DeleteMetricRuleTemplateResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetricRuleTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMetricRuleTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMetricRuleTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetricRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMetricRulesRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        self.id = id  # type: list[str]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMetricRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # >  The status code 200 indicates a success.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMetricRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMetricRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMetricRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMetricRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMetricRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMonitorGroupRequest(TeaModel):
    def __init__(self, group_id=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup(TeaModel):
    def __init__(self, name=None):
        # The name of the alert group.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DeleteMonitorGroupResponseBodyGroupContactGroups(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup]

    def validate(self):
        if self.contact_group:
            for k in self.contact_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupResponseBodyGroupContactGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactGroup'] = []
        if self.contact_group is not None:
            for k in self.contact_group:
                result['ContactGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_group = []
        if m.get('ContactGroup') is not None:
            for k in m.get('ContactGroup'):
                temp_model = DeleteMonitorGroupResponseBodyGroupContactGroupsContactGroup()
                self.contact_group.append(temp_model.from_map(k))
        return self


class DeleteMonitorGroupResponseBodyGroup(TeaModel):
    def __init__(self, contact_groups=None, group_name=None):
        # The alert groups that receive alert notifications for the application group.
        self.contact_groups = contact_groups  # type: DeleteMonitorGroupResponseBodyGroupContactGroups
        # The name of the application group.
        self.group_name = group_name  # type: str

    def validate(self):
        if self.contact_groups:
            self.contact_groups.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupResponseBodyGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups.to_map()
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroups') is not None:
            temp_model = DeleteMonitorGroupResponseBodyGroupContactGroups()
            self.contact_groups = temp_model.from_map(m['ContactGroups'])
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DeleteMonitorGroupResponseBody(TeaModel):
    def __init__(self, code=None, group=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The deleted application group.
        self.group = group  # type: DeleteMonitorGroupResponseBodyGroup
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        if self.group:
            self.group.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.group is not None:
            result['Group'] = self.group.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Group') is not None:
            temp_model = DeleteMonitorGroupResponseBodyGroup()
            self.group = temp_model.from_map(m['Group'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMonitorGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMonitorGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMonitorGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMonitorGroupDynamicRuleRequest(TeaModel):
    def __init__(self, category=None, group_id=None, region_id=None):
        # The service to which the rule applies. Valid values: ecs, rds, and slb.
        self.category = category  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: long
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupDynamicRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMonitorGroupDynamicRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupDynamicRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMonitorGroupDynamicRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMonitorGroupDynamicRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupDynamicRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMonitorGroupDynamicRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMonitorGroupInstancesRequest(TeaModel):
    def __init__(self, category=None, group_id=None, instance_id_list=None, region_id=None):
        # The abbreviation of the service name. Valid values:
        # 
        # *   ECS: Elastic Compute Service (ECS) instances provided by Alibaba Cloud and hosts not provided by Alibaba Cloud
        # *   RDS: ApsaraDB for RDS
        # *   ADS: AnalyticDB
        # *   SLB: Server Load Balancer (SLB)
        # *   VPC: Virtual Private Cloud (VPC)
        # *   APIGATEWAY: API Gateway
        # *   CDN: Alibaba Cloud Content Delivery Network (CDN)
        # *   CS: Container Service for Swarm
        # *   DCDN: Dynamic Route for CDN
        # *   DDoS: Anti-DDoS Pro
        # *   EIP: Elastic IP Address (EIP)
        # *   ELASTICSEARCH: Elasticsearch
        # *   EMR: E-MapReduce
        # *   ESS: Auto Scaling
        # *   HBASE: ApsaraDB for Hbase
        # *   IOT_EDGE: IoT Edge
        # *   K8S_POD: pods in Container Service for Kubernetes
        # *   KVSTORE_SHARDING: ApsaraDB for Redis of the cluster architecture
        # *   KVSTORE_SPLITRW: ApsaraDB for Redis of the read/write splitting architecture
        # *   KVSTORE_STANDARD: ApsaraDB for Redis of the standard architecture
        # *   MEMCACHE: ApsaraDB for Memcache
        # *   MNS: Message Service (MNS)
        # *   MONGODB: ApsaraDB for MongoDB of the replica set architecture
        # *   MONGODB_CLUSTER: ApsaraDB for MongoDB of the cluster architecture
        # *   MONGODB_SHARDING: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   MQ_TOPIC: MNS topics
        # *   OCS: ApsaraDB for Memcache of earlier versions
        # *   OPENSEARCH: Open Search
        # *   OSS: Object Storage Service (OSS)
        # *   POLARDB: PolarDB
        # *   PETADATA: HybridDB for MySQL
        # *   SCDN: Secure Content Delivery Network (SCDN)
        # *   SHAREBANDWIDTHPACKAGES: EIP Bandwidth Plan
        # *   SLS: Log Service
        # *   VPN: VPN Gateway
        self.category = category  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The instances to be removed from the application group. Separate multiple instances with commas (,). You can remove a maximum of 20 instances from an application group at a time.
        self.instance_id_list = instance_id_list  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id_list is not None:
            result['InstanceIdList'] = self.instance_id_list
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceIdList') is not None:
            self.instance_id_list = m.get('InstanceIdList')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMonitorGroupInstancesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMonitorGroupInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMonitorGroupInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMonitorGroupInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMonitorGroupNotifyPolicyRequest(TeaModel):
    def __init__(self, group_id=None, policy_type=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The policy type.
        # 
        # Valid value: PauseNotify.
        self.policy_type = policy_type  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupNotifyPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMonitorGroupNotifyPolicyResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, result=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The number of affected rows.
        self.result = result  # type: int
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitorGroupNotifyPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMonitorGroupNotifyPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMonitorGroupNotifyPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMonitorGroupNotifyPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMonitorGroupNotifyPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, instance_id=None, process_id=None, process_name=None, region_id=None):
        # The instance ID.
        self.instance_id = instance_id  # type: str
        # The process ID.
        # 
        # > You must configure either `ProcessId` or `ProcessName`.
        self.process_id = process_id  # type: str
        # The process name.
        # 
        # > You must configure either `ProcessId` or `ProcessName`.
        self.process_name = process_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSiteMonitorsRequest(TeaModel):
    def __init__(self, is_delete_alarms=None, region_id=None, task_ids=None):
        # Specifies whether to delete the alert rules configured for the site monitoring tasks. Valid values:
        # 
        # *   true (default value)
        # *   false
        self.is_delete_alarms = is_delete_alarms  # type: bool
        self.region_id = region_id  # type: str
        # The IDs of the site monitoring tasks that you want to delete. Separate multiple task IDs with commas (,).
        self.task_ids = task_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSiteMonitorsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.is_delete_alarms is not None:
            result['IsDeleteAlarms'] = self.is_delete_alarms
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IsDeleteAlarms') is not None:
            self.is_delete_alarms = m.get('IsDeleteAlarms')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DeleteSiteMonitorsResponseBodyData(TeaModel):
    def __init__(self, count=None):
        # The number of the site monitoring tasks that were deleted.
        self.count = count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSiteMonitorsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class DeleteSiteMonitorsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The information about the site monitoring tasks that were deleted.
        self.data = data  # type: DeleteSiteMonitorsResponseBodyData
        # The returned message. If the call was successful, the value success is returned. If the call failed, an error message such as `TaskId not found` is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates success. The value false indicates failure.
        self.success = success  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DeleteSiteMonitorsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DeleteSiteMonitorsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteSiteMonitorsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSiteMonitorsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSiteMonitorsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSiteMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeActiveMetricRuleListRequest(TeaModel):
    def __init__(self, product=None):
        # The abbreviation of the service name. The following services support one-click alert:
        # 
        # *   ecs: Elastic Compute Service (ECS)
        # *   rds: ApsaraDB for RDS
        # *   slb: Server Load Balancer (SLB)
        # *   redis_standard: ApsaraDB for Redis of the standard architecture
        # *   redis_sharding: ApsaraDB for Redis of the cluster architecture
        # *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
        # *   mongodb: ApsaraDB for MongoDB of the replica set architecture
        # *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   hbase: ApsaraDB for HBase
        # *   elasticsearch: Elasticsearch
        # *   opensearch: Open Search
        self.product = product  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product is not None:
            result['Product'] = self.product
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Product') is not None:
            self.product = m.get('Product')
        return self


class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator of the threshold for critical-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical aggregation method for critical-level alerts.
        self.statistics = statistics  # type: str
        # The threshold for critical-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
        self.times = times  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator of the threshold for info-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical aggregation method for info-level alerts.
        self.statistics = statistics  # type: str
        # The threshold for info-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an info-level alert is triggered.
        self.times = times  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator of the threshold for critical-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical aggregation method for warn-level alerts.
        self.statistics = statistics  # type: str
        # The threshold of warn-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a warn-level alert is triggered.
        self.times = times  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        # The condition for triggering critical-level alerts.
        self.critical = critical  # type: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical
        # The condition for triggering info-level alerts.
        self.info = info  # type: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo
        # The condition for triggering warn-level alerts.
        self.warn = warn  # type: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class DescribeActiveMetricRuleListResponseBodyAlertListAlert(TeaModel):
    def __init__(self, alert_state=None, contact_groups=None, dimensions=None, effective_interval=None,
                 enable_state=None, escalations=None, mail_subject=None, metric_name=None, namespace=None,
                 no_effective_interval=None, period=None, resources=None, rule_id=None, rule_name=None, silence_time=None, webhook=None):
        # The status of the alert rule. Valid values:
        # 
        # *   OK: The alert rule has no active alert.
        # *   ALARM: The alert rule has at least one active alert.
        # *   INSUFFICIENT_DATA: The alert rule has no data.
        self.alert_state = alert_state  # type: str
        # The alert group that receives alert notifications.
        self.contact_groups = contact_groups  # type: str
        # The dimensions that specify the resources for which you want to query monitoring data.
        # 
        # The value is a collection of key-value pairs. A typical key-value pair is `instanceId:XXXXXX`.
        # 
        # The key and value must be 1 to 64 bytes in length, respectively. Excessive bytes are truncated from the string.
        # 
        # The key and value can contain letters, digits, periods (.), hyphens (-), underscores (\_), forward slashes (/), and backslashes (\\).
        # 
        # >  Dimensions must be organized in a JSON string and follow the required order.
        self.dimensions = dimensions  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   true: The alert rule is enabled.
        # *   false: The alert rule is disabled.
        self.enable_state = enable_state  # type: bool
        # The conditions for triggering different levels of alerts.
        self.escalations = escalations  # type: DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations
        self.mail_subject = mail_subject  # type: str
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        # The namespace of the service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The aggregation period of the monitoring data. Unit: seconds. The default value is the minimum aggregation period, indicating that the metric is polled at the highest frequency. Typically, you do not need to specify the minimum aggregation period.
        self.period = period  # type: str
        # The resources that are associated with the alert rule. A one-click alert rule is associated with all resources. The return value is fixed.
        self.resources = resources  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
        self.silence_time = silence_time  # type: str
        # The callback URL.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertListAlert, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_state is not None:
            result['AlertState'] = self.alert_state
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.enable_state is not None:
            result['EnableState'] = self.enable_state
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.mail_subject is not None:
            result['MailSubject'] = self.mail_subject
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertState') is not None:
            self.alert_state = m.get('AlertState')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EnableState') is not None:
            self.enable_state = m.get('EnableState')
        if m.get('Escalations') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyAlertListAlertEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('MailSubject') is not None:
            self.mail_subject = m.get('MailSubject')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class DescribeActiveMetricRuleListResponseBodyAlertList(TeaModel):
    def __init__(self, alert=None):
        self.alert = alert  # type: list[DescribeActiveMetricRuleListResponseBodyAlertListAlert]

    def validate(self):
        if self.alert:
            for k in self.alert:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyAlertList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alert'] = []
        if self.alert is not None:
            for k in self.alert:
                result['Alert'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert = []
        if m.get('Alert') is not None:
            for k in m.get('Alert'):
                temp_model = DescribeActiveMetricRuleListResponseBodyAlertListAlert()
                self.alert.append(temp_model.from_map(k))
        return self


class DescribeActiveMetricRuleListResponseBodyDatapointsAlarm(TeaModel):
    def __init__(self, comparison_operator=None, contact_groups=None, enable=None, end_time=None,
                 evaluation_count=None, metric_name=None, namespace=None, period=None, rule_id=None, rule_name=None,
                 silence_time=None, start_time=None, state=None, statistics=None, threshold=None, webhook=None):
        # The comparison operator that is used in the alert rule. Valid values:
        # 
        # *   `>`
        # *   `<`
        # *   `>=`
        # *   `<=`
        # *   `=`
        # *   `=`
        self.comparison_operator = comparison_operator  # type: str
        # The alert group that receives alert notifications.
        self.contact_groups = contact_groups  # type: str
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   true: The alert rule is enabled.
        # *   false: The alert rule is disabled.
        self.enable = enable  # type: str
        # The beginning of the time period during which the alert rule is effective. Unit: hours. For example, the value 23 indicates `23:59:59`.
        self.end_time = end_time  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.evaluation_count = evaluation_count  # type: str
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        # The namespace of the service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The aggregation period of the monitoring data. Unit: seconds. The default value is the minimum aggregation period, indicating that the metric is polled at the highest frequency. Typically, you do not need to specify the minimum aggregation period.
        self.period = period  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
        self.silence_time = silence_time  # type: str
        # The end of the time period during which the alert rule is effective. Unit: hours. For example, the value 00 indicates `00:00:00`.
        self.start_time = start_time  # type: str
        # Indicates whether the alert rule is enabled.
        self.state = state  # type: str
        # The statistical aggregation method.
        self.statistics = statistics  # type: str
        # The threshold of the metric value.
        self.threshold = threshold  # type: str
        # The callback URL.
        self.webhook = webhook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyDatapointsAlarm, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class DescribeActiveMetricRuleListResponseBodyDatapoints(TeaModel):
    def __init__(self, alarm=None):
        self.alarm = alarm  # type: list[DescribeActiveMetricRuleListResponseBodyDatapointsAlarm]

    def validate(self):
        if self.alarm:
            for k in self.alarm:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBodyDatapoints, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alarm'] = []
        if self.alarm is not None:
            for k in self.alarm:
                result['Alarm'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alarm = []
        if m.get('Alarm') is not None:
            for k in m.get('Alarm'):
                temp_model = DescribeActiveMetricRuleListResponseBodyDatapointsAlarm()
                self.alarm.append(temp_model.from_map(k))
        return self


class DescribeActiveMetricRuleListResponseBody(TeaModel):
    def __init__(self, alert_list=None, code=None, datapoints=None, message=None, request_id=None, success=None):
        # The details of the alert rules.
        self.alert_list = alert_list  # type: DescribeActiveMetricRuleListResponseBodyAlertList
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The details of the alert rules.
        self.datapoints = datapoints  # type: DescribeActiveMetricRuleListResponseBodyDatapoints
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.alert_list:
            self.alert_list.validate()
        if self.datapoints:
            self.datapoints.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_list is not None:
            result['AlertList'] = self.alert_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertList') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyAlertList()
            self.alert_list = temp_model.from_map(m['AlertList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBodyDatapoints()
            self.datapoints = temp_model.from_map(m['Datapoints'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeActiveMetricRuleListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeActiveMetricRuleListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeActiveMetricRuleListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeActiveMetricRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlertHistoryListRequest(TeaModel):
    def __init__(self, ascending=None, end_time=None, group_id=None, metric_name=None, namespace=None, page=None,
                 page_size=None, region_id=None, rule_id=None, rule_name=None, start_time=None, state=None, status=None):
        # The order of alerts. Valid values:
        # 
        # *   true (default value): reverse chronological order
        # *   false: chronological order
        self.ascending = ascending  # type: bool
        # The end timestamp of the historical alerts that you want to query.
        # 
        # Unit: milliseconds.
        self.end_time = end_time  # type: str
        # The ID of the application group.
        # 
        # For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For information about how to query the name of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The number of the page to return.
        # 
        # Default value: 1.
        self.page = page  # type: int
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The ID of the alert rule.
        # 
        # For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        # 
        # For information about how to query the name of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_name = rule_name  # type: str
        # The start timestamp of the historical alerts that you want to query.
        # 
        # Unit: milliseconds.
        self.start_time = start_time  # type: str
        # The status of the alert. Valid values:
        # 
        # *   ALARM (default value): Alerts are triggered.
        # *   OK: No alerts are triggered.
        self.state = state  # type: str
        # Specifies whether alerts are muted. Valid values:
        # 
        # *   2 (default value): Alerts are muted and are not triggered within the mute period, even if the condition specified in the alert rule is met.
        # *   0: Alerts are triggered or cleared.
        # *   1: The alert rule is ineffective.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ascending is not None:
            result['Ascending'] = self.ascending
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.state is not None:
            result['State'] = self.state
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ascending') is not None:
            self.ascending = m.get('Ascending')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs(TeaModel):
    def __init__(self, contact_aliim=None):
        self.contact_aliim = contact_aliim  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_aliim is not None:
            result['ContactALIIM'] = self.contact_aliim
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactALIIM') is not None:
            self.contact_aliim = m.get('ContactALIIM')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails(TeaModel):
    def __init__(self, contact_mail=None):
        self.contact_mail = contact_mail  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_mail is not None:
            result['ContactMail'] = self.contact_mail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactMail') is not None:
            self.contact_mail = m.get('ContactMail')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses(TeaModel):
    def __init__(self, contact_sms=None):
        self.contact_sms = contact_sms  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_sms is not None:
            result['ContactSms'] = self.contact_sms
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactSms') is not None:
            self.contact_sms = m.get('ContactSms')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts(TeaModel):
    def __init__(self, contact=None):
        self.contact = contact  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact is not None:
            result['Contact'] = self.contact
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Contact') is not None:
            self.contact = m.get('Contact')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory(TeaModel):
    def __init__(self, alert_time=None, contact_aliims=None, contact_groups=None, contact_mails=None,
                 contact_smses=None, contacts=None, dimensions=None, evaluation_count=None, expression=None, group_id=None,
                 instance_name=None, last_time=None, level=None, metric_name=None, namespace=None, rule_id=None, rule_name=None,
                 state=None, status=None, value=None, webhooks=None):
        # The timestamp when the alert was triggered. Unit: milliseconds.
        self.alert_time = alert_time  # type: long
        # The TradeManager IDs of the alert contacts.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.contact_aliims = contact_aliims  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs
        # The alert contact groups.
        self.contact_groups = contact_groups  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups
        # The email addresses of the alert contacts.
        self.contact_mails = contact_mails  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails
        # The mobile numbers of the alert contacts.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.contact_smses = contact_smses  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses
        # The alert contacts that receive alert notifications.
        self.contacts = contacts  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts
        # The resources that are monitored.
        self.dimensions = dimensions  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.evaluation_count = evaluation_count  # type: int
        # The expression that is used to trigger alerts.
        self.expression = expression  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The instance name.
        self.instance_name = instance_name  # type: str
        # The duration of the alert. Unit: milliseconds.
        self.last_time = last_time  # type: long
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # The metric name.
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        self.namespace = namespace  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The alert status. Valid values:
        # 
        # *   ALARM: Alerts are triggered.
        # *   OK: No alerts are triggered.
        self.state = state  # type: str
        # Indicates whether alerts are muted. Valid values:
        # 
        # *   2 (default): Alerts are muted and are not triggered within the mute period, even if the condition specified in the alert rule is met.
        # *   0: Alerts are triggered or cleared.
        # *   1: The alert rule is ineffective.
        self.status = status  # type: int
        # The threshold of the metric value to trigger or clear an alert.
        self.value = value  # type: str
        # The callback URL.
        self.webhooks = webhooks  # type: str

    def validate(self):
        if self.contact_aliims:
            self.contact_aliims.validate()
        if self.contact_groups:
            self.contact_groups.validate()
        if self.contact_mails:
            self.contact_mails.validate()
        if self.contact_smses:
            self.contact_smses.validate()
        if self.contacts:
            self.contacts.validate()

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_time is not None:
            result['AlertTime'] = self.alert_time
        if self.contact_aliims is not None:
            result['ContactALIIMs'] = self.contact_aliims.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups.to_map()
        if self.contact_mails is not None:
            result['ContactMails'] = self.contact_mails.to_map()
        if self.contact_smses is not None:
            result['ContactSmses'] = self.contact_smses.to_map()
        if self.contacts is not None:
            result['Contacts'] = self.contacts.to_map()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.state is not None:
            result['State'] = self.state
        if self.status is not None:
            result['Status'] = self.status
        if self.value is not None:
            result['Value'] = self.value
        if self.webhooks is not None:
            result['Webhooks'] = self.webhooks
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertTime') is not None:
            self.alert_time = m.get('AlertTime')
        if m.get('ContactALIIMs') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactALIIMs()
            self.contact_aliims = temp_model.from_map(m['ContactALIIMs'])
        if m.get('ContactGroups') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactGroups()
            self.contact_groups = temp_model.from_map(m['ContactGroups'])
        if m.get('ContactMails') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactMails()
            self.contact_mails = temp_model.from_map(m['ContactMails'])
        if m.get('ContactSmses') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContactSmses()
            self.contact_smses = temp_model.from_map(m['ContactSmses'])
        if m.get('Contacts') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistoryContacts()
            self.contacts = temp_model.from_map(m['Contacts'])
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('State') is not None:
            self.state = m.get('State')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('Webhooks') is not None:
            self.webhooks = m.get('Webhooks')
        return self


class DescribeAlertHistoryListResponseBodyAlarmHistoryList(TeaModel):
    def __init__(self, alarm_history=None):
        self.alarm_history = alarm_history  # type: list[DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory]

    def validate(self):
        if self.alarm_history:
            for k in self.alarm_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBodyAlarmHistoryList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlarmHistory'] = []
        if self.alarm_history is not None:
            for k in self.alarm_history:
                result['AlarmHistory'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alarm_history = []
        if m.get('AlarmHistory') is not None:
            for k in m.get('AlarmHistory'):
                temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryListAlarmHistory()
                self.alarm_history.append(temp_model.from_map(k))
        return self


class DescribeAlertHistoryListResponseBody(TeaModel):
    def __init__(self, alarm_history_list=None, code=None, message=None, request_id=None, success=None, total=None):
        # The details of historical alerts.
        self.alarm_history_list = alarm_history_list  # type: DescribeAlertHistoryListResponseBodyAlarmHistoryList
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total = total  # type: str

    def validate(self):
        if self.alarm_history_list:
            self.alarm_history_list.validate()

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_history_list is not None:
            result['AlarmHistoryList'] = self.alarm_history_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmHistoryList') is not None:
            temp_model = DescribeAlertHistoryListResponseBodyAlarmHistoryList()
            self.alarm_history_list = temp_model.from_map(m['AlarmHistoryList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeAlertHistoryListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlertHistoryListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlertHistoryListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlertHistoryListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlertLogCountRequest(TeaModel):
    def __init__(self, contact_group=None, end_time=None, group_by=None, group_id=None, last_min=None, level=None,
                 metric_name=None, namespace=None, page_number=None, page_size=None, product=None, region_id=None,
                 rule_name=None, search_key=None, send_status=None, source_type=None, start_time=None):
        # The alert group.
        self.contact_group = contact_group  # type: str
        # The end timestamp of the alert logs to be queried.
        # 
        # Unit: milliseconds.
        # 
        # You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogCount` parameter is empty.
        # 
        # >  The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
        self.end_time = end_time  # type: long
        # The dimension based on which data is aggregated. This parameter is similar to the Group By clause of SQL statements. Valid values:
        # 
        # *   `product`: aggregates data by cloud service.
        # *   `level`: aggregates data by alert level.
        # *   `groupId`: aggregates data by application group.
        # *   `contactGroup`: aggregates data by alert group.
        # *   `product,metricName`: aggregates data both by cloud service and by metric.
        self.group_by = group_by  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The statistical period of alert logs. Unit: minutes.
        self.last_min = last_min  # type: str
        # The level and notification method of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # The name of the metric.
        # 
        # >  For more information about the metrics of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # >  For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
        # 
        # *   `product`: aggregates data by cloud service.
        # *   `level`: aggregates data by alert level.
        # *   `groupId`: aggregates data by application group.
        # *   `contactGroup`: aggregates data by alert contact group.
        # *   `product,metricName`: aggregates data both by cloud service and by metric.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        # The abbreviation of the service name.
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The keyword based on which the alert logs to be counted are searched.
        self.search_key = search_key  # type: str
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is triggered or cleared.
        # *   1: The alert is generated not during the effective period.
        # *   2: The alert is muted and not triggered in a specified period.
        # *   3: The host is restarting.
        # *   4: Notifications are not sent for the alert.
        # 
        # When the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
        self.send_status = send_status  # type: str
        # This parameter is deprecated.
        self.source_type = source_type  # type: str
        # The start timestamp of the alert logs to be queried.
        # 
        # Unit: milliseconds.
        # 
        # You can query only the alert logs within the last year. If the query time is longer than one year, the return value of the `AlertLogCount` parameter is empty.
        # 
        # >  The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_by is not None:
            result['GroupBy'] = self.group_by
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.last_min is not None:
            result['LastMin'] = self.last_min
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.send_status is not None:
            result['SendStatus'] = self.send_status
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupBy') is not None:
            self.group_by = m.get('GroupBy')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LastMin') is not None:
            self.last_min = m.get('LastMin')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SendStatus') is not None:
            self.send_status = m.get('SendStatus')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeAlertLogCountResponseBodyAlertLogCountLogs(TeaModel):
    def __init__(self, name=None, value=None):
        # The name of the dimension field based on which alert logs are aggregated.
        self.name = name  # type: str
        # The value of the dimension field based on which alert logs are aggregated.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogCountResponseBodyAlertLogCountLogs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlertLogCountResponseBodyAlertLogCount(TeaModel):
    def __init__(self, count=None, logs=None):
        # The number of alert logs.
        self.count = count  # type: int
        # The details about alert logs.
        self.logs = logs  # type: list[DescribeAlertLogCountResponseBodyAlertLogCountLogs]

    def validate(self):
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogCountResponseBodyAlertLogCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribeAlertLogCountResponseBodyAlertLogCountLogs()
                self.logs.append(temp_model.from_map(k))
        return self


class DescribeAlertLogCountResponseBody(TeaModel):
    def __init__(self, alert_log_count=None, code=None, message=None, request_id=None, success=None):
        # The statistics of alert logs.
        self.alert_log_count = alert_log_count  # type: list[DescribeAlertLogCountResponseBodyAlertLogCount]
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.alert_log_count:
            for k in self.alert_log_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertLogCount'] = []
        if self.alert_log_count is not None:
            for k in self.alert_log_count:
                result['AlertLogCount'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_log_count = []
        if m.get('AlertLogCount') is not None:
            for k in m.get('AlertLogCount'):
                temp_model = DescribeAlertLogCountResponseBodyAlertLogCount()
                self.alert_log_count.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeAlertLogCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlertLogCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlertLogCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlertLogCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlertLogHistogramRequest(TeaModel):
    def __init__(self, contact_group=None, end_time=None, group_by=None, group_id=None, last_min=None, level=None,
                 metric_name=None, namespace=None, page_number=None, page_size=None, product=None, region_id=None,
                 rule_name=None, search_key=None, send_status=None, source_type=None, start_time=None):
        # The alert contact group.
        self.contact_group = contact_group  # type: str
        # The end timestamp of the alert logs to be queried.
        # 
        # Unit: milliseconds.
        # 
        # > 
        # 
        # *   You can query only the alert logs within the last year.
        # 
        # *   The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
        self.end_time = end_time  # type: long
        # The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
        # 
        # *   `product`: aggregates data by cloud service.
        # *   `level`: aggregates data by alert level.
        # *   `groupId`: aggregates data by application group.
        # *   `contactGroup`: aggregates data by alert contact group.
        # *   `product,metricName`: aggregates data both by cloud service and by metric.
        self.group_by = group_by  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The statistical period of alert logs. Unit: minutes.
        self.last_min = last_min  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # The metric name.
        # 
        # >  For more information about the metrics of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the Alibaba Cloud service.
        # 
        # >  For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The page number.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        # The abbreviation of the Alibaba Cloud service name.
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The keyword that is used to query alert logs.
        self.search_key = search_key  # type: str
        # The alert status. Valid values:
        # 
        # *   0: The alert is triggered or cleared.
        # *   1: The alert is ineffective.
        # *   2: The alert is muted and not triggered in a specified period.
        # *   3: The host is restarting.
        # *   4: No alert notification is sent.
        # 
        # If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
        self.send_status = send_status  # type: str
        # This parameter is deprecated.
        self.source_type = source_type  # type: str
        # The start timestamp of the alert logs to be queried.
        # 
        # Unit: milliseconds.
        # 
        # > 
        # 
        # *   You can query only the alert logs within the last year.
        # 
        # *   The interval between the start time (`StartTime`) and end time (`EndTime`) must be less than or equal to 15 days.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogHistogramRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_by is not None:
            result['GroupBy'] = self.group_by
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.last_min is not None:
            result['LastMin'] = self.last_min
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.send_status is not None:
            result['SendStatus'] = self.send_status
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupBy') is not None:
            self.group_by = m.get('GroupBy')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LastMin') is not None:
            self.last_min = m.get('LastMin')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SendStatus') is not None:
            self.send_status = m.get('SendStatus')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeAlertLogHistogramResponseBodyAlertLogHistogramList(TeaModel):
    def __init__(self, count=None, from_=None, to=None):
        # The number of alert logs.
        self.count = count  # type: int
        # The start timestamp of the queried alert logs.
        # 
        # Unit: seconds.
        self.from_ = from_  # type: long
        # The end timestamp of the queried alert logs.
        # 
        # Unit: seconds.
        self.to = to  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogHistogramResponseBodyAlertLogHistogramList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.from_ is not None:
            result['From'] = self.from_
        if self.to is not None:
            result['To'] = self.to
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('From') is not None:
            self.from_ = m.get('From')
        if m.get('To') is not None:
            self.to = m.get('To')
        return self


class DescribeAlertLogHistogramResponseBody(TeaModel):
    def __init__(self, alert_log_histogram_list=None, code=None, message=None, request_id=None, success=None):
        # The number of alert logs that were generated during each interval of a time period.
        self.alert_log_histogram_list = alert_log_histogram_list  # type: list[DescribeAlertLogHistogramResponseBodyAlertLogHistogramList]
        # The response code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.alert_log_histogram_list:
            for k in self.alert_log_histogram_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogHistogramResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertLogHistogramList'] = []
        if self.alert_log_histogram_list is not None:
            for k in self.alert_log_histogram_list:
                result['AlertLogHistogramList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_log_histogram_list = []
        if m.get('AlertLogHistogramList') is not None:
            for k in m.get('AlertLogHistogramList'):
                temp_model = DescribeAlertLogHistogramResponseBodyAlertLogHistogramList()
                self.alert_log_histogram_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeAlertLogHistogramResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlertLogHistogramResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlertLogHistogramResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlertLogHistogramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlertLogListRequest(TeaModel):
    def __init__(self, contact_group=None, end_time=None, group_by=None, group_id=None, last_min=None, level=None,
                 metric_name=None, namespace=None, page_number=None, page_size=None, product=None, region_id=None, rule_id=None,
                 rule_name=None, search_key=None, send_status=None, source_type=None, start_time=None):
        # The alert contact group.
        self.contact_group = contact_group  # type: str
        # The end timestamp of the alert logs to be queried. Unit: milliseconds.
        self.end_time = end_time  # type: long
        # The dimension based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL. Valid values:
        # 
        # *   `product`: aggregates data by cloud service.
        # *   `level`: aggregates data by alert level.
        # *   `groupId`: aggregates data by application group.
        # *   `contactGroup`: aggregates data by alert contact group.
        # *   `product,metricName`: aggregates data both by cloud service and by metric.
        self.group_by = group_by  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The statistical period of alert logs. Unit: minutes.
        self.last_min = last_min  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # The metric name.
        # 
        # > For more information about the metrics of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # > For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The page number. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page. Default value: 10.
        self.page_size = page_size  # type: int
        # The abbreviation of the cloud service name.
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The ID of the alert rule. For more information about how to query the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The search keyword that is used to query alert logs.
        self.search_key = search_key  # type: str
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is triggered or cleared.
        # *   1: The alert is ineffective.
        # *   2: The alert is muted.
        # *   3: The host is restarting.
        # *   4: No alert notification is sent.
        # 
        # If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
        self.send_status = send_status  # type: str
        self.source_type = source_type  # type: str
        # The start timestamp of the alert logs to be queried. Unit: milliseconds.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_by is not None:
            result['GroupBy'] = self.group_by
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.last_min is not None:
            result['LastMin'] = self.last_min
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.search_key is not None:
            result['SearchKey'] = self.search_key
        if self.send_status is not None:
            result['SendStatus'] = self.send_status
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupBy') is not None:
            self.group_by = m.get('GroupBy')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LastMin') is not None:
            self.last_min = m.get('LastMin')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SearchKey') is not None:
            self.search_key = m.get('SearchKey')
        if m.get('SendStatus') is not None:
            self.send_status = m.get('SendStatus')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeAlertLogListResponseBodyAlertLogListDimensions(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the dimension.
        self.key = key  # type: str
        # The value of the dimension.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListDimensions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlertLogListResponseBodyAlertLogListEscalation(TeaModel):
    def __init__(self, expression=None, level=None, times=None):
        # The description of the alert rule.
        # 
        # > The content of the alert rule. If the metric value meets the alert condition, an alert is triggered.
        self.expression = expression  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListEscalation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.level is not None:
            result['Level'] = self.level
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeAlertLogListResponseBodyAlertLogListExtendedInfo(TeaModel):
    def __init__(self, name=None, value=None):
        # The name of the extended field.
        self.name = name  # type: str
        # The value of the extended field.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListExtendedInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList(TeaModel):
    def __init__(self, code=None, detail=None, request_id=None, success=None, notify_target_list=None):
        # The HTTP status code.
        # 
        # *   If the value of the `Channel` parameter is `WEBHOOK`, the status code is 200 or 500.
        # *   If the value of the `Channel` parameter is `MAIL`, `SMS`, `SLS`, `ONCALL`, `FC`, or `MNS`, this parameter is empty or not returned.
        self.code = code  # type: str
        # The details of the returned results.
        self.detail = detail  # type: str
        # The request ID returned when CloudMonitor calls another cloud service.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The queried resources.
        self.notify_target_list = notify_target_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.detail is not None:
            result['Detail'] = self.detail
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.notify_target_list is not None:
            result['notifyTargetList'] = self.notify_target_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Detail') is not None:
            self.detail = m.get('Detail')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('notifyTargetList') is not None:
            self.notify_target_list = m.get('notifyTargetList')
        return self


class DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList(TeaModel):
    def __init__(self, channel=None, result_list=None):
        # The method that is used to send alert notifications. Valid values:
        # 
        # *   MAIL: email
        # *   SMS: text message
        # *   WEBHOOK: alert callback
        # *   SLS: Simple Log Service
        # *   ONCALL: phone call
        # *   FC: Function Compute
        # *   MNS: Message Service queue
        self.channel = channel  # type: str
        # The sending results of alert notifications.
        self.result_list = result_list  # type: list[DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList]

    def validate(self):
        if self.result_list:
            for k in self.result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channel is not None:
            result['Channel'] = self.channel
        result['ResultList'] = []
        if self.result_list is not None:
            for k in self.result_list:
                result['ResultList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channel') is not None:
            self.channel = m.get('Channel')
        self.result_list = []
        if m.get('ResultList') is not None:
            for k in m.get('ResultList'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultListResultList()
                self.result_list.append(temp_model.from_map(k))
        return self


class DescribeAlertLogListResponseBodyAlertLogListSendDetail(TeaModel):
    def __init__(self, channel_result_list=None, result_code=None):
        # The list of sending results that are categorized by notification method.
        self.channel_result_list = channel_result_list  # type: list[DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList]
        # Indicates whether the alert notifications are sent.
        # 
        # *   If the alert notifications are sent, the value "success" is returned.
        # *   If the configuration is invalid, no alert notification is sent and an error code is returned.
        self.result_code = result_code  # type: str

    def validate(self):
        if self.channel_result_list:
            for k in self.channel_result_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListSendDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ChannelResultList'] = []
        if self.channel_result_list is not None:
            for k in self.channel_result_list:
                result['ChannelResultList'].append(k.to_map() if k else None)
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.channel_result_list = []
        if m.get('ChannelResultList') is not None:
            for k in m.get('ChannelResultList'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListSendDetailChannelResultList()
                self.channel_result_list.append(temp_model.from_map(k))
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        return self


class DescribeAlertLogListResponseBodyAlertLogListSendResultList(TeaModel):
    def __init__(self, key=None, value=None):
        # The category of the alert notification method. Valid values:
        # 
        # *   Mail: email
        # *   ALIIM: TradeManager
        # *   SMS: text message
        # *   CALL: phone call
        # *   DING: DingTalk chatbot
        # *   Merged: alert merging
        self.key = key  # type: str
        # The alert notification methods.
        self.value = value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListSendResultList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeAlertLogListResponseBodyAlertLogListWebhookList(TeaModel):
    def __init__(self, code=None, message=None, url=None):
        # The status code of the alert callback.
        self.code = code  # type: str
        # The message returned for the alert callback.
        self.message = message  # type: str
        # The callback URL.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogListWebhookList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['code'] = self.code
        if self.message is not None:
            result['message'] = self.message
        if self.url is not None:
            result['url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('code') is not None:
            self.code = m.get('code')
        if m.get('message') is not None:
            self.message = m.get('message')
        if m.get('url') is not None:
            self.url = m.get('url')
        return self


class DescribeAlertLogListResponseBodyAlertLogList(TeaModel):
    def __init__(self, alert_time=None, black_list_detail=None, black_list_name=None, black_list_uuid=None,
                 contact_aliiwwlist=None, contact_ding_list=None, contact_groups=None, contact_mail_list=None,
                 contact_on_call_list=None, contact_smslist=None, dimensions=None, dingding_webhook_list=None, escalation=None,
                 event_name=None, extended_info=None, group_id=None, group_name=None, instance_id=None, instance_name=None,
                 level=None, level_change=None, log_id=None, message=None, metric_name=None, namespace=None, product=None,
                 rule_id=None, rule_name=None, send_detail=None, send_result_list=None, send_status=None, webhook_list=None):
        # The timestamp that was generated when the alert was triggered. Unit: milliseconds.
        self.alert_time = alert_time  # type: str
        # The details of the blacklist policy.
        self.black_list_detail = black_list_detail  # type: str
        # The name of the blacklist policy.
        self.black_list_name = black_list_name  # type: str
        # The ID of the blacklist policy.
        self.black_list_uuid = black_list_uuid  # type: str
        # The TradeManager IDs of the alert contacts.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.contact_aliiwwlist = contact_aliiwwlist  # type: list[str]
        # The DingTalk chatbots of the alert contacts.
        self.contact_ding_list = contact_ding_list  # type: list[str]
        # The alert contact groups.
        self.contact_groups = contact_groups  # type: list[str]
        # The email addresses of the alert contacts.
        self.contact_mail_list = contact_mail_list  # type: list[str]
        # The phone numbers of the alert contacts that receive alert phone calls.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.contact_on_call_list = contact_on_call_list  # type: list[str]
        # The phone numbers of the alert contacts that receive alert text messages.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.contact_smslist = contact_smslist  # type: list[str]
        # The dimensions of the resource that triggered alerts.
        self.dimensions = dimensions  # type: list[DescribeAlertLogListResponseBodyAlertLogListDimensions]
        # The webhook URLs of the alert contacts.
        self.dingding_webhook_list = dingding_webhook_list  # type: list[str]
        # The alert rule based on which the alert is triggered.
        self.escalation = escalation  # type: DescribeAlertLogListResponseBodyAlertLogListEscalation
        # The event name.
        self.event_name = event_name  # type: str
        # The extended fields.
        self.extended_info = extended_info  # type: list[DescribeAlertLogListResponseBodyAlertLogListExtendedInfo]
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the application group.
        self.group_name = group_name  # type: str
        # The resource ID.
        self.instance_id = instance_id  # type: str
        # The resource name.
        self.instance_name = instance_name  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   P4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: str
        # Indicates whether the alert level was changed. Valid values:
        # 
        # *   `P4->OK`: The alert level was changed from P4 to OK.
        # *   `P4->P4`: The alert level was still P4.
        self.level_change = level_change  # type: str
        # The log ID.
        self.log_id = log_id  # type: str
        # The alert information in a JSON string.
        self.message = message  # type: str
        # The metric name.
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        self.namespace = namespace  # type: str
        # The identifier of the cloud service. Valid values:
        # 
        # *   If the cloud service is provided by Alibaba Cloud, the abbreviation of the service name is returned. Example: ECS.
        # *   If the cloud service is not provided by Alibaba Cloud, a value in the `acs_Service keyword` format is returned. Example: acs_networkmonitor.
        self.product = product  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The details of the alert notification method.
        self.send_detail = send_detail  # type: DescribeAlertLogListResponseBodyAlertLogListSendDetail
        # The sending results of alert notifications.
        self.send_result_list = send_result_list  # type: list[DescribeAlertLogListResponseBodyAlertLogListSendResultList]
        # The status of the alert. Valid values:
        # 
        # *   0: The alert is triggered or cleared.
        # *   1: The alert is ineffective.
        # *   2: The alert is muted.
        # *   3: The host is restarting.
        # *   4: No alert notification is sent.
        # 
        # If the value of the SendStatus parameter is 0, the value P4 of the Level parameter indicates a triggered alert and the value OK indicates a cleared alert.
        self.send_status = send_status  # type: str
        # The callback URLs.
        self.webhook_list = webhook_list  # type: list[DescribeAlertLogListResponseBodyAlertLogListWebhookList]

    def validate(self):
        if self.dimensions:
            for k in self.dimensions:
                if k:
                    k.validate()
        if self.escalation:
            self.escalation.validate()
        if self.extended_info:
            for k in self.extended_info:
                if k:
                    k.validate()
        if self.send_detail:
            self.send_detail.validate()
        if self.send_result_list:
            for k in self.send_result_list:
                if k:
                    k.validate()
        if self.webhook_list:
            for k in self.webhook_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBodyAlertLogList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_time is not None:
            result['AlertTime'] = self.alert_time
        if self.black_list_detail is not None:
            result['BlackListDetail'] = self.black_list_detail
        if self.black_list_name is not None:
            result['BlackListName'] = self.black_list_name
        if self.black_list_uuid is not None:
            result['BlackListUUID'] = self.black_list_uuid
        if self.contact_aliiwwlist is not None:
            result['ContactALIIWWList'] = self.contact_aliiwwlist
        if self.contact_ding_list is not None:
            result['ContactDingList'] = self.contact_ding_list
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.contact_mail_list is not None:
            result['ContactMailList'] = self.contact_mail_list
        if self.contact_on_call_list is not None:
            result['ContactOnCallList'] = self.contact_on_call_list
        if self.contact_smslist is not None:
            result['ContactSMSList'] = self.contact_smslist
        result['Dimensions'] = []
        if self.dimensions is not None:
            for k in self.dimensions:
                result['Dimensions'].append(k.to_map() if k else None)
        if self.dingding_webhook_list is not None:
            result['DingdingWebhookList'] = self.dingding_webhook_list
        if self.escalation is not None:
            result['Escalation'] = self.escalation.to_map()
        if self.event_name is not None:
            result['EventName'] = self.event_name
        result['ExtendedInfo'] = []
        if self.extended_info is not None:
            for k in self.extended_info:
                result['ExtendedInfo'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.level is not None:
            result['Level'] = self.level
        if self.level_change is not None:
            result['LevelChange'] = self.level_change
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.message is not None:
            result['Message'] = self.message
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.product is not None:
            result['Product'] = self.product
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.send_detail is not None:
            result['SendDetail'] = self.send_detail.to_map()
        result['SendResultList'] = []
        if self.send_result_list is not None:
            for k in self.send_result_list:
                result['SendResultList'].append(k.to_map() if k else None)
        if self.send_status is not None:
            result['SendStatus'] = self.send_status
        result['WebhookList'] = []
        if self.webhook_list is not None:
            for k in self.webhook_list:
                result['WebhookList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertTime') is not None:
            self.alert_time = m.get('AlertTime')
        if m.get('BlackListDetail') is not None:
            self.black_list_detail = m.get('BlackListDetail')
        if m.get('BlackListName') is not None:
            self.black_list_name = m.get('BlackListName')
        if m.get('BlackListUUID') is not None:
            self.black_list_uuid = m.get('BlackListUUID')
        if m.get('ContactALIIWWList') is not None:
            self.contact_aliiwwlist = m.get('ContactALIIWWList')
        if m.get('ContactDingList') is not None:
            self.contact_ding_list = m.get('ContactDingList')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('ContactMailList') is not None:
            self.contact_mail_list = m.get('ContactMailList')
        if m.get('ContactOnCallList') is not None:
            self.contact_on_call_list = m.get('ContactOnCallList')
        if m.get('ContactSMSList') is not None:
            self.contact_smslist = m.get('ContactSMSList')
        self.dimensions = []
        if m.get('Dimensions') is not None:
            for k in m.get('Dimensions'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListDimensions()
                self.dimensions.append(temp_model.from_map(k))
        if m.get('DingdingWebhookList') is not None:
            self.dingding_webhook_list = m.get('DingdingWebhookList')
        if m.get('Escalation') is not None:
            temp_model = DescribeAlertLogListResponseBodyAlertLogListEscalation()
            self.escalation = temp_model.from_map(m['Escalation'])
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        self.extended_info = []
        if m.get('ExtendedInfo') is not None:
            for k in m.get('ExtendedInfo'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListExtendedInfo()
                self.extended_info.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('LevelChange') is not None:
            self.level_change = m.get('LevelChange')
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SendDetail') is not None:
            temp_model = DescribeAlertLogListResponseBodyAlertLogListSendDetail()
            self.send_detail = temp_model.from_map(m['SendDetail'])
        self.send_result_list = []
        if m.get('SendResultList') is not None:
            for k in m.get('SendResultList'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListSendResultList()
                self.send_result_list.append(temp_model.from_map(k))
        if m.get('SendStatus') is not None:
            self.send_status = m.get('SendStatus')
        self.webhook_list = []
        if m.get('WebhookList') is not None:
            for k in m.get('WebhookList'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogListWebhookList()
                self.webhook_list.append(temp_model.from_map(k))
        return self


class DescribeAlertLogListResponseBody(TeaModel):
    def __init__(self, alert_log_list=None, code=None, message=None, page_number=None, page_size=None,
                 request_id=None, success=None):
        # The queried alert logs.
        self.alert_log_list = alert_log_list  # type: list[DescribeAlertLogListResponseBodyAlertLogList]
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The page number.
        self.page_number = page_number  # type: int
        # The number of entries per page.
        self.page_size = page_size  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.alert_log_list:
            for k in self.alert_log_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertLogListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertLogList'] = []
        if self.alert_log_list is not None:
            for k in self.alert_log_list:
                result['AlertLogList'].append(k.to_map() if k else None)
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_log_list = []
        if m.get('AlertLogList') is not None:
            for k in m.get('AlertLogList'):
                temp_model = DescribeAlertLogListResponseBodyAlertLogList()
                self.alert_log_list.append(temp_model.from_map(k))
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeAlertLogListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlertLogListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlertLogListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlertLogListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlertingMetricRuleResourcesRequest(TeaModel):
    def __init__(self, alert_before_time=None, dimensions=None, group_id=None, namespace=None, page=None,
                 page_size=None, region_id=None, rule_id=None):
        self.alert_before_time = alert_before_time  # type: str
        # The dimensions that specify the resources whose monitoring data you want to query.
        self.dimensions = dimensions  # type: str
        # The ID of the application group. For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The page number.
        # 
        # Default value: 1.
        self.page = page  # type: int
        # The number of entries per page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The ID of the alert rule. For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_before_time is not None:
            result['AlertBeforeTime'] = self.alert_before_time
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertBeforeTime') is not None:
            self.alert_before_time = m.get('AlertBeforeTime')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList(TeaModel):
    def __init__(self, comparison_operator=None, metric_name=None, period=None, statistics=None, threshold=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The metric name.
        self.metric_name = metric_name  # type: str
        # The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
        self.period = period  # type: str
        # The statistical method of the alert level. Valid values:
        # 
        # *   Maximum
        # *   Minimum
        # *   Average
        self.statistics = statistics  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList(TeaModel):
    def __init__(self, expression_list=None):
        self.expression_list = expression_list  # type: list[DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList]

    def validate(self):
        if self.expression_list:
            for k in self.expression_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExpressionList'] = []
        if self.expression_list is not None:
            for k in self.expression_list:
                result['ExpressionList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.expression_list = []
        if m.get('ExpressionList') is not None:
            for k in m.get('ExpressionList'):
                temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionListExpressionList()
                self.expression_list.append(temp_model.from_map(k))
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource(TeaModel):
    def __init__(self, comparison_operator=None, expression=None, expression_list=None, expression_list_join=None,
                 expression_raw=None, level=None, pre_condition=None, tag=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The description of the alert rule.
        # 
        # > The content of the alert rule. If the metric value meets the alert condition, an alert is triggered.
        self.expression = expression  # type: str
        # The description of the multi-metric alert rule.
        self.expression_list = expression_list  # type: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList
        # The relationship between multiple metrics. Valid values:
        # 
        # *   &&: If all metrics meet the alert conditions, CloudMonitor sends alert notifications.
        # *   ||: If one of the metrics meets the alert conditions, CloudMonitor sends alert notifications.
        self.expression_list_join = expression_list_join  # type: str
        # The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
        # 
        # *   Set an alert blacklist for specific resources. For example, if you specify `$instanceId != \"i-io8kfvcpp7x5****\" ``&&`` $Average > 50`, no alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
        # *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \"i-io8kfvcpp7x5****\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
        # *   Limit the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the number of instances whose `average metric value` exceeds 20 exceeds three.
        self.expression_raw = expression_raw  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: int
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   `>=`
        # *   `=`
        # *   `<=`
        # *   `>`
        # *   `<`
        # *   `!=`
        self.pre_condition = pre_condition  # type: str
        # The instance tag.
        self.tag = tag  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.times = times  # type: int

    def validate(self):
        if self.expression_list:
            self.expression_list.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.expression_list is not None:
            result['ExpressionList'] = self.expression_list.to_map()
        if self.expression_list_join is not None:
            result['ExpressionListJoin'] = self.expression_list_join
        if self.expression_raw is not None:
            result['ExpressionRaw'] = self.expression_raw
        if self.level is not None:
            result['Level'] = self.level
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('ExpressionList') is not None:
            temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResourceExpressionList()
            self.expression_list = temp_model.from_map(m['ExpressionList'])
        if m.get('ExpressionListJoin') is not None:
            self.expression_list_join = m.get('ExpressionListJoin')
        if m.get('ExpressionRaw') is not None:
            self.expression_raw = m.get('ExpressionRaw')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalationResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource(TeaModel):
    def __init__(self, dimensions=None, enable=None, escalation=None, group_id=None, last_alert_time=None,
                 last_modify_time=None, level=None, metric_name=None, metric_values=None, namespace=None, product_category=None,
                 resource=None, retry_times=None, rule_id=None, rule_name=None, start_time=None, statistics=None,
                 threshold=None):
        # The dimensions that specify the resources whose monitoring data you want to query.
        self.dimensions = dimensions  # type: str
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   true: The alert rule is enabled.
        # *   false: The alert rule is disabled.
        self.enable = enable  # type: str
        # The alert rule based on which the alert is triggered.
        self.escalation = escalation  # type: DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation
        # The ID of the application group.
        # 
        # > If the alert rule is associated with an application group, the ID of the application group is returned in this parameter.
        self.group_id = group_id  # type: str
        # The timestamp when the last alert was triggered for the resource based on the alert rule.
        # 
        # Unit: milliseconds.
        self.last_alert_time = last_alert_time  # type: str
        # The timestamp when the alert rule was last modified.
        # 
        # Unit: milliseconds.
        self.last_modify_time = last_modify_time  # type: str
        # The severity level and notification methods of the alert. Valid values:
        # 
        # *   4: Alert notifications are sent by using emails and DingTalk chatbots.
        # *   OK: No alert is generated.
        self.level = level  # type: int
        # The metric name.
        self.metric_name = metric_name  # type: str
        # The metric value that triggered the alert based on the alert rule. The value is a JSON string.
        self.metric_values = metric_values  # type: str
        # The namespace of the cloud service.
        self.namespace = namespace  # type: str
        # The type of the cloud service.
        self.product_category = product_category  # type: str
        # The resources that are monitored.
        self.resource = resource  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.retry_times = retry_times  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The timestamp when the resource was associated with the alert rule.
        # 
        # Unit: milliseconds.
        self.start_time = start_time  # type: str
        # The method used to calculate metric values that trigger alerts.
        self.statistics = statistics  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str

    def validate(self):
        if self.escalation:
            self.escalation.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.enable is not None:
            result['Enable'] = self.enable
        if self.escalation is not None:
            result['Escalation'] = self.escalation.to_map()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.last_alert_time is not None:
            result['LastAlertTime'] = self.last_alert_time
        if self.last_modify_time is not None:
            result['LastModifyTime'] = self.last_modify_time
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.metric_values is not None:
            result['MetricValues'] = self.metric_values
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.product_category is not None:
            result['ProductCategory'] = self.product_category
        if self.resource is not None:
            result['Resource'] = self.resource
        if self.retry_times is not None:
            result['RetryTimes'] = self.retry_times
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('Enable') is not None:
            self.enable = m.get('Enable')
        if m.get('Escalation') is not None:
            temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResourcesResourceEscalation()
            self.escalation = temp_model.from_map(m['Escalation'])
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LastAlertTime') is not None:
            self.last_alert_time = m.get('LastAlertTime')
        if m.get('LastModifyTime') is not None:
            self.last_modify_time = m.get('LastModifyTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('MetricValues') is not None:
            self.metric_values = m.get('MetricValues')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ProductCategory') is not None:
            self.product_category = m.get('ProductCategory')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        if m.get('RetryTimes') is not None:
            self.retry_times = m.get('RetryTimes')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeAlertingMetricRuleResourcesResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeAlertingMetricRuleResourcesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resources=None, success=None, total=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The resources to which the alert rule is applied.
        self.resources = resources  # type: DescribeAlertingMetricRuleResourcesResponseBodyResources
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total = total  # type: int

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeAlertingMetricRuleResourcesResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeAlertingMetricRuleResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlertingMetricRuleResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlertingMetricRuleResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlertingMetricRuleResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContactGroupListRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None):
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactGroupListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts(TeaModel):
    def __init__(self, contact=None):
        self.contact = contact  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact is not None:
            result['Contact'] = self.contact
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Contact') is not None:
            self.contact = m.get('Contact')
        return self


class DescribeContactGroupListResponseBodyContactGroupListContactGroup(TeaModel):
    def __init__(self, contacts=None, create_time=None, describe=None, enable_subscribed=None,
                 enabled_weekly_report=None, name=None, update_time=None):
        # The alert contacts in the alert group.
        self.contacts = contacts  # type: DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts
        # The time when the alert group was created. This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.create_time = create_time  # type: long
        # The description of the alert group.
        self.describe = describe  # type: str
        # Indicates whether the alert group subscribes to weekly reports. Valid values:
        # 
        # *   true: The alert group subscribes to weekly reports.
        # *   false: The alert group does not subscribe to weekly reports.
        self.enable_subscribed = enable_subscribed  # type: bool
        # Indicates whether the alert group can subscribe to weekly reports. Valid values:
        # 
        # *   true: The alert group can subscribe to weekly reports.
        # *   false: The alert group cannot subscribe to weekly reports.
        # 
        # >  The weekly report subscription feature is only available for Alibaba Cloud accounts with more than five Elastic Compute Service (ECS) instances.
        self.enabled_weekly_report = enabled_weekly_report  # type: bool
        # The name of the alert group.
        self.name = name  # type: str
        # The time when the alert group was modified. This value is a UNIX timestamp that represents the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        self.update_time = update_time  # type: long

    def validate(self):
        if self.contacts:
            self.contacts.validate()

    def to_map(self):
        _map = super(DescribeContactGroupListResponseBodyContactGroupListContactGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contacts is not None:
            result['Contacts'] = self.contacts.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.enable_subscribed is not None:
            result['EnableSubscribed'] = self.enable_subscribed
        if self.enabled_weekly_report is not None:
            result['EnabledWeeklyReport'] = self.enabled_weekly_report
        if self.name is not None:
            result['Name'] = self.name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Contacts') is not None:
            temp_model = DescribeContactGroupListResponseBodyContactGroupListContactGroupContacts()
            self.contacts = temp_model.from_map(m['Contacts'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('EnableSubscribed') is not None:
            self.enable_subscribed = m.get('EnableSubscribed')
        if m.get('EnabledWeeklyReport') is not None:
            self.enabled_weekly_report = m.get('EnabledWeeklyReport')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeContactGroupListResponseBodyContactGroupList(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[DescribeContactGroupListResponseBodyContactGroupListContactGroup]

    def validate(self):
        if self.contact_group:
            for k in self.contact_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeContactGroupListResponseBodyContactGroupList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactGroup'] = []
        if self.contact_group is not None:
            for k in self.contact_group:
                result['ContactGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_group = []
        if m.get('ContactGroup') is not None:
            for k in m.get('ContactGroup'):
                temp_model = DescribeContactGroupListResponseBodyContactGroupListContactGroup()
                self.contact_group.append(temp_model.from_map(k))
        return self


class DescribeContactGroupListResponseBodyContactGroups(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactGroupListResponseBodyContactGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        return self


class DescribeContactGroupListResponseBody(TeaModel):
    def __init__(self, code=None, contact_group_list=None, contact_groups=None, message=None, request_id=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The information about alert groups that were queried.
        self.contact_group_list = contact_group_list  # type: DescribeContactGroupListResponseBodyContactGroupList
        # The names of alert groups.
        self.contact_groups = contact_groups  # type: DescribeContactGroupListResponseBodyContactGroups
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The total number of the returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.contact_group_list:
            self.contact_group_list.validate()
        if self.contact_groups:
            self.contact_groups.validate()

    def to_map(self):
        _map = super(DescribeContactGroupListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.contact_group_list is not None:
            result['ContactGroupList'] = self.contact_group_list.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ContactGroupList') is not None:
            temp_model = DescribeContactGroupListResponseBodyContactGroupList()
            self.contact_group_list = temp_model.from_map(m['ContactGroupList'])
        if m.get('ContactGroups') is not None:
            temp_model = DescribeContactGroupListResponseBodyContactGroups()
            self.contact_groups = temp_model.from_map(m['ContactGroups'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeContactGroupListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContactGroupListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContactGroupListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContactGroupListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContactListRequest(TeaModel):
    def __init__(self, chanel_type=None, chanel_value=None, contact_name=None, page_number=None, page_size=None,
                 region_id=None):
        # The alert notification method. Valid values:
        # 
        # *   Mail: emails
        # *   DingWebHook: DingTalk chatbots
        self.chanel_type = chanel_type  # type: str
        # The value specified for the alert notification method.
        # 
        # >  This parameter is required only if you set the `ChanelType` parameter to `Mail`.
        self.chanel_value = chanel_value  # type: str
        # The name of the alert contact.
        self.contact_name = contact_name  # type: str
        # The number of the page to return.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Default value: 100.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.chanel_type is not None:
            result['ChanelType'] = self.chanel_type
        if self.chanel_value is not None:
            result['ChanelValue'] = self.chanel_value
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ChanelType') is not None:
            self.chanel_type = m.get('ChanelType')
        if m.get('ChanelValue') is not None:
            self.chanel_value = m.get('ChanelValue')
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeContactListResponseBodyContactsContactChannels(TeaModel):
    def __init__(self, ali_im=None, ding_web_hook=None, mail=None, sms=None):
        # The TradeManager ID of the alert contact.
        self.ali_im = ali_im  # type: str
        # The webhook URL of the DingTalk chatbot.
        self.ding_web_hook = ding_web_hook  # type: str
        # The email address of the alert contact.
        self.mail = mail  # type: str
        # The phone number of the alert contact.
        self.sms = sms  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListResponseBodyContactsContactChannels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_im is not None:
            result['AliIM'] = self.ali_im
        if self.ding_web_hook is not None:
            result['DingWebHook'] = self.ding_web_hook
        if self.mail is not None:
            result['Mail'] = self.mail
        if self.sms is not None:
            result['SMS'] = self.sms
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliIM') is not None:
            self.ali_im = m.get('AliIM')
        if m.get('DingWebHook') is not None:
            self.ding_web_hook = m.get('DingWebHook')
        if m.get('Mail') is not None:
            self.mail = m.get('Mail')
        if m.get('SMS') is not None:
            self.sms = m.get('SMS')
        return self


class DescribeContactListResponseBodyContactsContactChannelsState(TeaModel):
    def __init__(self, ali_im=None, ding_web_hook=None, mail=None, sms=None):
        # The status of the TradeManager ID.
        # 
        # Valid value: OK. The value OK indicates that the TradeManager ID is valid and can receive alert notifications.
        # 
        # >  This parameter can be returned only on the China site (aliyun.com).
        self.ali_im = ali_im  # type: str
        # The status of the DingTalk chatbot.
        # 
        # Valid value: OK. The value OK indicates that the DingTalk chatbot is normal and alert notifications can be received in a DingTalk group.
        self.ding_web_hook = ding_web_hook  # type: str
        # The status of the email address. Valid values:
        # 
        # *   PENDING: The email address is not activated. Alert notifications can be sent to the email address only after the email address is activated.
        # *   OK: The email address is activated and can receive alert notifications.
        self.mail = mail  # type: str
        # The status of the phone number. Valid values:
        # 
        # *   PENDING: The phone number is not activated. Alert notifications can be sent to the phone number by using text messages only after the phone number is activated.
        # *   OK: The phone number is activated and can receive alert notifications.
        # 
        # >  This parameter can be returned only on the China site (aliyun.com).
        self.sms = sms  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListResponseBodyContactsContactChannelsState, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_im is not None:
            result['AliIM'] = self.ali_im
        if self.ding_web_hook is not None:
            result['DingWebHook'] = self.ding_web_hook
        if self.mail is not None:
            result['Mail'] = self.mail
        if self.sms is not None:
            result['SMS'] = self.sms
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliIM') is not None:
            self.ali_im = m.get('AliIM')
        if m.get('DingWebHook') is not None:
            self.ding_web_hook = m.get('DingWebHook')
        if m.get('Mail') is not None:
            self.mail = m.get('Mail')
        if m.get('SMS') is not None:
            self.sms = m.get('SMS')
        return self


class DescribeContactListResponseBodyContactsContactContactGroups(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListResponseBodyContactsContactContactGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group is not None:
            result['ContactGroup'] = self.contact_group
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroup') is not None:
            self.contact_group = m.get('ContactGroup')
        return self


class DescribeContactListResponseBodyContactsContact(TeaModel):
    def __init__(self, channels=None, channels_state=None, contact_groups=None, create_time=None, desc=None,
                 lang=None, name=None, update_time=None):
        # The alert notification method.
        self.channels = channels  # type: DescribeContactListResponseBodyContactsContactChannels
        # The status of the alert notification method. Valid values: PENDING and OK.
        # 
        # The email address must be activated after it is added as the value specified for the alert notification method. The value PENDING indicates that the email address is not activated. The value OK indicates that the email address is activated.
        self.channels_state = channels_state  # type: DescribeContactListResponseBodyContactsContactChannelsState
        # The alert contact groups.
        self.contact_groups = contact_groups  # type: DescribeContactListResponseBodyContactsContactContactGroups
        # The timestamp when the alert contact was created.
        # 
        # Unit: milliseconds.
        self.create_time = create_time  # type: long
        # The description of the alert contact.
        self.desc = desc  # type: str
        # The language in which the alert information is displayed. Valid values:
        # 
        # *   zh-cn: simplified Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The name of the alert contact.
        self.name = name  # type: str
        # The timestamp when the alert contact was updated.
        # 
        # Unit: milliseconds.
        self.update_time = update_time  # type: long

    def validate(self):
        if self.channels:
            self.channels.validate()
        if self.channels_state:
            self.channels_state.validate()
        if self.contact_groups:
            self.contact_groups.validate()

    def to_map(self):
        _map = super(DescribeContactListResponseBodyContactsContact, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels.to_map()
        if self.channels_state is not None:
            result['ChannelsState'] = self.channels_state.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channels') is not None:
            temp_model = DescribeContactListResponseBodyContactsContactChannels()
            self.channels = temp_model.from_map(m['Channels'])
        if m.get('ChannelsState') is not None:
            temp_model = DescribeContactListResponseBodyContactsContactChannelsState()
            self.channels_state = temp_model.from_map(m['ChannelsState'])
        if m.get('ContactGroups') is not None:
            temp_model = DescribeContactListResponseBodyContactsContactContactGroups()
            self.contact_groups = temp_model.from_map(m['ContactGroups'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeContactListResponseBodyContacts(TeaModel):
    def __init__(self, contact=None):
        self.contact = contact  # type: list[DescribeContactListResponseBodyContactsContact]

    def validate(self):
        if self.contact:
            for k in self.contact:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeContactListResponseBodyContacts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contact'] = []
        if self.contact is not None:
            for k in self.contact:
                result['Contact'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact = []
        if m.get('Contact') is not None:
            for k in m.get('Contact'):
                temp_model = DescribeContactListResponseBodyContactsContact()
                self.contact.append(temp_model.from_map(k))
        return self


class DescribeContactListResponseBody(TeaModel):
    def __init__(self, code=None, contacts=None, message=None, request_id=None, success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The alert contacts.
        self.contacts = contacts  # type: DescribeContactListResponseBodyContacts
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.contacts:
            self.contacts.validate()

    def to_map(self):
        _map = super(DescribeContactListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.contacts is not None:
            result['Contacts'] = self.contacts.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Contacts') is not None:
            temp_model = DescribeContactListResponseBodyContacts()
            self.contacts = temp_model.from_map(m['Contacts'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeContactListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContactListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContactListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContactListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeContactListByContactGroupRequest(TeaModel):
    def __init__(self, contact_group_name=None, region_id=None):
        # The name of the alert group.
        self.contact_group_name = contact_group_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListByContactGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeContactListByContactGroupResponseBodyContactsContactChannels(TeaModel):
    def __init__(self, ali_im=None, ding_web_hook=None, mail=None, sms=None):
        # The TradeManager ID of the alert contact.
        # 
        # >  This parameter can be returned only on the China site (aliyun.com).
        self.ali_im = ali_im  # type: str
        # The webhook URL of the DingTalk chatbot.
        self.ding_web_hook = ding_web_hook  # type: str
        # The email address of the alert contact.
        self.mail = mail  # type: str
        # The phone number of the alert contact.
        # 
        # >  This parameter can be returned only on the China site (aliyun.com).
        self.sms = sms  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeContactListByContactGroupResponseBodyContactsContactChannels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_im is not None:
            result['AliIM'] = self.ali_im
        if self.ding_web_hook is not None:
            result['DingWebHook'] = self.ding_web_hook
        if self.mail is not None:
            result['Mail'] = self.mail
        if self.sms is not None:
            result['SMS'] = self.sms
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliIM') is not None:
            self.ali_im = m.get('AliIM')
        if m.get('DingWebHook') is not None:
            self.ding_web_hook = m.get('DingWebHook')
        if m.get('Mail') is not None:
            self.mail = m.get('Mail')
        if m.get('SMS') is not None:
            self.sms = m.get('SMS')
        return self


class DescribeContactListByContactGroupResponseBodyContactsContact(TeaModel):
    def __init__(self, channels=None, create_time=None, desc=None, name=None, update_time=None):
        # The alert notification targets.
        self.channels = channels  # type: DescribeContactListByContactGroupResponseBodyContactsContactChannels
        # The time when the alert contact was created.
        self.create_time = create_time  # type: long
        # The description of the alert contact.
        self.desc = desc  # type: str
        # The name of the alert contact.
        self.name = name  # type: str
        # The time when the alert contact was modified.
        self.update_time = update_time  # type: long

    def validate(self):
        if self.channels:
            self.channels.validate()

    def to_map(self):
        _map = super(DescribeContactListByContactGroupResponseBodyContactsContact, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.name is not None:
            result['Name'] = self.name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channels') is not None:
            temp_model = DescribeContactListByContactGroupResponseBodyContactsContactChannels()
            self.channels = temp_model.from_map(m['Channels'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeContactListByContactGroupResponseBodyContacts(TeaModel):
    def __init__(self, contact=None):
        self.contact = contact  # type: list[DescribeContactListByContactGroupResponseBodyContactsContact]

    def validate(self):
        if self.contact:
            for k in self.contact:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeContactListByContactGroupResponseBodyContacts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Contact'] = []
        if self.contact is not None:
            for k in self.contact:
                result['Contact'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact = []
        if m.get('Contact') is not None:
            for k in m.get('Contact'):
                temp_model = DescribeContactListByContactGroupResponseBodyContactsContact()
                self.contact.append(temp_model.from_map(k))
        return self


class DescribeContactListByContactGroupResponseBody(TeaModel):
    def __init__(self, code=None, contacts=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The alert group.
        self.contacts = contacts  # type: DescribeContactListByContactGroupResponseBodyContacts
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.contacts:
            self.contacts.validate()

    def to_map(self):
        _map = super(DescribeContactListByContactGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.contacts is not None:
            result['Contacts'] = self.contacts.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Contacts') is not None:
            temp_model = DescribeContactListByContactGroupResponseBodyContacts()
            self.contacts = temp_model.from_map(m['Contacts'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeContactListByContactGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeContactListByContactGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeContactListByContactGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeContactListByContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomEventAttributeRequest(TeaModel):
    def __init__(self, end_time=None, event_id=None, group_id=None, name=None, page_number=None, page_size=None,
                 region_id=None, search_keywords=None, start_time=None):
        # The end of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: str
        # The ID of the custom event.
        self.event_id = event_id  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the custom event.
        self.name = name  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
        # 
        # *   If you need to query the custom event whose content contains a and b, set the value to a and b.
        # *   If you need to query the custom event whose content contains a or b, set the value to a or b.
        self.search_keywords = search_keywords  # type: str
        # The beginning of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent(TeaModel):
    def __init__(self, content=None, group_id=None, id=None, name=None, time=None):
        # The content of the custom event.
        self.content = content  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The ID of the custom event.
        self.id = id  # type: str
        # The name of the custom event.
        self.name = name  # type: str
        # The time when the custom event occurred.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.time = time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.name is not None:
            result['Name'] = self.name
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeCustomEventAttributeResponseBodyCustomEvents(TeaModel):
    def __init__(self, custom_event=None):
        self.custom_event = custom_event  # type: list[DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent]

    def validate(self):
        if self.custom_event:
            for k in self.custom_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomEventAttributeResponseBodyCustomEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomEvent'] = []
        if self.custom_event is not None:
            for k in self.custom_event:
                result['CustomEvent'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.custom_event = []
        if m.get('CustomEvent') is not None:
            for k in m.get('CustomEvent'):
                temp_model = DescribeCustomEventAttributeResponseBodyCustomEventsCustomEvent()
                self.custom_event.append(temp_model.from_map(k))
        return self


class DescribeCustomEventAttributeResponseBody(TeaModel):
    def __init__(self, code=None, custom_events=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The details of the custom event.
        self.custom_events = custom_events  # type: DescribeCustomEventAttributeResponseBodyCustomEvents
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str

    def validate(self):
        if self.custom_events:
            self.custom_events.validate()

    def to_map(self):
        _map = super(DescribeCustomEventAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.custom_events is not None:
            result['CustomEvents'] = self.custom_events.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CustomEvents') is not None:
            temp_model = DescribeCustomEventAttributeResponseBodyCustomEvents()
            self.custom_events = temp_model.from_map(m['CustomEvents'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCustomEventAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomEventAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomEventAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomEventAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomEventCountRequest(TeaModel):
    def __init__(self, end_time=None, event_id=None, group_id=None, name=None, region_id=None, search_keywords=None,
                 start_time=None):
        # The end of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: str
        # The ID of the custom event.
        self.event_id = event_id  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the custom event.
        self.name = name  # type: str
        self.region_id = region_id  # type: str
        # The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
        # 
        # *   If you need to query the custom event whose content contains a and b, set the value to a and b.
        # *   If you need to query the custom event whose content contains a or b, set the value to a or b.
        self.search_keywords = search_keywords  # type: str
        # The beginning of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount(TeaModel):
    def __init__(self, name=None, num=None, time=None):
        # The name of the custom event.
        self.name = name  # type: str
        # The number of times that the custom event occurred in the specified time period.
        self.num = num  # type: int
        # The time when the custom event occurred.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.num is not None:
            result['Num'] = self.num
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeCustomEventCountResponseBodyCustomEventCounts(TeaModel):
    def __init__(self, custom_event_count=None):
        self.custom_event_count = custom_event_count  # type: list[DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount]

    def validate(self):
        if self.custom_event_count:
            for k in self.custom_event_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomEventCountResponseBodyCustomEventCounts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CustomEventCount'] = []
        if self.custom_event_count is not None:
            for k in self.custom_event_count:
                result['CustomEventCount'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.custom_event_count = []
        if m.get('CustomEventCount') is not None:
            for k in m.get('CustomEventCount'):
                temp_model = DescribeCustomEventCountResponseBodyCustomEventCountsCustomEventCount()
                self.custom_event_count.append(temp_model.from_map(k))
        return self


class DescribeCustomEventCountResponseBody(TeaModel):
    def __init__(self, code=None, custom_event_counts=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The details of the custom event.
        self.custom_event_counts = custom_event_counts  # type: DescribeCustomEventCountResponseBodyCustomEventCounts
        # The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        if self.custom_event_counts:
            self.custom_event_counts.validate()

    def to_map(self):
        _map = super(DescribeCustomEventCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.custom_event_counts is not None:
            result['CustomEventCounts'] = self.custom_event_counts.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CustomEventCounts') is not None:
            temp_model = DescribeCustomEventCountResponseBodyCustomEventCounts()
            self.custom_event_counts = temp_model.from_map(m['CustomEventCounts'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCustomEventCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomEventCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomEventCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomEventCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomEventHistogramRequest(TeaModel):
    def __init__(self, end_time=None, event_id=None, group_id=None, level=None, name=None, region_id=None,
                 search_keywords=None, start_time=None):
        # The end of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: str
        # The ID of the custom event.
        self.event_id = event_id  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The level of the custom event. Valid values:
        # 
        # *   CRITICAL
        # *   WARN
        # *   INFO
        self.level = level  # type: str
        # The name of the custom event.
        self.name = name  # type: str
        self.region_id = region_id  # type: str
        # The keywords that are contained in the content of the custom event to query. You can use a logical operator between keywords.
        # 
        # *   If you need to query the custom event whose content contains a and b, set the value to a and b.
        # *   If you need to query the custom event whose content contains a or b, set the value to a or b.
        self.search_keywords = search_keywords  # type: str
        # The beginning of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventHistogramRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram(TeaModel):
    def __init__(self, count=None, end_time=None, start_time=None):
        # The information about the number of times that the custom event occurred during an interval of a time period.
        self.count = count  # type: long
        # The end of an interval.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: long
        # The beginning of an interval.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeCustomEventHistogramResponseBodyEventHistograms(TeaModel):
    def __init__(self, event_histogram=None):
        self.event_histogram = event_histogram  # type: list[DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram]

    def validate(self):
        if self.event_histogram:
            for k in self.event_histogram:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomEventHistogramResponseBodyEventHistograms, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventHistogram'] = []
        if self.event_histogram is not None:
            for k in self.event_histogram:
                result['EventHistogram'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_histogram = []
        if m.get('EventHistogram') is not None:
            for k in m.get('EventHistogram'):
                temp_model = DescribeCustomEventHistogramResponseBodyEventHistogramsEventHistogram()
                self.event_histogram.append(temp_model.from_map(k))
        return self


class DescribeCustomEventHistogramResponseBody(TeaModel):
    def __init__(self, code=None, event_histograms=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The information about the number of times that the custom event occurred during each interval of a time period.
        self.event_histograms = event_histograms  # type: DescribeCustomEventHistogramResponseBodyEventHistograms
        # The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: str

    def validate(self):
        if self.event_histograms:
            self.event_histograms.validate()

    def to_map(self):
        _map = super(DescribeCustomEventHistogramResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.event_histograms is not None:
            result['EventHistograms'] = self.event_histograms.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EventHistograms') is not None:
            temp_model = DescribeCustomEventHistogramResponseBodyEventHistograms()
            self.event_histograms = temp_model.from_map(m['EventHistograms'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCustomEventHistogramResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomEventHistogramResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomEventHistogramResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomEventHistogramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomMetricListRequest(TeaModel):
    def __init__(self, dimension=None, group_id=None, md_5=None, metric_name=None, page_number=None, page_size=None,
                 region_id=None):
        # The dimensions that specify the resources for which you want to query custom metrics.
        self.dimension = dimension  # type: str
        # The ID of the application group.
        # 
        # For more information, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The MD5 value of the HTTP request body. The MD5 value is a 128-bit hash value used to verify the uniqueness of the reported custom metrics.
        self.md_5 = md_5  # type: str
        # The name of the custom metric.
        self.metric_name = metric_name  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries to return on each page.
        # 
        # Pages start from page 1. Default value: 10.
        self.page_size = page_size  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomMetricListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCustomMetricListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, result=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call is successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The reported custom metrics that are found in the query.
        self.result = result  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomMetricListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            self.result = m.get('Result')
        return self


class DescribeCustomMetricListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomMetricListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomMetricListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomMetricListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDynamicTagRuleListRequest(TeaModel):
    def __init__(self, dynamic_tag_rule_id=None, page_number=None, page_size=None, tag_key=None, tag_region_id=None,
                 tag_value=None):
        # The ID of the tag rule.
        self.dynamic_tag_rule_id = dynamic_tag_rule_id  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries to return on each page.
        # 
        # Minimum value: 1. Default value: 30.
        self.page_size = page_size  # type: str
        # The tag key.
        # 
        # For more information about how to obtain a tag key, see [DescribeTagKeyList](~~145558~~).
        self.tag_key = tag_key  # type: str
        # The ID of the region to which the tags belong.
        self.tag_region_id = tag_region_id  # type: str
        # The tag value.
        # 
        # For more information about how to obtain a tag value, see [DescribeTagKeyList](~~145557~~).
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_tag_rule_id is not None:
            result['DynamicTagRuleId'] = self.dynamic_tag_rule_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_region_id is not None:
            result['TagRegionId'] = self.tag_region_id
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicTagRuleId') is not None:
            self.dynamic_tag_rule_id = m.get('DynamicTagRuleId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagRegionId') is not None:
            self.tag_region_id = m.get('TagRegionId')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList(TeaModel):
    def __init__(self, contact_group_list=None):
        self.contact_group_list = contact_group_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_list is not None:
            result['ContactGroupList'] = self.contact_group_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupList') is not None:
            self.contact_group_list = m.get('ContactGroupList')
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress(TeaModel):
    def __init__(self, tag_key=None, tag_value=None, tag_value_match_function=None):
        # The tag key.
        self.tag_key = tag_key  # type: str
        # The tag value.
        # 
        # The `TagValue` and `TagValueMatchFunction` parameters must be used in pairs.
        self.tag_value = tag_value  # type: str
        # The method that is used to match tag values. Valid values:
        # 
        # *   all: includes all
        # *   startWith: starts with a prefix
        # *   endWith: ends with a suffix
        # *   contains: contains
        # *   notContains: does not contain
        # *   equals: equals
        self.tag_value_match_function = tag_value_match_function  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        if self.tag_value_match_function is not None:
            result['TagValueMatchFunction'] = self.tag_value_match_function
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        if m.get('TagValueMatchFunction') is not None:
            self.tag_value_match_function = m.get('TagValueMatchFunction')
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress(TeaModel):
    def __init__(self, match_express=None):
        self.match_express = match_express  # type: list[DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress]

    def validate(self):
        if self.match_express:
            for k in self.match_express:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchExpress'] = []
        if self.match_express is not None:
            for k in self.match_express:
                result['MatchExpress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.match_express = []
        if m.get('MatchExpress') is not None:
            for k in m.get('MatchExpress'):
                temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpressMatchExpress()
                self.match_express.append(temp_model.from_map(k))
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList(TeaModel):
    def __init__(self, template_id_list=None):
        self.template_id_list = template_id_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id_list is not None:
            result['TemplateIdList'] = self.template_id_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateIdList') is not None:
            self.template_id_list = m.get('TemplateIdList')
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup(TeaModel):
    def __init__(self, contact_group_list=None, dynamic_tag_rule_id=None, match_express=None,
                 match_express_filter_relation=None, region_id=None, status=None, tag_key=None, template_id_list=None):
        # The alert contact group.
        self.contact_group_list = contact_group_list  # type: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList
        # The ID of the tag rule.
        self.dynamic_tag_rule_id = dynamic_tag_rule_id  # type: str
        # The conditional expressions used to create an application group based on the tag.
        self.match_express = match_express  # type: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress
        # The logical operator that is used between conditional expressions. Valid values:
        # 
        # *   `and`
        # *   `or`
        # 
        # >  Only one logical operator can be used in a request.
        self.match_express_filter_relation = match_express_filter_relation  # type: str
        # The ID of the region to which the tags belong.
        self.region_id = region_id  # type: str
        # The status of adding instances that meet the tag rule to the application group. Valid values:
        # 
        # *   `RUNNING`
        # *   `FINISH`
        self.status = status  # type: str
        # The tag key.
        self.tag_key = tag_key  # type: str
        # The IDs of the alert templates.
        self.template_id_list = template_id_list  # type: DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList

    def validate(self):
        if self.contact_group_list:
            self.contact_group_list.validate()
        if self.match_express:
            self.match_express.validate()
        if self.template_id_list:
            self.template_id_list.validate()

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_list is not None:
            result['ContactGroupList'] = self.contact_group_list.to_map()
        if self.dynamic_tag_rule_id is not None:
            result['DynamicTagRuleId'] = self.dynamic_tag_rule_id
        if self.match_express is not None:
            result['MatchExpress'] = self.match_express.to_map()
        if self.match_express_filter_relation is not None:
            result['MatchExpressFilterRelation'] = self.match_express_filter_relation
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.template_id_list is not None:
            result['TemplateIdList'] = self.template_id_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupList') is not None:
            temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupContactGroupList()
            self.contact_group_list = temp_model.from_map(m['ContactGroupList'])
        if m.get('DynamicTagRuleId') is not None:
            self.dynamic_tag_rule_id = m.get('DynamicTagRuleId')
        if m.get('MatchExpress') is not None:
            temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupMatchExpress()
            self.match_express = temp_model.from_map(m['MatchExpress'])
        if m.get('MatchExpressFilterRelation') is not None:
            self.match_express_filter_relation = m.get('MatchExpressFilterRelation')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TemplateIdList') is not None:
            temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroupTemplateIdList()
            self.template_id_list = temp_model.from_map(m['TemplateIdList'])
        return self


class DescribeDynamicTagRuleListResponseBodyTagGroupList(TeaModel):
    def __init__(self, tag_group=None):
        self.tag_group = tag_group  # type: list[DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup]

    def validate(self):
        if self.tag_group:
            for k in self.tag_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBodyTagGroupList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['TagGroup'] = []
        if self.tag_group is not None:
            for k in self.tag_group:
                result['TagGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag_group = []
        if m.get('TagGroup') is not None:
            for k in m.get('TagGroup'):
                temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupListTagGroup()
                self.tag_group.append(temp_model.from_map(k))
        return self


class DescribeDynamicTagRuleListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, success=None,
                 tag_group_list=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: str
        # The number of entries returned per page.
        self.page_size = page_size  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The tag rules of application groups.
        self.tag_group_list = tag_group_list  # type: DescribeDynamicTagRuleListResponseBodyTagGroupList
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.tag_group_list:
            self.tag_group_list.validate()

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tag_group_list is not None:
            result['TagGroupList'] = self.tag_group_list.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TagGroupList') is not None:
            temp_model = DescribeDynamicTagRuleListResponseBodyTagGroupList()
            self.tag_group_list = temp_model.from_map(m['TagGroupList'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeDynamicTagRuleListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDynamicTagRuleListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDynamicTagRuleListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDynamicTagRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventRuleAttributeRequest(TeaModel):
    def __init__(self, region_id=None, rule_name=None, silence_time=None):
        self.region_id = region_id  # type: str
        # The name of the event-triggered alert rule.
        # 
        # For more information about how to obtain the name of an event-triggered alert rule, see [DescribeEventRuleList](~~114996~~).
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met.
        # 
        # Unit: seconds. Default value: 86400, which indicates one day.
        # 
        # >  Only one alert notification is sent during each mute period even if the metric value exceeds the alert threshold several times.
        self.silence_time = silence_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList(TeaModel):
    def __init__(self, event_type_list=None):
        self.event_type_list = event_type_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords(TeaModel):
    def __init__(self, keyword=None):
        self.keyword = keyword  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['keyword'] = self.keyword
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('keyword') is not None:
            self.keyword = m.get('keyword')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj(TeaModel):
    def __init__(self, keywords=None, relation=None):
        self.keywords = keywords  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords
        self.relation = relation  # type: str

    def validate(self):
        if self.keywords:
            self.keywords.validate()

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keywords is not None:
            result['Keywords'] = self.keywords.to_map()
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keywords') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObjKeywords()
            self.keywords = temp_model.from_map(m['Keywords'])
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList(TeaModel):
    def __init__(self, level_list=None):
        self.level_list = level_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level_list is not None:
            result['LevelList'] = self.level_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LevelList') is not None:
            self.level_list = m.get('LevelList')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternNameList(TeaModel):
    def __init__(self, name_list=None):
        self.name_list = name_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_list is not None:
            result['NameList'] = self.name_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NameList') is not None:
            self.name_list = m.get('NameList')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList(TeaModel):
    def __init__(self, status_list=None):
        self.status_list = status_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        return self


class DescribeEventRuleAttributeResponseBodyResultEventPattern(TeaModel):
    def __init__(self, event_type_list=None, keyword_filter_obj=None, level_list=None, name_list=None, product=None,
                 sqlfilter=None, status_list=None):
        # The types of the event-triggered alert rules.
        self.event_type_list = event_type_list  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList
        self.keyword_filter_obj = keyword_filter_obj  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj
        self.level_list = level_list  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList
        self.name_list = name_list  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternNameList
        # The name of the cloud service.
        self.product = product  # type: str
        self.sqlfilter = sqlfilter  # type: str
        self.status_list = status_list  # type: DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList

    def validate(self):
        if self.event_type_list:
            self.event_type_list.validate()
        if self.keyword_filter_obj:
            self.keyword_filter_obj.validate()
        if self.level_list:
            self.level_list.validate()
        if self.name_list:
            self.name_list.validate()
        if self.status_list:
            self.status_list.validate()

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResultEventPattern, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list.to_map()
        if self.keyword_filter_obj is not None:
            result['KeywordFilterObj'] = self.keyword_filter_obj.to_map()
        if self.level_list is not None:
            result['LevelList'] = self.level_list.to_map()
        if self.name_list is not None:
            result['NameList'] = self.name_list.to_map()
        if self.product is not None:
            result['Product'] = self.product
        if self.sqlfilter is not None:
            result['SQLFilter'] = self.sqlfilter
        if self.status_list is not None:
            result['StatusList'] = self.status_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventTypeList') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternEventTypeList()
            self.event_type_list = temp_model.from_map(m['EventTypeList'])
        if m.get('KeywordFilterObj') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternKeywordFilterObj()
            self.keyword_filter_obj = temp_model.from_map(m['KeywordFilterObj'])
        if m.get('LevelList') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternLevelList()
            self.level_list = temp_model.from_map(m['LevelList'])
        if m.get('NameList') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternNameList()
            self.name_list = temp_model.from_map(m['NameList'])
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('SQLFilter') is not None:
            self.sqlfilter = m.get('SQLFilter')
        if m.get('StatusList') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPatternStatusList()
            self.status_list = temp_model.from_map(m['StatusList'])
        return self


class DescribeEventRuleAttributeResponseBodyResult(TeaModel):
    def __init__(self, description=None, event_pattern=None, event_type=None, group_id=None, name=None, state=None):
        # The description of the event-triggered alert rule.
        self.description = description  # type: str
        # The event pattern. This parameter specifies the trigger conditions of an event.
        self.event_pattern = event_pattern  # type: DescribeEventRuleAttributeResponseBodyResultEventPattern
        # The type of the event. Valid values: Valid values:
        # 
        # *   SYSTEM: system event
        # *   CUSTOM: custom event
        self.event_type = event_type  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the event-triggered alert rule.
        self.name = name  # type: str
        # The status of the event-triggered alert rule. Valid values:
        # 
        # *   ENABLED
        # *   DISABLED
        self.state = state  # type: str

    def validate(self):
        if self.event_pattern:
            self.event_pattern.validate()

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBodyResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.event_pattern is not None:
            result['EventPattern'] = self.event_pattern.to_map()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EventPattern') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResultEventPattern()
            self.event_pattern = temp_model.from_map(m['EventPattern'])
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribeEventRuleAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, result=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The details of the event-triggered alert rule.
        self.result = result  # type: DescribeEventRuleAttributeResponseBodyResult
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = DescribeEventRuleAttributeResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeEventRuleAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEventRuleAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEventRuleAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventRuleAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventRuleListRequest(TeaModel):
    def __init__(self, group_id=None, is_enable=None, name_prefix=None, page_number=None, page_size=None,
                 region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        self.is_enable = is_enable  # type: bool
        # The prefix in the name of the event-triggered alert rule.
        self.name_prefix = name_prefix  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries to return on each page.
        # 
        # A minimum of one entry can be returned on each page. Default value: 10.
        self.page_size = page_size  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.name_prefix is not None:
            result['NamePrefix'] = self.name_prefix
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('NamePrefix') is not None:
            self.name_prefix = m.get('NamePrefix')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList(TeaModel):
    def __init__(self, event_type_list=None):
        self.event_type_list = event_type_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords(TeaModel):
    def __init__(self, keywords=None):
        self.keywords = keywords  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keywords is not None:
            result['Keywords'] = self.keywords
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keywords') is not None:
            self.keywords = m.get('Keywords')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter(TeaModel):
    def __init__(self, keywords=None, relation=None):
        # The keywords that are used to match events.
        self.keywords = keywords  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords
        # The relationship between multiple keywords in a condition. Valid values:
        # 
        # *   OR: The relationship between keywords is OR.
        # *   NOT: The keyword is excluded. The value NOT indicates that all events that do not contain the keywords are matched.
        self.relation = relation  # type: str

    def validate(self):
        if self.keywords:
            self.keywords.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keywords is not None:
            result['Keywords'] = self.keywords.to_map()
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keywords') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilterKeywords()
            self.keywords = temp_model.from_map(m['Keywords'])
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList(TeaModel):
    def __init__(self, level_list=None):
        self.level_list = level_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level_list is not None:
            result['LevelList'] = self.level_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LevelList') is not None:
            self.level_list = m.get('LevelList')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList(TeaModel):
    def __init__(self, name_list=None):
        self.name_list = name_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name_list is not None:
            result['NameList'] = self.name_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NameList') is not None:
            self.name_list = m.get('NameList')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern(TeaModel):
    def __init__(self, custom_filters=None, event_type_list=None, keyword_filter=None, level_list=None,
                 name_list=None, product=None, sqlfilter=None):
        # The custom filter condition. If an event contains a specified keyword, the event triggers an alert.
        self.custom_filters = custom_filters  # type: str
        # The type of the event-triggered alert rule.
        # 
        # `*` indicates all types of alert rules.
        self.event_type_list = event_type_list  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList
        # The filter keyword.
        self.keyword_filter = keyword_filter  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter
        # The level of the event. Valid values:
        # 
        # *   CRITICAL: critical
        # *   WARN: warning
        # *   INFO: information
        self.level_list = level_list  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList
        # The list of event names.
        self.name_list = name_list  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList
        # The abbreviation of the service name.
        self.product = product  # type: str
        # Indicates that logs are filtered based on the specified SQL statement. If the specified conditions are met, an alert is triggered.
        self.sqlfilter = sqlfilter  # type: str

    def validate(self):
        if self.event_type_list:
            self.event_type_list.validate()
        if self.keyword_filter:
            self.keyword_filter.validate()
        if self.level_list:
            self.level_list.validate()
        if self.name_list:
            self.name_list.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_filters is not None:
            result['CustomFilters'] = self.custom_filters
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list.to_map()
        if self.keyword_filter is not None:
            result['KeywordFilter'] = self.keyword_filter.to_map()
        if self.level_list is not None:
            result['LevelList'] = self.level_list.to_map()
        if self.name_list is not None:
            result['NameList'] = self.name_list.to_map()
        if self.product is not None:
            result['Product'] = self.product
        if self.sqlfilter is not None:
            result['SQLFilter'] = self.sqlfilter
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomFilters') is not None:
            self.custom_filters = m.get('CustomFilters')
        if m.get('EventTypeList') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternEventTypeList()
            self.event_type_list = temp_model.from_map(m['EventTypeList'])
        if m.get('KeywordFilter') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternKeywordFilter()
            self.keyword_filter = temp_model.from_map(m['KeywordFilter'])
        if m.get('LevelList') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternLevelList()
            self.level_list = temp_model.from_map(m['LevelList'])
        if m.get('NameList') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPatternNameList()
            self.name_list = temp_model.from_map(m['NameList'])
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('SQLFilter') is not None:
            self.sqlfilter = m.get('SQLFilter')
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern(TeaModel):
    def __init__(self, event_pattern=None):
        self.event_pattern = event_pattern  # type: list[DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern]

    def validate(self):
        if self.event_pattern:
            for k in self.event_pattern:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventPattern'] = []
        if self.event_pattern is not None:
            for k in self.event_pattern:
                result['EventPattern'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_pattern = []
        if m.get('EventPattern') is not None:
            for k in m.get('EventPattern'):
                temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPatternEventPattern()
                self.event_pattern.append(temp_model.from_map(k))
        return self


class DescribeEventRuleListResponseBodyEventRulesEventRule(TeaModel):
    def __init__(self, description=None, event_pattern=None, event_type=None, group_id=None, name=None,
                 silence_time=None, state=None):
        # The description of the event-triggered alert rule.
        self.description = description  # type: str
        # The mode of the event-triggered alert rule.
        self.event_pattern = event_pattern  # type: DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern
        # The type of the event. Valid values:
        # 
        # - SYSTEM: system event
        # - CUSTOM: custom event
        self.event_type = event_type  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the event-triggered alert rule.
        self.name = name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met.
        self.silence_time = silence_time  # type: long
        # The status of the event-triggered alert rule. Valid values:
        # 
        # *   ENABLED: enabled
        # *   DISABLED: disabled
        self.state = state  # type: str

    def validate(self):
        if self.event_pattern:
            self.event_pattern.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRulesEventRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.event_pattern is not None:
            result['EventPattern'] = self.event_pattern.to_map()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.name is not None:
            result['Name'] = self.name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EventPattern') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRulesEventRuleEventPattern()
            self.event_pattern = temp_model.from_map(m['EventPattern'])
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class DescribeEventRuleListResponseBodyEventRules(TeaModel):
    def __init__(self, event_rule=None):
        self.event_rule = event_rule  # type: list[DescribeEventRuleListResponseBodyEventRulesEventRule]

    def validate(self):
        if self.event_rule:
            for k in self.event_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBodyEventRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventRule'] = []
        if self.event_rule is not None:
            for k in self.event_rule:
                result['EventRule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_rule = []
        if m.get('EventRule') is not None:
            for k in m.get('EventRule'):
                temp_model = DescribeEventRuleListResponseBodyEventRulesEventRule()
                self.event_rule.append(temp_model.from_map(k))
        return self


class DescribeEventRuleListResponseBody(TeaModel):
    def __init__(self, code=None, event_rules=None, message=None, request_id=None, success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The event-triggered alert rules.
        self.event_rules = event_rules  # type: DescribeEventRuleListResponseBodyEventRules
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.event_rules:
            self.event_rules.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.event_rules is not None:
            result['EventRules'] = self.event_rules.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EventRules') is not None:
            temp_model = DescribeEventRuleListResponseBodyEventRules()
            self.event_rules = temp_model.from_map(m['EventRules'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeEventRuleListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEventRuleListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEventRuleListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeEventRuleTargetListRequest(TeaModel):
    def __init__(self, region_id=None, rule_name=None):
        self.region_id = region_id  # type: str
        # The name of the event-triggered alert rule.
        self.rule_name = rule_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class DescribeEventRuleTargetListResponseBodyContactParametersContactParameter(TeaModel):
    def __init__(self, contact_group_name=None, id=None, level=None):
        # The name of the alert group.
        self.contact_group_name = contact_group_name  # type: str
        # The ID of the recipient.
        self.id = id  # type: str
        # The alert notification methods. Valid values:
        # 
        # 4: Alert notifications are sent by using DingTalk chatbots and emails.
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyContactParametersContactParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeEventRuleTargetListResponseBodyContactParameters(TeaModel):
    def __init__(self, contact_parameter=None):
        self.contact_parameter = contact_parameter  # type: list[DescribeEventRuleTargetListResponseBodyContactParametersContactParameter]

    def validate(self):
        if self.contact_parameter:
            for k in self.contact_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyContactParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactParameter'] = []
        if self.contact_parameter is not None:
            for k in self.contact_parameter:
                result['ContactParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_parameter = []
        if m.get('ContactParameter') is not None:
            for k in m.get('ContactParameter'):
                temp_model = DescribeEventRuleTargetListResponseBodyContactParametersContactParameter()
                self.contact_parameter.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBodyFcParametersFCParameter(TeaModel):
    def __init__(self, arn=None, function_name=None, id=None, region=None, service_name=None):
        # The Alibaba Cloud Resource Name (ARN) of the function. 
        # 
        # Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
        # 
        # - Service: the code of an Alibaba Cloud service
        # - Region: the region ID
        # - Account: the ID of an Alibaba Cloud account
        # - ResourceType: the resource type
        # - ResourceId: the resource ID
        self.arn = arn  # type: str
        # The name of the function.
        self.function_name = function_name  # type: str
        # The ID of the recipient.
        self.id = id  # type: str
        # The region where Function Compute is deployed.
        self.region = region  # type: str
        # The name of the Function Compute service.
        self.service_name = service_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyFcParametersFCParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.id is not None:
            result['Id'] = self.id
        if self.region is not None:
            result['Region'] = self.region
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class DescribeEventRuleTargetListResponseBodyFcParameters(TeaModel):
    def __init__(self, fcparameter=None):
        self.fcparameter = fcparameter  # type: list[DescribeEventRuleTargetListResponseBodyFcParametersFCParameter]

    def validate(self):
        if self.fcparameter:
            for k in self.fcparameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyFcParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FCParameter'] = []
        if self.fcparameter is not None:
            for k in self.fcparameter:
                result['FCParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fcparameter = []
        if m.get('FCParameter') is not None:
            for k in m.get('FCParameter'):
                temp_model = DescribeEventRuleTargetListResponseBodyFcParametersFCParameter()
                self.fcparameter.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter(TeaModel):
    def __init__(self, arn=None, id=None, queue=None, region=None, topic=None):
        # The ARN of the MNS queue. 
        # 
        # Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
        # 
        # - Service: the code of an Alibaba Cloud service
        # - Region: the region ID
        # - Account: the ID of an Alibaba Cloud account
        # - ResourceType: the resource type
        # - ResourceId: the resource ID
        self.arn = arn  # type: str
        # The ID of the recipient.
        self.id = id  # type: str
        # The name of the MNS queue.
        self.queue = queue  # type: str
        # The region where MNS is deployed.
        self.region = region  # type: str
        # The MNS topic.
        self.topic = topic  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.region is not None:
            result['Region'] = self.region
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class DescribeEventRuleTargetListResponseBodyMnsParameters(TeaModel):
    def __init__(self, mns_parameter=None):
        self.mns_parameter = mns_parameter  # type: list[DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter]

    def validate(self):
        if self.mns_parameter:
            for k in self.mns_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyMnsParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MnsParameter'] = []
        if self.mns_parameter is not None:
            for k in self.mns_parameter:
                result['MnsParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.mns_parameter = []
        if m.get('MnsParameter') is not None:
            for k in m.get('MnsParameter'):
                temp_model = DescribeEventRuleTargetListResponseBodyMnsParametersMnsParameter()
                self.mns_parameter.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters(TeaModel):
    def __init__(self, action=None, arn=None, id=None, product=None, region=None, role=None, version=None):
        # The name of the API operation.
        self.action = action  # type: str
        # The ARN of the API operation. 
        # 
        # Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
        # 
        # - Service: the code of an Alibaba Cloud service
        # - Region: the region ID
        # - Account: the ID of an Alibaba Cloud account
        # - ResourceType: the resource type
        # - ResourceId: the resource ID The ARN of the Log Service Logstore. 
        # 
        # Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields:
        # - Service: the code of an Alibaba Cloud service
        # - Region: the region ID
        # - Account: the ID of an Alibaba Cloud account
        # - ResourceType: the resource type
        # - ResourceId: the resource ID
        self.arn = arn  # type: str
        # The ID of the recipient.
        self.id = id  # type: str
        # The ID of the cloud service to which the API operation belongs.
        self.product = product  # type: str
        # The region where the resource resides.
        self.region = region  # type: str
        # The name of the role.
        self.role = role  # type: str
        # The version of the API.
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.product is not None:
            result['Product'] = self.product
        if self.region is not None:
            result['Region'] = self.region
        if self.role is not None:
            result['Role'] = self.role
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class DescribeEventRuleTargetListResponseBodyOpenApiParameters(TeaModel):
    def __init__(self, open_api_parameters=None):
        self.open_api_parameters = open_api_parameters  # type: list[DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters]

    def validate(self):
        if self.open_api_parameters:
            for k in self.open_api_parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyOpenApiParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['OpenApiParameters'] = []
        if self.open_api_parameters is not None:
            for k in self.open_api_parameters:
                result['OpenApiParameters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.open_api_parameters = []
        if m.get('OpenApiParameters') is not None:
            for k in m.get('OpenApiParameters'):
                temp_model = DescribeEventRuleTargetListResponseBodyOpenApiParametersOpenApiParameters()
                self.open_api_parameters.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter(TeaModel):
    def __init__(self, arn=None, id=None, log_store=None, project=None, region=None):
        # The ARN of the Log Service Logstore. 
        # 
        # Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields: 
        # 
        # - Service: the code of an Alibaba Cloud service
        # - Region: the region ID
        # - Account: the ID of an Alibaba Cloud account
        # - ResourceType: the resource type
        # - ResourceId: the resource ID
        self.arn = arn  # type: str
        # The ID of the recipient.
        self.id = id  # type: str
        # The name of the Logstore.
        self.log_store = log_store  # type: str
        # The name of the project.
        self.project = project  # type: str
        # The ID of the region where the Log Service project resides.
        self.region = region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class DescribeEventRuleTargetListResponseBodySlsParameters(TeaModel):
    def __init__(self, sls_parameter=None):
        self.sls_parameter = sls_parameter  # type: list[DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter]

    def validate(self):
        if self.sls_parameter:
            for k in self.sls_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodySlsParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SlsParameter'] = []
        if self.sls_parameter is not None:
            for k in self.sls_parameter:
                result['SlsParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.sls_parameter = []
        if m.get('SlsParameter') is not None:
            for k in m.get('SlsParameter'):
                temp_model = DescribeEventRuleTargetListResponseBodySlsParametersSlsParameter()
                self.sls_parameter.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter(TeaModel):
    def __init__(self, id=None, method=None, protocol=None, url=None):
        # The ID of the recipient.
        self.id = id  # type: str
        # The HTTP request method. Valid values: GET and POST.
        self.method = method  # type: str
        # The protocol type.
        self.protocol = protocol  # type: str
        # The callback URL.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.method is not None:
            result['Method'] = self.method
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class DescribeEventRuleTargetListResponseBodyWebhookParameters(TeaModel):
    def __init__(self, webhook_parameter=None):
        self.webhook_parameter = webhook_parameter  # type: list[DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter]

    def validate(self):
        if self.webhook_parameter:
            for k in self.webhook_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBodyWebhookParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['WebhookParameter'] = []
        if self.webhook_parameter is not None:
            for k in self.webhook_parameter:
                result['WebhookParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.webhook_parameter = []
        if m.get('WebhookParameter') is not None:
            for k in m.get('WebhookParameter'):
                temp_model = DescribeEventRuleTargetListResponseBodyWebhookParametersWebhookParameter()
                self.webhook_parameter.append(temp_model.from_map(k))
        return self


class DescribeEventRuleTargetListResponseBody(TeaModel):
    def __init__(self, code=None, contact_parameters=None, fc_parameters=None, message=None, mns_parameters=None,
                 open_api_parameters=None, request_id=None, sls_parameters=None, webhook_parameters=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The information about the recipients if alert notifications are sent to the alert contacts of an alert contact group.
        self.contact_parameters = contact_parameters  # type: DescribeEventRuleTargetListResponseBodyContactParameters
        # The information about the recipients in Function Compute.
        self.fc_parameters = fc_parameters  # type: DescribeEventRuleTargetListResponseBodyFcParameters
        # The error message.
        self.message = message  # type: str
        # The information about the recipients in Message Service (MNS).
        self.mns_parameters = mns_parameters  # type: DescribeEventRuleTargetListResponseBodyMnsParameters
        # The information about the recipients in OpenAPI Explorer.
        self.open_api_parameters = open_api_parameters  # type: DescribeEventRuleTargetListResponseBodyOpenApiParameters
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the recipients in Log Service.
        self.sls_parameters = sls_parameters  # type: DescribeEventRuleTargetListResponseBodySlsParameters
        # The information about the recipients if alert notifications are sent by sending a request to a callback URL.
        self.webhook_parameters = webhook_parameters  # type: DescribeEventRuleTargetListResponseBodyWebhookParameters

    def validate(self):
        if self.contact_parameters:
            self.contact_parameters.validate()
        if self.fc_parameters:
            self.fc_parameters.validate()
        if self.mns_parameters:
            self.mns_parameters.validate()
        if self.open_api_parameters:
            self.open_api_parameters.validate()
        if self.sls_parameters:
            self.sls_parameters.validate()
        if self.webhook_parameters:
            self.webhook_parameters.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.contact_parameters is not None:
            result['ContactParameters'] = self.contact_parameters.to_map()
        if self.fc_parameters is not None:
            result['FcParameters'] = self.fc_parameters.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.mns_parameters is not None:
            result['MnsParameters'] = self.mns_parameters.to_map()
        if self.open_api_parameters is not None:
            result['OpenApiParameters'] = self.open_api_parameters.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sls_parameters is not None:
            result['SlsParameters'] = self.sls_parameters.to_map()
        if self.webhook_parameters is not None:
            result['WebhookParameters'] = self.webhook_parameters.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('ContactParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodyContactParameters()
            self.contact_parameters = temp_model.from_map(m['ContactParameters'])
        if m.get('FcParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodyFcParameters()
            self.fc_parameters = temp_model.from_map(m['FcParameters'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MnsParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodyMnsParameters()
            self.mns_parameters = temp_model.from_map(m['MnsParameters'])
        if m.get('OpenApiParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodyOpenApiParameters()
            self.open_api_parameters = temp_model.from_map(m['OpenApiParameters'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SlsParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodySlsParameters()
            self.sls_parameters = temp_model.from_map(m['SlsParameters'])
        if m.get('WebhookParameters') is not None:
            temp_model = DescribeEventRuleTargetListResponseBodyWebhookParameters()
            self.webhook_parameters = temp_model.from_map(m['WebhookParameters'])
        return self


class DescribeEventRuleTargetListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeEventRuleTargetListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeEventRuleTargetListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeEventRuleTargetListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExporterOutputListRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None):
        # The number of the page to return. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExporterOutputListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson(TeaModel):
    def __init__(self, ak=None, endpoint=None, logstore=None, project=None):
        # The AccessKey ID.
        self.ak = ak  # type: str
        # The Log Service endpoint to which the monitoring data is exported.
        self.endpoint = endpoint  # type: str
        # The Logstore.
        self.logstore = logstore  # type: str
        # The Log Service project to which the monitoring data is exported.
        self.project = project  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ak is not None:
            result['ak'] = self.ak
        if self.endpoint is not None:
            result['endpoint'] = self.endpoint
        if self.logstore is not None:
            result['logstore'] = self.logstore
        if self.project is not None:
            result['project'] = self.project
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ak') is not None:
            self.ak = m.get('ak')
        if m.get('endpoint') is not None:
            self.endpoint = m.get('endpoint')
        if m.get('logstore') is not None:
            self.logstore = m.get('logstore')
        if m.get('project') is not None:
            self.project = m.get('project')
        return self


class DescribeExporterOutputListResponseBodyDatapointsDatapoint(TeaModel):
    def __init__(self, config_json=None, create_time=None, dest_name=None, dest_type=None):
        # The JSON object that contains the details about the destination to which the monitoring data is exported.
        self.config_json = config_json  # type: DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson
        # The time when the configuration set was created. The value is a UNIX timestamp.
        self.create_time = create_time  # type: long
        # The name of the configuration set.
        self.dest_name = dest_name  # type: str
        # The service to which the monitoring data is exported.
        # 
        # > Only Log Service is supported. More services will be supported in the future.
        self.dest_type = dest_type  # type: str

    def validate(self):
        if self.config_json:
            self.config_json.validate()

    def to_map(self):
        _map = super(DescribeExporterOutputListResponseBodyDatapointsDatapoint, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_json is not None:
            result['ConfigJson'] = self.config_json.to_map()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.dest_name is not None:
            result['DestName'] = self.dest_name
        if self.dest_type is not None:
            result['DestType'] = self.dest_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigJson') is not None:
            temp_model = DescribeExporterOutputListResponseBodyDatapointsDatapointConfigJson()
            self.config_json = temp_model.from_map(m['ConfigJson'])
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DestName') is not None:
            self.dest_name = m.get('DestName')
        if m.get('DestType') is not None:
            self.dest_type = m.get('DestType')
        return self


class DescribeExporterOutputListResponseBodyDatapoints(TeaModel):
    def __init__(self, datapoint=None):
        self.datapoint = datapoint  # type: list[DescribeExporterOutputListResponseBodyDatapointsDatapoint]

    def validate(self):
        if self.datapoint:
            for k in self.datapoint:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExporterOutputListResponseBodyDatapoints, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Datapoint'] = []
        if self.datapoint is not None:
            for k in self.datapoint:
                result['Datapoint'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.datapoint = []
        if m.get('Datapoint') is not None:
            for k in m.get('Datapoint'):
                temp_model = DescribeExporterOutputListResponseBodyDatapointsDatapoint()
                self.datapoint.append(temp_model.from_map(k))
        return self


class DescribeExporterOutputListResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, page_number=None, request_id=None, success=None,
                 total=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code  # type: str
        # The configuration sets for exporting monitoring data.
        self.datapoints = datapoints  # type: DescribeExporterOutputListResponseBodyDatapoints
        # The returned message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.datapoints:
            self.datapoints.validate()

    def to_map(self):
        _map = super(DescribeExporterOutputListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            temp_model = DescribeExporterOutputListResponseBodyDatapoints()
            self.datapoints = temp_model.from_map(m['Datapoints'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeExporterOutputListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExporterOutputListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExporterOutputListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExporterOutputListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeExporterRuleListRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None):
        # The page number. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page. Default value: 1000.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExporterRuleListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeExporterRuleListResponseBodyDatapointsDatapointDstName(TeaModel):
    def __init__(self, dst_name=None):
        self.dst_name = dst_name  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeExporterRuleListResponseBodyDatapointsDatapointDstName, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dst_name is not None:
            result['DstName'] = self.dst_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DstName') is not None:
            self.dst_name = m.get('DstName')
        return self


class DescribeExporterRuleListResponseBodyDatapointsDatapoint(TeaModel):
    def __init__(self, create_time=None, describe=None, dimension=None, dst_name=None, enabled=None,
                 metric_name=None, namespace=None, rule_name=None, target_windows=None):
        # The time when the rule was created. The value is a UNIX timestamp.
        self.create_time = create_time  # type: long
        # The description of the rule.
        self.describe = describe  # type: str
        # The associated dimensions.
        self.dimension = dimension  # type: str
        self.dst_name = dst_name  # type: DescribeExporterRuleListResponseBodyDatapointsDatapointDstName
        # Indicates whether the rule is enabled.
        self.enabled = enabled  # type: bool
        # The name of the metric.
        # 
        # > For more information, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~28619~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the service.
        # 
        # > For more information, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~28619~~).
        self.namespace = namespace  # type: str
        # The name of the data export rule.
        self.rule_name = rule_name  # type: str
        # The time window of the exported data.\
        # Multiple windows are separated with commas (,).
        # 
        # > Data in a time window of less than 60 seconds cannot be exported.
        self.target_windows = target_windows  # type: str

    def validate(self):
        if self.dst_name:
            self.dst_name.validate()

    def to_map(self):
        _map = super(DescribeExporterRuleListResponseBodyDatapointsDatapoint, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.dst_name is not None:
            result['DstName'] = self.dst_name.to_map()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.target_windows is not None:
            result['TargetWindows'] = self.target_windows
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('DstName') is not None:
            temp_model = DescribeExporterRuleListResponseBodyDatapointsDatapointDstName()
            self.dst_name = temp_model.from_map(m['DstName'])
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TargetWindows') is not None:
            self.target_windows = m.get('TargetWindows')
        return self


class DescribeExporterRuleListResponseBodyDatapoints(TeaModel):
    def __init__(self, datapoint=None):
        self.datapoint = datapoint  # type: list[DescribeExporterRuleListResponseBodyDatapointsDatapoint]

    def validate(self):
        if self.datapoint:
            for k in self.datapoint:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeExporterRuleListResponseBodyDatapoints, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Datapoint'] = []
        if self.datapoint is not None:
            for k in self.datapoint:
                result['Datapoint'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.datapoint = []
        if m.get('Datapoint') is not None:
            for k in m.get('Datapoint'):
                temp_model = DescribeExporterRuleListResponseBodyDatapointsDatapoint()
                self.datapoint.append(temp_model.from_map(k))
        return self


class DescribeExporterRuleListResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, page_number=None, request_id=None, success=None,
                 total=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful. Other status codes indicate that the request failed.
        self.code = code  # type: str
        # The details of the data export rules.
        self.datapoints = datapoints  # type: DescribeExporterRuleListResponseBodyDatapoints
        # The returned message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`
        # *   `false`
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.datapoints:
            self.datapoints.validate()

    def to_map(self):
        _map = super(DescribeExporterRuleListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            temp_model = DescribeExporterRuleListResponseBodyDatapoints()
            self.datapoints = temp_model.from_map(m['Datapoints'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeExporterRuleListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeExporterRuleListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeExporterRuleListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeExporterRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, group_id=None, page_number=None, page_size=None, process_name=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The number of the page to return. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        # The name of the process monitoring task.
        self.process_name = process_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget(TeaModel):
    def __init__(self, arn=None, id=None, json_parmas=None, level=None):
        self.arn = arn  # type: str
        self.id = id  # type: str
        self.json_parmas = json_parmas  # type: str
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_parmas is not None:
            result['JsonParmas'] = self.json_parmas
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParmas') is not None:
            self.json_parmas = m.get('JsonParmas')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList(TeaModel):
    def __init__(self, target=None):
        self.target = target  # type: list[DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget]

    def validate(self):
        if self.target:
            for k in self.target:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Target'] = []
        if self.target is not None:
            for k in self.target:
                result['Target'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target = []
        if m.get('Target') is not None:
            for k in m.get('Target'):
                temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetListTarget()
                self.target.append(temp_model.from_map(k))
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig(TeaModel):
    def __init__(self, comparison_operator=None, effective_interval=None, escalations_level=None,
                 no_effective_interval=None, silence_time=None, statistics=None, target_list=None, threshold=None, times=None,
                 webhook=None):
        # The comparison operator of the threshold for critical-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # The level of the alert. Valid values:
        # 
        # *   critical
        # *   warn
        # *   info
        self.escalations_level = escalations_level  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The duration of the mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Minimum value: 3600, which is equivalent to one hour. Default value: 86400, which is equivalent to one day.
        # 
        # >  Only one alert notification is sent during each mute period even if the metric value consecutively exceeds the alert threshold several times.
        self.silence_time = silence_time  # type: str
        # The method used to calculate metric values that trigger alerts.
        self.statistics = statistics  # type: str
        self.target_list = target_list  # type: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList
        # The threshold for triggering alerts.
        self.threshold = threshold  # type: str
        # The number of times for which the threshold can be consecutively exceeded.
        # 
        # >  A metric triggers an alert only after the metric value reaches the threshold consecutively for the specified times.
        self.times = times  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.target_list:
            self.target_list.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.escalations_level is not None:
            result['EscalationsLevel'] = self.escalations_level
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.target_list is not None:
            result['TargetList'] = self.target_list.to_map()
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EscalationsLevel') is not None:
            self.escalations_level = m.get('EscalationsLevel')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('TargetList') is not None:
            temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfigTargetList()
            self.target_list = temp_model.from_map(m['TargetList'])
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig(TeaModel):
    def __init__(self, alert_config=None):
        self.alert_config = alert_config  # type: list[DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig]

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfigAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress(TeaModel):
    def __init__(self, function=None, name=None, value=None):
        # The method used to match the instances. Default value: all. Valid values:
        # 
        # *   all
        # *   startWith
        # *   endWith
        # *   contains
        # *   notContains
        # *   equals
        # 
        # >  The matched instances are monitored by the process monitoring task.
        self.function = function  # type: str
        # The criteria based on which the instances are matched.
        # 
        # >  Set the value to `name`, indicating that the instances are matched based on instance name.
        self.name = name  # type: str
        # The keyword used to match the instance name.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress(TeaModel):
    def __init__(self, match_express=None):
        self.match_express = match_express  # type: list[DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress]

    def validate(self):
        if self.match_express:
            for k in self.match_express:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MatchExpress'] = []
        if self.match_express is not None:
            for k in self.match_express:
                result['MatchExpress'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.match_express = []
        if m.get('MatchExpress') is not None:
            for k in m.get('MatchExpress'):
                temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpressMatchExpress()
                self.match_express.append(temp_model.from_map(k))
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess(TeaModel):
    def __init__(self, alert_config=None, group_id=None, id=None, match_express=None,
                 match_express_filter_relation=None, process_name=None):
        # The configurations of the alert rule.
        self.alert_config = alert_config  # type: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig
        self.group_id = group_id  # type: str
        # The ID of the process monitoring task.
        self.id = id  # type: str
        # The conditional expressions used to match the instances.
        # 
        # >  Only the instances that meet the conditional expressions are monitored by the process monitoring task.
        self.match_express = match_express  # type: DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress
        self.match_express_filter_relation = match_express_filter_relation  # type: str
        # The name of the process monitoring task.
        self.process_name = process_name  # type: str

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.match_express:
            self.match_express.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.match_express is not None:
            result['MatchExpress'] = self.match_express.to_map()
        if self.match_express_filter_relation is not None:
            result['MatchExpressFilterRelation'] = self.match_express_filter_relation
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchExpress') is not None:
            temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcessMatchExpress()
            self.match_express = temp_model.from_map(m['MatchExpress'])
        if m.get('MatchExpressFilterRelation') is not None:
            self.match_express_filter_relation = m.get('MatchExpressFilterRelation')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        return self


class DescribeGroupMonitoringAgentProcessResponseBodyProcesses(TeaModel):
    def __init__(self, process=None):
        self.process = process  # type: list[DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess]

    def validate(self):
        if self.process:
            for k in self.process:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBodyProcesses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Process'] = []
        if self.process is not None:
            for k in self.process:
                result['Process'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.process = []
        if m.get('Process') is not None:
            for k in m.get('Process'):
                temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcessesProcess()
                self.process.append(temp_model.from_map(k))
        return self


class DescribeGroupMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, processes=None, request_id=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The number of the returned page. Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries returned on each page. Default value: 10.
        self.page_size = page_size  # type: str
        # The process monitoring tasks created for the application group.
        self.processes = processes  # type: DescribeGroupMonitoringAgentProcessResponseBodyProcesses
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total = total  # type: str

    def validate(self):
        if self.processes:
            self.processes.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.processes is not None:
            result['Processes'] = self.processes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Processes') is not None:
            temp_model = DescribeGroupMonitoringAgentProcessResponseBodyProcesses()
            self.processes = temp_model.from_map(m['Processes'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeGroupMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHostAvailabilityListRequest(TeaModel):
    def __init__(self, group_id=None, id=None, ids=None, page_number=None, page_size=None, region_id=None,
                 task_name=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ID of the availability monitoring task.
        self.id = id  # type: long
        # The IDs of the availability monitoring tasks. Separate multiple IDs with commas (,).
        self.ids = ids  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The name of the availability monitoring task.
        self.task_name = task_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHostAvailabilityListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList(TeaModel):
    def __init__(self, aggregate=None, metric_name=None, operator=None, times=None, value=None):
        # The method used to calculate metric values that trigger alerts. Valid values:
        # 
        # *   Value: the value of the HTTP status code
        # *   Average: the average HTTP response time
        # *   Value: the value of the Telnet status code
        # *   TelnetLatency: the average Telnet response time
        # *   Average: the average Ping packet loss rate
        self.aggregate = aggregate  # type: str
        # The name of the metric. Valid values:
        # 
        # *   HttpStatus: HTTP status code
        # *   HttpLatency: HTTP response time
        # *   TelnetStatus: Telnet status code
        # *   TelnetLatency: Telnet response time
        # *   PingLostRate: Ping packet loss rate
        self.metric_name = metric_name  # type: str
        # The comparison operator that is used in the alert rule. Valid values:
        # 
        # *   `>`
        # *   `>=`
        # *   `<`
        # *   `<=`
        # *   `=`
        self.operator = operator  # type: str
        # The consecutive number of times for which the metric value is measured before an alert is triggered.
        self.times = times  # type: str
        # The alert threshold.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['Aggregate'] = self.aggregate
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.times is not None:
            result['Times'] = self.times
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Aggregate') is not None:
            self.aggregate = m.get('Aggregate')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList(TeaModel):
    def __init__(self, escalation_list=None):
        self.escalation_list = escalation_list  # type: list[DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList]

    def validate(self):
        if self.escalation_list:
            for k in self.escalation_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['escalationList'] = []
        if self.escalation_list is not None:
            for k in self.escalation_list:
                result['escalationList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.escalation_list = []
        if m.get('escalationList') is not None:
            for k in m.get('escalationList'):
                temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationListEscalationList()
                self.escalation_list.append(temp_model.from_map(k))
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        self.arn = arn  # type: str
        self.id = id  # type: str
        self.json_params = json_params  # type: str
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList(TeaModel):
    def __init__(self, target=None):
        self.target = target  # type: list[DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget]

    def validate(self):
        if self.target:
            for k in self.target:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Target'] = []
        if self.target is not None:
            for k in self.target:
                result['Target'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target = []
        if m.get('Target') is not None:
            for k in m.get('Target'):
                temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetListTarget()
                self.target.append(temp_model.from_map(k))
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig(TeaModel):
    def __init__(self, end_time=None, escalation_list=None, notify_type=None, silence_time=None, start_time=None,
                 target_list=None, web_hook=None):
        # The end of the time period during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # >  Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.end_time = end_time  # type: int
        # The trigger conditions of the alert rule.
        self.escalation_list = escalation_list  # type: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList
        # The alert notification methods. Valid values:
        # 
        # 0: Alert notifications are sent by using emails and DingTalk chatbots.
        self.notify_type = notify_type  # type: int
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
        self.silence_time = silence_time  # type: int
        # The beginning of the time period during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # >  Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.start_time = start_time  # type: int
        self.target_list = target_list  # type: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList
        # The callback URL.
        # 
        # CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
        self.web_hook = web_hook  # type: str

    def validate(self):
        if self.escalation_list:
            self.escalation_list.validate()
        if self.target_list:
            self.target_list.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.escalation_list is not None:
            result['EscalationList'] = self.escalation_list.to_map()
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.target_list is not None:
            result['TargetList'] = self.target_list.to_map()
        if self.web_hook is not None:
            result['WebHook'] = self.web_hook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EscalationList') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigEscalationList()
            self.escalation_list = temp_model.from_map(m['EscalationList'])
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TargetList') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfigTargetList()
            self.target_list = temp_model.from_map(m['TargetList'])
        if m.get('WebHook') is not None:
            self.web_hook = m.get('WebHook')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances(TeaModel):
    def __init__(self, instance=None):
        self.instance = instance  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance is not None:
            result['Instance'] = self.instance
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Instance') is not None:
            self.instance = m.get('Instance')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption(TeaModel):
    def __init__(self, http_keyword=None, http_method=None, http_negative=None, http_post_content=None,
                 http_response_charset=None, http_uri=None, interval=None, telnet_or_ping_host=None):
        # The response to the HTTP request.
        self.http_keyword = http_keyword  # type: str
        # The HTTP request method. Valid values:
        # 
        # *   GET
        # *   POST
        # *   HEAD
        self.http_method = http_method  # type: str
        # The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
        # 
        # *   true: If the HTTP response body includes the alert rule, an alert is triggered.
        # *   false: If the HTTP response does not include the alert rule, an alert is triggered.
        self.http_negative = http_negative  # type: bool
        # The content of the HTTP POST request.
        self.http_post_content = http_post_content  # type: str
        # The character set that is used in the HTTP response.
        self.http_response_charset = http_response_charset  # type: str
        # The URI that you want to monitor. If the TaskType parameter is set to HTTP, this parameter is required.
        self.http_uri = http_uri  # type: str
        # The interval at which detection requests are sent. Unit: seconds.
        self.interval = interval  # type: int
        # The domain name or IP address that you want to monitor.
        self.telnet_or_ping_host = telnet_or_ping_host  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_keyword is not None:
            result['HttpKeyword'] = self.http_keyword
        if self.http_method is not None:
            result['HttpMethod'] = self.http_method
        if self.http_negative is not None:
            result['HttpNegative'] = self.http_negative
        if self.http_post_content is not None:
            result['HttpPostContent'] = self.http_post_content
        if self.http_response_charset is not None:
            result['HttpResponseCharset'] = self.http_response_charset
        if self.http_uri is not None:
            result['HttpURI'] = self.http_uri
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.telnet_or_ping_host is not None:
            result['TelnetOrPingHost'] = self.telnet_or_ping_host
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpKeyword') is not None:
            self.http_keyword = m.get('HttpKeyword')
        if m.get('HttpMethod') is not None:
            self.http_method = m.get('HttpMethod')
        if m.get('HttpNegative') is not None:
            self.http_negative = m.get('HttpNegative')
        if m.get('HttpPostContent') is not None:
            self.http_post_content = m.get('HttpPostContent')
        if m.get('HttpResponseCharset') is not None:
            self.http_response_charset = m.get('HttpResponseCharset')
        if m.get('HttpURI') is not None:
            self.http_uri = m.get('HttpURI')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TelnetOrPingHost') is not None:
            self.telnet_or_ping_host = m.get('TelnetOrPingHost')
        return self


class DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig(TeaModel):
    def __init__(self, alert_config=None, disabled=None, group_id=None, group_name=None, id=None, instances=None,
                 task_name=None, task_option=None, task_scope=None, task_type=None):
        # The configurations of the alert rule.
        self.alert_config = alert_config  # type: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig
        # Indicates whether the availability monitoring task is disabled. Valid values:
        # 
        # *   true: The availability monitoring task is disabled.
        # *   false: The availability monitoring task is enabled.
        self.disabled = disabled  # type: bool
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The name of the application group.
        self.group_name = group_name  # type: str
        # The ID of the availability monitoring task.
        self.id = id  # type: long
        # The ECS instances that are monitored.
        self.instances = instances  # type: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances
        # The name of the availability monitoring task.
        self.task_name = task_name  # type: str
        # The optional parameters of the availability monitoring task.
        self.task_option = task_option  # type: DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption
        # The range of instances that are monitored by the availability monitoring task. Valid values:
        # 
        # *   GROUP: All ECS instances in the application group are monitored.
        # *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored.
        self.task_scope = task_scope  # type: str
        # The type of the availability monitoring task. Valid values:
        # 
        # *   PING
        # *   TELNET
        # *   HTTP
        self.task_type = task_type  # type: str

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.instances:
            self.instances.validate()
        if self.task_option:
            self.task_option.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.disabled is not None:
            result['Disabled'] = self.disabled
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.instances is not None:
            result['Instances'] = self.instances.to_map()
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_option is not None:
            result['TaskOption'] = self.task_option.to_map()
        if self.task_scope is not None:
            result['TaskScope'] = self.task_scope
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('Disabled') is not None:
            self.disabled = m.get('Disabled')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Instances') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigInstances()
            self.instances = temp_model.from_map(m['Instances'])
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskOption') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfigTaskOption()
            self.task_option = temp_model.from_map(m['TaskOption'])
        if m.get('TaskScope') is not None:
            self.task_scope = m.get('TaskScope')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeHostAvailabilityListResponseBodyTaskList(TeaModel):
    def __init__(self, node_task_config=None):
        self.node_task_config = node_task_config  # type: list[DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig]

    def validate(self):
        if self.node_task_config:
            for k in self.node_task_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBodyTaskList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeTaskConfig'] = []
        if self.node_task_config is not None:
            for k in self.node_task_config:
                result['NodeTaskConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node_task_config = []
        if m.get('NodeTaskConfig') is not None:
            for k in m.get('NodeTaskConfig'):
                temp_model = DescribeHostAvailabilityListResponseBodyTaskListNodeTaskConfig()
                self.node_task_config.append(temp_model.from_map(k))
        return self


class DescribeHostAvailabilityListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, task_list=None, total=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The details of the availability monitoring tasks.
        self.task_list = task_list  # type: DescribeHostAvailabilityListResponseBodyTaskList
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.task_list:
            self.task_list.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.task_list is not None:
            result['TaskList'] = self.task_list.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TaskList') is not None:
            temp_model = DescribeHostAvailabilityListResponseBodyTaskList()
            self.task_list = temp_model.from_map(m['TaskList'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeHostAvailabilityListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHostAvailabilityListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHostAvailabilityListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHostAvailabilityListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHybridMonitorDataListRequest(TeaModel):
    def __init__(self, end=None, namespace=None, period=None, prom_sql=None, region_id=None, start=None):
        # The timestamp that specifies the end of the time range to query.
        # 
        # Unit: seconds.
        self.end = end  # type: long
        # The name of the namespace.
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        # The interval at which monitoring data is collected.
        # 
        # Unit: seconds.
        self.period = period  # type: str
        # The name of the metric.
        # 
        # >  PromQL statements are supported.
        self.prom_sql = prom_sql  # type: str
        self.region_id = region_id  # type: str
        # The timestamp that specifies the beginning of the time range to query.
        # 
        # Unit: seconds.
        self.start = start  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end is not None:
            result['End'] = self.end
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.prom_sql is not None:
            result['PromSQL'] = self.prom_sql
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start is not None:
            result['Start'] = self.start
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('End') is not None:
            self.end = m.get('End')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PromSQL') is not None:
            self.prom_sql = m.get('PromSQL')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Start') is not None:
            self.start = m.get('Start')
        return self


class DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels(TeaModel):
    def __init__(self, k=None, v=None):
        # The tag key.
        self.k = k  # type: str
        # The tag value.
        self.v = v  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.k is not None:
            result['K'] = self.k
        if self.v is not None:
            result['V'] = self.v
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('K') is not None:
            self.k = m.get('K')
        if m.get('V') is not None:
            self.v = m.get('V')
        return self


class DescribeHybridMonitorDataListResponseBodyTimeSeriesValues(TeaModel):
    def __init__(self, ts=None, v=None):
        # The timestamp that indicates the time when the metric value is collected.
        # 
        # Unit: seconds.
        self.ts = ts  # type: str
        # The metric value.
        self.v = v  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListResponseBodyTimeSeriesValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ts is not None:
            result['Ts'] = self.ts
        if self.v is not None:
            result['V'] = self.v
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Ts') is not None:
            self.ts = m.get('Ts')
        if m.get('V') is not None:
            self.v = m.get('V')
        return self


class DescribeHybridMonitorDataListResponseBodyTimeSeries(TeaModel):
    def __init__(self, labels=None, metric_name=None, values=None):
        # The tags of the time dimension.
        self.labels = labels  # type: list[DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels]
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        # The metric values that are collected at different timestamps.
        self.values = values  # type: list[DescribeHybridMonitorDataListResponseBodyTimeSeriesValues]

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.values:
            for k in self.values:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListResponseBodyTimeSeries, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        result['Values'] = []
        if self.values is not None:
            for k in self.values:
                result['Values'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeHybridMonitorDataListResponseBodyTimeSeriesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        self.values = []
        if m.get('Values') is not None:
            for k in m.get('Values'):
                temp_model = DescribeHybridMonitorDataListResponseBodyTimeSeriesValues()
                self.values.append(temp_model.from_map(k))
        return self


class DescribeHybridMonitorDataListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, time_series=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: str
        # The returned monitoring data.
        self.time_series = time_series  # type: list[DescribeHybridMonitorDataListResponseBodyTimeSeries]

    def validate(self):
        if self.time_series:
            for k in self.time_series:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TimeSeries'] = []
        if self.time_series is not None:
            for k in self.time_series:
                result['TimeSeries'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.time_series = []
        if m.get('TimeSeries') is not None:
            for k in m.get('TimeSeries'):
                temp_model = DescribeHybridMonitorDataListResponseBodyTimeSeries()
                self.time_series.append(temp_model.from_map(k))
        return self


class DescribeHybridMonitorDataListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHybridMonitorDataListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorDataListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHybridMonitorDataListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHybridMonitorNamespaceListRequest(TeaModel):
    def __init__(self, keyword=None, namespace=None, page_number=None, page_size=None, region_id=None,
                 show_task_statistic=None):
        # The keyword that is used to search for namespaces.
        self.keyword = keyword  # type: str
        # The name of the namespace.
        # 
        # The name can contain uppercase letters, lowercase letters, digits, and hyphens (-).
        self.namespace = namespace  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # A minimum of 1 entry can be returned on each page. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # Specifies whether to return the configuration details of metric import tasks for Alibaba Cloud services and the number of metric import tasks for third-party services. Valid values:
        # 
        # *   true
        # *   false (default value)
        self.show_task_statistic = show_task_statistic  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_task_statistic is not None:
            result['ShowTaskStatistic'] = self.show_task_statistic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowTaskStatistic') is not None:
            self.show_task_statistic = m.get('ShowTaskStatistic')
        return self


class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList(TeaModel):
    def __init__(self, list=None, period=None):
        # The metrics.
        self.list = list  # type: list[str]
        # The interval at which metrics are collected.
        # 
        # Unit: seconds.
        self.period = period  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.list is not None:
            result['List'] = self.list
        if self.period is not None:
            result['Period'] = self.period
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('List') is not None:
            self.list = m.get('List')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        return self


class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList(TeaModel):
    def __init__(self, metric_list=None, namespace=None):
        # The list of metrics for the Alibaba Cloud service.
        self.metric_list = metric_list  # type: list[DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList]
        # The namespace for the Alibaba Cloud service.
        self.namespace = namespace  # type: str

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['MetricList'].append(k.to_map() if k else None)
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_list = []
        if m.get('MetricList') is not None:
            for k in m.get('MetricList'):
                temp_model = DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceListMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList(TeaModel):
    def __init__(self, namespace_list=None, user_id=None, yamlconfig=None):
        # The list of namespaces.
        self.namespace_list = namespace_list  # type: list[DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList]
        # The account that is used to create the namespace.
        self.user_id = user_id  # type: long
        self.yamlconfig = yamlconfig  # type: str

    def validate(self):
        if self.namespace_list:
            for k in self.namespace_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NamespaceList'] = []
        if self.namespace_list is not None:
            for k in self.namespace_list:
                result['NamespaceList'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.yamlconfig is not None:
            result['YAMLConfig'] = self.yamlconfig
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.namespace_list = []
        if m.get('NamespaceList') is not None:
            for k in m.get('NamespaceList'):
                temp_model = DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricListNamespaceList()
                self.namespace_list.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('YAMLConfig') is not None:
            self.yamlconfig = m.get('YAMLConfig')
        return self


class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail(TeaModel):
    def __init__(self, spec=None):
        # The data retention period. Valid values:
        # 
        # *   cms.s1.large: Data is stored for 15 days.
        # *   cms.s1.xlarge: Data is stored for 32 days.
        # *   cms.s1.2xlarge: Data is stored for 63 days.
        # *   cms.s1.3xlarge: Data is stored for 93 days.
        # *   cms.s1.6xlarge: Data is stored for 185 days.
        # *   cms.s1.12xlarge: Data is stored for 376 days.
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace(TeaModel):
    def __init__(self, aliyun_product_metric_list=None, create_time=None, description=None, detail=None, id=None,
                 is_delete=None, modify_time=None, namespace=None, not_aliyun_task_number=None):
        # The configuration details of metric import tasks for Alibaba Cloud services.
        self.aliyun_product_metric_list = aliyun_product_metric_list  # type: list[DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList]
        # The timestamp that was generated when the namespace was created.
        # 
        # Unit: milliseconds.
        self.create_time = create_time  # type: str
        # The description of the namespace.
        self.description = description  # type: str
        # The details of the data retention period.
        self.detail = detail  # type: DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail
        # The ID of the namespace.
        self.id = id  # type: str
        # Indicates whether the namespace is deleted. Valid values:
        # 
        # *   0: The namespace is not deleted.
        # *   1: The namespace is deleted.
        self.is_delete = is_delete  # type: int
        # The timestamp that was generated when the namespace was last modified.
        self.modify_time = modify_time  # type: str
        # The name of the namespace.
        self.namespace = namespace  # type: str
        # The number of metric import tasks for third-party services.
        self.not_aliyun_task_number = not_aliyun_task_number  # type: long

    def validate(self):
        if self.aliyun_product_metric_list:
            for k in self.aliyun_product_metric_list:
                if k:
                    k.validate()
        if self.detail:
            self.detail.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AliyunProductMetricList'] = []
        if self.aliyun_product_metric_list is not None:
            for k in self.aliyun_product_metric_list:
                result['AliyunProductMetricList'].append(k.to_map() if k else None)
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.detail is not None:
            result['Detail'] = self.detail.to_map()
        if self.id is not None:
            result['Id'] = self.id
        if self.is_delete is not None:
            result['IsDelete'] = self.is_delete
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.not_aliyun_task_number is not None:
            result['NotAliyunTaskNumber'] = self.not_aliyun_task_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aliyun_product_metric_list = []
        if m.get('AliyunProductMetricList') is not None:
            for k in m.get('AliyunProductMetricList'):
                temp_model = DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceAliyunProductMetricList()
                self.aliyun_product_metric_list.append(temp_model.from_map(k))
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Detail') is not None:
            temp_model = DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespaceDetail()
            self.detail = temp_model.from_map(m['Detail'])
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsDelete') is not None:
            self.is_delete = m.get('IsDelete')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NotAliyunTaskNumber') is not None:
            self.not_aliyun_task_number = m.get('NotAliyunTaskNumber')
        return self


class DescribeHybridMonitorNamespaceListResponseBody(TeaModel):
    def __init__(self, code=None, describe_hybrid_monitor_namespace=None, message=None, page_number=None,
                 page_size=None, request_id=None, success=None, total=None):
        # The returned message.
        self.code = code  # type: str
        # The details of the namespaces.
        self.describe_hybrid_monitor_namespace = describe_hybrid_monitor_namespace  # type: list[DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace]
        # The error message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.describe_hybrid_monitor_namespace:
            for k in self.describe_hybrid_monitor_namespace:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DescribeHybridMonitorNamespace'] = []
        if self.describe_hybrid_monitor_namespace is not None:
            for k in self.describe_hybrid_monitor_namespace:
                result['DescribeHybridMonitorNamespace'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.describe_hybrid_monitor_namespace = []
        if m.get('DescribeHybridMonitorNamespace') is not None:
            for k in m.get('DescribeHybridMonitorNamespace'):
                temp_model = DescribeHybridMonitorNamespaceListResponseBodyDescribeHybridMonitorNamespace()
                self.describe_hybrid_monitor_namespace.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeHybridMonitorNamespaceListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHybridMonitorNamespaceListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorNamespaceListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHybridMonitorNamespaceListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHybridMonitorSLSGroupRequest(TeaModel):
    def __init__(self, keyword=None, page_number=None, page_size=None, region_id=None, slsgroup_name=None):
        # The keyword that is used to search for Logstore groups.
        self.keyword = keyword  # type: str
        # The page number.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: str
        # The number of entries per page.
        # 
        # Minimum value: 1. Default value: 10.
        self.page_size = page_size  # type: str
        self.region_id = region_id  # type: str
        # The name of the Logstore group.
        self.slsgroup_name = slsgroup_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorSLSGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slsgroup_name is not None:
            result['SLSGroupName'] = self.slsgroup_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SLSGroupName') is not None:
            self.slsgroup_name = m.get('SLSGroupName')
        return self


class DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig(TeaModel):
    def __init__(self, slslogstore=None, slsproject=None, slsregion=None, slsuser_id=None):
        # The Logstore.
        self.slslogstore = slslogstore  # type: str
        # The Simple Log Service project.
        self.slsproject = slsproject  # type: str
        # The region ID.
        self.slsregion = slsregion  # type: str
        # The member ID.
        # 
        # **Description** This parameter is returned when you call the operation by using an administrative account.
        self.slsuser_id = slsuser_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slslogstore is not None:
            result['SLSLogstore'] = self.slslogstore
        if self.slsproject is not None:
            result['SLSProject'] = self.slsproject
        if self.slsregion is not None:
            result['SLSRegion'] = self.slsregion
        if self.slsuser_id is not None:
            result['SLSUserId'] = self.slsuser_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SLSLogstore') is not None:
            self.slslogstore = m.get('SLSLogstore')
        if m.get('SLSProject') is not None:
            self.slsproject = m.get('SLSProject')
        if m.get('SLSRegion') is not None:
            self.slsregion = m.get('SLSRegion')
        if m.get('SLSUserId') is not None:
            self.slsuser_id = m.get('SLSUserId')
        return self


class DescribeHybridMonitorSLSGroupResponseBodyList(TeaModel):
    def __init__(self, create_time=None, slsgroup_config=None, slsgroup_description=None, slsgroup_name=None,
                 update_time=None):
        # The time when the Logstore group was created.
        # 
        # Unit: milliseconds.
        self.create_time = create_time  # type: str
        # The configurations of the Logstore group.
        self.slsgroup_config = slsgroup_config  # type: list[DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig]
        # The description of the Logstore group.
        self.slsgroup_description = slsgroup_description  # type: str
        # The name of the Logstore group.
        self.slsgroup_name = slsgroup_name  # type: str
        # The time when the Logstore group was modified.
        # 
        # Unit: milliseconds.
        self.update_time = update_time  # type: str

    def validate(self):
        if self.slsgroup_config:
            for k in self.slsgroup_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorSLSGroupResponseBodyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        result['SLSGroupConfig'] = []
        if self.slsgroup_config is not None:
            for k in self.slsgroup_config:
                result['SLSGroupConfig'].append(k.to_map() if k else None)
        if self.slsgroup_description is not None:
            result['SLSGroupDescription'] = self.slsgroup_description
        if self.slsgroup_name is not None:
            result['SLSGroupName'] = self.slsgroup_name
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        self.slsgroup_config = []
        if m.get('SLSGroupConfig') is not None:
            for k in m.get('SLSGroupConfig'):
                temp_model = DescribeHybridMonitorSLSGroupResponseBodyListSLSGroupConfig()
                self.slsgroup_config.append(temp_model.from_map(k))
        if m.get('SLSGroupDescription') is not None:
            self.slsgroup_description = m.get('SLSGroupDescription')
        if m.get('SLSGroupName') is not None:
            self.slsgroup_name = m.get('SLSGroupName')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeHybridMonitorSLSGroupResponseBody(TeaModel):
    def __init__(self, code=None, list=None, message=None, page_number=None, page_size=None, request_id=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The queried Logstore groups.
        self.list = list  # type: list[DescribeHybridMonitorSLSGroupResponseBodyList]
        # The error message.
        self.message = message  # type: str
        # The page number.
        self.page_number = page_number  # type: long
        # The number of entries per page.
        self.page_size = page_size  # type: long
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str
        # The total number of entries returned.
        self.total = total  # type: long

    def validate(self):
        if self.list:
            for k in self.list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorSLSGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['List'] = []
        if self.list is not None:
            for k in self.list:
                result['List'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.list = []
        if m.get('List') is not None:
            for k in m.get('List'):
                temp_model = DescribeHybridMonitorSLSGroupResponseBodyList()
                self.list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeHybridMonitorSLSGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHybridMonitorSLSGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorSLSGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHybridMonitorSLSGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeHybridMonitorTaskListRequest(TeaModel):
    def __init__(self, group_id=None, include_aliyun_task=None, keyword=None, namespace=None, page_number=None,
                 page_size=None, region_id=None, target_user_id=None, task_id=None, task_type=None):
        # The ID of the application group.
        # 
        # For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # Specifies whether the returned result includes metric import tasks for Alibaba Cloud services. Valid values:
        # 
        # *   true (default): The returned result includes metric import tasks for Alibaba Cloud services.
        # *   false: The returned result excludes metric import tasks for Alibaba Cloud services.
        self.include_aliyun_task = include_aliyun_task  # type: bool
        # The keyword that is used for the search.
        self.keyword = keyword  # type: str
        # The name of the namespace.
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        # The page number.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page.
        # 
        # Pages start from page 1. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The ID of the member account.
        # 
        # > This parameter is required only if you use a management account to call this operation to delete the metric import tasks that belong to a member in a resource directory. In this case, the `TaskType` parameter is set to `aliyun_fc`.
        self.target_user_id = target_user_id  # type: long
        # The ID of the metric import task.
        self.task_id = task_id  # type: str
        # The type of the metric import task. Valid values:
        # 
        # *   aliyun_fc: metric import tasks for Alibaba Cloud services
        # *   aliyun_sls: metrics for logs imported from Log Service
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.include_aliyun_task is not None:
            result['IncludeAliyunTask'] = self.include_aliyun_task
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('IncludeAliyunTask') is not None:
            self.include_aliyun_task = m.get('IncludeAliyunTask')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels(TeaModel):
    def __init__(self, name=None, value=None):
        # The tag key.
        self.name = name  # type: str
        # The tag value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress(TeaModel):
    def __init__(self, function=None, name=None, value=None):
        # The method that is used to match the instance name. Valid values:
        # 
        # *   startWith: starts with a prefix
        # *   endWith: ends with a suffix
        # *   all: matches all
        # *   equals: equals
        # *   contains: contains
        # *   notContains: does not contain
        self.function = function  # type: str
        # The instance name.
        self.name = name  # type: str
        # The keyword that corresponds to the instance name.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress(TeaModel):
    def __init__(self, alias=None, express=None):
        # The alias of the extended field that indicates the result of basic operations that are performed on aggregation results.
        self.alias = alias  # type: str
        # The extended field that indicates the result of basic operations that are performed on aggregation results.
        self.express = express  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.express is not None:
            result['Express'] = self.express
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters(TeaModel):
    def __init__(self, operator=None, slskey_name=None, value=None):
        # The method that is used to filter logs imported from Log Service. Valid values:
        # 
        # *   `contain`: contains
        # *   `notContain`: does not contain
        # *   `>`: greater than
        # *   `<`: less than
        # *   `=`: equal to
        # *   `! =`: not equal to
        # *   `>=`: greater than or equal to
        # *   `<=`: less than or equal to
        self.operator = operator  # type: str
        # The name of the key that is used to filter logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str
        # The value of the key that is used to filter logs imported from Log Service.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter(TeaModel):
    def __init__(self, filters=None, relation=None):
        # The conditions that are used to filter logs imported from Log Service.
        self.filters = filters  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters]
        # The relationship between multiple filter conditions. Valid values:
        # 
        # *   and (default): Logs are processed only if all filter conditions are met.
        # *   or: Logs are processed if one of the filter conditions is met.
        self.relation = relation  # type: str

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['Filters'].append(k.to_map() if k else None)
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filters = []
        if m.get('Filters') is not None:
            for k in m.get('Filters'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilterFilters()
                self.filters.append(temp_model.from_map(k))
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy(TeaModel):
    def __init__(self, alias=None, slskey_name=None):
        # The alias of the aggregation result.
        self.alias = alias  # type: str
        # The name of the key that is used to aggregate logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics(TeaModel):
    def __init__(self, alias=None, function=None, parameter_1=None, parameter_2=None, slskey_name=None):
        # The alias of the aggregation result.
        self.alias = alias  # type: str
        # The function that is used to aggregate log data within a statistical period. Valid values:
        # 
        # *   count: counts the number.
        # *   sum: calculates the total value.
        # *   avg: calculates the average value.
        # *   max: calculates the maximum value.
        # *   min: calculates the minimum value.
        # *   value: collects samples within the statistical period.
        # *   countps: calculates the average number of the specified field per second by using the following formula: Counted number of the specified field/Total number of seconds within the statistical period.
        # *   sumps: calculates the average number of the specified field per second by using the following formula: Total value of the specified field/Total number of seconds within the statistical period.
        # *   distinct: counts the number of logs where the specified field appears within the statistical period.
        # *   distribution: counts the number of logs that meet a specified condition within the statistical period.
        # *   percentile: sorts the values of the specified field in ascending order, and then returns the value that is at the specified percentile within the statistical period. Example: P50.
        self.function = function  # type: str
        # The value of the function that is used to aggregate logs imported from Log Service.
        # 
        # *   If the `Function` parameter is set to `distribution`, this parameter indicates the lower limit of the statistical interval. For example, 200 indicates that the number of HTTP requests whose status code is 2XX is calculated.
        # *   If the `Function` parameter is set to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        self.parameter_1 = parameter_1  # type: str
        # The value of the function that is used to aggregate logs imported from Log Service.
        # 
        # > This parameter is returned only if the `Function` parameter is set to `distribution`. This parameter indicates the upper limit of the statistical interval. For example, 299 indicates that the number of HTTP requests whose status code is 2XX is calculated.
        self.parameter_2 = parameter_2  # type: str
        # The name of the key that is used to aggregate logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.function is not None:
            result['Function'] = self.function
        if self.parameter_1 is not None:
            result['Parameter1'] = self.parameter_1
        if self.parameter_2 is not None:
            result['Parameter2'] = self.parameter_2
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Parameter1') is not None:
            self.parameter_1 = m.get('Parameter1')
        if m.get('Parameter2') is not None:
            self.parameter_2 = m.get('Parameter2')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig(TeaModel):
    def __init__(self, express=None, filter=None, group_by=None, statistics=None):
        # The extended fields that indicate the results of basic operations that are performed on aggregation results.
        self.express = express  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress]
        # The conditions that are used to filter logs imported from Log Service.
        self.filter = filter  # type: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter
        # The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        self.group_by = group_by  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy]
        # The methods that are used to aggregate logs imported from Log Service.
        self.statistics = statistics  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics]

    def validate(self):
        if self.express:
            for k in self.express:
                if k:
                    k.validate()
        if self.filter:
            self.filter.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Express'] = []
        if self.express is not None:
            for k in self.express:
                result['Express'].append(k.to_map() if k else None)
        if self.filter is not None:
            result['Filter'] = self.filter.to_map()
        result['GroupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['GroupBy'].append(k.to_map() if k else None)
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.express = []
        if m.get('Express') is not None:
            for k in m.get('Express'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigExpress()
                self.express.append(temp_model.from_map(k))
        if m.get('Filter') is not None:
            temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigFilter()
            self.filter = temp_model.from_map(m['Filter'])
        self.group_by = []
        if m.get('GroupBy') is not None:
            for k in m.get('GroupBy'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigGroupBy()
                self.group_by.append(temp_model.from_map(k))
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfigStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class DescribeHybridMonitorTaskListResponseBodyTaskList(TeaModel):
    def __init__(self, attach_labels=None, collect_interval=None, collect_target_endpoint=None,
                 collect_target_path=None, collect_target_type=None, collect_timout=None, create_time=None, description=None,
                 extra_info=None, group_id=None, instances=None, log_file_path=None, log_process=None, log_sample=None,
                 log_split=None, match_express=None, match_express_relation=None, namespace=None, network_type=None,
                 slsprocess=None, slsprocess_config=None, target_user_id=None, task_id=None, task_name=None, task_type=None,
                 upload_region=None, yarmconfig=None):
        # The tags of the metric import task.
        self.attach_labels = attach_labels  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels]
        # The interval at which the CloudMonitor agent collects host monitoring data. Valid values:
        # 
        # *   15
        # *   30
        # *   60
        # 
        # Unit: seconds.
        self.collect_interval = collect_interval  # type: int
        # The URL of the destination from which the CloudMonitor agent collects host monitoring data.
        self.collect_target_endpoint = collect_target_endpoint  # type: str
        # The relative path from which the CloudMonitor agent collects monitoring data.
        self.collect_target_path = collect_target_path  # type: str
        # The type of the monitoring data. Valid values: Spring, Tomcat, Nginx, Tengine, JVM, Redis, and MySQL.
        self.collect_target_type = collect_target_type  # type: str
        # The timeout period during which the CloudMonitor agent collects host monitoring data. Valid values:
        # 
        # *   0
        # *   15
        # *   30
        # *   60
        # 
        # Unit: seconds.
        self.collect_timout = collect_timout  # type: int
        # The timestamp when the metric import task was created.
        # 
        # Unit: milliseconds.
        self.create_time = create_time  # type: str
        # The description of the metric import task.
        self.description = description  # type: str
        # The additional information of the instance.
        self.extra_info = extra_info  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The instances where monitoring data is collected in batches.
        self.instances = instances  # type: list[str]
        self.log_file_path = log_file_path  # type: str
        # The method that is used to aggregate on-premises log data.
        self.log_process = log_process  # type: str
        # The sample on-premises log.
        self.log_sample = log_sample  # type: str
        # The result that is returned after on-premises log data is split based on the specified matching mode.
        # 
        # > The matching modes of on-premises log data include full regex mode, delimiter mode, and JSON mode.
        self.log_split = log_split  # type: str
        # The conditions that are used to match the instances in the application group.
        self.match_express = match_express  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress]
        # The relationship between the conditions that are used to filter metric import tasks. Valid values:
        # 
        # *   or
        # *   and
        self.match_express_relation = match_express_relation  # type: str
        # The namespace to which the host belongs.
        self.namespace = namespace  # type: str
        # The network type of the host. Valid values:
        # 
        # *   `vpc`
        # *   `Internet`
        self.network_type = network_type  # type: str
        # The configurations of the logs that are imported from Log Service.
        self.slsprocess = slsprocess  # type: str
        # The configurations of the logs that are imported from Log Service.
        # 
        # > This parameter is returned only if the `TaskType` parameter is set to `aliyun_sls`.
        self.slsprocess_config = slsprocess_config  # type: DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig
        # The ID of the member account.
        # 
        # > This parameter is displayed only when you call this operation by using a management account.
        self.target_user_id = target_user_id  # type: str
        # The ID of the metric import task.
        self.task_id = task_id  # type: str
        # The name of the metric import task.
        self.task_name = task_name  # type: str
        # The type of the metric import task. Valid values:
        # 
        # *   aliyun_fc: metric import tasks for Alibaba Cloud services
        # *   aliyun_sls: metrics for logs imported from Log Service
        self.task_type = task_type  # type: str
        # The region where the host resides.
        self.upload_region = upload_region  # type: str
        # The configuration file of the Alibaba Cloud service that you want to monitor by using Hybrid Cloud Monitoring.
        # 
        # *   namespace: the namespace of the Alibaba Cloud service.
        # *   metric_list: the metrics of the Alibaba Cloud service.
        self.yarmconfig = yarmconfig  # type: str

    def validate(self):
        if self.attach_labels:
            for k in self.attach_labels:
                if k:
                    k.validate()
        if self.match_express:
            for k in self.match_express:
                if k:
                    k.validate()
        if self.slsprocess_config:
            self.slsprocess_config.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBodyTaskList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttachLabels'] = []
        if self.attach_labels is not None:
            for k in self.attach_labels:
                result['AttachLabels'].append(k.to_map() if k else None)
        if self.collect_interval is not None:
            result['CollectInterval'] = self.collect_interval
        if self.collect_target_endpoint is not None:
            result['CollectTargetEndpoint'] = self.collect_target_endpoint
        if self.collect_target_path is not None:
            result['CollectTargetPath'] = self.collect_target_path
        if self.collect_target_type is not None:
            result['CollectTargetType'] = self.collect_target_type
        if self.collect_timout is not None:
            result['CollectTimout'] = self.collect_timout
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.log_file_path is not None:
            result['LogFilePath'] = self.log_file_path
        if self.log_process is not None:
            result['LogProcess'] = self.log_process
        if self.log_sample is not None:
            result['LogSample'] = self.log_sample
        if self.log_split is not None:
            result['LogSplit'] = self.log_split
        result['MatchExpress'] = []
        if self.match_express is not None:
            for k in self.match_express:
                result['MatchExpress'].append(k.to_map() if k else None)
        if self.match_express_relation is not None:
            result['MatchExpressRelation'] = self.match_express_relation
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.slsprocess is not None:
            result['SLSProcess'] = self.slsprocess
        if self.slsprocess_config is not None:
            result['SLSProcessConfig'] = self.slsprocess_config.to_map()
        if self.target_user_id is not None:
            result['TargetUserId'] = self.target_user_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.upload_region is not None:
            result['UploadRegion'] = self.upload_region
        if self.yarmconfig is not None:
            result['YARMConfig'] = self.yarmconfig
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.attach_labels = []
        if m.get('AttachLabels') is not None:
            for k in m.get('AttachLabels'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListAttachLabels()
                self.attach_labels.append(temp_model.from_map(k))
        if m.get('CollectInterval') is not None:
            self.collect_interval = m.get('CollectInterval')
        if m.get('CollectTargetEndpoint') is not None:
            self.collect_target_endpoint = m.get('CollectTargetEndpoint')
        if m.get('CollectTargetPath') is not None:
            self.collect_target_path = m.get('CollectTargetPath')
        if m.get('CollectTargetType') is not None:
            self.collect_target_type = m.get('CollectTargetType')
        if m.get('CollectTimout') is not None:
            self.collect_timout = m.get('CollectTimout')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('LogFilePath') is not None:
            self.log_file_path = m.get('LogFilePath')
        if m.get('LogProcess') is not None:
            self.log_process = m.get('LogProcess')
        if m.get('LogSample') is not None:
            self.log_sample = m.get('LogSample')
        if m.get('LogSplit') is not None:
            self.log_split = m.get('LogSplit')
        self.match_express = []
        if m.get('MatchExpress') is not None:
            for k in m.get('MatchExpress'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListMatchExpress()
                self.match_express.append(temp_model.from_map(k))
        if m.get('MatchExpressRelation') is not None:
            self.match_express_relation = m.get('MatchExpressRelation')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('SLSProcess') is not None:
            self.slsprocess = m.get('SLSProcess')
        if m.get('SLSProcessConfig') is not None:
            temp_model = DescribeHybridMonitorTaskListResponseBodyTaskListSLSProcessConfig()
            self.slsprocess_config = temp_model.from_map(m['SLSProcessConfig'])
        if m.get('TargetUserId') is not None:
            self.target_user_id = m.get('TargetUserId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UploadRegion') is not None:
            self.upload_region = m.get('UploadRegion')
        if m.get('YARMConfig') is not None:
            self.yarmconfig = m.get('YARMConfig')
        return self


class DescribeHybridMonitorTaskListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, success=None,
                 task_list=None, total=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned message.
        # 
        # *   If the request was successful, the value `successful` is returned.
        # *   If the request failed, an error message is returned.
        self.message = message  # type: str
        # The page number.
        self.page_number = page_number  # type: int
        # The number of entries per page.
        self.page_size = page_size  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str
        # The metric import tasks.
        self.task_list = task_list  # type: list[DescribeHybridMonitorTaskListResponseBodyTaskList]
        # The total number of entries returned.
        self.total = total  # type: int

    def validate(self):
        if self.task_list:
            for k in self.task_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        result['TaskList'] = []
        if self.task_list is not None:
            for k in self.task_list:
                result['TaskList'].append(k.to_map() if k else None)
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        self.task_list = []
        if m.get('TaskList') is not None:
            for k in m.get('TaskList'):
                temp_model = DescribeHybridMonitorTaskListResponseBodyTaskList()
                self.task_list.append(temp_model.from_map(k))
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeHybridMonitorTaskListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeHybridMonitorTaskListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeHybridMonitorTaskListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeHybridMonitorTaskListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogMonitorAttributeRequest(TeaModel):
    def __init__(self, metric_name=None, region_id=None):
        # The name of the log monitoring metric. Exact match is supported.
        # 
        # For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates(TeaModel):
    def __init__(self, alias=None, field_name=None, function=None, max=None, min=None):
        # The alias of the aggregate function.
        self.alias = alias  # type: str
        # The name of the field in logs.
        self.field_name = field_name  # type: str
        # The function that is used to aggregate the monitoring data of logs within an aggregation period. Valid values:
        # 
        # *   count: counts the number.
        # *   sum: calculates the total value.
        # *   avg: calculates the average value.
        # *   max: selects the maximum value.
        # *   min: selects the minimum value.
        # *   countps: calculates the counted number of the specified field divided by the total number of seconds of the aggregation period.
        # *   sumps: calculates the total value of the specified field divided by the total number of seconds of the aggregation period.
        # *   distinct: counts the number of logs where the specified field appears within the aggregation period.
        self.function = function  # type: str
        # The maximum value.
        self.max = max  # type: str
        # The minimum value.
        self.min = min  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.function is not None:
            result['Function'] = self.function
        if self.max is not None:
            result['Max'] = self.max
        if self.min is not None:
            result['Min'] = self.min
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Max') is not None:
            self.max = m.get('Max')
        if m.get('Min') is not None:
            self.min = m.get('Min')
        return self


class DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter(TeaModel):
    def __init__(self, key=None, operator=None, value=None):
        # The name of the log field used for matching in the filter condition.
        self.key = key  # type: str
        # The method that is used to match the field value. Valid values:
        # 
        # *   `contain`
        # *   `notContain`
        # *   `>`: greater than
        # *   `<`: less than
        # *   `>=`: greater than or equal to
        # *   `<=`: less than or equal to
        self.operator = operator  # type: str
        # The field value to be matched in the filter condition.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLogMonitorAttributeResponseBodyLogMonitor(TeaModel):
    def __init__(self, aggregates=None, gmt_create=None, group_id=None, groupbys=None, log_id=None,
                 metric_express=None, metric_name=None, sls_logstore=None, sls_project=None, sls_region_id=None,
                 tumblingwindows=None, value_filter=None, value_filter_relation=None):
        # The aggregate functions.
        self.aggregates = aggregates  # type: list[DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates]
        # The time when the log monitoring metric was created.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.gmt_create = gmt_create  # type: long
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The dimension based on which the data is grouped. This parameter is equivalent to the GROUP BY clause in SQL statements. If no dimension is specified, all data is aggregated based on the aggregate function.
        self.groupbys = groupbys  # type: list[str]
        # The ID returned by Log Service.
        self.log_id = log_id  # type: long
        # The extended field. The extended field allows you to perform basic operations on the aggregation results.
        # 
        # Assume that you have calculated TotalNumber and 5XXNumber by aggregating the data. TotalNumber indicates the total number of HTTP requests, and 5XXNumber indicates the number of HTTP requests whose status code is greater than 499. You can calculate the server error rate by adding the following formula to the extended field: 5XXNumber/TotalNumber\*100.
        self.metric_express = metric_express  # type: str
        # The name of the log monitoring metric. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The name of the Log Service Logstore.
        self.sls_logstore = sls_logstore  # type: str
        # The name of the Log Service project.
        self.sls_project = sls_project  # type: str
        # The ID of the region where the Log Service Logstore resides.
        self.sls_region_id = sls_region_id  # type: str
        # The size of the tumbling window for calculation. Unit: seconds. The system performs an aggregation for each tumbling window.
        self.tumblingwindows = tumblingwindows  # type: list[str]
        # The condition that is used to filter logs. The ValueFilter and ValueFilterRelation parameters are used in pair. The filter condition is equivalent to the WHERE clause in SQL statements.
        # 
        # If no filter condition is specified, all logs are processed. Assume that logs contain the Level field, which may be set to Error. If you need to calculate the number of times that logs of the Error level appear every minute, you can set the filter condition to Level=Error and count the number of logs that meet this condition.
        self.value_filter = value_filter  # type: list[DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter]
        # The logical operator that is used between log filter conditions. The ValueFilter and ValueFilterRelation parameters are used in pair. Valid values:
        # 
        # *   and
        # *   or
        self.value_filter_relation = value_filter_relation  # type: str

    def validate(self):
        if self.aggregates:
            for k in self.aggregates:
                if k:
                    k.validate()
        if self.value_filter:
            for k in self.value_filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeResponseBodyLogMonitor, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Aggregates'] = []
        if self.aggregates is not None:
            for k in self.aggregates:
                result['Aggregates'].append(k.to_map() if k else None)
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.groupbys is not None:
            result['Groupbys'] = self.groupbys
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.metric_express is not None:
            result['MetricExpress'] = self.metric_express
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.sls_logstore is not None:
            result['SlsLogstore'] = self.sls_logstore
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.sls_region_id is not None:
            result['SlsRegionId'] = self.sls_region_id
        if self.tumblingwindows is not None:
            result['Tumblingwindows'] = self.tumblingwindows
        result['ValueFilter'] = []
        if self.value_filter is not None:
            for k in self.value_filter:
                result['ValueFilter'].append(k.to_map() if k else None)
        if self.value_filter_relation is not None:
            result['ValueFilterRelation'] = self.value_filter_relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aggregates = []
        if m.get('Aggregates') is not None:
            for k in m.get('Aggregates'):
                temp_model = DescribeLogMonitorAttributeResponseBodyLogMonitorAggregates()
                self.aggregates.append(temp_model.from_map(k))
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Groupbys') is not None:
            self.groupbys = m.get('Groupbys')
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('MetricExpress') is not None:
            self.metric_express = m.get('MetricExpress')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('SlsLogstore') is not None:
            self.sls_logstore = m.get('SlsLogstore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('SlsRegionId') is not None:
            self.sls_region_id = m.get('SlsRegionId')
        if m.get('Tumblingwindows') is not None:
            self.tumblingwindows = m.get('Tumblingwindows')
        self.value_filter = []
        if m.get('ValueFilter') is not None:
            for k in m.get('ValueFilter'):
                temp_model = DescribeLogMonitorAttributeResponseBodyLogMonitorValueFilter()
                self.value_filter.append(temp_model.from_map(k))
        if m.get('ValueFilterRelation') is not None:
            self.value_filter_relation = m.get('ValueFilterRelation')
        return self


class DescribeLogMonitorAttributeResponseBody(TeaModel):
    def __init__(self, code=None, log_monitor=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The details of the log monitoring metric.
        self.log_monitor = log_monitor  # type: DescribeLogMonitorAttributeResponseBodyLogMonitor
        # The returned message. If the call was successful, the value success is returned. If the call failed, an error message is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.log_monitor:
            self.log_monitor.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.log_monitor is not None:
            result['LogMonitor'] = self.log_monitor.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('LogMonitor') is not None:
            temp_model = DescribeLogMonitorAttributeResponseBodyLogMonitor()
            self.log_monitor = temp_model.from_map(m['LogMonitor'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeLogMonitorAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLogMonitorAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogMonitorAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeLogMonitorListRequest(TeaModel):
    def __init__(self, group_id=None, page_number=None, page_size=None, region_id=None, search_value=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 10
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The keyword that is used to search for log monitoring metrics. Fuzzy match is supported.
        self.search_value = search_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMonitorListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_value is not None:
            result['SearchValue'] = self.search_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchValue') is not None:
            self.search_value = m.get('SearchValue')
        return self


class DescribeLogMonitorListResponseBodyLogMonitorListValueFilter(TeaModel):
    def __init__(self, key=None, operator=None, value=None):
        # The name of the log field used for matching in the filter condition.
        self.key = key  # type: str
        # The method that is used to match the field value. Valid values:
        # 
        # *   contain
        # *   notContain
        # *   `>`: greater than
        # *   `<`: less than
        # *   `>=`: greater than or equal to
        # *   `<=`: less than or equal to
        self.operator = operator  # type: str
        # The field value to be matched in the filter condition.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeLogMonitorListResponseBodyLogMonitorListValueFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeLogMonitorListResponseBodyLogMonitorList(TeaModel):
    def __init__(self, gmt_create=None, group_id=None, log_id=None, metric_name=None, sls_logstore=None,
                 sls_project=None, sls_region_id=None, value_filter=None, value_filter_relation=None):
        # The time when the log monitoring metric was created.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.gmt_create = gmt_create  # type: long
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ID returned by Log Service.
        self.log_id = log_id  # type: long
        # The name of the log monitoring metric. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The name of the Log Service Logstore.
        self.sls_logstore = sls_logstore  # type: str
        # The name of the Log Service project.
        self.sls_project = sls_project  # type: str
        # The ID of the region where the Log Service Logstore resides.
        self.sls_region_id = sls_region_id  # type: str
        # The condition that is used to filter logs. The ValueFilter and ValueFilterRelation parameters are used in pair. The filter condition is equivalent to the WHERE clause in SQL statements.
        # 
        # If no filter condition is specified, all logs are processed. Assume that logs contain the Level field, which may be set to Error. If you need to calculate the number of times that logs of the Error level appear every minute, you can set the filter condition to Level=Error and count the number of logs that meet this condition.
        self.value_filter = value_filter  # type: list[DescribeLogMonitorListResponseBodyLogMonitorListValueFilter]
        # The logical operator that is used between log filter conditions. The ValueFilter and ValueFilterRelation parameters are used in pair. Valid values:
        # 
        # *   and
        # *   or
        self.value_filter_relation = value_filter_relation  # type: str

    def validate(self):
        if self.value_filter:
            for k in self.value_filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorListResponseBodyLogMonitorList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.sls_logstore is not None:
            result['SlsLogstore'] = self.sls_logstore
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.sls_region_id is not None:
            result['SlsRegionId'] = self.sls_region_id
        result['ValueFilter'] = []
        if self.value_filter is not None:
            for k in self.value_filter:
                result['ValueFilter'].append(k.to_map() if k else None)
        if self.value_filter_relation is not None:
            result['ValueFilterRelation'] = self.value_filter_relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('SlsLogstore') is not None:
            self.sls_logstore = m.get('SlsLogstore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('SlsRegionId') is not None:
            self.sls_region_id = m.get('SlsRegionId')
        self.value_filter = []
        if m.get('ValueFilter') is not None:
            for k in m.get('ValueFilter'):
                temp_model = DescribeLogMonitorListResponseBodyLogMonitorListValueFilter()
                self.value_filter.append(temp_model.from_map(k))
        if m.get('ValueFilterRelation') is not None:
            self.value_filter_relation = m.get('ValueFilterRelation')
        return self


class DescribeLogMonitorListResponseBody(TeaModel):
    def __init__(self, code=None, log_monitor_list=None, message=None, page_number=None, page_size=None,
                 request_id=None, success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The log monitoring metrics.
        self.log_monitor_list = log_monitor_list  # type: list[DescribeLogMonitorListResponseBodyLogMonitorList]
        # The returned message.
        self.message = message  # type: str
        # The number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned on each page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The total number of the returned entries.
        self.total = total  # type: long

    def validate(self):
        if self.log_monitor_list:
            for k in self.log_monitor_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['LogMonitorList'] = []
        if self.log_monitor_list is not None:
            for k in self.log_monitor_list:
                result['LogMonitorList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.log_monitor_list = []
        if m.get('LogMonitorList') is not None:
            for k in m.get('LogMonitorList'):
                temp_model = DescribeLogMonitorListResponseBodyLogMonitorList()
                self.log_monitor_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeLogMonitorListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeLogMonitorListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeLogMonitorListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeLogMonitorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricDataRequest(TeaModel):
    def __init__(self, dimensions=None, end_time=None, express=None, length=None, metric_name=None, namespace=None,
                 period=None, region_id=None, start_time=None):
        # The dimensions that specify the resources whose monitoring data you want to query.
        # 
        # Set the value to a collection of key-value pairs. A typical key-value pair is `instanceId:i-2ze2d6j5uhg20x47****`.
        # 
        # >  You can query a maximum of 50 instances in a single request.
        self.dimensions = dimensions  # type: str
        # The end of the time range to query.
        # 
        # *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
        # 
        # *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.```` The following examples demonstrate how to determine the period in which monitoring data is queried:
        # 
        #     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
        # 
        # The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        # 
        # >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.end_time = end_time  # type: str
        # The expression that is used to compute the query results in real time.
        # 
        # >  Only the `groupby` expression is supported. This expression is similar to the `GROUP BY` statement that is used in databases.
        self.express = express  # type: str
        # The number of entries to return on each page.
        # 
        # Default value: 1000.
        # 
        # >  The maximum value of the Length parameter in a request is 1440.
        self.length = length  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about the metrics of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The statistical period of the metric.
        # 
        # Valid values: 15, 60, 900, and 3600.
        # 
        # Unit: seconds.
        # 
        # > - If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported.
        # > - For more information about the statistical period of a metric that is specified by the `MetricName` parameter, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        self.region_id = region_id  # type: str
        # The beginning of the time range to query.
        # 
        # *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
        # 
        # *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.```` The following examples demonstrate how to determine the period in which monitoring data is queried:
        # 
        #     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
        # 
        # The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        # 
        # > 
        # *   You must set the `StartTime` parameter to a point in time that is later than 00:00:00 Thursday, January 1, 1970. Otherwise, this parameter is invalid.
        # *   We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.express is not None:
            result['Express'] = self.express
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMetricDataResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, period=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The monitoring data. The value includes the following fields:
        # 
        # *   `timestamp`: the timestamp when the alert was triggered.
        # *   `userId`: the ID of the user for which the alert was triggered.
        # *   `instanceId`: the ID of the instance for which the alert was triggered.
        # *   `Minimum`, `Average`, and `Maximum`: the aggregation methods.
        self.datapoints = datapoints  # type: str
        # The error message.
        self.message = message  # type: str
        # The statistical period of the monitoring data.
        # 
        # Valid values: 15, 60, 900, and 3600.
        # 
        # Unit: seconds.
        self.period = period  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints
        if self.message is not None:
            result['Message'] = self.message
        if self.period is not None:
            result['Period'] = self.period
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            self.datapoints = m.get('Datapoints')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricLastRequest(TeaModel):
    def __init__(self, dimensions=None, end_time=None, express=None, length=None, metric_name=None, namespace=None,
                 next_token=None, period=None, region_id=None, start_time=None):
        # The monitoring dimensions of the specified resource.
        # 
        # Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
        # 
        # >  You can query a maximum of 50 instances in each request.
        self.dimensions = dimensions  # type: str
        # The end of the time range to query monitoring data.
        # 
        # *   For second-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and 20 minutes earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
        # *   For minute-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and 2 hours earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
        # *   For hour-level data, the start time is obtained by comparing the time that is specified by the StartTime parameter and two days earlier of the time that is specified by the EndTime parameter. The earlier one of the compared points in time is used as the start time.
        self.end_time = end_time  # type: str
        # The expression that is used to calculate the query results in real time.
        self.express = express  # type: str
        # The number of entries per page.
        # 
        # Default value: 1000. This value indicates that a maximum of 1,000 entries of monitoring data can be returned on each page.
        # 
        # >  The maximum value of the Length parameter for each request is 1440.
        self.length = length  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about metric names, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The pagination token.
        # 
        # *   If the number of results exceeds the maximum number of entries allowed on a single page, a pagination token is returned.
        # *   This token can be used as an input parameter to obtain the next page of results. If all results are obtained, no token is returned.
        self.next_token = next_token  # type: str
        # The statistical period of the monitoring data.
        # 
        # Valid values: 15, 60, 900, and 3600.
        # 
        # Unit: seconds.
        # 
        # > 
        # 
        # *   If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported. The statistical period of metrics (`MetricName`) varies for each cloud service. The statistical period of metrics is displayed in the `MinPeriods` column on the **Metrics** page for each cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        self.region_id = region_id  # type: str
        # The start of the time range to query monitoring data.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricLastRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.express is not None:
            result['Express'] = self.express
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMetricLastResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, next_token=None, period=None, request_id=None,
                 success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The monitoring data.
        self.datapoints = datapoints  # type: str
        # The error message.
        self.message = message  # type: str
        # The pagination token.
        self.next_token = next_token  # type: str
        # The time interval.
        # 
        # Unit: seconds.
        self.period = period  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricLastResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.period is not None:
            result['Period'] = self.period
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            self.datapoints = m.get('Datapoints')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMetricLastResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricLastResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricLastResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricLastResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricListRequest(TeaModel):
    def __init__(self, dimensions=None, end_time=None, express=None, length=None, metric_name=None, namespace=None,
                 next_token=None, period=None, region_id=None, start_time=None):
        # The dimensions that specify the resources whose monitoring data you want to query.
        # 
        # Set the value to a collection of key-value pairs. A typical key-value pair is `instanceId:i-2ze2d6j5uhg20x47****`.
        # 
        # >  You can query a maximum of 50 instances in a single request.
        self.dimensions = dimensions  # type: str
        # The end of the time range to query. The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        self.end_time = end_time  # type: str
        # The expression that is used to compute the query results in real time.
        # 
        # >  Only the groupby expression is supported. This expression is similar to the GROUP BY statement that is used in databases.
        self.express = express  # type: str
        # The number of entries to return on each page.
        # 
        # >  The maximum value of the Length parameter in a request is 1440.
        self.length = length  # type: str
        # The name of the metric.
        # 
        # For more information about metric names, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service. Format: acs_service name.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The paging token.
        # 
        # >  If this parameter is not specified, the data on the first page is returned. A return value other than Null of this parameter indicates that not all entries have been returned. You can use this value as an input parameter to obtain entries on the next page. The value Null indicates that all query results have been returned.
        self.next_token = next_token  # type: str
        # The interval at which the monitoring data is queried.
        # 
        # Valid values: 60, 300, and 900.
        # 
        # Unit: seconds.
        # 
        # >  Configure this parameter based on your business scenario.
        self.period = period  # type: str
        self.region_id = region_id  # type: str
        # The beginning of the time range to query. The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        # 
        # >  The specified period includes the end time and excludes the start time. The start time must be earlier than the end time.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.express is not None:
            result['Express'] = self.express
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMetricListResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, next_token=None, period=None, request_id=None,
                 success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The monitoring data.
        self.datapoints = datapoints  # type: str
        # The error message.
        self.message = message  # type: str
        # The paging token.
        self.next_token = next_token  # type: str
        # The interval at which the monitoring data is queried. Unit: seconds. Valid values: 60, 300, and 900.
        self.period = period  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.period is not None:
            result['Period'] = self.period
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            self.datapoints = m.get('Datapoints')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMetricListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricMetaListRequest(TeaModel):
    def __init__(self, labels=None, metric_name=None, namespace=None, page_number=None, page_size=None,
                 region_id=None):
        # The tags for filtering metrics. Specify a JSON string.
        # 
        # Format:`[{"name":"tag name","value":"tag value"},{"name":"tag name","value":"tag value"}]`. The following tags are available:
        # 
        # *   metricCategory: the category of the metric.
        # *   alertEnable: specifies whether to report alerts for the metric.
        # *   alertUnit: the suggested unit of the metric value in alerts.
        # *   unitFactor: the factor for metric unit conversion.
        # *   minAlertPeriod: the minimum time interval to report a new alert.
        # *   productCategory: the category of the service.
        self.labels = labels  # type: str
        # The name of the metric. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the service.
        # 
        # For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The page to return. Default value: 1
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 30.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricMetaListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMetricMetaListResponseBodyResourcesResource(TeaModel):
    def __init__(self, description=None, dimensions=None, labels=None, metric_name=None, namespace=None,
                 periods=None, statistics=None, unit=None):
        # The description of the metric.
        self.description = description  # type: str
        # The dimensions of the metric. Multiple dimensions are separated with commas (,).
        self.dimensions = dimensions  # type: str
        # The tags of the metric, including one or more JSON strings. Format: `[{"name":"tag name","value":"tag value"}]`. The `name` can be repeated.
        # 
        # The following tags are available:
        # 
        # *   metricCategory: the category of the metric.
        # *   alertEnable: specifies whether to report alerts for the metric.
        # *   alertUnit: the suggested unit of the metric value in alerts.
        # *   unitFactor: the factor for metric unit conversion.
        # *   minAlertPeriod: the minimum time interval to report a new alert.
        # *   productCategory: the category of the service.
        self.labels = labels  # type: str
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        # The namespace of the service. The value is usually in the format of acs_Service.
        self.namespace = namespace  # type: str
        # The statistical period of the metric. Multiple statistical periods are separated with commas (,).
        self.periods = periods  # type: str
        # The statistical method. Multiple statistic methods are separated with commas (,).
        self.statistics = statistics  # type: str
        # The unit of the metric.
        self.unit = unit  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricMetaListResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.periods is not None:
            result['Periods'] = self.periods
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.unit is not None:
            result['Unit'] = self.unit
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Periods') is not None:
            self.periods = m.get('Periods')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        return self


class DescribeMetricMetaListResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeMetricMetaListResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricMetaListResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeMetricMetaListResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeMetricMetaListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resources=None, success=None, total_count=None):
        # The response code.
        # 
        # >  The HTTP 200 code indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The configuration of the metric.
        self.resources = resources  # type: DescribeMetricMetaListResponseBodyResources
        # Indicates whether the request was successful. The value true indicates success. The value false indicates failure.
        self.success = success  # type: bool
        # The total number of returned records.
        self.total_count = total_count  # type: str

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeMetricMetaListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeMetricMetaListResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeMetricMetaListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricMetaListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricMetaListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricMetaListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleBlackListRequest(TeaModel):
    def __init__(self, category=None, ids=None, instance_ids=None, is_enable=None, name=None, namespace=None,
                 order=None, page_number=None, page_size=None, region_id=None, scope_type=None):
        # The ID of the blacklist policy.
        self.category = category  # type: str
        self.ids = ids  # type: list[str]
        # The IDs of the instances in the blacklist policy.
        # 
        # Valid values of N: 0 to 10.
        self.instance_ids = instance_ids  # type: list[str]
        # The status of the blacklist policy. Valid values:
        # 
        # *   true: The blacklist policy is enabled.
        # *   false: The blacklist policy is disabled.
        self.is_enable = is_enable  # type: bool
        # The name of the blacklist policy.
        # 
        # This parameter supports fuzzy match.
        self.name = name  # type: str
        # The timestamp when the blacklist policy expired.
        # 
        # Unit: milliseconds.
        self.namespace = namespace  # type: str
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.order = order  # type: int
        # The name of the metric.
        self.page_number = page_number  # type: int
        # The categories of the Alibaba Cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The effective scope of the blacklist policy. Valid values:
        # 
        # *   USER: The blacklist policy takes effect only within the current Alibaba Cloud account.
        # *   GROUP: The blacklist policy takes effect only within the specified application group.
        self.scope_type = scope_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleBlackListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.ids is not None:
            result['Ids'] = self.ids
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.order is not None:
            result['Order'] = self.order
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Ids') is not None:
            self.ids = m.get('Ids')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        return self


class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics(TeaModel):
    def __init__(self, metric_name=None, resource=None):
        # For more information about common request parameters, see [Common parameters](~~199331~~).
        self.metric_name = metric_name  # type: str
        # The ID of the request.
        self.resource = resource  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.resource is not None:
            result['Resource'] = self.resource
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        return self


class DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList(TeaModel):
    def __init__(self, category=None, create_time=None, effective_time=None, enable_end_time=None,
                 enable_start_time=None, id=None, instances=None, is_enable=None, metrics=None, name=None, namespace=None,
                 scope_type=None, scope_value=None, update_time=None):
        # The name of the blacklist policy.
        self.category = category  # type: str
        # The metrics of the instance.
        self.create_time = create_time  # type: str
        # The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
        self.effective_time = effective_time  # type: str
        # The number of entries to return on each page.
        # 
        # Default value: 10.
        self.enable_end_time = enable_end_time  # type: long
        # The ID of the application group. The value of this parameter is a JSON array.
        # 
        # >  This parameter is returned only if the `ScopeType` parameter is set to `GROUP`.
        self.enable_start_time = enable_start_time  # type: long
        # The timestamp when the blacklist policy was modified.
        # 
        # Unit: milliseconds.
        self.id = id  # type: str
        self.instances = instances  # type: list[str]
        # The total number of blacklist policies.
        self.is_enable = is_enable  # type: bool
        # The method that is used to sort query results by time. Valid values:
        # 
        # *   DESC (default): descending order
        # *   ASC: ascending order
        self.metrics = metrics  # type: list[DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics]
        # The status of the blacklist policy. Valid values:
        # 
        # *   true: The blacklist policy is enabled.
        # *   false: The blacklist policy is disabled.
        self.name = name  # type: str
        # The number of the page to return.
        # 
        # Default value: 1.
        self.namespace = namespace  # type: str
        # The IDs of instances that belong to the specified cloud service.
        self.scope_type = scope_type  # type: str
        self.scope_value = scope_value  # type: list[str]
        # The ID of the blacklist policy.
        self.update_time = update_time  # type: str

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.effective_time is not None:
            result['EffectiveTime'] = self.effective_time
        if self.enable_end_time is not None:
            result['EnableEndTime'] = self.enable_end_time
        if self.enable_start_time is not None:
            result['EnableStartTime'] = self.enable_start_time
        if self.id is not None:
            result['Id'] = self.id
        if self.instances is not None:
            result['Instances'] = self.instances
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EffectiveTime') is not None:
            self.effective_time = m.get('EffectiveTime')
        if m.get('EnableEndTime') is not None:
            self.enable_end_time = m.get('EnableEndTime')
        if m.get('EnableStartTime') is not None:
            self.enable_start_time = m.get('EnableStartTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackListMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeMetricRuleBlackListResponseBody(TeaModel):
    def __init__(self, code=None, describe_metric_rule_black_list=None, message=None, request_id=None, success=None,
                 total=None):
        # The categories of the Alibaba Cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
        self.code = code  # type: str
        # The timestamp when the blacklist policy started to take effect.
        # 
        # Unit: milliseconds.
        self.describe_metric_rule_black_list = describe_metric_rule_black_list  # type: list[DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList]
        # The error message.
        self.message = message  # type: str
        # The namespace of the cloud service.
        self.request_id = request_id  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.success = success  # type: bool
        # The timestamp when the blacklist policy was created.
        # 
        # Unit: milliseconds.
        self.total = total  # type: int

    def validate(self):
        if self.describe_metric_rule_black_list:
            for k in self.describe_metric_rule_black_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleBlackListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['DescribeMetricRuleBlackList'] = []
        if self.describe_metric_rule_black_list is not None:
            for k in self.describe_metric_rule_black_list:
                result['DescribeMetricRuleBlackList'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.describe_metric_rule_black_list = []
        if m.get('DescribeMetricRuleBlackList') is not None:
            for k in m.get('DescribeMetricRuleBlackList'):
                temp_model = DescribeMetricRuleBlackListResponseBodyDescribeMetricRuleBlackList()
                self.describe_metric_rule_black_list.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMetricRuleBlackListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleBlackListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleBlackListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleBlackListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleCountRequest(TeaModel):
    def __init__(self, metric_name=None, namespace=None, region_id=None):
        # The name of the metric. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMetricRuleCountResponseBodyMetricRuleCount(TeaModel):
    def __init__(self, alarm=None, disable=None, nodata=None, ok=None, total=None):
        # The number of alert rules with active alerts.
        self.alarm = alarm  # type: int
        # The number of disabled alert rules.
        self.disable = disable  # type: int
        # The number of alert rules without data.
        self.nodata = nodata  # type: int
        # The number of alert rules without active alerts.
        self.ok = ok  # type: int
        # The total number of alert rules.
        self.total = total  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleCountResponseBodyMetricRuleCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm is not None:
            result['Alarm'] = self.alarm
        if self.disable is not None:
            result['Disable'] = self.disable
        if self.nodata is not None:
            result['Nodata'] = self.nodata
        if self.ok is not None:
            result['Ok'] = self.ok
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alarm') is not None:
            self.alarm = m.get('Alarm')
        if m.get('Disable') is not None:
            self.disable = m.get('Disable')
        if m.get('Nodata') is not None:
            self.nodata = m.get('Nodata')
        if m.get('Ok') is not None:
            self.ok = m.get('Ok')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMetricRuleCountResponseBody(TeaModel):
    def __init__(self, code=None, message=None, metric_rule_count=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The number of alert rules in each state.
        self.metric_rule_count = metric_rule_count  # type: DescribeMetricRuleCountResponseBodyMetricRuleCount
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.metric_rule_count:
            self.metric_rule_count.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.metric_rule_count is not None:
            result['MetricRuleCount'] = self.metric_rule_count.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricRuleCount') is not None:
            temp_model = DescribeMetricRuleCountResponseBodyMetricRuleCount()
            self.metric_rule_count = temp_model.from_map(m['MetricRuleCount'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMetricRuleCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleListRequest(TeaModel):
    def __init__(self, alert_state=None, dimensions=None, enable_state=None, group_id=None, metric_name=None,
                 namespace=None, page=None, page_size=None, region_id=None, rule_ids=None, rule_name=None):
        # The status of the alert rule. Valid values:
        # 
        # *   OK: The alert rule has no active alerts.
        # *   ALARM: The alert rule has active alerts.
        # *   INSUFFICIENT_DATA: No data is available.
        self.alert_state = alert_state  # type: str
        # The monitoring dimensions of the specified resource.
        # 
        # Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
        self.dimensions = dimensions  # type: str
        # Specifies whether to query enabled or disabled alert rules. Valid values:
        # 
        # *   true: queries enabled alert rules.
        # *   false: queries disabled alert rules.
        self.enable_state = enable_state  # type: bool
        # The ID of the application group.
        # 
        # For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The name of the metric.
        # 
        # For information about how to obtain the name of a metric, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The page number of the page to return.
        # 
        # Minimum value: 1. Default value: 1.
        self.page = page  # type: int
        # The number of entries to return on each page.
        # 
        # Minimum value: 1. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The ID of the alert rule. You can specify up to 20 IDs at a time. Separate multiple IDs with commas (,).
        self.rule_ids = rule_ids  # type: str
        # The name of the alert rule.
        # 
        # This parameter supports fuzzy match.
        self.rule_name = rule_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_state is not None:
            result['AlertState'] = self.alert_state
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.enable_state is not None:
            result['EnableState'] = self.enable_state
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_ids is not None:
            result['RuleIds'] = self.rule_ids
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertState') is not None:
            self.alert_state = m.get('AlertState')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EnableState') is not None:
            self.enable_state = m.get('EnableState')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleIds') is not None:
            self.rule_ids = m.get('RuleIds')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList(TeaModel):
    def __init__(self, comparison_operator=None, metric_name=None, period=None, statistics=None, threshold=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The metric that is used to monitor the cloud service.
        self.metric_name = metric_name  # type: str
        # The aggregation period of the metric.
        # 
        # Unit: seconds.
        self.period = period  # type: int
        # The statistical method of the metric. Valid values:
        # 
        # *   $Maximum: the maximum value
        # *   $Minimum: the minimum value
        # *   $Average: the average value
        # *   $Availability: the availability rate (usually used for site monitoring)
        # 
        # >  `$` is the prefix of the metric. For information about the Alibaba Cloud services that are supported by CloudMonitor, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList(TeaModel):
    def __init__(self, expression_list=None):
        self.expression_list = expression_list  # type: list[DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList]

    def validate(self):
        if self.expression_list:
            for k in self.expression_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExpressionList'] = []
        if self.expression_list is not None:
            for k in self.expression_list:
                result['ExpressionList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.expression_list = []
        if m.get('ExpressionList') is not None:
            for k in m.get('ExpressionList'):
                temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionListExpressionList()
                self.expression_list.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression(TeaModel):
    def __init__(self, expression_list=None, expression_list_join=None, expression_raw=None, level=None, times=None):
        # The trigger conditions that are created in standard mode.
        self.expression_list = expression_list  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList
        # The relationship between the trigger conditions for multiple metrics. Valid values:
        # 
        # *   `&&`: An alert is triggered only if all metrics meet the trigger conditions. An alert is triggered only if the results of all expressions specified in the ExpressionList parameter are `true`.
        # *   `||`: An alert is triggered if one of the metrics meets the trigger conditions.
        self.expression_list_join = expression_list_join  # type: str
        # The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
        # 
        # *   Set an alert blacklist for specific resources. For example, if you specify `$instanceId != \"i-io8kfvcpp7x5****\" ``&&`` $Average > 50`, no alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
        # *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \"i-io8kfvcpp7x5****\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
        # *   Limit the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the number of instances whose `average metric value` exceeds 20 exceeds three.
        self.expression_raw = expression_raw  # type: str
        # The level of the alert. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        self.level = level  # type: str
        # The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        self.times = times  # type: int

    def validate(self):
        if self.expression_list:
            self.expression_list.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expression_list is not None:
            result['ExpressionList'] = self.expression_list.to_map()
        if self.expression_list_join is not None:
            result['ExpressionListJoin'] = self.expression_list_join
        if self.expression_raw is not None:
            result['ExpressionRaw'] = self.expression_raw
        if self.level is not None:
            result['Level'] = self.level
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExpressionList') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpressionExpressionList()
            self.expression_list = temp_model.from_map(m['ExpressionList'])
        if m.get('ExpressionListJoin') is not None:
            self.expression_list_join = m.get('ExpressionListJoin')
        if m.get('ExpressionRaw') is not None:
            self.expression_raw = m.get('ExpressionRaw')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, pre_condition=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The additional conditions for triggering Critical-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
        # 
        # For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
        # 
        # >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
        self.pre_condition = pre_condition  # type: str
        # The statistical methods for Critical-level alerts.
        self.statistics = statistics  # type: str
        # The threshold for Critical-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, pre_condition=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The additional conditions for triggering Info-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
        # 
        # For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
        # 
        # >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
        self.pre_condition = pre_condition  # type: str
        # The statistical methods for Info-level alerts.
        self.statistics = statistics  # type: str
        # The threshold for Info-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, pre_condition=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The additional conditions for triggering Warn-level alerts. The additional conditions take effect when the value of the ComparisonOperator parameter is GreaterThanYesterday, LessThanYesterday, GreaterThanLastWeek, LessThanLastWeek, GreaterThanLastPeriod, or LessThanLastPeriod.
        # 
        # For example, the values of the PreCondition, ComparisonOperator, and Threshold parameters are set to $Average>80, GreaterThanYesterday, and 10, respectively. An alert is triggered only when the average metric value is greater than 80 and 10% greater than the average metric value at the same time yesterday.
        # 
        # >  $Average is a placeholder that consists of `a dollar sign ($) and the statistical method`. CloudMonitor replaces the placeholder with the aggregated value or original value before value comparison.
        self.pre_condition = pre_condition  # type: str
        # The statistical methods for Warn-level alerts.
        self.statistics = statistics  # type: str
        # The threshold for Warn-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        # The conditions for triggering Critical-level alerts.
        self.critical = critical  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical
        # The conditions for triggering Info-level alerts.
        self.info = info  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo
        # The conditions for triggering Warn-level alerts.
        self.warn = warn  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the alert rule.
        self.key = key  # type: str
        # The tag value of the alert rule.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmLabels(TeaModel):
    def __init__(self, labels=None):
        self.labels = labels  # type: list[DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels]

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmLabelsLabels()
                self.labels.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the annotation.
        self.key = key  # type: str
        # The value of the annotation.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations(TeaModel):
    def __init__(self, annotations=None):
        self.annotations = annotations  # type: list[DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations]

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotationsAnnotations()
                self.annotations.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus(TeaModel):
    def __init__(self, annotations=None, level=None, prom_ql=None, times=None):
        # The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        # 
        # >  This parameter is equivalent to the annotations parameter of open source Prometheus.
        self.annotations = annotations  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations
        # The level of the alert. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        self.level = level  # type: str
        # The PromQL query statement.
        # 
        # >  The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        self.prom_ql = prom_ql  # type: str
        # The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        self.times = times  # type: long

    def validate(self):
        if self.annotations:
            self.annotations.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.annotations is not None:
            result['Annotations'] = self.annotations.to_map()
        if self.level is not None:
            result['Level'] = self.level
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Annotations') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheusAnnotations()
            self.annotations = temp_model.from_map(m['Annotations'])
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleListResponseBodyAlarmsAlarm(TeaModel):
    def __init__(self, alert_state=None, composite_expression=None, contact_groups=None, dimensions=None,
                 effective_interval=None, enable_state=None, escalations=None, group_id=None, group_name=None, labels=None,
                 mail_subject=None, metric_name=None, namespace=None, no_data_policy=None, no_effective_interval=None,
                 period=None, prometheus=None, resources=None, rule_id=None, rule_name=None, silence_time=None,
                 source_type=None, webhook=None):
        # The status of the alert rule. Valid values:
        # 
        # *   OK: The alert rule has no active alerts.
        # *   ALARM: The alert rule has active alerts.
        # *   INSUFFICIENT_DATA: No data is available.
        self.alert_state = alert_state  # type: str
        # The trigger conditions for multiple metrics.
        # 
        # >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
        self.composite_expression = composite_expression  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression
        # The alert contact group.
        self.contact_groups = contact_groups  # type: str
        # The dimensions of the alert rule.
        self.dimensions = dimensions  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   true: The alert rule is enabled.
        # *   false: The alert rule is disabled.
        self.enable_state = enable_state  # type: bool
        # The conditions for triggering different levels of alerts.
        self.escalations = escalations  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the application group.
        # 
        # >  If the alert rule is associated with an application group, the name of the application group is returned in this parameter.
        self.group_name = group_name  # type: str
        # The tags of the alert rule.
        self.labels = labels  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmLabels
        # The subject of the alert notification email.
        self.mail_subject = mail_subject  # type: str
        # The name of the metric.
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        self.namespace = namespace  # type: str
        # The method that is used to handle alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The status is considered normal.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The statistical period.
        self.period = period  # type: str
        # The Prometheus alert rule.
        # 
        # >  This parameter is required only when you create a Prometheus alert rule for Hybrid Cloud Monitoring.
        self.prometheus = prometheus  # type: DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus
        # The resources that are associated with the alert rule.
        self.resources = resources  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alert notifications are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. Minimum value: 3600.
        # 
        # Only one alert is reported during each mute period even if the metric value consecutively exceeds the alert rule threshold several times.
        self.silence_time = silence_time  # type: int
        # The type of the alert rule. Valid value: METRIC. This value indicates an alert rule for time series metrics.
        self.source_type = source_type  # type: str
        # The callback URL. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.composite_expression:
            self.composite_expression.validate()
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            self.labels.validate()
        if self.prometheus:
            self.prometheus.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarmsAlarm, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_state is not None:
            result['AlertState'] = self.alert_state
        if self.composite_expression is not None:
            result['CompositeExpression'] = self.composite_expression.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.enable_state is not None:
            result['EnableState'] = self.enable_state
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.labels is not None:
            result['Labels'] = self.labels.to_map()
        if self.mail_subject is not None:
            result['MailSubject'] = self.mail_subject
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.prometheus is not None:
            result['Prometheus'] = self.prometheus.to_map()
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.source_type is not None:
            result['SourceType'] = self.source_type
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertState') is not None:
            self.alert_state = m.get('AlertState')
        if m.get('CompositeExpression') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmCompositeExpression()
            self.composite_expression = temp_model.from_map(m['CompositeExpression'])
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EnableState') is not None:
            self.enable_state = m.get('EnableState')
        if m.get('Escalations') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Labels') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmLabels()
            self.labels = temp_model.from_map(m['Labels'])
        if m.get('MailSubject') is not None:
            self.mail_subject = m.get('MailSubject')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Prometheus') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarmPrometheus()
            self.prometheus = temp_model.from_map(m['Prometheus'])
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('SourceType') is not None:
            self.source_type = m.get('SourceType')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class DescribeMetricRuleListResponseBodyAlarms(TeaModel):
    def __init__(self, alarm=None):
        self.alarm = alarm  # type: list[DescribeMetricRuleListResponseBodyAlarmsAlarm]

    def validate(self):
        if self.alarm:
            for k in self.alarm:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBodyAlarms, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Alarm'] = []
        if self.alarm is not None:
            for k in self.alarm:
                result['Alarm'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alarm = []
        if m.get('Alarm') is not None:
            for k in m.get('Alarm'):
                temp_model = DescribeMetricRuleListResponseBodyAlarmsAlarm()
                self.alarm.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleListResponseBody(TeaModel):
    def __init__(self, alarms=None, code=None, message=None, request_id=None, success=None, total=None):
        # The details of the alert rules.
        self.alarms = alarms  # type: DescribeMetricRuleListResponseBodyAlarms
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: str

    def validate(self):
        if self.alarms:
            self.alarms.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarms is not None:
            result['Alarms'] = self.alarms.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alarms') is not None:
            temp_model = DescribeMetricRuleListResponseBodyAlarms()
            self.alarms = temp_model.from_map(m['Alarms'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMetricRuleListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleTargetsRequest(TeaModel):
    def __init__(self, region_id=None, rule_id=None):
        self.region_id = region_id  # type: str
        # The ID of the alert rule.
        # 
        # For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTargetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DescribeMetricRuleTargetsResponseBodyTargetsTarget(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The Alibaba Cloud Resource Name (ARN) of the resource. Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # *   {userId}: the ID of the Alibaba Cloud account.
        # *   {regionId}: the region ID of the message queue or topic.
        # *   {Resource type}`: the type of the resource for which alerts are triggered. Valid values: - **queues** - **topics** {Resource name}: the name of the resource. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.`
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        self.id = id  # type: str
        # The parameters of the alert callback. The parameters are in the JSON format.
        self.json_params = json_params  # type: str
        # The level of the alert. Valid values:
        # 
        # *   INFO: information
        # *   WARN: warning
        # *   CRITICAL: critical
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTargetsResponseBodyTargetsTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class DescribeMetricRuleTargetsResponseBodyTargets(TeaModel):
    def __init__(self, target=None):
        self.target = target  # type: list[DescribeMetricRuleTargetsResponseBodyTargetsTarget]

    def validate(self):
        if self.target:
            for k in self.target:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTargetsResponseBodyTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Target'] = []
        if self.target is not None:
            for k in self.target:
                result['Target'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target = []
        if m.get('Target') is not None:
            for k in m.get('Target'):
                temp_model = DescribeMetricRuleTargetsResponseBodyTargetsTarget()
                self.target.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleTargetsResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, targets=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The information about the resource for which alerts are triggered.
        self.targets = targets  # type: DescribeMetricRuleTargetsResponseBodyTargets

    def validate(self):
        if self.targets:
            self.targets.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTargetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.targets is not None:
            result['Targets'] = self.targets.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Targets') is not None:
            temp_model = DescribeMetricRuleTargetsResponseBodyTargets()
            self.targets = temp_model.from_map(m['Targets'])
        return self


class DescribeMetricRuleTargetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleTargetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTargetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleTemplateAttributeRequest(TeaModel):
    def __init__(self, name=None, region_id=None, template_id=None):
        # The name of the alert template. You must specify at least one of the `Name` and `TemplateId` parameters.
        # 
        # For more information about how to query the names of alert templates, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.name = name  # type: str
        self.region_id = region_id  # type: str
        # The ID of the alert template. You must specify at least one of the `Name` and `TemplateId` parameters.
        # 
        # For more information about how to query the IDs of alert templates, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.template_id = template_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical method for Critical-level alerts.
        # 
        # The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Critical-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical method for Info-level alerts.
        # 
        # The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Info-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical method for Warn-level alerts.
        # 
        # The value of the `Statistics` parameter varies with the cloud service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Warn-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        # The conditions for triggering Critical-level alerts.
        self.critical = critical  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical
        # The conditions for triggering Info-level alerts.
        self.info = info  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo
        # The conditions for triggering Warn-level alerts.
        self.warn = warn  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # 报警模板的标签键。
        self.key = key  # type: str
        # 报警模板的标签值。
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels(TeaModel):
    def __init__(self, labels=None):
        self.labels = labels  # type: list[DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels]

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabelsLabels()
                self.labels.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate(TeaModel):
    def __init__(self, category=None, escalations=None, labels=None, metric_name=None, namespace=None,
                 no_data_policy=None, rule_name=None, selector=None, webhook=None):
        # The abbreviation of the cloud service name.
        self.category = category  # type: str
        # The threshold and the alert level.
        self.escalations = escalations  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations
        # 报警模板标签。
        self.labels = labels  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        self.namespace = namespace  # type: str
        # The processing method of alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The alert rule has no active alerts.
        self.no_data_policy = no_data_policy  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The dimension of the alert. It is an extended field.
        self.selector = selector  # type: str
        # The callback URL to which a request is sent when an alert is triggered.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            self.labels.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.labels is not None:
            result['Labels'] = self.labels.to_map()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.selector is not None:
            result['Selector'] = self.selector
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Escalations') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('Labels') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplateLabels()
            self.labels = temp_model.from_map(m['Labels'])
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Selector') is not None:
            self.selector = m.get('Selector')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates(TeaModel):
    def __init__(self, alert_template=None):
        self.alert_template = alert_template  # type: list[DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate]

    def validate(self):
        if self.alert_template:
            for k in self.alert_template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertTemplate'] = []
        if self.alert_template is not None:
            for k in self.alert_template:
                result['AlertTemplate'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_template = []
        if m.get('AlertTemplate') is not None:
            for k in m.get('AlertTemplate'):
                temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplatesAlertTemplate()
                self.alert_template.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleTemplateAttributeResponseBodyResource(TeaModel):
    def __init__(self, alert_templates=None, description=None, name=None, rest_version=None, template_id=None):
        # The list of alert templates.
        self.alert_templates = alert_templates  # type: DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates
        self.description = description  # type: str
        # The name of the alert template.
        self.name = name  # type: str
        # The version of the alert template.
        self.rest_version = rest_version  # type: str
        # The ID of the alert template.
        self.template_id = template_id  # type: str

    def validate(self):
        if self.alert_templates:
            self.alert_templates.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBodyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_templates is not None:
            result['AlertTemplates'] = self.alert_templates.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.rest_version is not None:
            result['RestVersion'] = self.rest_version
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertTemplates') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResourceAlertTemplates()
            self.alert_templates = temp_model.from_map(m['AlertTemplates'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RestVersion') is not None:
            self.rest_version = m.get('RestVersion')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeMetricRuleTemplateAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The details of the alert template.
        self.resource = resource  # type: DescribeMetricRuleTemplateAttributeResponseBodyResource
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMetricRuleTemplateAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleTemplateAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleTemplateAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricRuleTemplateListRequest(TeaModel):
    def __init__(self, history=None, keyword=None, name=None, order=None, order_by=None, page_number=None,
                 page_size=None, region_id=None, template_id=None):
        # Specifies whether to display the history of applying the alert templates to application groups. Valid values:
        # 
        # *   true
        # *   false (default)
        self.history = history  # type: bool
        # The keyword of the alert template name.
        self.keyword = keyword  # type: str
        # The name of the alert template.
        self.name = name  # type: str
        # The sorting order. Valid values:
        # 
        # *   true (default): ascending order
        # *   false: descending order
        self.order = order  # type: bool
        # The sorting basis. Valid values:
        # 
        # *   gmtMotified: sorts alert templates by modification time
        # *   gmtCreate (default): sorts alert templates by creation time
        self.order_by = order_by  # type: str
        # The page number.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: long
        # The number of entries per page.
        self.page_size = page_size  # type: long
        self.region_id = region_id  # type: str
        # The ID of the alert template.
        self.template_id = template_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.history is not None:
            result['History'] = self.history
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.name is not None:
            result['Name'] = self.name
        if self.order is not None:
            result['Order'] = self.order
        if self.order_by is not None:
            result['OrderBy'] = self.order_by
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('History') is not None:
            self.history = m.get('History')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Order') is not None:
            self.order = m.get('Order')
        if m.get('OrderBy') is not None:
            self.order_by = m.get('OrderBy')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory(TeaModel):
    def __init__(self, apply_time=None, group_id=None, group_name=None):
        # The timestamp when the alert template was applied to the application group.
        # 
        # Unit: milliseconds.
        self.apply_time = apply_time  # type: long
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The name of the application group.
        self.group_name = group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_time is not None:
            result['ApplyTime'] = self.apply_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApplyTime') is not None:
            self.apply_time = m.get('ApplyTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        return self


class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories(TeaModel):
    def __init__(self, apply_history=None):
        self.apply_history = apply_history  # type: list[DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory]

    def validate(self):
        if self.apply_history:
            for k in self.apply_history:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ApplyHistory'] = []
        if self.apply_history is not None:
            for k in self.apply_history:
                result['ApplyHistory'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.apply_history = []
        if m.get('ApplyHistory') is not None:
            for k in m.get('ApplyHistory'):
                temp_model = DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistoriesApplyHistory()
                self.apply_history.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate(TeaModel):
    def __init__(self, apply_histories=None, description=None, gmt_create=None, gmt_modified=None, name=None,
                 rest_version=None, template_id=None):
        # The history of applying the alert templates to application groups.
        self.apply_histories = apply_histories  # type: DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories
        # The description of the alert template.
        self.description = description  # type: str
        # The timestamp when the alert template was created.
        # 
        # Unit: milliseconds.
        self.gmt_create = gmt_create  # type: long
        # The timestamp when the alert template was modified.
        # 
        # Unit: milliseconds.
        self.gmt_modified = gmt_modified  # type: long
        # The name of the alert template.
        self.name = name  # type: str
        # The version of the alert template.
        # 
        # Default value: 0.
        self.rest_version = rest_version  # type: long
        # The ID of the alert template.
        self.template_id = template_id  # type: long

    def validate(self):
        if self.apply_histories:
            self.apply_histories.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.apply_histories is not None:
            result['ApplyHistories'] = self.apply_histories.to_map()
        if self.description is not None:
            result['Description'] = self.description
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.name is not None:
            result['Name'] = self.name
        if self.rest_version is not None:
            result['RestVersion'] = self.rest_version
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ApplyHistories') is not None:
            temp_model = DescribeMetricRuleTemplateListResponseBodyTemplatesTemplateApplyHistories()
            self.apply_histories = temp_model.from_map(m['ApplyHistories'])
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RestVersion') is not None:
            self.rest_version = m.get('RestVersion')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeMetricRuleTemplateListResponseBodyTemplates(TeaModel):
    def __init__(self, template=None):
        self.template = template  # type: list[DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate]

    def validate(self):
        if self.template:
            for k in self.template:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponseBodyTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Template'] = []
        if self.template is not None:
            for k in self.template:
                result['Template'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.template = []
        if m.get('Template') is not None:
            for k in m.get('Template'):
                temp_model = DescribeMetricRuleTemplateListResponseBodyTemplatesTemplate()
                self.template.append(temp_model.from_map(k))
        return self


class DescribeMetricRuleTemplateListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, templates=None, total=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The queried alert templates.
        self.templates = templates  # type: DescribeMetricRuleTemplateListResponseBodyTemplates
        # The total number of entries returned.
        self.total = total  # type: long

    def validate(self):
        if self.templates:
            self.templates.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.templates is not None:
            result['Templates'] = self.templates.to_map()
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Templates') is not None:
            temp_model = DescribeMetricRuleTemplateListResponseBodyTemplates()
            self.templates = temp_model.from_map(m['Templates'])
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMetricRuleTemplateListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricRuleTemplateListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricRuleTemplateListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricRuleTemplateListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMetricTopRequest(TeaModel):
    def __init__(self, dimensions=None, end_time=None, express=None, length=None, metric_name=None, namespace=None,
                 order_desc=None, orderby=None, period=None, region_id=None, start_time=None):
        # The monitoring dimensions of the specified resource.
        # 
        # Set the value to a collection of `key:value` pairs. Example: `{"userId":"120886317861****"}` or `{"instanceId":"i-2ze2d6j5uhg20x47****"}`.
        # 
        # >  You can query a maximum of 50 instances in each request.
        self.dimensions = dimensions  # type: str
        # The end of the time range to query monitoring data.
        # 
        # *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
        # 
        # *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.````
        # 
        #     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
        # 
        # The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   Time format: YYYY-MM-DDThh:mm:ssZ
        # 
        # >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.end_time = end_time  # type: str
        # The expression that is used to compute the query results in real time.
        # 
        # >  Only the `groupby` expression is supported. This expression is similar to the GROUP BY statement used in databases.
        self.express = express  # type: str
        # The number of entries per page.
        # 
        # Default value: 10.
        # 
        # >  The maximum value of the Length parameter in a request is 1440.
        self.length = length  # type: str
        # The metric that is used to monitor the cloud service.
        # 
        # For more information about metric names, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The order in which data is sorted. Valid values:
        # 
        # *   True: sorts data in ascending order.
        # *   False (default): sorts data in descending order.
        self.order_desc = order_desc  # type: str
        # The field based on which data is sorted. Valid values:
        # 
        # *   Average
        # *   Minimum
        # *   Maximum
        self.orderby = orderby  # type: str
        # The statistical period of the monitoring data.
        # 
        # Valid values: 15, 60, 900, and 3600.
        # 
        # Unit: seconds.
        # 
        # > 
        # 
        # *   If this parameter is not specified, monitoring data is queried based on the period in which metric values are reported.
        # 
        # *   Statistical periods vary based on the metrics that are specified by `MetricName`. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        self.region_id = region_id  # type: str
        # The start of the time range to query monitoring data.
        # 
        # *   If the `StartTime` and `EndTime` parameters are not specified, the monitoring data of the last statistical period is queried.``
        # 
        # *   If the `StartTime` and `EndTime` parameters are specified, the monitoring data of the last statistical period in the specified time range is queried.````
        # 
        #     *   If you set the `Period` parameter to 15, the specified time range must be less than or equal to 20 minutes. For example, if you set the StartTime parameter to 2021-05-08 08:10:00 and the EndTime parameter to 2021-05-08 08:30:00, the monitoring data of the last 15 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 60 or 900, the specified time range must be less than or equal to 2 hours. For example, if you set the Period parameter to 60, the StartTime parameter to 2021-05-08 08:00:00, and the EndTime parameter to 2021-05-08 10:00:00, the monitoring data of the last 60 seconds in the time range is queried.
        #     *   If you set the `Period` parameter to 3600, the specified time range must be less than or equal to two days. For example, if you set the StartTime parameter to 2021-05-08 08:00:00 and the EndTime parameter to 2021-05-10 08:00:00, the monitoring data of the last 3,600 seconds in the time range is queried.
        # 
        # The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   Time format: YYYY-MM-DDThh:mm:ssZ
        # 
        # > 
        # 
        # *   You must set the `StartTime` parameter to a point in time that is later than 00:00:00 Thursday, January 1, 1970. Otherwise, this parameter is invalid.
        # 
        # *   We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricTopRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.express is not None:
            result['Express'] = self.express
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.order_desc is not None:
            result['OrderDesc'] = self.order_desc
        if self.orderby is not None:
            result['Orderby'] = self.orderby
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('OrderDesc') is not None:
            self.order_desc = m.get('OrderDesc')
        if m.get('Orderby') is not None:
            self.orderby = m.get('Orderby')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeMetricTopResponseBody(TeaModel):
    def __init__(self, code=None, datapoints=None, message=None, period=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The monitoring data.
        self.datapoints = datapoints  # type: str
        # The error message.
        self.message = message  # type: str
        # The statistical period of the monitoring data. Unit: seconds. Valid values: 15, 60, 900, and 3600.
        self.period = period  # type: str
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMetricTopResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints
        if self.message is not None:
            result['Message'] = self.message
        if self.period is not None:
            result['Period'] = self.period
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            self.datapoints = m.get('Datapoints')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeMetricTopResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMetricTopResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMetricTopResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMetricTopResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupCategoriesRequest(TeaModel):
    def __init__(self, group_id=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem(TeaModel):
    def __init__(self, category=None, count=None):
        # The name of the cloud service. Valid values:
        # 
        # *   ecs: Elastic Compute Service (ECS) instances that are provided by Alibaba Cloud and hosts that are not provided by Alibaba Cloud
        # *   rds: ApsaraDB RDS
        # *   ads: AnalyticDB
        # *   slb: Server Load Balancer (SLB)
        # *   vpc: Virtual Private Cloud (VPC)
        # *   apigateway: API Gateway
        # *   cdn: Alibaba Cloud Content Delivery Network (CDN)
        # *   cs: Container Service for Swarm
        # *   dcdn: Dynamic Route for CDN (DCDN)
        # *   ddos: Anti-DDoS
        # *   eip: Elastic IP Address (EIP)
        # *   elasticsearch: Elasticsearch
        # *   emr: E-MapReduce
        # *   ess: Auto Scaling
        # *   hbase: ApsaraDB for HBase
        # *   iot_edge: IoT Edge
        # *   k8s_pod: pods in Container Service for Kubernetes (ACK)
        # *   kvstore_sharding: ApsaraDB for Redis of the cluster master-replica architecture
        # *   kvstore_splitrw: ApsaraDB for Redis of the read/write splitting architecture
        # *   kvstore_standard: ApsaraDB for Redis of the standard master-replica architecture
        # *   memcache: ApsaraDB for Memcache
        # *   mns: Message Service (MNS)
        # *   mongodb: ApsaraDB for MongoDB of the replica set architecture
        # *   mongodb_cluster: ApsaraDB for MongoDB of the cluster architecture
        # *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   mq_topic: MNS topics
        # *   ocs: ApsaraDB for Memcache of earlier versions
        # *   opensearch: Open Search
        # *   oss: Object Storage Service (OSS)
        # *   polardb: PolarDB
        # *   petadata: HybridDB for MySQL
        # *   scdn: Secure CDN (SCDN)
        # *   sharebandwidthpackages: EIP Bandwidth Plan
        # *   sls: Log Service
        # *   vpn: VPN Gateway
        self.category = category  # type: str
        # The number of resources that belong to the cloud service.
        self.count = count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.count is not None:
            result['Count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        return self


class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory(TeaModel):
    def __init__(self, category_item=None):
        self.category_item = category_item  # type: list[DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem]

    def validate(self):
        if self.category_item:
            for k in self.category_item:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CategoryItem'] = []
        if self.category_item is not None:
            for k in self.category_item:
                result['CategoryItem'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.category_item = []
        if m.get('CategoryItem') is not None:
            for k in m.get('CategoryItem'):
                temp_model = DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategoryCategoryItem()
                self.category_item.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories(TeaModel):
    def __init__(self, group_id=None, monitor_group_category=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # One of the cloud services to which the resources in the application group belong and the number of resources that belong to the cloud service.
        self.monitor_group_category = monitor_group_category  # type: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory

    def validate(self):
        if self.monitor_group_category:
            self.monitor_group_category.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.monitor_group_category is not None:
            result['MonitorGroupCategory'] = self.monitor_group_category.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MonitorGroupCategory') is not None:
            temp_model = DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategoriesMonitorGroupCategory()
            self.monitor_group_category = temp_model.from_map(m['MonitorGroupCategory'])
        return self


class DescribeMonitorGroupCategoriesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, monitor_group_categories=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The cloud services to which the resources in the application group belong and the number of resources that belong to the cloud service.
        self.monitor_group_categories = monitor_group_categories  # type: DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.monitor_group_categories:
            self.monitor_group_categories.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.monitor_group_categories is not None:
            result['MonitorGroupCategories'] = self.monitor_group_categories.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MonitorGroupCategories') is not None:
            temp_model = DescribeMonitorGroupCategoriesResponseBodyMonitorGroupCategories()
            self.monitor_group_categories = temp_model.from_map(m['MonitorGroupCategories'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitorGroupCategoriesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupCategoriesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupCategoriesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupCategoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupDynamicRulesRequest(TeaModel):
    def __init__(self, group_id=None, region_id=None):
        # The ID of application group.
        self.group_id = group_id  # type: long
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter(TeaModel):
    def __init__(self, function=None, name=None, value=None):
        # The method that is used to filter the instances. Valid values:
        # 
        # *   contains: includes a specified element
        # *   startWith: specifies a prefix
        # *   endWith: specifies a suffix
        self.function = function  # type: str
        # The name of the instance.
        self.name = name  # type: str
        # The value of the dynamic rule.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters(TeaModel):
    def __init__(self, filter=None):
        self.filter = filter  # type: list[DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter]

    def validate(self):
        if self.filter:
            for k in self.filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filter'] = []
        if self.filter is not None:
            for k in self.filter:
                result['Filter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filter = []
        if m.get('Filter') is not None:
            for k in m.get('Filter'):
                temp_model = DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFiltersFilter()
                self.filter.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupDynamicRulesResponseBodyResourceResource(TeaModel):
    def __init__(self, category=None, filter_relation=None, filters=None):
        # The type of the cloud service to which the dynamic rule belongs. Valid values:
        # 
        # *   ecs: Elastic Compute Service (ECS)
        # *   rds: ApsaraDB RDS
        # *   slb: Server Load Balancer (SLB)
        self.category = category  # type: str
        # The filtering condition. Valid values:
        # 
        # *   and: queries the instances that meet all alert rules
        # *   or: queries the instances that meet any alert rule
        self.filter_relation = filter_relation  # type: str
        # The dynamic rules of the application group.
        self.filters = filters  # type: DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters

    def validate(self):
        if self.filters:
            self.filters.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponseBodyResourceResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.filter_relation is not None:
            result['FilterRelation'] = self.filter_relation
        if self.filters is not None:
            result['Filters'] = self.filters.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('FilterRelation') is not None:
            self.filter_relation = m.get('FilterRelation')
        if m.get('Filters') is not None:
            temp_model = DescribeMonitorGroupDynamicRulesResponseBodyResourceResourceFilters()
            self.filters = temp_model.from_map(m['Filters'])
        return self


class DescribeMonitorGroupDynamicRulesResponseBodyResource(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeMonitorGroupDynamicRulesResponseBodyResourceResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponseBodyResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeMonitorGroupDynamicRulesResponseBodyResourceResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupDynamicRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource=None, success=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The resources that is associated with the application group.
        self.resource = resource  # type: DescribeMonitorGroupDynamicRulesResponseBodyResource
        self.success = success  # type: bool

    def validate(self):
        if self.resource:
            self.resource.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource is not None:
            result['Resource'] = self.resource.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resource') is not None:
            temp_model = DescribeMonitorGroupDynamicRulesResponseBodyResource()
            self.resource = temp_model.from_map(m['Resource'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitorGroupDynamicRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupDynamicRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupDynamicRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupDynamicRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupInstanceAttributeRequest(TeaModel):
    def __init__(self, category=None, group_id=None, instance_ids=None, keyword=None, page_number=None,
                 page_size=None, region_id=None, total=None):
        # The abbreviation of the Alibaba Cloud service name.
        # 
        # To obtain the abbreviation of an Alibaba Cloud service name, call the [DescribeProjectMeta](~~114916~~) operation. The `metricCategory` tag in the `Labels` response parameter indicates the abbreviation of the Alibaba Cloud service name.
        self.category = category  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ID of the resource. Separate multiple resource IDs with commas (,). You can query the details about a maximum of 20 resources in each request.
        self.instance_ids = instance_ids  # type: str
        # The keyword that is used to search for resources.
        self.keyword = keyword  # type: str
        # The number of the page to return.
        # 
        # Valid values: 1 to 1000000000.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Valid values: 1 to 1000000000.
        # 
        # Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # Specifies whether to return the total number of resources in the specified application group. Valid values:
        # 
        # *   true (default value)
        # *   false
        self.total = total  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion(TeaModel):
    def __init__(self, availability_zone=None, region_id=None):
        self.availability_zone = availability_zone  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.availability_zone is not None:
            result['AvailabilityZone'] = self.availability_zone
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AvailabilityZone') is not None:
            self.availability_zone = m.get('AvailabilityZone')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key.
        self.key = key  # type: str
        # The tag value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc(TeaModel):
    def __init__(self, vpc_instance_id=None, vswitch_instance_id=None):
        # The ID of the VPC.
        self.vpc_instance_id = vpc_instance_id  # type: str
        # The ID of the vSwitch to which the instance belongs.
        self.vswitch_instance_id = vswitch_instance_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.vpc_instance_id is not None:
            result['VpcInstanceId'] = self.vpc_instance_id
        if self.vswitch_instance_id is not None:
            result['VswitchInstanceId'] = self.vswitch_instance_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('VpcInstanceId') is not None:
            self.vpc_instance_id = m.get('VpcInstanceId')
        if m.get('VswitchInstanceId') is not None:
            self.vswitch_instance_id = m.get('VswitchInstanceId')
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource(TeaModel):
    def __init__(self, category=None, desc=None, dimension=None, instance_id=None, instance_name=None,
                 network_type=None, region=None, tags=None, vpc=None):
        # The name of the cloud service.
        self.category = category  # type: str
        # The description of the resource.
        self.desc = desc  # type: str
        # The dimensions of the resource that is associated with the application group.
        self.dimension = dimension  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The network type.
        self.network_type = network_type  # type: str
        self.region = region  # type: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion
        # The tags of the resource.
        self.tags = tags  # type: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags
        # The information about the virtual private cloud (VPC).
        self.vpc = vpc  # type: DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc

    def validate(self):
        if self.region:
            self.region.validate()
        if self.tags:
            self.tags.validate()
        if self.vpc:
            self.vpc.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.dimension is not None:
            result['Dimension'] = self.dimension
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.region is not None:
            result['Region'] = self.region.to_map()
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.vpc is not None:
            result['Vpc'] = self.vpc.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('Dimension') is not None:
            self.dimension = m.get('Dimension')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('Region') is not None:
            temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceRegion()
            self.region = temp_model.from_map(m['Region'])
        if m.get('Tags') is not None:
            temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('Vpc') is not None:
            temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResourceVpc()
            self.vpc = temp_model.from_map(m['Vpc'])
        return self


class DescribeMonitorGroupInstanceAttributeResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupInstanceAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, resources=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The total number of returned pages.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The resources that are associated with the application group.
        self.resources = resources  # type: DescribeMonitorGroupInstanceAttributeResponseBodyResources
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeMonitorGroupInstanceAttributeResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitorGroupInstanceAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupInstanceAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstanceAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupInstanceAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupInstancesRequest(TeaModel):
    def __init__(self, category=None, group_id=None, instance_ids=None, keyword=None, page_number=None,
                 page_size=None, region_id=None):
        # The abbreviation of the name of the service to which the instances in the application group belong. Valid values:
        # 
        # *   ECS: Elastic Compute Service (ECS) instances provided by Alibaba Cloud and hosts not provided by Alibaba Cloud
        # *   RDS: ApsaraDB for RDS
        # *   ADS: AnalyticDB
        # *   SLB: Server Load Balancer (SLB)
        # *   VPC: Virtual Private Cloud (VPC)
        # *   APIGATEWAY: API Gateway
        # *   CDN: Alibaba Cloud Content Delivery Network (CDN)
        # *   CS: Container Service for Swarm
        # *   DCDN: Dynamic Route for CDN
        # *   DDoS: Anti-DDoS Pro
        # *   EIP: Elastic IP Address (EIP)
        # *   ELASTICSEARCH: Elasticsearch
        # *   EMR: E-MapReduce
        # *   ESS: Auto Scaling
        # *   HBASE: ApsaraDB for Hbase
        # *   IOT_EDGE: IoT Edge
        # *   K8S_POD: pods in Container Service for Kubernetes
        # *   KVSTORE_SHARDING: ApsaraDB for Redis of the cluster architecture
        # *   KVSTORE_SPLITRW: ApsaraDB for Redis of the read/write splitting architecture
        # *   KVSTORE_STANDARD: ApsaraDB for Redis of the standard architecture
        # *   MEMCACHE: ApsaraDB for Memcache
        # *   MNS: Message Service (MNS)
        # *   MONGODB: ApsaraDB for MongoDB of the replica set architecture
        # *   MONGODB_CLUSTER: ApsaraDB for MongoDB of the cluster architecture
        # *   MONGODB_SHARDING: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   MQ_TOPIC: MNS topics
        # *   OCS: ApsaraDB for Memcache of earlier versions
        # *   OPENSEARCH: Open Search
        # *   OSS: Object Storage Service (OSS)
        # *   POLARDB: PolarDB
        # *   PETADATA: HybridDB for MySQL
        # *   SCDN: Secure Content Delivery Network (SCDN)
        # *   SHAREBANDWIDTHPACKAGES: EIP Bandwidth Plan
        # *   SLS: Log Service
        # *   VPN: VPN Gateway
        # 
        # Valid values of N: 1 to 200.
        self.category = category  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ID of the instance. You can query multiple instances by specifying multiple IDs.
        self.instance_ids = instance_ids  # type: str
        # The keyword used to search for instances. Fuzzy search based on instance name is supported.
        self.keyword = keyword  # type: str
        # The number of the page to return. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupInstancesResponseBodyResourcesResource(TeaModel):
    def __init__(self, category=None, id=None, instance_id=None, instance_name=None, region_id=None):
        # The abbreviation of the service name.
        self.category = category  # type: str
        # The ID of the resource.
        self.id = id  # type: long
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The ID of the region where the instance resides.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupInstancesResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupInstancesResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeMonitorGroupInstancesResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstancesResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeMonitorGroupInstancesResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupInstancesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, resources=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned on each page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the resources in the application group.
        self.resources = resources  # type: DescribeMonitorGroupInstancesResponseBodyResources
        # Indicates whether the call was successful.
        self.success = success  # type: bool
        self.total = total  # type: int

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeMonitorGroupInstancesResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitorGroupInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupNotifyPolicyListRequest(TeaModel):
    def __init__(self, group_id=None, page_number=None, page_size=None, policy_type=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The page number. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page. Default value: 10.
        self.page_size = page_size  # type: int
        # The policy type.
        # 
        # Valid value: PauseNotify.
        self.policy_type = policy_type  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupNotifyPolicyListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.policy_type is not None:
            result['PolicyType'] = self.policy_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PolicyType') is not None:
            self.policy_type = m.get('PolicyType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy(TeaModel):
    def __init__(self, end_time=None, group_id=None, id=None, start_time=None, type=None):
        # The end of the time range to query.
        # 
        # Unit: milliseconds.
        self.end_time = end_time  # type: long
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The policy ID.
        self.id = id  # type: str
        # The beginning of the time range to query.
        # 
        # Unit: milliseconds.
        self.start_time = start_time  # type: long
        # The policy type.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList(TeaModel):
    def __init__(self, notify_policy=None):
        self.notify_policy = notify_policy  # type: list[DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy]

    def validate(self):
        if self.notify_policy:
            for k in self.notify_policy:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NotifyPolicy'] = []
        if self.notify_policy is not None:
            for k in self.notify_policy:
                result['NotifyPolicy'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.notify_policy = []
        if m.get('NotifyPolicy') is not None:
            for k in m.get('NotifyPolicy'):
                temp_model = DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyListNotifyPolicy()
                self.notify_policy.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupNotifyPolicyListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, notify_policy_list=None, request_id=None, success=None, total=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The returned policies.
        self.notify_policy_list = notify_policy_list  # type: DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str
        # The total number of entries returned.
        self.total = total  # type: int

    def validate(self):
        if self.notify_policy_list:
            self.notify_policy_list.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupNotifyPolicyListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.notify_policy_list is not None:
            result['NotifyPolicyList'] = self.notify_policy_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NotifyPolicyList') is not None:
            temp_model = DescribeMonitorGroupNotifyPolicyListResponseBodyNotifyPolicyList()
            self.notify_policy_list = temp_model.from_map(m['NotifyPolicyList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitorGroupNotifyPolicyListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupNotifyPolicyListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupNotifyPolicyListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupNotifyPolicyListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorGroupsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the application group. Valid values of N: 1 to 5.
        self.key = key  # type: str
        # The tag value of the application group. Valid values of N: 1 to 5.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMonitorGroupsRequest(TeaModel):
    def __init__(self, dynamic_tag_rule_id=None, group_founder_tag_key=None, group_founder_tag_value=None,
                 group_id=None, group_name=None, include_template_history=None, instance_id=None, keyword=None,
                 page_number=None, page_size=None, region_id=None, select_contact_groups=None, tag=None, type=None, types=None):
        # The ID of the tag rule.
        self.dynamic_tag_rule_id = dynamic_tag_rule_id  # type: str
        # The tag key that is created for the application group by using the tag rule.
        self.group_founder_tag_key = group_founder_tag_key  # type: str
        # The tag value that is created for the application group by using the tag rule.
        self.group_founder_tag_value = group_founder_tag_value  # type: str
        # The ID of the application group. Separate multiple application group IDs with commas (,).
        self.group_id = group_id  # type: str
        # The name of the application group.
        self.group_name = group_name  # type: str
        # Specifies whether to include the historical alert templates that are applied to the application group in the response. Valid values:
        # 
        # *   true
        # *   false
        self.include_template_history = include_template_history  # type: bool
        # The instance ID. This parameter is used to query the application group to which the specified instance belongs.
        self.instance_id = instance_id  # type: str
        # The keyword that is used for the search.
        self.keyword = keyword  # type: str
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Pages start from page 1. Default value: 30.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # Specifies whether to include the alert contact groups in the response. Valid values:
        # 
        # *   true
        # *   false
        self.select_contact_groups = select_contact_groups  # type: bool
        # The tags of the application group.
        self.tag = tag  # type: list[DescribeMonitorGroupsRequestTag]
        # The type of the application group. Valid values:
        # 
        # *   custom: a self-managed application group
        # *   ehpc_cluster: an application group that is synchronized from an Elastic High Performance Computing (E-HPC) cluster
        # *   kubernetes: an application group that is synchronized from a Container Service for Kubernetes (ACK) cluster
        self.type = type  # type: str
        # The type of the application group. Valid values:
        # 
        # *   custom: a self-managed application group
        # *   ehpc_cluster: an application group that is synchronized from an Elastic High Performance Computing (E-HPC) cluster
        # *   kubernetes: an application group that is synchronized from a Container Service for Kubernetes (ACK) cluster
        # *   tag: an application group that is automatically created by using tags
        # *   resMgr: an application group that is created by using resource groups
        # *   ess: an application group that is synchronized from Auto Scaling (ESS)
        self.types = types  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dynamic_tag_rule_id is not None:
            result['DynamicTagRuleId'] = self.dynamic_tag_rule_id
        if self.group_founder_tag_key is not None:
            result['GroupFounderTagKey'] = self.group_founder_tag_key
        if self.group_founder_tag_value is not None:
            result['GroupFounderTagValue'] = self.group_founder_tag_value
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.include_template_history is not None:
            result['IncludeTemplateHistory'] = self.include_template_history
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.select_contact_groups is not None:
            result['SelectContactGroups'] = self.select_contact_groups
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.type is not None:
            result['Type'] = self.type
        if self.types is not None:
            result['Types'] = self.types
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DynamicTagRuleId') is not None:
            self.dynamic_tag_rule_id = m.get('DynamicTagRuleId')
        if m.get('GroupFounderTagKey') is not None:
            self.group_founder_tag_key = m.get('GroupFounderTagKey')
        if m.get('GroupFounderTagValue') is not None:
            self.group_founder_tag_value = m.get('GroupFounderTagValue')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('IncludeTemplateHistory') is not None:
            self.include_template_history = m.get('IncludeTemplateHistory')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SelectContactGroups') is not None:
            self.select_contact_groups = m.get('SelectContactGroups')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeMonitorGroupsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Types') is not None:
            self.types = m.get('Types')
        return self


class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup(TeaModel):
    def __init__(self, name=None):
        # The name of the alert contact group.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups(TeaModel):
    def __init__(self, contact_group=None):
        self.contact_group = contact_group  # type: list[DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup]

    def validate(self):
        if self.contact_group:
            for k in self.contact_group:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactGroup'] = []
        if self.contact_group is not None:
            for k in self.contact_group:
                result['ContactGroup'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_group = []
        if m.get('ContactGroup') is not None:
            for k in m.get('ContactGroup'):
                temp_model = DescribeMonitorGroupsResponseBodyResourcesResourceContactGroupsContactGroup()
                self.contact_group.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the application group.
        self.key = key  # type: str
        # The tag value of the application group.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeMonitorGroupsResponseBodyResourcesResourceTags(TeaModel):
    def __init__(self, tag=None):
        self.tag = tag  # type: list[DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResourceTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeMonitorGroupsResponseBodyResourcesResourceTagsTag()
                self.tag.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds(TeaModel):
    def __init__(self, template_id=None):
        self.template_id = template_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class DescribeMonitorGroupsResponseBodyResourcesResource(TeaModel):
    def __init__(self, bind_url=None, contact_groups=None, dynamic_tag_rule_id=None, gmt_create=None,
                 gmt_modified=None, group_founder_tag_key=None, group_founder_tag_value=None, group_id=None, group_name=None,
                 resource_group_id=None, service_id=None, tags=None, template_ids=None, type=None):
        # The URL of the ACK cluster from which the application group is synchronized.
        self.bind_url = bind_url  # type: str
        # The alert contact groups.
        self.contact_groups = contact_groups  # type: DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups
        # The ID of the tag rule.
        self.dynamic_tag_rule_id = dynamic_tag_rule_id  # type: str
        # The timestamp when the application group was created. Unit: milliseconds.
        self.gmt_create = gmt_create  # type: long
        # The timestamp when the application group was modified. Unit: milliseconds.
        self.gmt_modified = gmt_modified  # type: long
        # The tag key that is created for the application group by using the tag rule.
        self.group_founder_tag_key = group_founder_tag_key  # type: str
        # The tag value that is created for the application group by using the tag rule.
        self.group_founder_tag_value = group_founder_tag_value  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The name of the application group.
        self.group_name = group_name  # type: str
        # The resource ID.
        self.resource_group_id = resource_group_id  # type: str
        # The ID of the Alibaba Cloud service.
        self.service_id = service_id  # type: str
        # The tags that are attached to the application group.
        self.tags = tags  # type: DescribeMonitorGroupsResponseBodyResourcesResourceTags
        # The ID of the template.
        self.template_ids = template_ids  # type: DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds
        # The type of the application group. Valid values:
        # 
        # *   custom: a self-managed application group
        # *   ehpc_cluster: an application group that is synchronized from an E-HPC cluster
        # *   kubernetes: an application group that is synchronized from an ACK cluster
        self.type = type  # type: str

    def validate(self):
        if self.contact_groups:
            self.contact_groups.validate()
        if self.tags:
            self.tags.validate()
        if self.template_ids:
            self.template_ids.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_url is not None:
            result['BindUrl'] = self.bind_url
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups.to_map()
        if self.dynamic_tag_rule_id is not None:
            result['DynamicTagRuleId'] = self.dynamic_tag_rule_id
        if self.gmt_create is not None:
            result['GmtCreate'] = self.gmt_create
        if self.gmt_modified is not None:
            result['GmtModified'] = self.gmt_modified
        if self.group_founder_tag_key is not None:
            result['GroupFounderTagKey'] = self.group_founder_tag_key
        if self.group_founder_tag_value is not None:
            result['GroupFounderTagValue'] = self.group_founder_tag_value
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.resource_group_id is not None:
            result['ResourceGroupId'] = self.resource_group_id
        if self.service_id is not None:
            result['ServiceId'] = self.service_id
        if self.tags is not None:
            result['Tags'] = self.tags.to_map()
        if self.template_ids is not None:
            result['TemplateIds'] = self.template_ids.to_map()
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindUrl') is not None:
            self.bind_url = m.get('BindUrl')
        if m.get('ContactGroups') is not None:
            temp_model = DescribeMonitorGroupsResponseBodyResourcesResourceContactGroups()
            self.contact_groups = temp_model.from_map(m['ContactGroups'])
        if m.get('DynamicTagRuleId') is not None:
            self.dynamic_tag_rule_id = m.get('DynamicTagRuleId')
        if m.get('GmtCreate') is not None:
            self.gmt_create = m.get('GmtCreate')
        if m.get('GmtModified') is not None:
            self.gmt_modified = m.get('GmtModified')
        if m.get('GroupFounderTagKey') is not None:
            self.group_founder_tag_key = m.get('GroupFounderTagKey')
        if m.get('GroupFounderTagValue') is not None:
            self.group_founder_tag_value = m.get('GroupFounderTagValue')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('ResourceGroupId') is not None:
            self.resource_group_id = m.get('ResourceGroupId')
        if m.get('ServiceId') is not None:
            self.service_id = m.get('ServiceId')
        if m.get('Tags') is not None:
            temp_model = DescribeMonitorGroupsResponseBodyResourcesResourceTags()
            self.tags = temp_model.from_map(m['Tags'])
        if m.get('TemplateIds') is not None:
            temp_model = DescribeMonitorGroupsResponseBodyResourcesResourceTemplateIds()
            self.template_ids = temp_model.from_map(m['TemplateIds'])
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeMonitorGroupsResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeMonitorGroupsResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeMonitorGroupsResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeMonitorGroupsResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, resources=None,
                 success=None, total=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # The resources that are associated with the application group.
        self.resources = resources  # type: DescribeMonitorGroupsResponseBodyResources
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeMonitorGroupsResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitorGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitorResourceQuotaAttributeRequest(TeaModel):
    def __init__(self, region_id=None, show_used=None):
        self.region_id = region_id  # type: str
        # Specifies whether to return information about used quotas. Valid values:
        # 
        # *   true (default): yes
        # *   false: no
        self.show_used = show_used  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.show_used is not None:
            result['ShowUsed'] = self.show_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ShowUsed') is not None:
            self.show_used = m.get('ShowUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of API calls. Unit: 10,000 calls.
        self.quota_limit = quota_limit  # type: int
        # The quota of API calls in your resource plan. Unit: 10,000 calls.
        self.quota_package = quota_package  # type: int
        # The used quota of API calls in your resource plan. Unit: calls.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of the time series for custom monitoring.
        self.quota_limit = quota_limit  # type: int
        # The quota of the time series for custom monitoring in your resource plan.
        self.quota_package = quota_package  # type: int
        # The used quota of the time series for custom monitoring in your resource plan.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota(TeaModel):
    def __init__(self, instance_id=None, suit_info=None):
        # The ID of the instance monitored by Hybrid Cloud Monitoring.
        self.instance_id = instance_id  # type: str
        # The description of Hybrid Cloud Monitoring.
        self.suit_info = suit_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.suit_info is not None:
            result['SuitInfo'] = self.suit_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('SuitInfo') is not None:
            self.suit_info = m.get('SuitInfo')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of events that can be reported in event monitoring. The total quota is the value that is multiplied by 10,000.
        self.quota_limit = quota_limit  # type: int
        # The quota of events that can be reported in event monitoring in your resource plan. The total quota is the value that is multiplied by 10,000.
        self.quota_package = quota_package  # type: int
        # The used quota of events that can be reported in event monitoring in your resource plan. The total quota is the value that is multiplied by 10,000.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of processed log data in log monitoring. Unit: MB/min.
        self.quota_limit = quota_limit  # type: int
        # The quota of processed log data in log monitoring in your resource plan. Unit: MB/min.
        self.quota_package = quota_package  # type: int
        # The used quota of processed log data in log monitoring in your resource plan. Unit: MB/min.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of alert phone calls. Unit: calls.
        self.quota_limit = quota_limit  # type: int
        # The quota of alert phone calls in your resource plan. Unit: calls.
        self.quota_package = quota_package  # type: int
        # The used quota of alert phone calls in your resource plan. Unit: calls.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of alert text messages.
        self.quota_limit = quota_limit  # type: int
        # The quota of alert text messages in your resource plan.
        self.quota_package = quota_package  # type: int
        # The used quota of alert text messages in your resource plan.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        self.quota_limit = quota_limit  # type: int
        self.quota_package = quota_package  # type: int
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of ECS detection points for site monitoring.
        # 
        # > The value indicates the maximum number of ECS detection points that you can select for a site monitoring task.
        self.quota_limit = quota_limit  # type: int
        # The quota of ECS detection points for site monitoring in your resource plan.
        self.quota_package = quota_package  # type: int
        # The used quota of ECS detection points for site monitoring in your resource plan.
        # 
        # > The value indicates the total number of ECS detection points that are used by existing site monitoring tasks.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        self.quota_limit = quota_limit  # type: int
        self.quota_package = quota_package  # type: int
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of carrier detection points for site monitoring.
        self.quota_limit = quota_limit  # type: int
        # The quota of carrier detection points for site monitoring in your resource plan.
        self.quota_package = quota_package  # type: int
        # The used quota of carrier detection points for site monitoring in your resource plan.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask(TeaModel):
    def __init__(self, quota_limit=None, quota_package=None, quota_used=None):
        # The total quota of site monitoring tasks.
        self.quota_limit = quota_limit  # type: int
        # The quota of site monitoring tasks in your resource plan.
        self.quota_package = quota_package  # type: int
        # The used quota of site monitoring tasks in your resource plan.
        self.quota_used = quota_used  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.quota_limit is not None:
            result['QuotaLimit'] = self.quota_limit
        if self.quota_package is not None:
            result['QuotaPackage'] = self.quota_package
        if self.quota_used is not None:
            result['QuotaUsed'] = self.quota_used
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('QuotaLimit') is not None:
            self.quota_limit = m.get('QuotaLimit')
        if m.get('QuotaPackage') is not None:
            self.quota_package = m.get('QuotaPackage')
        if m.get('QuotaUsed') is not None:
            self.quota_used = m.get('QuotaUsed')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota(TeaModel):
    def __init__(self, api=None, custom_monitor=None, enterprise_quota=None, event_monitor=None, expire_time=None,
                 instance_id=None, log_monitor=None, phone=None, sms=None, site_monitor_browser=None,
                 site_monitor_ecs_probe=None, site_monitor_mobile=None, site_monitor_operator_probe=None, site_monitor_task=None,
                 suit_info=None):
        # The details about the quota of API calls.
        self.api = api  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi
        # The details about the quota for custom monitoring.
        self.custom_monitor = custom_monitor  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor
        # The details about the quota of Hybrid Cloud Monitoring.
        self.enterprise_quota = enterprise_quota  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota
        # The details about the quota for event monitoring.
        self.event_monitor = event_monitor  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor
        # The time when the resource plan expires.
        self.expire_time = expire_time  # type: str
        # The ID of the resource plan.
        self.instance_id = instance_id  # type: str
        # The details about the quota for log monitoring.
        self.log_monitor = log_monitor  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor
        # The details about the quota of alert phone calls.
        self.phone = phone  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone
        # The details about the quota of alert text messages.
        self.sms = sms  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS
        self.site_monitor_browser = site_monitor_browser  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser
        # The details about the quota of ECS detection points for site monitoring.
        self.site_monitor_ecs_probe = site_monitor_ecs_probe  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe
        self.site_monitor_mobile = site_monitor_mobile  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile
        # The details about the quota of carrier detection points for site monitoring.
        self.site_monitor_operator_probe = site_monitor_operator_probe  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe
        # The quota of site monitoring tasks.
        self.site_monitor_task = site_monitor_task  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask
        # The current edition of CloudMonitor. Valid values:
        # 
        # *   free: Free Edition
        # *   pro: Pro Edition
        # *   cms_post: pay-as-you-go
        self.suit_info = suit_info  # type: str

    def validate(self):
        if self.api:
            self.api.validate()
        if self.custom_monitor:
            self.custom_monitor.validate()
        if self.enterprise_quota:
            self.enterprise_quota.validate()
        if self.event_monitor:
            self.event_monitor.validate()
        if self.log_monitor:
            self.log_monitor.validate()
        if self.phone:
            self.phone.validate()
        if self.sms:
            self.sms.validate()
        if self.site_monitor_browser:
            self.site_monitor_browser.validate()
        if self.site_monitor_ecs_probe:
            self.site_monitor_ecs_probe.validate()
        if self.site_monitor_mobile:
            self.site_monitor_mobile.validate()
        if self.site_monitor_operator_probe:
            self.site_monitor_operator_probe.validate()
        if self.site_monitor_task:
            self.site_monitor_task.validate()

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.api is not None:
            result['Api'] = self.api.to_map()
        if self.custom_monitor is not None:
            result['CustomMonitor'] = self.custom_monitor.to_map()
        if self.enterprise_quota is not None:
            result['EnterpriseQuota'] = self.enterprise_quota.to_map()
        if self.event_monitor is not None:
            result['EventMonitor'] = self.event_monitor.to_map()
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.log_monitor is not None:
            result['LogMonitor'] = self.log_monitor.to_map()
        if self.phone is not None:
            result['Phone'] = self.phone.to_map()
        if self.sms is not None:
            result['SMS'] = self.sms.to_map()
        if self.site_monitor_browser is not None:
            result['SiteMonitorBrowser'] = self.site_monitor_browser.to_map()
        if self.site_monitor_ecs_probe is not None:
            result['SiteMonitorEcsProbe'] = self.site_monitor_ecs_probe.to_map()
        if self.site_monitor_mobile is not None:
            result['SiteMonitorMobile'] = self.site_monitor_mobile.to_map()
        if self.site_monitor_operator_probe is not None:
            result['SiteMonitorOperatorProbe'] = self.site_monitor_operator_probe.to_map()
        if self.site_monitor_task is not None:
            result['SiteMonitorTask'] = self.site_monitor_task.to_map()
        if self.suit_info is not None:
            result['SuitInfo'] = self.suit_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Api') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaApi()
            self.api = temp_model.from_map(m['Api'])
        if m.get('CustomMonitor') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaCustomMonitor()
            self.custom_monitor = temp_model.from_map(m['CustomMonitor'])
        if m.get('EnterpriseQuota') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEnterpriseQuota()
            self.enterprise_quota = temp_model.from_map(m['EnterpriseQuota'])
        if m.get('EventMonitor') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaEventMonitor()
            self.event_monitor = temp_model.from_map(m['EventMonitor'])
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('LogMonitor') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaLogMonitor()
            self.log_monitor = temp_model.from_map(m['LogMonitor'])
        if m.get('Phone') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaPhone()
            self.phone = temp_model.from_map(m['Phone'])
        if m.get('SMS') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSMS()
            self.sms = temp_model.from_map(m['SMS'])
        if m.get('SiteMonitorBrowser') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorBrowser()
            self.site_monitor_browser = temp_model.from_map(m['SiteMonitorBrowser'])
        if m.get('SiteMonitorEcsProbe') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorEcsProbe()
            self.site_monitor_ecs_probe = temp_model.from_map(m['SiteMonitorEcsProbe'])
        if m.get('SiteMonitorMobile') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorMobile()
            self.site_monitor_mobile = temp_model.from_map(m['SiteMonitorMobile'])
        if m.get('SiteMonitorOperatorProbe') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorOperatorProbe()
            self.site_monitor_operator_probe = temp_model.from_map(m['SiteMonitorOperatorProbe'])
        if m.get('SiteMonitorTask') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuotaSiteMonitorTask()
            self.site_monitor_task = temp_model.from_map(m['SiteMonitorTask'])
        if m.get('SuitInfo') is not None:
            self.suit_info = m.get('SuitInfo')
        return self


class DescribeMonitorResourceQuotaAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, resource_quota=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The details about the resource quotas of CloudMonitor.
        self.resource_quota = resource_quota  # type: DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota

    def validate(self):
        if self.resource_quota:
            self.resource_quota.validate()

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resource_quota is not None:
            result['ResourceQuota'] = self.resource_quota.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ResourceQuota') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBodyResourceQuota()
            self.resource_quota = temp_model.from_map(m['ResourceQuota'])
        return self


class DescribeMonitorResourceQuotaAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitorResourceQuotaAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitorResourceQuotaAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitorResourceQuotaAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringAgentAccessKeyRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentAccessKeyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitoringAgentAccessKeyResponseBody(TeaModel):
    def __init__(self, access_key=None, code=None, message=None, request_id=None, secret_key=None, success=None):
        # The AccessKey ID that is required to install the agent.
        self.access_key = access_key  # type: str
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The AccessKey secret that is required to install the agent.
        self.secret_key = secret_key  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentAccessKeyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_key is not None:
            result['AccessKey'] = self.access_key
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.secret_key is not None:
            result['SecretKey'] = self.secret_key
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessKey') is not None:
            self.access_key = m.get('AccessKey')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SecretKey') is not None:
            self.secret_key = m.get('SecretKey')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitoringAgentAccessKeyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringAgentAccessKeyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentAccessKeyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringAgentAccessKeyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringAgentConfigRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitoringAgentConfigResponseBody(TeaModel):
    def __init__(self, auto_install=None, code=None, enable_active_alert=None, enable_install_agent_new_ecs=None,
                 message=None, request_id=None, success=None):
        # Indicates whether the Cloud Monitor agent is automatically installed on existing Elastic Compute Service (ECS) instances. Valid values:
        # 
        # *   true
        # *   false
        self.auto_install = auto_install  # type: bool
        # The status code.
        # 
        # >  The status code 200 indicates a success.
        self.code = code  # type: str
        # The service for which one-click alert is enabled.
        self.enable_active_alert = enable_active_alert  # type: str
        # Indicates whether the Cloud Monitor agent is automatically installed on new ECS instances. Valid values:
        # 
        # *   true
        # *   false
        self.enable_install_agent_new_ecs = enable_install_agent_new_ecs  # type: bool
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_install is not None:
            result['AutoInstall'] = self.auto_install
        if self.code is not None:
            result['Code'] = self.code
        if self.enable_active_alert is not None:
            result['EnableActiveAlert'] = self.enable_active_alert
        if self.enable_install_agent_new_ecs is not None:
            result['EnableInstallAgentNewECS'] = self.enable_install_agent_new_ecs
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoInstall') is not None:
            self.auto_install = m.get('AutoInstall')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnableActiveAlert') is not None:
            self.enable_active_alert = m.get('EnableActiveAlert')
        if m.get('EnableInstallAgentNewECS') is not None:
            self.enable_install_agent_new_ecs = m.get('EnableInstallAgentNewECS')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitoringAgentConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringAgentConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringAgentConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringAgentHostsRequest(TeaModel):
    def __init__(self, aliyun_host=None, host_name=None, instance_ids=None, instance_region_id=None, key_word=None,
                 page_number=None, page_size=None, region_id=None, serial_numbers=None, status=None, sysom_status=None):
        # Specifies whether to query Elastic Compute Service (ECS) instances that are provided by Alibaba Cloud or to query hosts that are not provided by Alibaba Cloud. Valid values:
        # 
        # *   true (default value): queries all the ECS instances that are provided by Alibaba Cloud.
        # *   false: queries all the hosts that are not provided by Alibaba Cloud.
        self.aliyun_host = aliyun_host  # type: bool
        # The name of the host.
        self.host_name = host_name  # type: str
        # The ID of the instance.
        self.instance_ids = instance_ids  # type: str
        # The region ID of the instance.
        self.instance_region_id = instance_region_id  # type: str
        # The keyword that is used in fuzzy match.
        self.key_word = key_word  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page. Valid values:
        # 
        # *   10
        # *   20
        # *   50
        # *   100
        # 
        # > Although Alibaba Cloud does not limit the maximum value of this parameter, we recommend that you do not set it to an excessively large value. If you set it to an excessively large value, a timeout error may occur.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The serial number of the host.
        # 
        # After the CloudMonitor agent is installed on a host, a globally unique serial number is generated. A host that is not provided by Alibaba Cloud has a serial number instead of an instance ID.
        # 
        # > This parameter can be used to accurately search for a monitored host.
        self.serial_numbers = serial_numbers  # type: str
        # The status of the hosts that you want to query. Valid values:
        # 
        # *   Running: queries the hosts that are running.
        # *   Stopped: queries the hosts that are stopped, are not installed, or fail to be installed.
        self.status = status  # type: str
        # The status of SysOM. Valid values:
        # 
        # *   installing: SysOM is being installed.
        # *   running: SysOM is running.
        # *   stopped: SysOM is stopped.
        # *   uninstalling: SysOM is being uninstalled.
        self.sysom_status = sysom_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentHostsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aliyun_host is not None:
            result['AliyunHost'] = self.aliyun_host
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.instance_region_id is not None:
            result['InstanceRegionId'] = self.instance_region_id
        if self.key_word is not None:
            result['KeyWord'] = self.key_word
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.serial_numbers is not None:
            result['SerialNumbers'] = self.serial_numbers
        if self.status is not None:
            result['Status'] = self.status
        if self.sysom_status is not None:
            result['SysomStatus'] = self.sysom_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliyunHost') is not None:
            self.aliyun_host = m.get('AliyunHost')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('InstanceRegionId') is not None:
            self.instance_region_id = m.get('InstanceRegionId')
        if m.get('KeyWord') is not None:
            self.key_word = m.get('KeyWord')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SerialNumbers') is not None:
            self.serial_numbers = m.get('SerialNumbers')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SysomStatus') is not None:
            self.sysom_status = m.get('SysomStatus')
        return self


class DescribeMonitoringAgentHostsResponseBodyHostsHost(TeaModel):
    def __init__(self, agent_version=None, ali_uid=None, eip_address=None, eip_id=None, host_name=None,
                 instance_id=None, instance_type_family=None, ip_group=None, nat_ip=None, network_type=None,
                 operating_system=None, region=None, serial_number=None, is_aliyun_host=None):
        # The version of the CloudMonitor agent.
        self.agent_version = agent_version  # type: str
        # The ID of the Alibaba Cloud account.
        self.ali_uid = ali_uid  # type: long
        # The elastic IP address (EIP) of the host.
        self.eip_address = eip_address  # type: str
        # The ID of the EIP.
        self.eip_id = eip_id  # type: str
        # The name of the host.
        self.host_name = host_name  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The type of the ECS instance.
        self.instance_type_family = instance_type_family  # type: str
        # The IP address of the host.
        # 
        # > Multiple IP addresses are separated with commas (,).
        self.ip_group = ip_group  # type: str
        # The IP address of the Network Address Translation (NAT) gateway.
        self.nat_ip = nat_ip  # type: str
        # The network type.
        self.network_type = network_type  # type: str
        # The operating system.
        self.operating_system = operating_system  # type: str
        # The ID of the region.
        self.region = region  # type: str
        # The serial number of the host. A host that is not provided by Alibaba Cloud has a serial number instead of an instance ID.
        # 
        # > This parameter can be used to accurately search for a monitored host.
        self.serial_number = serial_number  # type: str
        # Indicates whether the host is provided by Alibaba Cloud. Valid values:
        # 
        # *   true: The host is provided by Alibaba Cloud.
        # *   false: The host is not provided by Alibaba Cloud.
        self.is_aliyun_host = is_aliyun_host  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentHostsResponseBodyHostsHost, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.agent_version is not None:
            result['AgentVersion'] = self.agent_version
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.eip_address is not None:
            result['EipAddress'] = self.eip_address
        if self.eip_id is not None:
            result['EipId'] = self.eip_id
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.ip_group is not None:
            result['IpGroup'] = self.ip_group
        if self.nat_ip is not None:
            result['NatIp'] = self.nat_ip
        if self.network_type is not None:
            result['NetworkType'] = self.network_type
        if self.operating_system is not None:
            result['OperatingSystem'] = self.operating_system
        if self.region is not None:
            result['Region'] = self.region
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.is_aliyun_host is not None:
            result['isAliyunHost'] = self.is_aliyun_host
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AgentVersion') is not None:
            self.agent_version = m.get('AgentVersion')
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('EipAddress') is not None:
            self.eip_address = m.get('EipAddress')
        if m.get('EipId') is not None:
            self.eip_id = m.get('EipId')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('IpGroup') is not None:
            self.ip_group = m.get('IpGroup')
        if m.get('NatIp') is not None:
            self.nat_ip = m.get('NatIp')
        if m.get('NetworkType') is not None:
            self.network_type = m.get('NetworkType')
        if m.get('OperatingSystem') is not None:
            self.operating_system = m.get('OperatingSystem')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('isAliyunHost') is not None:
            self.is_aliyun_host = m.get('isAliyunHost')
        return self


class DescribeMonitoringAgentHostsResponseBodyHosts(TeaModel):
    def __init__(self, host=None):
        self.host = host  # type: list[DescribeMonitoringAgentHostsResponseBodyHostsHost]

    def validate(self):
        if self.host:
            for k in self.host:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentHostsResponseBodyHosts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Host'] = []
        if self.host is not None:
            for k in self.host:
                result['Host'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.host = []
        if m.get('Host') is not None:
            for k in m.get('Host'):
                temp_model = DescribeMonitoringAgentHostsResponseBodyHostsHost()
                self.host.append(temp_model.from_map(k))
        return self


class DescribeMonitoringAgentHostsResponseBody(TeaModel):
    def __init__(self, code=None, hosts=None, message=None, page_number=None, page_size=None, page_total=None,
                 request_id=None, success=None, total=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The information about the hosts.
        self.hosts = hosts  # type: DescribeMonitoringAgentHostsResponseBodyHosts
        # The error message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The total number of returned pages.
        self.page_total = page_total  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool
        # The total number of returned entries.
        self.total = total  # type: int

    def validate(self):
        if self.hosts:
            self.hosts.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentHostsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.hosts is not None:
            result['Hosts'] = self.hosts.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.page_total is not None:
            result['PageTotal'] = self.page_total
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Hosts') is not None:
            temp_model = DescribeMonitoringAgentHostsResponseBodyHosts()
            self.hosts = temp_model.from_map(m['Hosts'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('PageTotal') is not None:
            self.page_total = m.get('PageTotal')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeMonitoringAgentHostsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringAgentHostsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentHostsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringAgentHostsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringAgentProcessesRequest(TeaModel):
    def __init__(self, instance_id=None, region_id=None):
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentProcessesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess(TeaModel):
    def __init__(self, command=None, group_id=None, instance_id=None, process_id=None, process_name=None,
                 process_user=None):
        # The command used to obtain the number of processes. Valid value: `number`.
        # 
        # >  The `number` command obtains the number of processes that match the condition.
        self.command = command  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The ID of the instance.
        self.instance_id = instance_id  # type: str
        # The ID of the process.
        self.process_id = process_id  # type: long
        # The name of the process.
        self.process_name = process_name  # type: str
        # The user who launched the process.
        self.process_user = process_user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command is not None:
            result['Command'] = self.command
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.process_id is not None:
            result['ProcessId'] = self.process_id
        if self.process_name is not None:
            result['ProcessName'] = self.process_name
        if self.process_user is not None:
            result['ProcessUser'] = self.process_user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Command') is not None:
            self.command = m.get('Command')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('ProcessId') is not None:
            self.process_id = m.get('ProcessId')
        if m.get('ProcessName') is not None:
            self.process_name = m.get('ProcessName')
        if m.get('ProcessUser') is not None:
            self.process_user = m.get('ProcessUser')
        return self


class DescribeMonitoringAgentProcessesResponseBodyNodeProcesses(TeaModel):
    def __init__(self, node_process=None):
        self.node_process = node_process  # type: list[DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess]

    def validate(self):
        if self.node_process:
            for k in self.node_process:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentProcessesResponseBodyNodeProcesses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeProcess'] = []
        if self.node_process is not None:
            for k in self.node_process:
                result['NodeProcess'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node_process = []
        if m.get('NodeProcess') is not None:
            for k in m.get('NodeProcess'):
                temp_model = DescribeMonitoringAgentProcessesResponseBodyNodeProcessesNodeProcess()
                self.node_process.append(temp_model.from_map(k))
        return self


class DescribeMonitoringAgentProcessesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, node_processes=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The information about the processes.
        self.node_processes = node_processes  # type: DescribeMonitoringAgentProcessesResponseBodyNodeProcesses
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.node_processes:
            self.node_processes.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentProcessesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.node_processes is not None:
            result['NodeProcesses'] = self.node_processes.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NodeProcesses') is not None:
            temp_model = DescribeMonitoringAgentProcessesResponseBodyNodeProcesses()
            self.node_processes = temp_model.from_map(m['NodeProcesses'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitoringAgentProcessesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringAgentProcessesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentProcessesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringAgentProcessesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringAgentStatusesRequest(TeaModel):
    def __init__(self, host_availability_task_id=None, instance_ids=None, region_id=None):
        # The ID of the availability monitoring task.
        self.host_availability_task_id = host_availability_task_id  # type: str
        # The instance IDs. Separate multiple instance IDs with commas (,).
        self.instance_ids = instance_ids  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentStatusesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_availability_task_id is not None:
            result['HostAvailabilityTaskId'] = self.host_availability_task_id
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HostAvailabilityTaskId') is not None:
            self.host_availability_task_id = m.get('HostAvailabilityTaskId')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus(TeaModel):
    def __init__(self, auto_install=None, instance_id=None, os_monitor_config=None, os_monitor_error_code=None,
                 os_monitor_error_detail=None, os_monitor_status=None, os_monitor_version=None, status=None):
        # Indicates whether the CloudMonitor agent is automatically installed. Valid values:
        # 
        # *   true: The CloudMonitor agent is automatically installed.
        # *   false: The CloudMonitor agent is not automatically installed.
        self.auto_install = auto_install  # type: bool
        # The instance ID.
        self.instance_id = instance_id  # type: str
        # Indicates whether the SysAK monitoring feature is enabled.`` Valid values:
        # 
        # *   `true`: The SysAK monitoring feature is enabled.
        # *   `false`: the SysAK monitoring feature is disabled.
        self.os_monitor_config = os_monitor_config  # type: str
        # The error status of SysOM. Valid values:
        # 
        # *   `install_fail`: SysOM fails to be installed or an unknown error occurs.
        # *   `install_assist_invalid`: SysOM fails to be installed because the status of Cloud Assistant is invalid.
        # *   `install_assist_command_fail`: SysOM fails to be installed because the installation command fails to run.
        # *   `uninstall_fail`: SysOM fails to be uninstalled or an unknown error occurs.
        # *   `uninstall_assist_invalid`: SysOM fails to be uninstalled because the status of Cloud Assistant is invalid.
        # *   `uninstall_assist_command_fail`: SysOM fails to be uninstalled because the uninstallation command fails to run.
        self.os_monitor_error_code = os_monitor_error_code  # type: str
        # The details of the execution error. Valid values:
        # 
        # *   `Command.ErrorCode.Fail.Downlaod.REGIN_ID`: Failed to obtain the region ID.
        # *   `Command.ErrorCode.Fail.Downlaod.SYSAK`: Failed to download the .rpm package of System Analyse Kit (SysAK).
        # *   `Command.ErrorCode.Fail.Downlaod.CMON_FILE`: Failed to download the CMON file.
        # *   `Command.ErrorCode.Fail.Downlaod.BTF`: Failed to start SysAK because the BTF file is not found.
        # *   `Command.ErrorCode.Fail.Start.SYSAK`: Failed to start SysAK due to an unknown error.
        self.os_monitor_error_detail = os_monitor_error_detail  # type: str
        # The status of SysOM. Valid values:
        # 
        # *   installing: SysOM is being installed.
        # *   running: SysOM is running.
        # *   stopped: SysOM is stopped.
        # *   uninstalling: SysOM is being uninstalled.
        self.os_monitor_status = os_monitor_status  # type: str
        # The SysOM version.
        self.os_monitor_version = os_monitor_version  # type: str
        # The status of the CloudMonitor agent. Valid values:
        # 
        # *   running: The CloudMonitor agent is running.
        # *   stopped: The CloudMonitor agent is stopped.
        # *   installing: The CloudMonitor agent is being installed.
        # *   install_faild: The CloudMonitor agent fails to be installed.
        # *   abnormal: The CloudMonitor agent is not properly installed.
        # *   not_installed: The CloudMonitor agent is not installed.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_install is not None:
            result['AutoInstall'] = self.auto_install
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.os_monitor_config is not None:
            result['OsMonitorConfig'] = self.os_monitor_config
        if self.os_monitor_error_code is not None:
            result['OsMonitorErrorCode'] = self.os_monitor_error_code
        if self.os_monitor_error_detail is not None:
            result['OsMonitorErrorDetail'] = self.os_monitor_error_detail
        if self.os_monitor_status is not None:
            result['OsMonitorStatus'] = self.os_monitor_status
        if self.os_monitor_version is not None:
            result['OsMonitorVersion'] = self.os_monitor_version
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoInstall') is not None:
            self.auto_install = m.get('AutoInstall')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('OsMonitorConfig') is not None:
            self.os_monitor_config = m.get('OsMonitorConfig')
        if m.get('OsMonitorErrorCode') is not None:
            self.os_monitor_error_code = m.get('OsMonitorErrorCode')
        if m.get('OsMonitorErrorDetail') is not None:
            self.os_monitor_error_detail = m.get('OsMonitorErrorDetail')
        if m.get('OsMonitorStatus') is not None:
            self.os_monitor_status = m.get('OsMonitorStatus')
        if m.get('OsMonitorVersion') is not None:
            self.os_monitor_version = m.get('OsMonitorVersion')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeMonitoringAgentStatusesResponseBodyNodeStatusList(TeaModel):
    def __init__(self, node_status=None):
        self.node_status = node_status  # type: list[DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus]

    def validate(self):
        if self.node_status:
            for k in self.node_status:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentStatusesResponseBodyNodeStatusList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeStatus'] = []
        if self.node_status is not None:
            for k in self.node_status:
                result['NodeStatus'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node_status = []
        if m.get('NodeStatus') is not None:
            for k in m.get('NodeStatus'):
                temp_model = DescribeMonitoringAgentStatusesResponseBodyNodeStatusListNodeStatus()
                self.node_status.append(temp_model.from_map(k))
        return self


class DescribeMonitoringAgentStatusesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, node_status_list=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The host status information.
        self.node_status_list = node_status_list  # type: DescribeMonitoringAgentStatusesResponseBodyNodeStatusList
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.node_status_list:
            self.node_status_list.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentStatusesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.node_status_list is not None:
            result['NodeStatusList'] = self.node_status_list.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NodeStatusList') is not None:
            temp_model = DescribeMonitoringAgentStatusesResponseBodyNodeStatusList()
            self.node_status_list = temp_model.from_map(m['NodeStatusList'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitoringAgentStatusesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringAgentStatusesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringAgentStatusesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringAgentStatusesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeMonitoringConfigRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeMonitoringConfigResponseBody(TeaModel):
    def __init__(self, auto_install=None, code=None, enable_install_agent_new_ecs=None, message=None,
                 request_id=None, success=None):
        # Indicates whether the Cloud Monitor agent is automatically installed on existing ECS instances. Valid values:
        # 
        # *   true
        # *   false
        self.auto_install = auto_install  # type: bool
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # Indicates whether the Cloud Monitor agent is automatically installed on new Elastic Compute Service (ECS) instances. Valid values:
        # 
        # *   true
        # *   false
        self.enable_install_agent_new_ecs = enable_install_agent_new_ecs  # type: bool
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeMonitoringConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_install is not None:
            result['AutoInstall'] = self.auto_install
        if self.code is not None:
            result['Code'] = self.code
        if self.enable_install_agent_new_ecs is not None:
            result['EnableInstallAgentNewECS'] = self.enable_install_agent_new_ecs
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoInstall') is not None:
            self.auto_install = m.get('AutoInstall')
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('EnableInstallAgentNewECS') is not None:
            self.enable_install_agent_new_ecs = m.get('EnableInstallAgentNewECS')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeMonitoringConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeMonitoringConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeMonitoringConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeMonitoringConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProductResourceTagKeyListRequest(TeaModel):
    def __init__(self, next_token=None, region_id=None):
        # The pagination cursor.
        self.next_token = next_token  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProductResourceTagKeyListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeProductResourceTagKeyListResponseBodyTagKeys(TeaModel):
    def __init__(self, tag_key=None):
        self.tag_key = tag_key  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProductResourceTagKeyListResponseBodyTagKeys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class DescribeProductResourceTagKeyListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, next_token=None, request_id=None, success=None, tag_keys=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The pagination cursor. If more entries are to be returned on the next page, a pagination cursor is returned.
        # 
        # >  If the value of this parameter is not null, more entries are to be returned on the next page. You can use the returned pagination cursor as a request parameter to obtain entries on the next page. If the value of this parameter is null, all the entries have been returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool
        # The keys of tags.
        self.tag_keys = tag_keys  # type: DescribeProductResourceTagKeyListResponseBodyTagKeys

    def validate(self):
        if self.tag_keys:
            self.tag_keys.validate()

    def to_map(self):
        _map = super(DescribeProductResourceTagKeyListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TagKeys') is not None:
            temp_model = DescribeProductResourceTagKeyListResponseBodyTagKeys()
            self.tag_keys = temp_model.from_map(m['TagKeys'])
        return self


class DescribeProductResourceTagKeyListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProductResourceTagKeyListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProductResourceTagKeyListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProductResourceTagKeyListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProductsOfActiveMetricRuleRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig(TeaModel):
    def __init__(self, evaluation_count=None, metric_name=None, namespace=None, period=None, statistics=None,
                 threshold=None):
        # The consecutive number of times for which the metric value is measured before an alert is triggered.
        self.evaluation_count = evaluation_count  # type: str
        # The name of the metric. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the service. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The aggregation period of the monitoring data. Unit: minutes. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        # The statistical aggregation method that is used to calculate metric values that trigger alerts. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold of the metric value.
        self.threshold = threshold  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList(TeaModel):
    def __init__(self, alert_init_config=None):
        self.alert_init_config = alert_init_config  # type: list[DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig]

    def validate(self):
        if self.alert_init_config:
            for k in self.alert_init_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertInitConfig'] = []
        if self.alert_init_config is not None:
            for k in self.alert_init_config:
                result['AlertInitConfig'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_init_config = []
        if m.get('AlertInitConfig') is not None:
            for k in m.get('AlertInitConfig'):
                temp_model = DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigListAlertInitConfig()
                self.alert_init_config.append(temp_model.from_map(k))
        return self


class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule(TeaModel):
    def __init__(self, alert_init_config_list=None, product=None):
        # The initial alert rules that are generated after one-click alert is enabled for a service.
        self.alert_init_config_list = alert_init_config_list  # type: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList
        self.product = product  # type: str

    def validate(self):
        if self.alert_init_config_list:
            self.alert_init_config_list.validate()

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_init_config_list is not None:
            result['AlertInitConfigList'] = self.alert_init_config_list.to_map()
        if self.product is not None:
            result['Product'] = self.product
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertInitConfigList') is not None:
            temp_model = DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRuleAlertInitConfigList()
            self.alert_init_config_list = temp_model.from_map(m['AlertInitConfigList'])
        if m.get('Product') is not None:
            self.product = m.get('Product')
        return self


class DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList(TeaModel):
    def __init__(self, all_product_init_metric_rule=None):
        self.all_product_init_metric_rule = all_product_init_metric_rule  # type: list[DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule]

    def validate(self):
        if self.all_product_init_metric_rule:
            for k in self.all_product_init_metric_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AllProductInitMetricRule'] = []
        if self.all_product_init_metric_rule is not None:
            for k in self.all_product_init_metric_rule:
                result['AllProductInitMetricRule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.all_product_init_metric_rule = []
        if m.get('AllProductInitMetricRule') is not None:
            for k in m.get('AllProductInitMetricRule'):
                temp_model = DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleListAllProductInitMetricRule()
                self.all_product_init_metric_rule.append(temp_model.from_map(k))
        return self


class DescribeProductsOfActiveMetricRuleResponseBody(TeaModel):
    def __init__(self, all_product_init_metric_rule_list=None, code=None, datapoints=None, message=None,
                 request_id=None, success=None):
        # The information about the services for which one-click alert is enabled.
        self.all_product_init_metric_rule_list = all_product_init_metric_rule_list  # type: DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList
        self.code = code  # type: int
        self.datapoints = datapoints  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.all_product_init_metric_rule_list:
            self.all_product_init_metric_rule_list.validate()

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_product_init_metric_rule_list is not None:
            result['AllProductInitMetricRuleList'] = self.all_product_init_metric_rule_list.to_map()
        if self.code is not None:
            result['Code'] = self.code
        if self.datapoints is not None:
            result['Datapoints'] = self.datapoints
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllProductInitMetricRuleList') is not None:
            temp_model = DescribeProductsOfActiveMetricRuleResponseBodyAllProductInitMetricRuleList()
            self.all_product_init_metric_rule_list = temp_model.from_map(m['AllProductInitMetricRuleList'])
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Datapoints') is not None:
            self.datapoints = m.get('Datapoints')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeProductsOfActiveMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProductsOfActiveMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProductsOfActiveMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProductsOfActiveMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeProjectMetaRequest(TeaModel):
    def __init__(self, labels=None, page_number=None, page_size=None):
        # The tags. Tags are used to filter services.
        # 
        # You can filter services only by the tag whose `name` is `product`. Example: {"name":"product","value":"ECS"}.
        # 
        # > We recommend that you do not use the special tags in the CloudMonitor console.
        self.labels = labels  # type: str
        # The page number.
        # 
        # Valid values: 1 to 100.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries per page.
        # 
        # Valid values: 1 to 10000.
        # 
        # Default value: 30.
        # 
        # > The value of this parameter is not limited. You can view a large number of entries per page.
        self.page_size = page_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectMetaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        return self


class DescribeProjectMetaResponseBodyResourcesResource(TeaModel):
    def __init__(self, description=None, labels=None, namespace=None):
        # The description.
        self.description = description  # type: str
        # The tags. Tags are used to filter services.
        # 
        # Tags are returned in the following format: `[{"name":"Tag key","value":"Tag value"}, {"name":"Tag key","value":"Tag value"}]`. The following tags are commonly used:
        # 
        # *   alertUnit: the unit of the metric value in alerts. If the unit is small, the original metric value may be too large. In this case, you can use the `alertUnit` tag to specify an appropriate unit. This tag is used in CloudMonitor.
        # *   minAlertPeriod: the minimum time interval to report a new alert. The interval is usually set to 1 minute.
        # *   metricCategory: the service specification. Example: kvstore_sharding. An Alibaba Cloud service may have different specifications that are defined in the same namespace. You can use this parameter to distinguish between service specifications.
        # *   is_alarm: specifies whether an alert rule can be set. We recommend that you do not use the special tags in the CloudMonitor console.
        self.labels = labels  # type: str
        # The namespace of the cloud service. Format: `acs_Service name abbreviation`. For more information about namespaces, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeProjectMetaResponseBodyResourcesResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.labels is not None:
            result['Labels'] = self.labels
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Labels') is not None:
            self.labels = m.get('Labels')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        return self


class DescribeProjectMetaResponseBodyResources(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeProjectMetaResponseBodyResourcesResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeProjectMetaResponseBodyResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeProjectMetaResponseBodyResourcesResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeProjectMetaResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None, resources=None,
                 success=None, total=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The page number.
        self.page_number = page_number  # type: str
        # The number of entries per page.
        self.page_size = page_size  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The details of the cloud service.
        self.resources = resources  # type: DescribeProjectMetaResponseBodyResources
        # Indicates whether the request was successful. Valid values: true: The request was successful. false: The request failed.
        self.success = success  # type: bool
        # The total number of entries returned.
        self.total = total  # type: str

    def validate(self):
        if self.resources:
            self.resources.validate()

    def to_map(self):
        _map = super(DescribeProjectMetaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.resources is not None:
            result['Resources'] = self.resources.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total is not None:
            result['Total'] = self.total
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Resources') is not None:
            temp_model = DescribeProjectMetaResponseBodyResources()
            self.resources = temp_model.from_map(m['Resources'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Total') is not None:
            self.total = m.get('Total')
        return self


class DescribeProjectMetaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeProjectMetaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeProjectMetaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeProjectMetaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorAttributeRequest(TeaModel):
    def __init__(self, include_alert=None, region_id=None, task_id=None):
        # Specifies whether to return the information of the alert rules that are configured for the site monitoring task. Valid values:
        # 
        # *   true: The system returns the information of the alert rules that are configured for the site monitoring task.
        # *   false (default): The system does not return the information of the alert rules that are configured for the site monitoring task.
        self.include_alert = include_alert  # type: bool
        self.region_id = region_id  # type: str
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.include_alert is not None:
            result['IncludeAlert'] = self.include_alert
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IncludeAlert') is not None:
            self.include_alert = m.get('IncludeAlert')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule(TeaModel):
    def __init__(self, action_enable=None, alarm_actions=None, comparison_operator=None, dimensions=None,
                 evaluation_count=None, expression=None, level=None, metric_name=None, namespace=None, ok_actions=None, period=None,
                 rule_id=None, rule_name=None, state_value=None, statistics=None, threshold=None):
        # Indicates whether the alert rule is enabled. Valid values:
        # 
        # *   true: The alert rule is enabled.
        # *   false: The alert rule is disabled.
        self.action_enable = action_enable  # type: str
        # The alert contact group to which alert notifications are sent.
        self.alarm_actions = alarm_actions  # type: str
        # The operator that is used to compare the metric value with the threshold in the alert rule. Valid values:
        # 
        # *   `>=`
        # *   `>`
        # *   `<=`
        # *   `<`
        # *   `=`
        # *   `!=`
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The dimension of the alert rule.
        self.dimensions = dimensions  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered.
        self.evaluation_count = evaluation_count  # type: str
        # The expression that is used to trigger alerts.
        self.expression = expression  # type: str
        # The alert severity. Valid values:
        # 
        # *   1: critical
        # *   2: warning
        # *   3: information
        self.level = level  # type: str
        # The metric name.
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # The value is in the following format: acs_service name.
        self.namespace = namespace  # type: str
        # The alert contact group that receives alert notifications.
        self.ok_actions = ok_actions  # type: str
        # The time interval. The value is the same as the interval at which metric data is reported. Unit: seconds.
        # 
        # >  If you specify a statistical period for the alert rule, data is queried based on the statistical period.
        self.period = period  # type: str
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The alert status. Valid values:
        # 
        # *   OK: The alert rule has no active alerts.
        # *   ALARM: The alert rule has active alerts.
        self.state_value = state_value  # type: str
        # The statistical method of the alert rule. Valid values:
        # 
        # *   Availability: the percentage of available detection points
        # *   AvailableNumber: the number of available detection points
        # *   ErrorCodeMaximum: a status code for an alert
        # *   ErrorCodeMinimum: all status codes for a set of alerts
        # *   Average: response time
        self.statistics = statistics  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action_enable is not None:
            result['ActionEnable'] = self.action_enable
        if self.alarm_actions is not None:
            result['AlarmActions'] = self.alarm_actions
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.expression is not None:
            result['Expression'] = self.expression
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.ok_actions is not None:
            result['OkActions'] = self.ok_actions
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.state_value is not None:
            result['StateValue'] = self.state_value
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ActionEnable') is not None:
            self.action_enable = m.get('ActionEnable')
        if m.get('AlarmActions') is not None:
            self.alarm_actions = m.get('AlarmActions')
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('Expression') is not None:
            self.expression = m.get('Expression')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('OkActions') is not None:
            self.ok_actions = m.get('OkActions')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('StateValue') is not None:
            self.state_value = m.get('StateValue')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class DescribeSiteMonitorAttributeResponseBodyMetricRules(TeaModel):
    def __init__(self, metric_rule=None):
        self.metric_rule = metric_rule  # type: list[DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule]

    def validate(self):
        if self.metric_rule:
            for k in self.metric_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodyMetricRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricRule'] = []
        if self.metric_rule is not None:
            for k in self.metric_rule:
                result['MetricRule'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_rule = []
        if m.get('MetricRule') is not None:
            for k in m.get('MetricRule'):
                temp_model = DescribeSiteMonitorAttributeResponseBodyMetricRulesMetricRule()
                self.metric_rule.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays(TeaModel):
    def __init__(self, days=None):
        self.days = days  # type: list[int]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['days'] = self.days
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('days') is not None:
            self.days = m.get('days')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule(TeaModel):
    def __init__(self, days=None, end_hour=None, start_hour=None, time_zone=None):
        self.days = days  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays
        self.end_hour = end_hour  # type: int
        self.start_hour = start_hour  # type: int
        self.time_zone = time_zone  # type: str

    def validate(self):
        if self.days:
            self.days.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.days is not None:
            result['days'] = self.days.to_map()
        if self.end_hour is not None:
            result['end_hour'] = self.end_hour
        if self.start_hour is not None:
            result['start_hour'] = self.start_hour
        if self.time_zone is not None:
            result['time_zone'] = self.time_zone
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('days') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomScheduleDays()
            self.days = temp_model.from_map(m['days'])
        if m.get('end_hour') is not None:
            self.end_hour = m.get('end_hour')
        if m.get('start_hour') is not None:
            self.start_hour = m.get('start_hour')
        if m.get('time_zone') is not None:
            self.time_zone = m.get('time_zone')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity(TeaModel):
    def __init__(self, city=None, city_name=None, isp=None, isp_name=None):
        # The city ID.
        self.city = city  # type: str
        # The city name.
        self.city_name = city_name  # type: str
        # The carrier ID.
        self.isp = isp  # type: str
        # The carrier name.
        self.isp_name = isp_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.city_name is not None:
            result['CityName'] = self.city_name
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.isp_name is not None:
            result['IspName'] = self.isp_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CityName') is not None:
            self.city_name = m.get('CityName')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('IspName') is not None:
            self.isp_name = m.get('IspName')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities(TeaModel):
    def __init__(self, isp_city=None):
        self.isp_city = isp_city  # type: list[DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity]

    def validate(self):
        if self.isp_city:
            for k in self.isp_city:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCity'] = []
        if self.isp_city is not None:
            for k in self.isp_city:
                result['IspCity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.isp_city = []
        if m.get('IspCity') is not None:
            for k in m.get('IspCity'):
                temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCitiesIspCity()
                self.isp_city.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions(TeaModel):
    def __init__(self, operator=None, property=None, target=None, type=None):
        self.operator = operator  # type: str
        self.property = property  # type: str
        self.target = target  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['operator'] = self.operator
        if self.property is not None:
            result['property'] = self.property
        if self.target is not None:
            result['target'] = self.target
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('property') is not None:
            self.property = m.get('property')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions(TeaModel):
    def __init__(self, assertions=None):
        self.assertions = assertions  # type: list[DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions]

    def validate(self):
        if self.assertions:
            for k in self.assertions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['assertions'] = []
        if self.assertions is not None:
            for k in self.assertions:
                result['assertions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.assertions = []
        if m.get('assertions') is not None:
            for k in m.get('assertions'):
                temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertionsAssertions()
                self.assertions.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList(TeaModel):
    def __init__(self, blocked_url_list=None):
        self.blocked_url_list = blocked_url_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.blocked_url_list is not None:
            result['blocked_url_list'] = self.blocked_url_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('blocked_url_list') is not None:
            self.blocked_url_list = m.get('blocked_url_list')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders(TeaModel):
    def __init__(self, browser_headers=None):
        self.browser_headers = browser_headers  # type: list[dict[str, any]]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.browser_headers is not None:
            result['browser_headers'] = self.browser_headers
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('browser_headers') is not None:
            self.browser_headers = m.get('browser_headers')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts(TeaModel):
    def __init__(self, browser_hosts=None):
        self.browser_hosts = browser_hosts  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.browser_hosts is not None:
            result['browser_hosts'] = self.browser_hosts
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('browser_hosts') is not None:
            self.browser_hosts = m.get('browser_hosts')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo(TeaModel):
    def __init__(self, browser=None, device=None):
        self.browser = browser  # type: str
        self.device = device  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.browser is not None:
            result['browser'] = self.browser
        if self.device is not None:
            result['device'] = self.device
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('browser') is not None:
            self.browser = m.get('browser')
        if m.get('device') is not None:
            self.device = m.get('device')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo(TeaModel):
    def __init__(self, browser_info=None):
        self.browser_info = browser_info  # type: list[DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo]

    def validate(self):
        if self.browser_info:
            for k in self.browser_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['browser_info'] = []
        if self.browser_info is not None:
            for k in self.browser_info:
                result['browser_info'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.browser_info = []
        if m.get('browser_info') is not None:
            for k in m.get('browser_info'):
                temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfoBrowserInfo()
                self.browser_info.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString(TeaModel):
    def __init__(self, expect_exist_string=None):
        self.expect_exist_string = expect_exist_string  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_exist_string is not None:
            result['expect_exist_string'] = self.expect_exist_string
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('expect_exist_string') is not None:
            self.expect_exist_string = m.get('expect_exist_string')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString(TeaModel):
    def __init__(self, expect_non_exist_string=None):
        self.expect_non_exist_string = expect_non_exist_string  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.expect_non_exist_string is not None:
            result['expect_non_exist_string'] = self.expect_non_exist_string
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('expect_non_exist_string') is not None:
            self.expect_non_exist_string = m.get('expect_non_exist_string')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist(TeaModel):
    def __init__(self, traffic_hijack_element_blacklist=None):
        self.traffic_hijack_element_blacklist = traffic_hijack_element_blacklist  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.traffic_hijack_element_blacklist is not None:
            result['traffic_hijack_element_blacklist'] = self.traffic_hijack_element_blacklist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('traffic_hijack_element_blacklist') is not None:
            self.traffic_hijack_element_blacklist = m.get('traffic_hijack_element_blacklist')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist(TeaModel):
    def __init__(self, traffic_hijack_element_whitelist=None):
        self.traffic_hijack_element_whitelist = traffic_hijack_element_whitelist  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.traffic_hijack_element_whitelist is not None:
            result['traffic_hijack_element_whitelist'] = self.traffic_hijack_element_whitelist
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('traffic_hijack_element_whitelist') is not None:
            self.traffic_hijack_element_whitelist = m.get('traffic_hijack_element_whitelist')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson(TeaModel):
    def __init__(self, assertions=None, attempts=None, authentication=None, blocked_url_list=None,
                 browser_headers=None, browser_hosts=None, browser_info=None, browser_insecure=None, browser_task_version=None,
                 cookie=None, diagnosis_mtr=None, diagnosis_ping=None, dns_hijack_whitelist=None, dns_match_rule=None,
                 dns_server=None, dns_type=None, expect_exist_string=None, expect_non_exist_string=None, expect_value=None,
                 failure_rate=None, header=None, http_method=None, is_base_64encode=None, match_rule=None, min_tls_version=None,
                 password=None, ping_num=None, ping_port=None, ping_type=None, port=None, protocol=None, request_content=None,
                 request_format=None, response_content=None, response_format=None, retry_delay=None, strict_mode=None,
                 time_out=None, traffic_hijack_element_blacklist=None, traffic_hijack_element_count=None,
                 traffic_hijack_element_whitelist=None, username=None, wait_time_after_completion=None):
        self.assertions = assertions  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions
        # The number of retries after a DNS failure occurred.
        self.attempts = attempts  # type: long
        # Indicates whether the security authentication feature is enabled. Valid values:
        # 
        # *   0: The feature is disabled.
        # *   1: The feature is enabled.
        self.authentication = authentication  # type: int
        self.blocked_url_list = blocked_url_list  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList
        self.browser_headers = browser_headers  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders
        self.browser_hosts = browser_hosts  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts
        self.browser_info = browser_info  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo
        self.browser_insecure = browser_insecure  # type: bool
        self.browser_task_version = browser_task_version  # type: str
        # The cookie of the HTTP request.
        self.cookie = cookie  # type: str
        self.diagnosis_mtr = diagnosis_mtr  # type: bool
        self.diagnosis_ping = diagnosis_ping  # type: bool
        self.dns_hijack_whitelist = dns_hijack_whitelist  # type: str
        # The relationship between the list of expected aliases or IP addresses and the list of DNS results. Valid values:
        # 
        # *   IN_DNS: The list of expected values is a subset of the list of DNS results.
        # *   DNS_IN: The list of DNS results is a subset of the list of expected values.
        # *   EQUAL: The list of DNS results is the same as the list of expected values.
        # *   ANY: The list of DNS results intersects with the list of expected values.
        self.dns_match_rule = dns_match_rule  # type: str
        # The IP address of the DNS server.
        # 
        # >  This parameter is returned only if the TaskType parameter is set to DNS.
        self.dns_server = dns_server  # type: str
        # The type of the DNS record. This parameter is returned only if the TaskType parameter is set to DNS. Valid values:
        # 
        # *   A (default): a record that specifies an IP address related to the specified host name or domain name.
        # *   CNAME: a record that maps multiple domain names to a domain name.
        # *   NS: a record that specifies a DNS server used to parse domain names.
        # *   MX: a record that links domain names to the address of a mail server.
        # *   TXT: a record that stores the text information of host name or domain names. The text must be 1 to 512 bytes in length. The TXT record serves as a Sender Policy Framework (SPF) record to fight against spam.
        self.dns_type = dns_type  # type: str
        self.expect_exist_string = expect_exist_string  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString
        self.expect_non_exist_string = expect_non_exist_string  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString
        # The domain name or alias to be parsed.
        # 
        # >  This parameter is returned only if the TaskType parameter is set to DNS.
        self.expect_value = expect_value  # type: str
        # The packet loss rate.
        # 
        # >  This parameter is returned only if the TaskType parameter is set to PING.
        self.failure_rate = failure_rate  # type: float
        # The header of the HTTP request.
        self.header = header  # type: str
        # The HTTP request method. Valid values:
        # 
        # *   get
        # *   post
        # *   head
        self.http_method = http_method  # type: str
        self.is_base_64encode = is_base_64encode  # type: str
        # Indicates whether the alert rule is included. Valid values:
        # 
        # *   0: The alert rule is included.
        # *   1: The alert rule is excluded.
        self.match_rule = match_rule  # type: int
        self.min_tls_version = min_tls_version  # type: str
        # The password of the SMTP, POP3, or FTP protocol.
        self.password = password  # type: str
        # The heartbeat of the PING protocol.
        self.ping_num = ping_num  # type: int
        self.ping_port = ping_port  # type: int
        self.ping_type = ping_type  # type: str
        # The port number of the TCP, UDP, SMTP, or POP3 protocol.
        self.port = port  # type: int
        # The protocol that is used to send the request.
        self.protocol = protocol  # type: str
        # The content of the HTTP request.
        self.request_content = request_content  # type: str
        # The format of the HTTP request. Valid values:
        # 
        # *   hex: hexadecimal
        # *   txt: text
        self.request_format = request_format  # type: str
        # The response to the HTTP request.
        self.response_content = response_content  # type: str
        # The format of the HTTP response. Valid values:
        # 
        # *   hex: hexadecimal
        # *   txt: text
        self.response_format = response_format  # type: str
        self.retry_delay = retry_delay  # type: int
        self.strict_mode = strict_mode  # type: bool
        # The timeout period. Unit: milliseconds.
        self.time_out = time_out  # type: long
        self.traffic_hijack_element_blacklist = traffic_hijack_element_blacklist  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist
        self.traffic_hijack_element_count = traffic_hijack_element_count  # type: int
        self.traffic_hijack_element_whitelist = traffic_hijack_element_whitelist  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist
        # The username of the FTP, SMTP, or POP3 protocol.
        self.username = username  # type: str
        self.wait_time_after_completion = wait_time_after_completion  # type: int

    def validate(self):
        if self.assertions:
            self.assertions.validate()
        if self.blocked_url_list:
            self.blocked_url_list.validate()
        if self.browser_headers:
            self.browser_headers.validate()
        if self.browser_hosts:
            self.browser_hosts.validate()
        if self.browser_info:
            self.browser_info.validate()
        if self.expect_exist_string:
            self.expect_exist_string.validate()
        if self.expect_non_exist_string:
            self.expect_non_exist_string.validate()
        if self.traffic_hijack_element_blacklist:
            self.traffic_hijack_element_blacklist.validate()
        if self.traffic_hijack_element_whitelist:
            self.traffic_hijack_element_whitelist.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.assertions is not None:
            result['assertions'] = self.assertions.to_map()
        if self.attempts is not None:
            result['attempts'] = self.attempts
        if self.authentication is not None:
            result['authentication'] = self.authentication
        if self.blocked_url_list is not None:
            result['blocked_url_list'] = self.blocked_url_list.to_map()
        if self.browser_headers is not None:
            result['browser_headers'] = self.browser_headers.to_map()
        if self.browser_hosts is not None:
            result['browser_hosts'] = self.browser_hosts.to_map()
        if self.browser_info is not None:
            result['browser_info'] = self.browser_info.to_map()
        if self.browser_insecure is not None:
            result['browser_insecure'] = self.browser_insecure
        if self.browser_task_version is not None:
            result['browser_task_version'] = self.browser_task_version
        if self.cookie is not None:
            result['cookie'] = self.cookie
        if self.diagnosis_mtr is not None:
            result['diagnosis_mtr'] = self.diagnosis_mtr
        if self.diagnosis_ping is not None:
            result['diagnosis_ping'] = self.diagnosis_ping
        if self.dns_hijack_whitelist is not None:
            result['dns_hijack_whitelist'] = self.dns_hijack_whitelist
        if self.dns_match_rule is not None:
            result['dns_match_rule'] = self.dns_match_rule
        if self.dns_server is not None:
            result['dns_server'] = self.dns_server
        if self.dns_type is not None:
            result['dns_type'] = self.dns_type
        if self.expect_exist_string is not None:
            result['expect_exist_string'] = self.expect_exist_string.to_map()
        if self.expect_non_exist_string is not None:
            result['expect_non_exist_string'] = self.expect_non_exist_string.to_map()
        if self.expect_value is not None:
            result['expect_value'] = self.expect_value
        if self.failure_rate is not None:
            result['failure_rate'] = self.failure_rate
        if self.header is not None:
            result['header'] = self.header
        if self.http_method is not None:
            result['http_method'] = self.http_method
        if self.is_base_64encode is not None:
            result['isBase64Encode'] = self.is_base_64encode
        if self.match_rule is not None:
            result['match_rule'] = self.match_rule
        if self.min_tls_version is not None:
            result['min_tls_version'] = self.min_tls_version
        if self.password is not None:
            result['password'] = self.password
        if self.ping_num is not None:
            result['ping_num'] = self.ping_num
        if self.ping_port is not None:
            result['ping_port'] = self.ping_port
        if self.ping_type is not None:
            result['ping_type'] = self.ping_type
        if self.port is not None:
            result['port'] = self.port
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.request_content is not None:
            result['request_content'] = self.request_content
        if self.request_format is not None:
            result['request_format'] = self.request_format
        if self.response_content is not None:
            result['response_content'] = self.response_content
        if self.response_format is not None:
            result['response_format'] = self.response_format
        if self.retry_delay is not None:
            result['retry_delay'] = self.retry_delay
        if self.strict_mode is not None:
            result['strict_mode'] = self.strict_mode
        if self.time_out is not None:
            result['time_out'] = self.time_out
        if self.traffic_hijack_element_blacklist is not None:
            result['traffic_hijack_element_blacklist'] = self.traffic_hijack_element_blacklist.to_map()
        if self.traffic_hijack_element_count is not None:
            result['traffic_hijack_element_count'] = self.traffic_hijack_element_count
        if self.traffic_hijack_element_whitelist is not None:
            result['traffic_hijack_element_whitelist'] = self.traffic_hijack_element_whitelist.to_map()
        if self.username is not None:
            result['username'] = self.username
        if self.wait_time_after_completion is not None:
            result['waitTime_after_completion'] = self.wait_time_after_completion
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('assertions') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonAssertions()
            self.assertions = temp_model.from_map(m['assertions'])
        if m.get('attempts') is not None:
            self.attempts = m.get('attempts')
        if m.get('authentication') is not None:
            self.authentication = m.get('authentication')
        if m.get('blocked_url_list') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBlockedUrlList()
            self.blocked_url_list = temp_model.from_map(m['blocked_url_list'])
        if m.get('browser_headers') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHeaders()
            self.browser_headers = temp_model.from_map(m['browser_headers'])
        if m.get('browser_hosts') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserHosts()
            self.browser_hosts = temp_model.from_map(m['browser_hosts'])
        if m.get('browser_info') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonBrowserInfo()
            self.browser_info = temp_model.from_map(m['browser_info'])
        if m.get('browser_insecure') is not None:
            self.browser_insecure = m.get('browser_insecure')
        if m.get('browser_task_version') is not None:
            self.browser_task_version = m.get('browser_task_version')
        if m.get('cookie') is not None:
            self.cookie = m.get('cookie')
        if m.get('diagnosis_mtr') is not None:
            self.diagnosis_mtr = m.get('diagnosis_mtr')
        if m.get('diagnosis_ping') is not None:
            self.diagnosis_ping = m.get('diagnosis_ping')
        if m.get('dns_hijack_whitelist') is not None:
            self.dns_hijack_whitelist = m.get('dns_hijack_whitelist')
        if m.get('dns_match_rule') is not None:
            self.dns_match_rule = m.get('dns_match_rule')
        if m.get('dns_server') is not None:
            self.dns_server = m.get('dns_server')
        if m.get('dns_type') is not None:
            self.dns_type = m.get('dns_type')
        if m.get('expect_exist_string') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectExistString()
            self.expect_exist_string = temp_model.from_map(m['expect_exist_string'])
        if m.get('expect_non_exist_string') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonExpectNonExistString()
            self.expect_non_exist_string = temp_model.from_map(m['expect_non_exist_string'])
        if m.get('expect_value') is not None:
            self.expect_value = m.get('expect_value')
        if m.get('failure_rate') is not None:
            self.failure_rate = m.get('failure_rate')
        if m.get('header') is not None:
            self.header = m.get('header')
        if m.get('http_method') is not None:
            self.http_method = m.get('http_method')
        if m.get('isBase64Encode') is not None:
            self.is_base_64encode = m.get('isBase64Encode')
        if m.get('match_rule') is not None:
            self.match_rule = m.get('match_rule')
        if m.get('min_tls_version') is not None:
            self.min_tls_version = m.get('min_tls_version')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('ping_num') is not None:
            self.ping_num = m.get('ping_num')
        if m.get('ping_port') is not None:
            self.ping_port = m.get('ping_port')
        if m.get('ping_type') is not None:
            self.ping_type = m.get('ping_type')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('request_content') is not None:
            self.request_content = m.get('request_content')
        if m.get('request_format') is not None:
            self.request_format = m.get('request_format')
        if m.get('response_content') is not None:
            self.response_content = m.get('response_content')
        if m.get('response_format') is not None:
            self.response_format = m.get('response_format')
        if m.get('retry_delay') is not None:
            self.retry_delay = m.get('retry_delay')
        if m.get('strict_mode') is not None:
            self.strict_mode = m.get('strict_mode')
        if m.get('time_out') is not None:
            self.time_out = m.get('time_out')
        if m.get('traffic_hijack_element_blacklist') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementBlacklist()
            self.traffic_hijack_element_blacklist = temp_model.from_map(m['traffic_hijack_element_blacklist'])
        if m.get('traffic_hijack_element_count') is not None:
            self.traffic_hijack_element_count = m.get('traffic_hijack_element_count')
        if m.get('traffic_hijack_element_whitelist') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJsonTrafficHijackElementWhitelist()
            self.traffic_hijack_element_whitelist = temp_model.from_map(m['traffic_hijack_element_whitelist'])
        if m.get('username') is not None:
            self.username = m.get('username')
        if m.get('waitTime_after_completion') is not None:
            self.wait_time_after_completion = m.get('waitTime_after_completion')
        return self


class DescribeSiteMonitorAttributeResponseBodySiteMonitors(TeaModel):
    def __init__(self, address=None, agent_group=None, custom_schedule=None, interval=None, isp_cities=None,
                 option_json=None, task_id=None, task_name=None, task_state=None, task_type=None):
        # The URL that is monitored by the site monitoring task.
        self.address = address  # type: str
        self.agent_group = agent_group  # type: str
        self.custom_schedule = custom_schedule  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule
        # The interval at which the site monitoring task is executed. Unit: minutes. Valid values: 1, 5, 15, 30, and 60.
        self.interval = interval  # type: str
        # The information of detection points. The information includes the carriers that provide the detection points and the cities where the detection points reside.
        self.isp_cities = isp_cities  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities
        # The extended options of the site monitoring task. The options vary based on the specified protocol. For more information, see [CreateSiteMonitor](~~115048~~).
        self.option_json = option_json  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The name of the site monitoring task.
        self.task_name = task_name  # type: str
        # The status of the site monitoring task. Valid values:
        # 
        # *   1: The task is enabled.
        # *   2: The task is disabled.
        self.task_state = task_state  # type: str
        # The protocol that is used by the site monitoring task. Valid values: HTTP, HTTPS, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
        self.task_type = task_type  # type: str

    def validate(self):
        if self.custom_schedule:
            self.custom_schedule.validate()
        if self.isp_cities:
            self.isp_cities.validate()
        if self.option_json:
            self.option_json.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBodySiteMonitors, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.agent_group is not None:
            result['AgentGroup'] = self.agent_group
        if self.custom_schedule is not None:
            result['CustomSchedule'] = self.custom_schedule.to_map()
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities.to_map()
        if self.option_json is not None:
            result['OptionJson'] = self.option_json.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_state is not None:
            result['TaskState'] = self.task_state
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AgentGroup') is not None:
            self.agent_group = m.get('AgentGroup')
        if m.get('CustomSchedule') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsCustomSchedule()
            self.custom_schedule = temp_model.from_map(m['CustomSchedule'])
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IspCities') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsIspCities()
            self.isp_cities = temp_model.from_map(m['IspCities'])
        if m.get('OptionJson') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitorsOptionJson()
            self.option_json = temp_model.from_map(m['OptionJson'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskState') is not None:
            self.task_state = m.get('TaskState')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeSiteMonitorAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, metric_rules=None, request_id=None, site_monitors=None, success=None):
        # The response code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The information of the alert rules that are configured for the site monitoring task.
        self.metric_rules = metric_rules  # type: DescribeSiteMonitorAttributeResponseBodyMetricRules
        # The request ID.
        self.request_id = request_id  # type: str
        # The details of the site monitoring task.
        self.site_monitors = site_monitors  # type: DescribeSiteMonitorAttributeResponseBodySiteMonitors
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.metric_rules:
            self.metric_rules.validate()
        if self.site_monitors:
            self.site_monitors.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.metric_rules is not None:
            result['MetricRules'] = self.metric_rules.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.site_monitors is not None:
            result['SiteMonitors'] = self.site_monitors.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MetricRules') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodyMetricRules()
            self.metric_rules = temp_model.from_map(m['MetricRules'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SiteMonitors') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBodySiteMonitors()
            self.site_monitors = temp_model.from_map(m['SiteMonitors'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorDataRequest(TeaModel):
    def __init__(self, end_time=None, length=None, metric_name=None, next_token=None, period=None, region_id=None,
                 start_time=None, task_id=None, type=None):
        # The end of the time range for the query. Supported formats:
        # 
        # *   UNIX timestamp: The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        # *   Time format: The value is in the YYYY-MM-DDThh:mm:ssZ format.
        self.end_time = end_time  # type: str
        # The number of data points to return.
        self.length = length  # type: int
        # The name of the metric. Valid values:
        # 
        # *   Availability
        # *   ResponseTime
        self.metric_name = metric_name  # type: str
        # The pagination cursor.
        self.next_token = next_token  # type: str
        # The interval at which monitoring data is returned. The value is an integral multiple of 60. Unit: seconds.
        # 
        # >  The default value equals the minimum interval at which detection requests are sent to the monitored address.
        self.period = period  # type: str
        self.region_id = region_id  # type: str
        # The beginning of the time range for the query. Supported formats:
        # 
        # *   UNIX timestamp: The value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        # *   Time format: The value is in the YYYY-MM-DDThh:mm:ssZ format.
        self.start_time = start_time  # type: str
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The type of the monitored object whose monitoring data is to be queried. Valid values:
        # 
        # *   metric
        # *   event
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeSiteMonitorDataResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, next_token=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned monitoring data.
        self.data = data  # type: str
        # The returned message.
        self.message = message  # type: str
        # The pagination cursor.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorISPCityListRequest(TeaModel):
    def __init__(self, city=None, ipv4=None, ipv6=None, isp=None, region_id=None, view_all=None):
        # The name or ID of the city.
        # 
        # > City names support fuzzy match.
        self.city = city  # type: str
        # Specifies whether to query IPv4 probes. Valid values:
        # 
        # *   true (default): IPv4 probes are queried.
        # *   false: IPv4 probes are not queried.
        self.ipv4 = ipv4  # type: bool
        # Specifies whether to query IPv6 probes. Valid values:
        # 
        # *   true (default): IPv6 probes are queried.
        # *   false: IPv6 probes are not queried.
        self.ipv6 = ipv6  # type: bool
        # The name or ID of the carrier.
        # 
        # > Carrier names support fuzzy match.
        self.isp = isp  # type: str
        self.region_id = region_id  # type: str
        # Specifies whether to return all detection points. Valid values:
        # 
        # *   true (default): returns all detection points.
        # *   false: returns only available detection points.
        self.view_all = view_all  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.city is not None:
            result['City'] = self.city
        if self.ipv4 is not None:
            result['IPV4'] = self.ipv4
        if self.ipv6 is not None:
            result['IPV6'] = self.ipv6
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.view_all is not None:
            result['ViewAll'] = self.view_all
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('IPV4') is not None:
            self.ipv4 = m.get('IPV4')
        if m.get('IPV6') is not None:
            self.ipv6 = m.get('IPV6')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ViewAll') is not None:
            self.view_all = m.get('ViewAll')
        return self


class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool(TeaModel):
    def __init__(self, ippool=None):
        self.ippool = ippool  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ippool is not None:
            result['IPPool'] = self.ippool
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IPPool') is not None:
            self.ippool = m.get('IPPool')
        return self


class DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity(TeaModel):
    def __init__(self, area_en=None, area_zh_c_n=None, city=None, city_name_en=None, city_name_zh_c_n=None,
                 country=None, country_en=None, country_zh_c_n=None, ippool=None, ipv4probe_count=None,
                 ipv6probe_count=None, isp=None, isp_name_en=None, isp_name_zh_c_n=None, region=None, region_en=None,
                 region_zh_c_n=None):
        self.area_en = area_en  # type: str
        self.area_zh_c_n = area_zh_c_n  # type: str
        # The city ID.
        self.city = city  # type: str
        self.city_name_en = city_name_en  # type: str
        self.city_name_zh_c_n = city_name_zh_c_n  # type: str
        # The country name.
        # 
        # > This parameter is valid only on the China site (aliyun.com).
        self.country = country  # type: str
        self.country_en = country_en  # type: str
        self.country_zh_c_n = country_zh_c_n  # type: str
        # The IP address pool.
        self.ippool = ippool  # type: DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool
        # The number of IPv4 probes.
        self.ipv4probe_count = ipv4probe_count  # type: str
        # The number of IPv6 probes.
        self.ipv6probe_count = ipv6probe_count  # type: str
        # The carrier ID.
        self.isp = isp  # type: str
        self.isp_name_en = isp_name_en  # type: str
        self.isp_name_zh_c_n = isp_name_zh_c_n  # type: str
        # The province name.
        self.region = region  # type: str
        self.region_en = region_en  # type: str
        self.region_zh_c_n = region_zh_c_n  # type: str

    def validate(self):
        if self.ippool:
            self.ippool.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.area_en is not None:
            result['Area.en'] = self.area_en
        if self.area_zh_c_n is not None:
            result['Area.zh_CN'] = self.area_zh_c_n
        if self.city is not None:
            result['City'] = self.city
        if self.city_name_en is not None:
            result['CityName.en'] = self.city_name_en
        if self.city_name_zh_c_n is not None:
            result['CityName.zh_CN'] = self.city_name_zh_c_n
        if self.country is not None:
            result['Country'] = self.country
        if self.country_en is not None:
            result['Country.en'] = self.country_en
        if self.country_zh_c_n is not None:
            result['Country.zh_CN'] = self.country_zh_c_n
        if self.ippool is not None:
            result['IPPool'] = self.ippool.to_map()
        if self.ipv4probe_count is not None:
            result['IPV4ProbeCount'] = self.ipv4probe_count
        if self.ipv6probe_count is not None:
            result['IPV6ProbeCount'] = self.ipv6probe_count
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.isp_name_en is not None:
            result['IspName.en'] = self.isp_name_en
        if self.isp_name_zh_c_n is not None:
            result['IspName.zh_CN'] = self.isp_name_zh_c_n
        if self.region is not None:
            result['Region'] = self.region
        if self.region_en is not None:
            result['Region.en'] = self.region_en
        if self.region_zh_c_n is not None:
            result['Region.zh_CN'] = self.region_zh_c_n
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Area.en') is not None:
            self.area_en = m.get('Area.en')
        if m.get('Area.zh_CN') is not None:
            self.area_zh_c_n = m.get('Area.zh_CN')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('CityName.en') is not None:
            self.city_name_en = m.get('CityName.en')
        if m.get('CityName.zh_CN') is not None:
            self.city_name_zh_c_n = m.get('CityName.zh_CN')
        if m.get('Country') is not None:
            self.country = m.get('Country')
        if m.get('Country.en') is not None:
            self.country_en = m.get('Country.en')
        if m.get('Country.zh_CN') is not None:
            self.country_zh_c_n = m.get('Country.zh_CN')
        if m.get('IPPool') is not None:
            temp_model = DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCityIPPool()
            self.ippool = temp_model.from_map(m['IPPool'])
        if m.get('IPV4ProbeCount') is not None:
            self.ipv4probe_count = m.get('IPV4ProbeCount')
        if m.get('IPV6ProbeCount') is not None:
            self.ipv6probe_count = m.get('IPV6ProbeCount')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('IspName.en') is not None:
            self.isp_name_en = m.get('IspName.en')
        if m.get('IspName.zh_CN') is not None:
            self.isp_name_zh_c_n = m.get('IspName.zh_CN')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Region.en') is not None:
            self.region_en = m.get('Region.en')
        if m.get('Region.zh_CN') is not None:
            self.region_zh_c_n = m.get('Region.zh_CN')
        return self


class DescribeSiteMonitorISPCityListResponseBodyIspCityList(TeaModel):
    def __init__(self, isp_city=None):
        self.isp_city = isp_city  # type: list[DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity]

    def validate(self):
        if self.isp_city:
            for k in self.isp_city:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListResponseBodyIspCityList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['IspCity'] = []
        if self.isp_city is not None:
            for k in self.isp_city:
                result['IspCity'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.isp_city = []
        if m.get('IspCity') is not None:
            for k in m.get('IspCity'):
                temp_model = DescribeSiteMonitorISPCityListResponseBodyIspCityListIspCity()
                self.isp_city.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorISPCityListResponseBody(TeaModel):
    def __init__(self, code=None, isp_city_list=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The queried detection points.
        self.isp_city_list = isp_city_list  # type: DescribeSiteMonitorISPCityListResponseBodyIspCityList
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        if self.isp_city_list:
            self.isp_city_list.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.isp_city_list is not None:
            result['IspCityList'] = self.isp_city_list.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('IspCityList') is not None:
            temp_model = DescribeSiteMonitorISPCityListResponseBodyIspCityList()
            self.isp_city_list = temp_model.from_map(m['IspCityList'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorISPCityListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorISPCityListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorISPCityListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorISPCityListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorListRequest(TeaModel):
    def __init__(self, keyword=None, page=None, page_size=None, region_id=None, task_id=None, task_state=None,
                 task_type=None):
        # The keyword to be matched.
        # 
        # >  You can search for tasks by name or address. Fuzzy search is supported.
        self.keyword = keyword  # type: str
        # The number of the page to return. Default value: 1.
        self.page = page  # type: int
        # The number of entries to return on each page. Default value: 10.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The status of the task. Valid values:
        # 
        # *   1: The task is enabled.
        # *   2: The task is disabled.
        self.task_state = task_state  # type: str
        # The protocol that is used by the site monitoring task. Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
        self.task_type = task_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.keyword is not None:
            result['Keyword'] = self.keyword
        if self.page is not None:
            result['Page'] = self.page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_state is not None:
            result['TaskState'] = self.task_state
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Keyword') is not None:
            self.keyword = m.get('Keyword')
        if m.get('Page') is not None:
            self.page = m.get('Page')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskState') is not None:
            self.task_state = m.get('TaskState')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        return self


class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions(TeaModel):
    def __init__(self, operator=None, property=None, target=None, type=None):
        # The comparison operator of the assertion. Valid values:
        # 
        # *   contains: contains
        # *   doesNotContain: does not contain
        # *   matches: matches regular expressions
        # *   doesNotMatch: does not match regular expressions
        # *   is: equal to a numeric value or matches a character
        # *   isNot: not equal to
        # *   lessThan: less than
        # *   moreThan: greater than
        self.operator = operator  # type: str
        # The parsing path of the assertion.
        # 
        # *   If the assertion type is `body_json`, the path is `json path`.
        # *   If the assertion type is `body_xml`, the path is `xml path`.
        self.property = property  # type: str
        # The numeric value or character used for matching.
        self.target = target  # type: str
        # The type of the assertion. Valid values:
        # 
        # *   response_time: checks whether the response time meets expectations.
        # *   status_code: checks whether the HTTP status code meets expectations.
        # *   header: checks whether the fields in the response header meet expectations.
        # *   body_text: checks whether the content in the response body meets expectations by using text matching.
        # *   body_json: checks whether the content in the response body meets expectations by using JSON parsing (JSONPath).
        # *   body_xml: checks whether the content in the response body meets expectations by using XML parsing (XPath).
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['operator'] = self.operator
        if self.property is not None:
            result['property'] = self.property
        if self.target is not None:
            result['target'] = self.target
        if self.type is not None:
            result['type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('operator') is not None:
            self.operator = m.get('operator')
        if m.get('property') is not None:
            self.property = m.get('property')
        if m.get('target') is not None:
            self.target = m.get('target')
        if m.get('type') is not None:
            self.type = m.get('type')
        return self


class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions(TeaModel):
    def __init__(self, assertions=None):
        self.assertions = assertions  # type: list[DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions]

    def validate(self):
        if self.assertions:
            for k in self.assertions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['assertions'] = []
        if self.assertions is not None:
            for k in self.assertions:
                result['assertions'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.assertions = []
        if m.get('assertions') is not None:
            for k in m.get('assertions'):
                temp_model = DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertionsAssertions()
                self.assertions.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson(TeaModel):
    def __init__(self, acceptable_response_code=None, assertions=None, attempts=None, authentication=None,
                 cert_verify=None, cookie=None, diagnosis_mtr=None, diagnosis_ping=None, dns_match_rule=None, dns_server=None,
                 dns_type=None, enable_operator_dns=None, failure_rate=None, header=None, http_method=None,
                 is_base_64encode=None, match_rule=None, password=None, ping_num=None, port=None, protocol=None, proxy_protocol=None,
                 request_content=None, request_format=None, response_content=None, response_format=None, retry_delay=None,
                 time_out=None, unfollow_redirect=None, username=None):
        # The acceptable status code.
        # 
        # >  We recommend that you configure assertions.
        self.acceptable_response_code = acceptable_response_code  # type: str
        # The assertions.
        self.assertions = assertions  # type: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions
        # The number of retries after a DNS failure occurred.
        self.attempts = attempts  # type: long
        # Indicates whether the security authentication feature is enabled. Valid values:
        # 
        # *   0: The feature is enabled.
        # *   1: The feature is disabled.
        self.authentication = authentication  # type: int
        # Indicates whether the certificate is verified. Valid values:
        # 
        # *   false (default value): The certificate is not verified.
        # *   true: The certificate is verified.
        self.cert_verify = cert_verify  # type: bool
        # The cookie of the HTTP request.
        self.cookie = cookie  # type: str
        # Indicates whether MTR is automatically used to diagnose network issues if a task fails. Valid values:
        # 
        # *   false (default value): MTR is not automatically used to diagnose network issues if a task fails.
        # *   true: MTR is automatically used to diagnose network issues if a task fails.
        self.diagnosis_mtr = diagnosis_mtr  # type: bool
        # Indicates whether ping requests are automatically sent to detect network latency if a detection task fails. Valid values:
        # 
        # *   false (default value): Ping requests are not automatically sent to detect network latency if a detection task fails.
        # *   true: Ping requests are automatically sent to detect network latency if a detection task fails.
        self.diagnosis_ping = diagnosis_ping  # type: bool
        # The relationship between the list of expected aliases or IP addresses and the list of DNS results. Valid values:
        # 
        # *   IN_DNS: The list of expected values is a subset of the list of DNS results.
        # *   DNS_IN: The list of DNS results is a subset of the list of expected values.
        # *   EQUAL: The list of DNS results is the same as the list of expected values.
        # *   ANY: The list of DNS results intersects with the list of expected values.
        self.dns_match_rule = dns_match_rule  # type: str
        # The domain name or IP address of the DNS server.
        self.dns_server = dns_server  # type: str
        # The type of the DNS record. This parameter is returned only if the TaskType parameter is set to DNS. Valid values:
        # 
        # *   A (default value): a record that specifies an IP address related to the specified host name or domain name.
        # *   CNAME: a record that maps multiple domain names to a domain name.
        # *   NS: a record that specifies a DNS server used to parse domain names.
        # *   MX: a record that links domain names to the address of a mail server.
        # *   TXT: a record that stores the text information of host name or domain names. The text must be 1 to 512 bytes in length. The TXT record serves as a Sender Policy Framework (SPF) record to fight against spam.
        # *   AAAA: a record that maps a domain name to the relevant IPv6 address.
        self.dns_type = dns_type  # type: str
        # Indicates whether the DNS server of the carrier is used.
        # 
        # *   true (default value): The DNS server of the carrier is used.
        # *   false: The DNS server of the carrier is not used. The default DNS server or the specified DNS server is used.
        self.enable_operator_dns = enable_operator_dns  # type: bool
        # The packet loss rate.
        # 
        # >  This parameter is returned only if the TaskType parameter is set to PING.
        self.failure_rate = failure_rate  # type: float
        # The header of the HTTP request. An HTTP header is a key-value pair in which the key and the value are separated by a colon (:). The format is `key1:value1`. Each HTTP header occupies a line.
        self.header = header  # type: str
        # The HTTP request method. Valid values:
        # 
        # *   get
        # *   post
        # *   head
        self.http_method = http_method  # type: str
        # Indicates whether the password is decoded by using the Base64 algorithm. Valid values:
        # 
        # *   true: The password is decoded by using the Base64 algorithm.
        # *   false (default value): The password is not decoded by using the Base64 algorithm.
        self.is_base_64encode = is_base_64encode  # type: str
        # Indicates whether the alert rule is included. Valid values:
        # 
        # *   0: The alert rule is included.
        # *   1: The alert rule is not included.
        self.match_rule = match_rule  # type: int
        # The password of the SMTP, POP3, or FTP protocol.
        self.password = password  # type: str
        # The number of hops for the PING protocol.
        self.ping_num = ping_num  # type: int
        # The port number of the TCP, UDP, SMTP, or POP3 protocol.
        self.port = port  # type: int
        # The protocol type of DNS detection. Valid values:
        # 
        # *   udp (default value)
        # *   tcp
        # *   tcp-tls
        self.protocol = protocol  # type: str
        # Indicates whether the PROXY protocol is enabled. Valid values:
        # 
        # *   false (default value): The PROXY protocol is disabled.
        # *   true: The PROXY protocol is enabled.
        self.proxy_protocol = proxy_protocol  # type: bool
        # The content of the HTTP request.
        self.request_content = request_content  # type: str
        # The format of the HTTP request. Valid values:
        # 
        # *   hex: hexadecimal
        # *   txt: text
        self.request_format = request_format  # type: str
        # The response to the HTTP request.
        # 
        # *   Hexadecimal format: If the request content is a byte string and cannot be represented in printable characters, you can convert the byte string to printable characters in the hexadecimal format. If you convert the byte string to printable characters in the hexadecimal format, one byte is converted to two hexadecimal characters. For example, (byte)1 is converted to `01` and (byte)27 is converted to `1B`. If the request content is a binary array in the Java format, for example, `{(byte)1, (byte)27}`, you can convert the binary array to `011b` or `011B`. Hexadecimal characters are not case-sensitive in site monitoring tasks. You can enter `011B` in the request content and set the request_format parameter to hex.
        # *   Text format: Common text refers to strings that consist of printable characters.
        self.response_content = response_content  # type: str
        # The format of the HTTP response. Valid values:
        # 
        # *   hex: hexadecimal
        # *   txt: text
        self.response_format = response_format  # type: str
        # The number of times a failed detection request is retried.
        self.retry_delay = retry_delay  # type: int
        # The timeout period. Unit: milliseconds.
        self.time_out = time_out  # type: long
        # Indicates whether redirects are followed if the status code 301 or 302 is returned. Valid values:
        # 
        # *   true: Redirects are not followed.
        # *   false (default value): Redirects are followed.
        self.unfollow_redirect = unfollow_redirect  # type: bool
        # The username of the FTP, SMTP, or POP3 protocol.
        self.username = username  # type: str

    def validate(self):
        if self.assertions:
            self.assertions.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.acceptable_response_code is not None:
            result['acceptable_response_code'] = self.acceptable_response_code
        if self.assertions is not None:
            result['assertions'] = self.assertions.to_map()
        if self.attempts is not None:
            result['attempts'] = self.attempts
        if self.authentication is not None:
            result['authentication'] = self.authentication
        if self.cert_verify is not None:
            result['cert_verify'] = self.cert_verify
        if self.cookie is not None:
            result['cookie'] = self.cookie
        if self.diagnosis_mtr is not None:
            result['diagnosis_mtr'] = self.diagnosis_mtr
        if self.diagnosis_ping is not None:
            result['diagnosis_ping'] = self.diagnosis_ping
        if self.dns_match_rule is not None:
            result['dns_match_rule'] = self.dns_match_rule
        if self.dns_server is not None:
            result['dns_server'] = self.dns_server
        if self.dns_type is not None:
            result['dns_type'] = self.dns_type
        if self.enable_operator_dns is not None:
            result['enable_operator_dns'] = self.enable_operator_dns
        if self.failure_rate is not None:
            result['failure_rate'] = self.failure_rate
        if self.header is not None:
            result['header'] = self.header
        if self.http_method is not None:
            result['http_method'] = self.http_method
        if self.is_base_64encode is not None:
            result['isBase64Encode'] = self.is_base_64encode
        if self.match_rule is not None:
            result['match_rule'] = self.match_rule
        if self.password is not None:
            result['password'] = self.password
        if self.ping_num is not None:
            result['ping_num'] = self.ping_num
        if self.port is not None:
            result['port'] = self.port
        if self.protocol is not None:
            result['protocol'] = self.protocol
        if self.proxy_protocol is not None:
            result['proxy_protocol'] = self.proxy_protocol
        if self.request_content is not None:
            result['request_content'] = self.request_content
        if self.request_format is not None:
            result['request_format'] = self.request_format
        if self.response_content is not None:
            result['response_content'] = self.response_content
        if self.response_format is not None:
            result['response_format'] = self.response_format
        if self.retry_delay is not None:
            result['retry_delay'] = self.retry_delay
        if self.time_out is not None:
            result['time_out'] = self.time_out
        if self.unfollow_redirect is not None:
            result['unfollow_redirect'] = self.unfollow_redirect
        if self.username is not None:
            result['username'] = self.username
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('acceptable_response_code') is not None:
            self.acceptable_response_code = m.get('acceptable_response_code')
        if m.get('assertions') is not None:
            temp_model = DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJsonAssertions()
            self.assertions = temp_model.from_map(m['assertions'])
        if m.get('attempts') is not None:
            self.attempts = m.get('attempts')
        if m.get('authentication') is not None:
            self.authentication = m.get('authentication')
        if m.get('cert_verify') is not None:
            self.cert_verify = m.get('cert_verify')
        if m.get('cookie') is not None:
            self.cookie = m.get('cookie')
        if m.get('diagnosis_mtr') is not None:
            self.diagnosis_mtr = m.get('diagnosis_mtr')
        if m.get('diagnosis_ping') is not None:
            self.diagnosis_ping = m.get('diagnosis_ping')
        if m.get('dns_match_rule') is not None:
            self.dns_match_rule = m.get('dns_match_rule')
        if m.get('dns_server') is not None:
            self.dns_server = m.get('dns_server')
        if m.get('dns_type') is not None:
            self.dns_type = m.get('dns_type')
        if m.get('enable_operator_dns') is not None:
            self.enable_operator_dns = m.get('enable_operator_dns')
        if m.get('failure_rate') is not None:
            self.failure_rate = m.get('failure_rate')
        if m.get('header') is not None:
            self.header = m.get('header')
        if m.get('http_method') is not None:
            self.http_method = m.get('http_method')
        if m.get('isBase64Encode') is not None:
            self.is_base_64encode = m.get('isBase64Encode')
        if m.get('match_rule') is not None:
            self.match_rule = m.get('match_rule')
        if m.get('password') is not None:
            self.password = m.get('password')
        if m.get('ping_num') is not None:
            self.ping_num = m.get('ping_num')
        if m.get('port') is not None:
            self.port = m.get('port')
        if m.get('protocol') is not None:
            self.protocol = m.get('protocol')
        if m.get('proxy_protocol') is not None:
            self.proxy_protocol = m.get('proxy_protocol')
        if m.get('request_content') is not None:
            self.request_content = m.get('request_content')
        if m.get('request_format') is not None:
            self.request_format = m.get('request_format')
        if m.get('response_content') is not None:
            self.response_content = m.get('response_content')
        if m.get('response_format') is not None:
            self.response_format = m.get('response_format')
        if m.get('retry_delay') is not None:
            self.retry_delay = m.get('retry_delay')
        if m.get('time_out') is not None:
            self.time_out = m.get('time_out')
        if m.get('unfollow_redirect') is not None:
            self.unfollow_redirect = m.get('unfollow_redirect')
        if m.get('username') is not None:
            self.username = m.get('username')
        return self


class DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor(TeaModel):
    def __init__(self, address=None, agent_group=None, create_time=None, interval=None, options_json=None,
                 task_id=None, task_name=None, task_state=None, task_type=None, update_time=None):
        # The URL or IP address that is monitored by the site monitoring task.
        self.address = address  # type: str
        self.agent_group = agent_group  # type: str
        # The time when the site monitoring task was created.
        self.create_time = create_time  # type: str
        # The interval at which detection requests are sent. Unit: minutes.
        self.interval = interval  # type: str
        # The extended options of the site monitoring task. The options vary based on the specified protocol. For more information, see [CreateSiteMonitor](~~115048~~).
        self.options_json = options_json  # type: DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The name of the site monitoring task.
        self.task_name = task_name  # type: str
        # The status of the task. Valid values:
        # 
        # *   1: The task is enabled.
        # *   2: The task is disabled.
        self.task_state = task_state  # type: str
        # The protocol that is used by the site monitoring task. Valid values: HTTP, PING, TCP, UDP, DNS, SMTP, POP3, and FTP.
        self.task_type = task_type  # type: str
        # The time when the site monitoring task was updated.
        self.update_time = update_time  # type: str

    def validate(self):
        if self.options_json:
            self.options_json.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.agent_group is not None:
            result['AgentGroup'] = self.agent_group
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_state is not None:
            result['TaskState'] = self.task_state
        if self.task_type is not None:
            result['TaskType'] = self.task_type
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AgentGroup') is not None:
            self.agent_group = m.get('AgentGroup')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('OptionsJson') is not None:
            temp_model = DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitorOptionsJson()
            self.options_json = temp_model.from_map(m['OptionsJson'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskState') is not None:
            self.task_state = m.get('TaskState')
        if m.get('TaskType') is not None:
            self.task_type = m.get('TaskType')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeSiteMonitorListResponseBodySiteMonitors(TeaModel):
    def __init__(self, site_monitor=None):
        self.site_monitor = site_monitor  # type: list[DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor]

    def validate(self):
        if self.site_monitor:
            for k in self.site_monitor:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBodySiteMonitors, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SiteMonitor'] = []
        if self.site_monitor is not None:
            for k in self.site_monitor:
                result['SiteMonitor'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.site_monitor = []
        if m.get('SiteMonitor') is not None:
            for k in m.get('SiteMonitor'):
                temp_model = DescribeSiteMonitorListResponseBodySiteMonitorsSiteMonitor()
                self.site_monitor.append(temp_model.from_map(k))
        return self


class DescribeSiteMonitorListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, page_number=None, page_size=None, request_id=None,
                 site_monitors=None, success=None, total_count=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The page number of the returned page.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The site monitoring tasks that are returned.
        self.site_monitors = site_monitors  # type: DescribeSiteMonitorListResponseBodySiteMonitors
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str
        # The total number of returned entries.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.site_monitors:
            self.site_monitors.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.site_monitors is not None:
            result['SiteMonitors'] = self.site_monitors.to_map()
        if self.success is not None:
            result['Success'] = self.success
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SiteMonitors') is not None:
            temp_model = DescribeSiteMonitorListResponseBodySiteMonitors()
            self.site_monitors = temp_model.from_map(m['SiteMonitors'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSiteMonitorListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorLogRequest(TeaModel):
    def __init__(self, browser=None, browser_info=None, city=None, device=None, end_time=None, filter=None, isp=None,
                 length=None, metric_name=None, next_token=None, region_id=None, start_time=None, task_ids=None):
        # 浏览器类型。
        self.browser = browser  # type: str
        # 该参数已废弃，无需关注。
        self.browser_info = browser_info  # type: str
        # The city identification code.
        self.city = city  # type: str
        # 设备类型（模拟屏幕大小类型）。
        self.device = device  # type: str
        # The end of the time range to query. Valid values:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        # 
        # >  We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.end_time = end_time  # type: str
        # The filter condition.
        # 
        # You can specify a simple expression, for example, `TotalTime>100`. In this case, the operation returns only the data for instant test tasks whose total response time exceeds 100 milliseconds.
        self.filter = filter  # type: str
        # The carrier identification code.
        self.isp = isp  # type: str
        # The number of entries to return on each page. Valid values: 1 to 1440.
        self.length = length  # type: int
        # The name of the metric.
        # 
        # Only the `ProbeLog` metric is supported.
        self.metric_name = metric_name  # type: str
        # The token that is used to initiate the next request if the response of the current request is truncated. You can use the token to initiate another request and obtain the remaining records.``
        self.next_token = next_token  # type: str
        self.region_id = region_id  # type: str
        # The start of the time range to query. The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format
        # 
        # > 
        # 
        # *   The specified time range includes the end time and excludes the start time. The start time must be earlier than the end time.\
        #     We recommend that you use UNIX timestamps to prevent time zone-related issues.
        self.start_time = start_time  # type: str
        # The IDs of the instant test tasks. Separate multiple task IDs with commas (,).
        self.task_ids = task_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorLogRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.browser is not None:
            result['Browser'] = self.browser
        if self.browser_info is not None:
            result['BrowserInfo'] = self.browser_info
        if self.city is not None:
            result['City'] = self.city
        if self.device is not None:
            result['Device'] = self.device
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.isp is not None:
            result['Isp'] = self.isp
        if self.length is not None:
            result['Length'] = self.length
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Browser') is not None:
            self.browser = m.get('Browser')
        if m.get('BrowserInfo') is not None:
            self.browser_info = m.get('BrowserInfo')
        if m.get('City') is not None:
            self.city = m.get('City')
        if m.get('Device') is not None:
            self.device = m.get('Device')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('Isp') is not None:
            self.isp = m.get('Isp')
        if m.get('Length') is not None:
            self.length = m.get('Length')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DescribeSiteMonitorLogResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, next_token=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # **\
        # 
        # **Description** The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The logs of the instant test tasks.
        self.data = data  # type: str
        # The returned message.
        self.message = message  # type: str
        # A pagination token. It can be used in the next request to retrieve a new page of results.
        self.next_token = next_token  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorLogResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorLogResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorLogResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorLogResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorLogResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorQuotaRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorQuotaRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeSiteMonitorQuotaResponseBodyData(TeaModel):
    def __init__(self, second_monitor=None, site_monitor_idc_quota=None, site_monitor_operator_quota_quota=None,
                 site_monitor_quota_task_used=None, site_monitor_task_quota=None, site_monitor_version=None):
        # Indicates whether the second-level monitoring is enabled. Valid values:
        # 
        # *   true
        # *   false
        self.second_monitor = second_monitor  # type: bool
        # The quota of detection points that are provided by Alibaba Cloud. Five detection points are provided for free.
        self.site_monitor_idc_quota = site_monitor_idc_quota  # type: int
        # The quota of detection points that are not provided by Alibaba Cloud. Default value: 0.
        self.site_monitor_operator_quota_quota = site_monitor_operator_quota_quota  # type: int
        # The used quota of site monitoring tasks.
        self.site_monitor_quota_task_used = site_monitor_quota_task_used  # type: int
        # The quota of site monitoring tasks.
        self.site_monitor_task_quota = site_monitor_task_quota  # type: int
        # The version of site monitoring. Valid values:
        # 
        # *   V1
        # *   V2
        self.site_monitor_version = site_monitor_version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorQuotaResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.second_monitor is not None:
            result['SecondMonitor'] = self.second_monitor
        if self.site_monitor_idc_quota is not None:
            result['SiteMonitorIdcQuota'] = self.site_monitor_idc_quota
        if self.site_monitor_operator_quota_quota is not None:
            result['SiteMonitorOperatorQuotaQuota'] = self.site_monitor_operator_quota_quota
        if self.site_monitor_quota_task_used is not None:
            result['SiteMonitorQuotaTaskUsed'] = self.site_monitor_quota_task_used
        if self.site_monitor_task_quota is not None:
            result['SiteMonitorTaskQuota'] = self.site_monitor_task_quota
        if self.site_monitor_version is not None:
            result['SiteMonitorVersion'] = self.site_monitor_version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SecondMonitor') is not None:
            self.second_monitor = m.get('SecondMonitor')
        if m.get('SiteMonitorIdcQuota') is not None:
            self.site_monitor_idc_quota = m.get('SiteMonitorIdcQuota')
        if m.get('SiteMonitorOperatorQuotaQuota') is not None:
            self.site_monitor_operator_quota_quota = m.get('SiteMonitorOperatorQuotaQuota')
        if m.get('SiteMonitorQuotaTaskUsed') is not None:
            self.site_monitor_quota_task_used = m.get('SiteMonitorQuotaTaskUsed')
        if m.get('SiteMonitorTaskQuota') is not None:
            self.site_monitor_task_quota = m.get('SiteMonitorTaskQuota')
        if m.get('SiteMonitorVersion') is not None:
            self.site_monitor_version = m.get('SiteMonitorVersion')
        return self


class DescribeSiteMonitorQuotaResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The quotas and version of site monitoring.
        self.data = data  # type: DescribeSiteMonitorQuotaResponseBodyData
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorQuotaResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeSiteMonitorQuotaResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorQuotaResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorQuotaResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorQuotaResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorQuotaResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSiteMonitorStatisticsRequest(TeaModel):
    def __init__(self, metric_name=None, region_id=None, start_time=None, task_id=None, time_range=None):
        # The name of the metric. Valid values:
        # 
        # *   Availability
        # *   ErrorRate
        # *   ResponseTime
        self.metric_name = metric_name  # type: str
        self.region_id = region_id  # type: str
        # The timestamp that specifies the beginning of the time range to query.
        # 
        # Unit: milliseconds. The default value is 1 hour ahead of the current time.
        self.start_time = start_time  # type: str
        # The ID of the site monitoring task.
        # 
        # For more information about how to obtain the ID of a site monitoring task, see [DescribeSiteMonitorList](~~115052~~).
        self.task_id = task_id  # type: str
        # The statistical period.
        # 
        # Unit: minutes. Default value: 1440 (1 day). Maximum value: 43200 (30 days).
        self.time_range = time_range  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorStatisticsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.time_range is not None:
            result['TimeRange'] = self.time_range
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TimeRange') is not None:
            self.time_range = m.get('TimeRange')
        return self


class DescribeSiteMonitorStatisticsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The statistics of the specified metric.
        self.data = data  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSiteMonitorStatisticsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSiteMonitorStatisticsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSiteMonitorStatisticsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSiteMonitorStatisticsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSiteMonitorStatisticsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSystemEventAttributeRequest(TeaModel):
    def __init__(self, end_time=None, event_type=None, group_id=None, level=None, name=None, page_number=None,
                 page_size=None, product=None, region_id=None, search_keywords=None, start_time=None, status=None):
        # The end of the time range to query.
        # 
        # The value must be a UNIX timestamp. It is the number of seconds that have elapsed since 00:00:00 UTC, January 1, 1970.
        self.end_time = end_time  # type: str
        # The type of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to query the types of system events.
        self.event_type = event_type  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The level of the system event. Valid values:
        # 
        # *   CRITICAL: critical
        # *   WARN: warning
        # *   INFO: information
        self.level = level  # type: str
        # The name of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to query the names of system events.
        self.name = name  # type: str
        # The number of the page to return.
        # 
        # Valid values: 1 to 100000000.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Valid values: 1 to 100.
        # 
        # Default value: 10
        self.page_size = page_size  # type: int
        # The abbreviation of the service name.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to query the abbreviations of service names.
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The keywords that are used to search for the system event. Valid values:
        # 
        # *   If you want to search for the system event whose content contains a and b, set the value to `a and b`.
        # *   If you want to search for the system event whose content contains a or b, set the value to `a or b`.
        self.search_keywords = search_keywords  # type: str
        # The beginning of the time range to query.
        # 
        # The value must be a UNIX timestamp. It is the number of seconds that have elapsed since 00:00:00 UTC, January 1, 1970.
        self.start_time = start_time  # type: str
        # The status of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to query the statuses of system events.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent(TeaModel):
    def __init__(self, content=None, group_id=None, instance_name=None, level=None, name=None, product=None,
                 region_id=None, resource_id=None, status=None, time=None):
        # The details of the system event.
        self.content = content  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The level of the system event. Valid values:
        # 
        # *   CRITICAL: critical
        # *   WARN: warning
        # *   INFO: information
        self.level = level  # type: str
        # The name of the system event.
        self.name = name  # type: str
        # The abbreviation of the service name.
        self.product = product  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The status of the system event.
        self.status = status  # type: str
        # The timestamp when the system event occurred.
        # 
        # Unit: milliseconds.
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.status is not None:
            result['Status'] = self.status
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeSystemEventAttributeResponseBodySystemEvents(TeaModel):
    def __init__(self, system_event=None):
        self.system_event = system_event  # type: list[DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent]

    def validate(self):
        if self.system_event:
            for k in self.system_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSystemEventAttributeResponseBodySystemEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SystemEvent'] = []
        if self.system_event is not None:
            for k in self.system_event:
                result['SystemEvent'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.system_event = []
        if m.get('SystemEvent') is not None:
            for k in m.get('SystemEvent'):
                temp_model = DescribeSystemEventAttributeResponseBodySystemEventsSystemEvent()
                self.system_event.append(temp_model.from_map(k))
        return self


class DescribeSystemEventAttributeResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, system_events=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The message that is returned. If the call is successful, `success` is returned. If the call fails, an error message is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values: True: The call is successful. false: The call fails.
        self.success = success  # type: str
        # The details of the system event.
        self.system_events = system_events  # type: DescribeSystemEventAttributeResponseBodySystemEvents

    def validate(self):
        if self.system_events:
            self.system_events.validate()

    def to_map(self):
        _map = super(DescribeSystemEventAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.system_events is not None:
            result['SystemEvents'] = self.system_events.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SystemEvents') is not None:
            temp_model = DescribeSystemEventAttributeResponseBodySystemEvents()
            self.system_events = temp_model.from_map(m['SystemEvents'])
        return self


class DescribeSystemEventAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSystemEventAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSystemEventAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSystemEventAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSystemEventCountRequest(TeaModel):
    def __init__(self, end_time=None, event_type=None, group_id=None, level=None, name=None, product=None,
                 region_id=None, search_keywords=None, start_time=None, status=None):
        # The timestamp that specifies the end of the time range to query. Unit: milliseconds.
        self.end_time = end_time  # type: str
        # The type of the system event.
        # 
        # You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `EventType`. The value of the EventType parameter indicates the types of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.event_type = event_type  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The level of the system event. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        # 
        # You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Level`. The value of the Level parameter indicates the levels of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.level = level  # type: str
        # The name of the system event.
        # 
        # You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Name`. The value of the Name parameter indicates the names of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.name = name  # type: str
        # The name of the cloud service in which the system event occurred.
        # 
        # You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Product`. The value of the Product parameter indicates the names of all cloud services in which the system events of your Alibaba Cloud account occurred. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The keywords that are used to search for the system event. You can use a logical operator to connect keywords. Valid values:
        # 
        # *   If you want to search for the system event whose content contains a and b, set the value to `a and b`.
        # *   If you want to search for the system event whose content contains a or b, set the value to `a or b`.
        self.search_keywords = search_keywords  # type: str
        # The timestamp that specifies the start of the time range to query. Unit: milliseconds.
        self.start_time = start_time  # type: str
        # The status of the system event.
        # 
        # You can call the DescribeSystemEventMetaList operation to obtain the value of the response parameter `Status`. The value of the Status parameter indicates the status of system events that occurred for all cloud services in your Alibaba Cloud account. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventCountRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount(TeaModel):
    def __init__(self, content=None, group_id=None, instance_name=None, level=None, name=None, num=None, product=None,
                 region_id=None, resource_id=None, status=None, time=None):
        # The description of the system event.
        self.content = content  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the instance.
        self.instance_name = instance_name  # type: str
        # The level of the system event. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        self.level = level  # type: str
        # The name of the system event.
        self.name = name  # type: str
        # The number of times that the system event occurred.
        self.num = num  # type: long
        # The name of the cloud service in which the system event occurred.
        self.product = product  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the resource.
        self.resource_id = resource_id  # type: str
        # The status of the system event.
        self.status = status  # type: str
        # The timestamp when the system event occurred. Unit: milliseconds.
        self.time = time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.num is not None:
            result['Num'] = self.num
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.status is not None:
            result['Status'] = self.status
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Num') is not None:
            self.num = m.get('Num')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class DescribeSystemEventCountResponseBodySystemEventCounts(TeaModel):
    def __init__(self, system_event_count=None):
        self.system_event_count = system_event_count  # type: list[DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount]

    def validate(self):
        if self.system_event_count:
            for k in self.system_event_count:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSystemEventCountResponseBodySystemEventCounts, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SystemEventCount'] = []
        if self.system_event_count is not None:
            for k in self.system_event_count:
                result['SystemEventCount'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.system_event_count = []
        if m.get('SystemEventCount') is not None:
            for k in m.get('SystemEventCount'):
                temp_model = DescribeSystemEventCountResponseBodySystemEventCountsSystemEventCount()
                self.system_event_count.append(temp_model.from_map(k))
        return self


class DescribeSystemEventCountResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, system_event_counts=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str
        # The details of the system event.
        self.system_event_counts = system_event_counts  # type: DescribeSystemEventCountResponseBodySystemEventCounts

    def validate(self):
        if self.system_event_counts:
            self.system_event_counts.validate()

    def to_map(self):
        _map = super(DescribeSystemEventCountResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.system_event_counts is not None:
            result['SystemEventCounts'] = self.system_event_counts.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SystemEventCounts') is not None:
            temp_model = DescribeSystemEventCountResponseBodySystemEventCounts()
            self.system_event_counts = temp_model.from_map(m['SystemEventCounts'])
        return self


class DescribeSystemEventCountResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSystemEventCountResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSystemEventCountResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSystemEventCountResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSystemEventHistogramRequest(TeaModel):
    def __init__(self, end_time=None, event_type=None, group_id=None, level=None, name=None, product=None,
                 region_id=None, search_keywords=None, start_time=None, status=None):
        # The end of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: str
        # The type of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to view the types of system events.
        self.event_type = event_type  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The level of the system event. Valid values:
        # 
        # *   CRITICAL
        # *   WARN
        # *   INFO
        self.level = level  # type: str
        # The name of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to view the names of system events.
        self.name = name  # type: str
        # The abbreviation of the service name.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to view the abbreviations of service names.
        self.product = product  # type: str
        self.region_id = region_id  # type: str
        # The keywords contained in the content of the system event to query. You can use a logical operator between keywords. Examples:
        # 
        # *   If you need to query the system event whose content contains a and b, set the value to `a and b`.
        # *   If you need to query the system event whose content contains a or b, set the value to `a or b`.
        self.search_keywords = search_keywords  # type: str
        # The beginning of the time range to query.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: str
        # The status of the system event.
        # 
        # >  You can call the [DescribeSystemEventMetaList](~~114972~~) operation to view the statuses of system events.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventHistogramRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.search_keywords is not None:
            result['SearchKeywords'] = self.search_keywords
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SearchKeywords') is not None:
            self.search_keywords = m.get('SearchKeywords')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram(TeaModel):
    def __init__(self, count=None, end_time=None, start_time=None):
        # The number of times that the system event occurred.
        self.count = count  # type: long
        # The end of an interval.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.end_time = end_time  # type: long
        # The beginning of an interval.
        # 
        # This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
        self.start_time = start_time  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['Count'] = self.count
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSystemEventHistogramResponseBodySystemEventHistograms(TeaModel):
    def __init__(self, system_event_histogram=None):
        self.system_event_histogram = system_event_histogram  # type: list[DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram]

    def validate(self):
        if self.system_event_histogram:
            for k in self.system_event_histogram:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSystemEventHistogramResponseBodySystemEventHistograms, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['SystemEventHistogram'] = []
        if self.system_event_histogram is not None:
            for k in self.system_event_histogram:
                result['SystemEventHistogram'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.system_event_histogram = []
        if m.get('SystemEventHistogram') is not None:
            for k in m.get('SystemEventHistogram'):
                temp_model = DescribeSystemEventHistogramResponseBodySystemEventHistogramsSystemEventHistogram()
                self.system_event_histogram.append(temp_model.from_map(k))
        return self


class DescribeSystemEventHistogramResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, system_event_histograms=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: str
        # The information about the number of times that the system event occurred during each interval of a time period.
        self.system_event_histograms = system_event_histograms  # type: DescribeSystemEventHistogramResponseBodySystemEventHistograms

    def validate(self):
        if self.system_event_histograms:
            self.system_event_histograms.validate()

    def to_map(self):
        _map = super(DescribeSystemEventHistogramResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.system_event_histograms is not None:
            result['SystemEventHistograms'] = self.system_event_histograms.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('SystemEventHistograms') is not None:
            temp_model = DescribeSystemEventHistogramResponseBodySystemEventHistograms()
            self.system_event_histograms = temp_model.from_map(m['SystemEventHistograms'])
        return self


class DescribeSystemEventHistogramResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSystemEventHistogramResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSystemEventHistogramResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSystemEventHistogramResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSystemEventMetaListRequest(TeaModel):
    def __init__(self, region_id=None):
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventMetaListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeSystemEventMetaListResponseBodyDataResource(TeaModel):
    def __init__(self, event_type=None, level=None, name=None, name_desc=None, name_desc_en=None, product=None,
                 status=None, status_desc=None):
        # The type of the system event. Valid values:
        # 
        # *   StatusNotification
        # *   Exception
        # *   Maintenance
        self.event_type = event_type  # type: str
        # The level of the alert. Valid values:
        # 
        # *   CRITICAL
        # *   WARN
        # *   INFO
        self.level = level  # type: str
        # The name of the system event.
        self.name = name  # type: str
        # The description of the system event, in Chinese.
        self.name_desc = name_desc  # type: str
        self.name_desc_en = name_desc_en  # type: str
        # The abbreviation of the service name.
        self.product = product  # type: str
        # The status of the system event.
        self.status = status  # type: str
        # The description of the event status.
        self.status_desc = status_desc  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSystemEventMetaListResponseBodyDataResource, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.name_desc is not None:
            result['NameDesc'] = self.name_desc
        if self.name_desc_en is not None:
            result['NameDesc.En'] = self.name_desc_en
        if self.product is not None:
            result['Product'] = self.product
        if self.status is not None:
            result['Status'] = self.status
        if self.status_desc is not None:
            result['StatusDesc'] = self.status_desc
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDesc') is not None:
            self.name_desc = m.get('NameDesc')
        if m.get('NameDesc.En') is not None:
            self.name_desc_en = m.get('NameDesc.En')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StatusDesc') is not None:
            self.status_desc = m.get('StatusDesc')
        return self


class DescribeSystemEventMetaListResponseBodyData(TeaModel):
    def __init__(self, resource=None):
        self.resource = resource  # type: list[DescribeSystemEventMetaListResponseBodyDataResource]

    def validate(self):
        if self.resource:
            for k in self.resource:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSystemEventMetaListResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Resource'] = []
        if self.resource is not None:
            for k in self.resource:
                result['Resource'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.resource = []
        if m.get('Resource') is not None:
            for k in m.get('Resource'):
                temp_model = DescribeSystemEventMetaListResponseBodyDataResource()
                self.resource.append(temp_model.from_map(k))
        return self


class DescribeSystemEventMetaListResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The detailed meta information.
        self.data = data  # type: DescribeSystemEventMetaListResponseBodyData
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DescribeSystemEventMetaListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DescribeSystemEventMetaListResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeSystemEventMetaListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSystemEventMetaListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSystemEventMetaListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSystemEventMetaListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagKeyListRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None):
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Maximum value: 100. Default value: 50.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagKeyListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeTagKeyListResponseBodyTagKeys(TeaModel):
    def __init__(self, tag_key=None):
        self.tag_key = tag_key  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagKeyListResponseBodyTagKeys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class DescribeTagKeyListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, tag_keys=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The tag keys returned.
        self.tag_keys = tag_keys  # type: DescribeTagKeyListResponseBodyTagKeys

    def validate(self):
        if self.tag_keys:
            self.tag_keys.validate()

    def to_map(self):
        _map = super(DescribeTagKeyListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tag_keys is not None:
            result['TagKeys'] = self.tag_keys.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TagKeys') is not None:
            temp_model = DescribeTagKeyListResponseBodyTagKeys()
            self.tag_keys = temp_model.from_map(m['TagKeys'])
        return self


class DescribeTagKeyListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTagKeyListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTagKeyListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagKeyListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeTagValueListRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None, tag_key=None):
        # The number of the page to return.
        # 
        # Pages start from page 1. Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        # 
        # Valid values: 1 to 100. Pages start from page 1. Default value: 50.
        self.page_size = page_size  # type: int
        self.region_id = region_id  # type: str
        # The key of the tag whose values you want to query.
        # 
        # For more information about how to obtain a tag key, see [DescribeTagKeyList](~~145558~~).
        self.tag_key = tag_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagValueListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class DescribeTagValueListResponseBodyTagValues(TeaModel):
    def __init__(self, tag_value=None):
        self.tag_value = tag_value  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeTagValueListResponseBodyTagValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class DescribeTagValueListResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, tag_values=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The tag values returned.
        self.tag_values = tag_values  # type: DescribeTagValueListResponseBodyTagValues

    def validate(self):
        if self.tag_values:
            self.tag_values.validate()

    def to_map(self):
        _map = super(DescribeTagValueListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tag_values is not None:
            result['TagValues'] = self.tag_values.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('TagValues') is not None:
            temp_model = DescribeTagValueListResponseBodyTagValues()
            self.tag_values = temp_model.from_map(m['TagValues'])
        return self


class DescribeTagValueListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeTagValueListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeTagValueListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeTagValueListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUnhealthyHostAvailabilityRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        self.id = id  # type: list[long]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList(TeaModel):
    def __init__(self, string=None):
        self.string = string  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.string is not None:
            result['String'] = self.string
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('String') is not None:
            self.string = m.get('String')
        return self


class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance(TeaModel):
    def __init__(self, id=None, instance_list=None):
        # The ID of the availability monitoring task.
        self.id = id  # type: long
        # The unhealthy instances that are detected by the availability monitoring task.
        self.instance_list = instance_list  # type: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList

    def validate(self):
        if self.instance_list:
            self.instance_list.validate()

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceList') is not None:
            temp_model = DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstanceInstanceList()
            self.instance_list = temp_model.from_map(m['InstanceList'])
        return self


class DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList(TeaModel):
    def __init__(self, node_task_instance=None):
        self.node_task_instance = node_task_instance  # type: list[DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance]

    def validate(self):
        if self.node_task_instance:
            for k in self.node_task_instance:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NodeTaskInstance'] = []
        if self.node_task_instance is not None:
            for k in self.node_task_instance:
                result['NodeTaskInstance'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.node_task_instance = []
        if m.get('NodeTaskInstance') is not None:
            for k in m.get('NodeTaskInstance'):
                temp_model = DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyListNodeTaskInstance()
                self.node_task_instance.append(temp_model.from_map(k))
        return self


class DescribeUnhealthyHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, unhealthy_list=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool
        # The unhealthy instances that are detected by the specified availability monitoring tasks.
        self.unhealthy_list = unhealthy_list  # type: DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList

    def validate(self):
        if self.unhealthy_list:
            self.unhealthy_list.validate()

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.unhealthy_list is not None:
            result['UnhealthyList'] = self.unhealthy_list.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('UnhealthyList') is not None:
            temp_model = DescribeUnhealthyHostAvailabilityResponseBodyUnhealthyList()
            self.unhealthy_list = temp_model.from_map(m['UnhealthyList'])
        return self


class DescribeUnhealthyHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUnhealthyHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUnhealthyHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUnhealthyHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableActiveMetricRuleRequest(TeaModel):
    def __init__(self, product=None, region_id=None):
        # The service for which you want to disable one-click alert. Valid values:
        # 
        # *   ecs: Elastic Compute Service (ECS)
        # *   rds: ApsaraDB RDS
        # *   slb: Server Load Balancer (SLB)
        # *   redis_standard: ApsaraDB for Redis of the standard architecture
        # *   redis_sharding: ApsaraDB for Redis of the cluster architecture
        # *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
        # *   mongodb: ApsaraDB for MongoDB of the replica set architecture
        # *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   hbase: ApsaraDB for HBase
        # *   elasticsearch: Elasticsearch
        # *   opensearch: Open Search
        self.product = product  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableActiveMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DisableActiveMetricRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableActiveMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableActiveMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableActiveMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableActiveMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableActiveMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableEventRulesRequest(TeaModel):
    def __init__(self, region_id=None, rule_names=None):
        self.region_id = region_id  # type: str
        self.rule_names = rule_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableEventRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_names is not None:
            result['RuleNames'] = self.rule_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleNames') is not None:
            self.rule_names = m.get('RuleNames')
        return self


class DisableEventRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableEventRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableEventRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableEventRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableEventRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableEventRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableHostAvailabilityRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        self.id = id  # type: list[long]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DisableHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # >  The status code 200 indicates a success.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableMetricRulesRequest(TeaModel):
    def __init__(self, region_id=None, rule_id=None):
        self.region_id = region_id  # type: str
        self.rule_id = rule_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableMetricRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class DisableMetricRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableMetricRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableMetricRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableMetricRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableMetricRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableMetricRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableSiteMonitorsRequest(TeaModel):
    def __init__(self, region_id=None, task_ids=None):
        self.region_id = region_id  # type: str
        # The IDs of the site monitoring tasks. Separate multiple IDs with commas (,).
        self.task_ids = task_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableSiteMonitorsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class DisableSiteMonitorsResponseBodyData(TeaModel):
    def __init__(self, count=None):
        # The number of detection points.
        self.count = count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableSiteMonitorsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class DisableSiteMonitorsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # >  The status code 200 indicates a success.
        self.code = code  # type: str
        # The number of detection points that were monitored by the site monitoring tasks.
        self.data = data  # type: DisableSiteMonitorsResponseBodyData
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(DisableSiteMonitorsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = DisableSiteMonitorsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DisableSiteMonitorsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableSiteMonitorsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableSiteMonitorsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableSiteMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableActiveMetricRuleRequest(TeaModel):
    def __init__(self, product=None, region_id=None):
        # The cloud service for which you want to enable initiative alert. Valid values:
        # 
        # *   ecs: Elastic Compute Service (ECS)
        # *   rds: ApsaraDB RDS
        # *   slb: Server Load Balancer (SLB)
        # *   redis_standard: ApsaraDB for Redis of the standard architecture
        # *   redis_sharding: ApsaraDB for Redis of the cluster architecture
        # *   redis_splitrw: ApsaraDB for Redis of the read/write splitting architecture
        # *   mongodb: ApsaraDB for MongoDB of the replica set architecture
        # *   mongodb_sharding: ApsaraDB for MongoDB of the sharded cluster architecture
        # *   hbase: ApsaraDB for HBase
        # *   elasticsearch: Elasticsearch
        # *   opensearch: OpenSearch
        self.product = product  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableActiveMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EnableActiveMetricRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableActiveMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableActiveMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableActiveMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableActiveMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableActiveMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableEventRulesRequest(TeaModel):
    def __init__(self, region_id=None, rule_names=None):
        self.region_id = region_id  # type: str
        self.rule_names = rule_names  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableEventRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_names is not None:
            result['RuleNames'] = self.rule_names
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleNames') is not None:
            self.rule_names = m.get('RuleNames')
        return self


class EnableEventRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableEventRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableEventRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableEventRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableEventRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableEventRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableHostAvailabilityRequest(TeaModel):
    def __init__(self, id=None, region_id=None):
        self.id = id  # type: list[long]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EnableHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # >  The HTTP status code 200 indicates a success.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableMetricRuleBlackListRequest(TeaModel):
    def __init__(self, id=None, is_enable=None, region_id=None):
        # The IDs of the blacklist policies. Separate multiple IDs with commas (,). You can specify up to 50 IDs.
        # 
        # For information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](~~457257~~).
        # 
        # > You can also set this parameter to a JSON array. Example: `["a9ad2ac2-3ed9-11ed-b878-0242ac12****","5cb8a9a4-198f-4651-a353-f8b28788****"]`.
        self.id = id  # type: str
        # Specifies whether to enable the blacklist policy. Valid values:
        # 
        # *   true: The blacklist policy is enabled.
        # *   false (default): The blacklist policy is disabled.
        self.is_enable = is_enable  # type: bool
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableMetricRuleBlackListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.is_enable is not None:
            result['IsEnable'] = self.is_enable
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('IsEnable') is not None:
            self.is_enable = m.get('IsEnable')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class EnableMetricRuleBlackListResponseBody(TeaModel):
    def __init__(self, code=None, count=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The number of blacklist policies that are enabled or disabled.
        self.count = count  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableMetricRuleBlackListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableMetricRuleBlackListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableMetricRuleBlackListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableMetricRuleBlackListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableMetricRuleBlackListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableMetricRulesRequest(TeaModel):
    def __init__(self, region_id=None, rule_id=None):
        self.region_id = region_id  # type: str
        # The IDs of the alert rules.
        # 
        # Valid values of N: 1 to 100.
        # 
        # For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableMetricRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class EnableMetricRulesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableMetricRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableMetricRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableMetricRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableMetricRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableMetricRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class EnableSiteMonitorsRequest(TeaModel):
    def __init__(self, region_id=None, task_ids=None):
        self.region_id = region_id  # type: str
        # The IDs of the site monitoring tasks. Separate multiple instance IDs with commas (,).
        self.task_ids = task_ids  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableSiteMonitorsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_ids is not None:
            result['TaskIds'] = self.task_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskIds') is not None:
            self.task_ids = m.get('TaskIds')
        return self


class EnableSiteMonitorsResponseBodyData(TeaModel):
    def __init__(self, count=None):
        # The number of detection points.
        self.count = count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(EnableSiteMonitorsResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class EnableSiteMonitorsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # >  The status code 200 indicates a success.
        self.code = code  # type: str
        # The number of detection points that are affected by the site monitoring tasks.
        self.data = data  # type: EnableSiteMonitorsResponseBodyData
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the operation was successful. Valid values:
        # 
        # *   true: successful.
        # *   false: failed.
        self.success = success  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(EnableSiteMonitorsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = EnableSiteMonitorsResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class EnableSiteMonitorsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: EnableSiteMonitorsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(EnableSiteMonitorsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = EnableSiteMonitorsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class InstallMonitoringAgentRequest(TeaModel):
    def __init__(self, force=None, install_command=None, instance_ids=None, region_id=None):
        # Specifies whether to install the CloudMonitor agent. Valid values:
        # 
        # *   true (default value): yes
        # *   false: no
        self.force = force  # type: bool
        # Specifies whether to install the CloudMonitor agent on all ECS instances that belong to the current Alibaba Cloud account. Valid values:
        # 
        # *   `onlyInstallNotHasAgent`: installs the latest version of the CloudMonitor agent only on ECS instances on which the agent is not installed.
        # *   `onlyUpgradeAgent`: upgrades the CloudMonitor agent to the latest version only for ECS instances on which an earlier version of the agent is installed.
        # *   `installAndUpgrade`: installs the latest version of the CloudMonitor agent on ECS instances on which the agent is not installed, and upgrades the CloudMonitor agent to the latest version for ECS instances on which an earlier version of the agent is installed.
        # 
        # >  If you set the InstallCommand parameter, the `InstanceIds` parameter does not take effect.
        self.install_command = install_command  # type: str
        self.instance_ids = instance_ids  # type: list[str]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallMonitoringAgentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force is not None:
            result['Force'] = self.force
        if self.install_command is not None:
            result['InstallCommand'] = self.install_command
        if self.instance_ids is not None:
            result['InstanceIds'] = self.instance_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('InstallCommand') is not None:
            self.install_command = m.get('InstallCommand')
        if m.get('InstanceIds') is not None:
            self.instance_ids = m.get('InstanceIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class InstallMonitoringAgentResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(InstallMonitoringAgentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class InstallMonitoringAgentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: InstallMonitoringAgentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(InstallMonitoringAgentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = InstallMonitoringAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The Alibaba Cloud Resource Name (ARN) of the resource.
        # 
        # For information about how to obtain the ARN of a resource, see [DescribeMetricRuleTargets](~~121592~~).
        # 
        # Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # *   {userId}: the ID of the Alibaba Cloud account.
        # *   {regionId}: the region ID of the message queue or topic.
        # *   {Resource type}`: the type of the resource for which alerts are triggered. Valid values: - **queues** - **topics** {Resource name}: the name of the resource. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.`
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        # 
        # For information about how to obtain the ID of a resource for which alerts are triggered, see [DescribeMetricRuleTargets](~~121592~~).
        self.id = id  # type: str
        # The parameters of the alert callback. The parameters are in the JSON format.
        self.json_params = json_params  # type: str
        # The level of the alert. Valid values:
        # 
        # *   INFO: information
        # *   WARN: warning
        # *   CRITICAL: critical
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class ModifyGroupMonitoringAgentProcessRequestAlertConfig(TeaModel):
    def __init__(self, comparison_operator=None, effective_interval=None, escalations_level=None,
                 no_effective_interval=None, silence_time=None, statistics=None, target_list=None, threshold=None, times=None,
                 webhook=None):
        # The comparison operator that is used to compare the metric value with the threshold. Valid values of N: 1 to 200. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold.
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday.
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The time period during which the alert rule is effective. Valid values of N: 1 to 200.
        self.effective_interval = effective_interval  # type: str
        # The level of the alert. Valid values of N: 1 to 200. Valid values:
        # 
        # *   critical (default value): critical
        # *   warn: warning
        # *   info: information
        self.escalations_level = escalations_level  # type: str
        # The time period during which the alert rule is ineffective. Valid values of N: 1 to 200.
        self.no_effective_interval = no_effective_interval  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Valid values of N: 1 to 200.
        # 
        # Unit: seconds. Minimum value: 3600, which is equivalent to one hour. Default value: 86400, which is equivalent to one day.
        # 
        # >  Only one alert notification is sent during a mute period even if the metric value exceeds the alert threshold during consecutive checks.
        self.silence_time = silence_time  # type: str
        # The statistical aggregation method that is used to calculate the metric values. Valid values of N: 1 to 200.
        # 
        # >  Set the value to Average.
        self.statistics = statistics  # type: str
        self.target_list = target_list  # type: list[ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList]
        # The alert threshold. Valid values of N: 1 to 200.
        self.threshold = threshold  # type: str
        # The number of times for which the threshold can be consecutively exceeded. Valid values of N: 1 to 200. Default value: 3.
        # 
        # >  A metric triggers an alert only after the metric value reaches the threshold consecutively for the specified times.
        self.times = times  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule. Valid values of N: 1 to 200.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.target_list:
            for k in self.target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyGroupMonitoringAgentProcessRequestAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.escalations_level is not None:
            result['EscalationsLevel'] = self.escalations_level
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        result['TargetList'] = []
        if self.target_list is not None:
            for k in self.target_list:
                result['TargetList'].append(k.to_map() if k else None)
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EscalationsLevel') is not None:
            self.escalations_level = m.get('EscalationsLevel')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        self.target_list = []
        if m.get('TargetList') is not None:
            for k in m.get('TargetList'):
                temp_model = ModifyGroupMonitoringAgentProcessRequestAlertConfigTargetList()
                self.target_list.append(temp_model.from_map(k))
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ModifyGroupMonitoringAgentProcessRequest(TeaModel):
    def __init__(self, alert_config=None, group_id=None, id=None, match_express_filter_relation=None,
                 region_id=None):
        self.alert_config = alert_config  # type: list[ModifyGroupMonitoringAgentProcessRequestAlertConfig]
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The ID of the process monitoring task.
        self.id = id  # type: str
        # The logical operator used between conditional expressions that are used to match instances. Valid values:
        # 
        # *   all
        # *   and
        # *   or
        self.match_express_filter_relation = match_express_filter_relation  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        if self.alert_config:
            for k in self.alert_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyGroupMonitoringAgentProcessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertConfig'] = []
        if self.alert_config is not None:
            for k in self.alert_config:
                result['AlertConfig'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.match_express_filter_relation is not None:
            result['MatchExpressFilterRelation'] = self.match_express_filter_relation
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_config = []
        if m.get('AlertConfig') is not None:
            for k in m.get('AlertConfig'):
                temp_model = ModifyGroupMonitoringAgentProcessRequestAlertConfig()
                self.alert_config.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('MatchExpressFilterRelation') is not None:
            self.match_express_filter_relation = m.get('MatchExpressFilterRelation')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyGroupMonitoringAgentProcessResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyGroupMonitoringAgentProcessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyGroupMonitoringAgentProcessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyGroupMonitoringAgentProcessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyGroupMonitoringAgentProcessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyGroupMonitoringAgentProcessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHostAvailabilityRequestAlertConfig(TeaModel):
    def __init__(self, end_time=None, notify_type=None, silence_time=None, start_time=None, web_hook=None):
        # The end of the time range during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.end_time = end_time  # type: int
        # The alert notification methods. Valid values:
        # 
        # 0: Alert notifications are sent by using emails and DingTalk chatbots.
        self.notify_type = notify_type  # type: int
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400. The default value indicates one day.
        self.silence_time = silence_time  # type: int
        # The beginning of the time range during which the alert rule is effective. Valid values: 0 to 23.
        # 
        # For example, if the `AlertConfig.StartTime` parameter is set to 0 and the `AlertConfig.EndTime` parameter is set to 22, the alert rule is effective from 00:00:00 to 22:00:00.
        # 
        # > Alert notifications are sent based on the specified threshold only if the alert rule is effective.
        self.start_time = start_time  # type: int
        # The callback URL.
        self.web_hook = web_hook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostAvailabilityRequestAlertConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.notify_type is not None:
            result['NotifyType'] = self.notify_type
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.web_hook is not None:
            result['WebHook'] = self.web_hook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('NotifyType') is not None:
            self.notify_type = m.get('NotifyType')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('WebHook') is not None:
            self.web_hook = m.get('WebHook')
        return self


class ModifyHostAvailabilityRequestTaskOption(TeaModel):
    def __init__(self, http_header=None, http_method=None, http_negative=None, http_post_content=None,
                 http_response_charset=None, http_response_match_content=None, http_uri=None, interval=None, telnet_or_ping_host=None):
        # The header of the HTTP request. Format: `Parameter name:Parameter value`. Separate multiple parameters with carriage return characters. Example:
        # 
        #     params1:value1
        #     params2:value2
        self.http_header = http_header  # type: str
        # The HTTP request method. Valid values:
        # 
        # *   GET
        # *   POST
        # *   HEAD
        # 
        # > This parameter must be specified when TaskType is set to HTTP. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](~~115317~~).
        self.http_method = http_method  # type: str
        # The method to trigger an alert. The alert can be triggered based on whether the specified alert rule is included in the response body. Valid values:
        # 
        # *   true: If the HTTP response body includes the alert rule, an alert is triggered.
        # *   false: If the HTTP response does not include the alert rule, an alert is triggered.
        # 
        # > This parameter must be specified when TaskType is set to HTTP. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](~~115317~~).
        self.http_negative = http_negative  # type: bool
        # The content of the HTTP POST request.
        self.http_post_content = http_post_content  # type: str
        # The character set that is used in the HTTP response.
        # 
        # > Only UTF-8 is supported.
        self.http_response_charset = http_response_charset  # type: str
        # The response to the HTTP request.
        self.http_response_match_content = http_response_match_content  # type: str
        # The URI that you want to monitor. This parameter must be specified when TaskType is set to HTTP.
        self.http_uri = http_uri  # type: str
        # The interval at which detection requests are sent. Unit: seconds. Valid values: 15, 30, 60, 120, 300, 900, 1800, and 3600.
        # 
        # > This parameter is available only for the CloudMonitor agent V3.5.1 or later.
        self.interval = interval  # type: int
        # The domain name or IP address that you want to monitor.
        # 
        # > This parameter must be specified when TaskType is set to PING or TELNET. For more information about how to configure the TaskType parameter, see [CreateHostAvailability](~~115317~~).
        self.telnet_or_ping_host = telnet_or_ping_host  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostAvailabilityRequestTaskOption, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.http_header is not None:
            result['HttpHeader'] = self.http_header
        if self.http_method is not None:
            result['HttpMethod'] = self.http_method
        if self.http_negative is not None:
            result['HttpNegative'] = self.http_negative
        if self.http_post_content is not None:
            result['HttpPostContent'] = self.http_post_content
        if self.http_response_charset is not None:
            result['HttpResponseCharset'] = self.http_response_charset
        if self.http_response_match_content is not None:
            result['HttpResponseMatchContent'] = self.http_response_match_content
        if self.http_uri is not None:
            result['HttpURI'] = self.http_uri
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.telnet_or_ping_host is not None:
            result['TelnetOrPingHost'] = self.telnet_or_ping_host
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HttpHeader') is not None:
            self.http_header = m.get('HttpHeader')
        if m.get('HttpMethod') is not None:
            self.http_method = m.get('HttpMethod')
        if m.get('HttpNegative') is not None:
            self.http_negative = m.get('HttpNegative')
        if m.get('HttpPostContent') is not None:
            self.http_post_content = m.get('HttpPostContent')
        if m.get('HttpResponseCharset') is not None:
            self.http_response_charset = m.get('HttpResponseCharset')
        if m.get('HttpResponseMatchContent') is not None:
            self.http_response_match_content = m.get('HttpResponseMatchContent')
        if m.get('HttpURI') is not None:
            self.http_uri = m.get('HttpURI')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('TelnetOrPingHost') is not None:
            self.telnet_or_ping_host = m.get('TelnetOrPingHost')
        return self


class ModifyHostAvailabilityRequestAlertConfigEscalationList(TeaModel):
    def __init__(self, aggregate=None, metric_name=None, operator=None, times=None, value=None):
        # The method used to calculate the metric values that trigger alerts. Valid values of N: 1 to 21. The value of this parameter varies based on the metric. The following items show the correspondence between metrics and calculation methods:
        # 
        # *   HttpStatus: Value
        # *   HttpLatency: Average
        # *   TelnetStatus: Value
        # *   TelnetLatency: Average
        # *   PingLostRate: Average
        # 
        # > The value Value indicates the original value and is used for metrics such as status codes. The value Average indicates the average value and is used for metrics such as the latency and packet loss rate.
        self.aggregate = aggregate  # type: str
        # The metric for which the alert feature is enabled. Valid values of N: 1 to 21. Valid values:
        # 
        # *   HttpStatus: HTTP status code
        # *   HttpLatency: HTTP response time
        # *   TelnetStatus: Telnet status code
        # *   TelnetLatency: Telnet response time
        # *   PingLostRate: Ping packet loss rate
        self.metric_name = metric_name  # type: str
        # The comparison operator that is used in the alert rule. Valid values of N: 1 to 21. Valid values:
        # 
        # *   `>`
        # *   `>=`
        # *   `<`
        # *   `<=`
        # *   `=`
        self.operator = operator  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an alert is triggered. Valid values of N: 1 to 21.
        self.times = times  # type: int
        # The alert threshold. Valid values of N: 1 to 21.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostAvailabilityRequestAlertConfigEscalationList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.aggregate is not None:
            result['Aggregate'] = self.aggregate
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.times is not None:
            result['Times'] = self.times
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Aggregate') is not None:
            self.aggregate = m.get('Aggregate')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ModifyHostAvailabilityRequestAlertConfigTargetList(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The Alibaba Cloud Resource Name (ARN) of the resource.
        # 
        # Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # 
        # *   {userId}: the ID of the Alibaba Cloud account.
        # 
        # *   {regionId}: the region ID of the message queue or topic.
        # 
        # *   {Resource type}: the type of the resource that triggers the alert. Valid values:
        # 
        #     *   **queues**\
        #     *   **topics**\
        # 
        # *   {Resource name}: the resource name.
        # 
        #     *   If the resource type is **queues**, the resource name is the queue name.
        #     *   If the resource type is **topics**, the resource name is the topic name.
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        self.id = id  # type: str
        # The parameters of the alert callback. The parameters are in the JSON format.
        self.json_params = json_params  # type: str
        # The alert level. Valid values:
        # 
        # *   INFO
        # *   WARN
        # *   CRITICAL
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostAvailabilityRequestAlertConfigTargetList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class ModifyHostAvailabilityRequest(TeaModel):
    def __init__(self, alert_config=None, task_option=None, alert_config_escalation_list=None,
                 alert_config_target_list=None, group_id=None, id=None, instance_list=None, region_id=None, task_name=None, task_scope=None):
        self.alert_config = alert_config  # type: ModifyHostAvailabilityRequestAlertConfig
        self.task_option = task_option  # type: ModifyHostAvailabilityRequestTaskOption
        # The alert configurations.
        self.alert_config_escalation_list = alert_config_escalation_list  # type: list[ModifyHostAvailabilityRequestAlertConfigEscalationList]
        # The information about the resources for which alerts are triggered.
        self.alert_config_target_list = alert_config_target_list  # type: list[ModifyHostAvailabilityRequestAlertConfigTargetList]
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # The ID of the availability monitoring task.
        self.id = id  # type: long
        # The ECS instances that are monitored. Valid values of N: 1 to 21.
        # 
        # > This parameter must be specified when `TaskScope` is set to `GROUP_SPEC_INSTANCE`.
        self.instance_list = instance_list  # type: list[str]
        self.region_id = region_id  # type: str
        # The name of the availability monitoring task.
        self.task_name = task_name  # type: str
        # The range of instances that are monitored by the availability monitoring task. Valid values:
        # 
        # *   GROUP: All Elastic Compute Service (ECS) instances in the application group are monitored.
        # *   GROUP_SPEC_INSTANCE: Specified ECS instances in the application group are monitored. The TaskScope parameter must be used in combination with the InstanceList.N parameter. The InstanceList.N parameter specifies the ECS instances to be monitored.
        self.task_scope = task_scope  # type: str

    def validate(self):
        if self.alert_config:
            self.alert_config.validate()
        if self.task_option:
            self.task_option.validate()
        if self.alert_config_escalation_list:
            for k in self.alert_config_escalation_list:
                if k:
                    k.validate()
        if self.alert_config_target_list:
            for k in self.alert_config_target_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyHostAvailabilityRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alert_config is not None:
            result['AlertConfig'] = self.alert_config.to_map()
        if self.task_option is not None:
            result['TaskOption'] = self.task_option.to_map()
        result['AlertConfigEscalationList'] = []
        if self.alert_config_escalation_list is not None:
            for k in self.alert_config_escalation_list:
                result['AlertConfigEscalationList'].append(k.to_map() if k else None)
        result['AlertConfigTargetList'] = []
        if self.alert_config_target_list is not None:
            for k in self.alert_config_target_list:
                result['AlertConfigTargetList'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.id is not None:
            result['Id'] = self.id
        if self.instance_list is not None:
            result['InstanceList'] = self.instance_list
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        if self.task_scope is not None:
            result['TaskScope'] = self.task_scope
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlertConfig') is not None:
            temp_model = ModifyHostAvailabilityRequestAlertConfig()
            self.alert_config = temp_model.from_map(m['AlertConfig'])
        if m.get('TaskOption') is not None:
            temp_model = ModifyHostAvailabilityRequestTaskOption()
            self.task_option = temp_model.from_map(m['TaskOption'])
        self.alert_config_escalation_list = []
        if m.get('AlertConfigEscalationList') is not None:
            for k in m.get('AlertConfigEscalationList'):
                temp_model = ModifyHostAvailabilityRequestAlertConfigEscalationList()
                self.alert_config_escalation_list.append(temp_model.from_map(k))
        self.alert_config_target_list = []
        if m.get('AlertConfigTargetList') is not None:
            for k in m.get('AlertConfigTargetList'):
                temp_model = ModifyHostAvailabilityRequestAlertConfigTargetList()
                self.alert_config_target_list.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('InstanceList') is not None:
            self.instance_list = m.get('InstanceList')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        if m.get('TaskScope') is not None:
            self.task_scope = m.get('TaskScope')
        return self


class ModifyHostAvailabilityResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostAvailabilityResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyHostAvailabilityResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHostAvailabilityResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHostAvailabilityResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHostAvailabilityResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHostInfoRequest(TeaModel):
    def __init__(self, host_name=None, instance_id=None, region_id=None):
        # The name of the host.
        self.host_name = host_name  # type: str
        # The ID of the instance. Only hosts not on Alibaba Cloud are supported.
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyHostInfoResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHostInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyHostInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHostInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHostInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHostInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHybridMonitorNamespaceRequest(TeaModel):
    def __init__(self, description=None, namespace=None, region_id=None, spec=None):
        # The description of the namespace.
        self.description = description  # type: str
        # The name of the namespace.
        # 
        # The name can contain letters, digits, and hyphens (-).
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The data retention period. Valid values:
        # 
        # *   cms.s1.large: Data is stored for 15 days.
        # *   cms.s1.xlarge: Data is stored for 32 days.
        # *   cms.s1.2xlarge: Data is stored for 63 days.
        # *   cms.s1.3xlarge: Data is stored for 93 days.
        # *   cms.s1.6xlarge: Data is stored for 185 days.
        # *   cms.s1.12xlarge: Data is stored for 376 days.
        # 
        # For information about the pricing for different retention periods, see the **Pricing** section in [Billing of the dashboard feature](~~223532~~).
        self.spec = spec  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorNamespaceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.spec is not None:
            result['Spec'] = self.spec
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Spec') is not None:
            self.spec = m.get('Spec')
        return self


class ModifyHybridMonitorNamespaceResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The returned message.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorNamespaceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyHybridMonitorNamespaceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHybridMonitorNamespaceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorNamespaceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHybridMonitorNamespaceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHybridMonitorSLSGroupRequestSLSGroupConfig(TeaModel):
    def __init__(self, slslogstore=None, slsproject=None, slsregion=None, slsuser_id=None):
        # The Logstore.
        # 
        # Valid values of N: 1 to 25.
        self.slslogstore = slslogstore  # type: str
        # The Simple Log Service project.
        # 
        # Valid values of N: 1 to 25.
        self.slsproject = slsproject  # type: str
        # The region ID.
        # 
        # Valid values of N: 1 to 25.
        self.slsregion = slsregion  # type: str
        # The member ID.
        # 
        # Valid values of N: 1 to 25.
        # 
        # If you call this operation by using the management account of a resource directory, you can connect the Alibaba Cloud services that are activated for all members in the resource directory to Hybrid Cloud Monitoring. You can use the resource directory to monitor Alibaba Cloud services across enterprise accounts.
        # 
        # > If a member uses CloudMonitor for the first time, you must make sure that the service-linked role AliyunServiceRoleForCloudMonitor is attached to the member. For more information, see [Manage the service-linked role for CloudMonitor](~~170423~~).
        self.slsuser_id = slsuser_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorSLSGroupRequestSLSGroupConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.slslogstore is not None:
            result['SLSLogstore'] = self.slslogstore
        if self.slsproject is not None:
            result['SLSProject'] = self.slsproject
        if self.slsregion is not None:
            result['SLSRegion'] = self.slsregion
        if self.slsuser_id is not None:
            result['SLSUserId'] = self.slsuser_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('SLSLogstore') is not None:
            self.slslogstore = m.get('SLSLogstore')
        if m.get('SLSProject') is not None:
            self.slsproject = m.get('SLSProject')
        if m.get('SLSRegion') is not None:
            self.slsregion = m.get('SLSRegion')
        if m.get('SLSUserId') is not None:
            self.slsuser_id = m.get('SLSUserId')
        return self


class ModifyHybridMonitorSLSGroupRequest(TeaModel):
    def __init__(self, region_id=None, slsgroup_config=None, slsgroup_description=None, slsgroup_name=None):
        self.region_id = region_id  # type: str
        # The configurations of the Logstore group.
        # 
        # Valid values of N: 1 to 25.
        self.slsgroup_config = slsgroup_config  # type: list[ModifyHybridMonitorSLSGroupRequestSLSGroupConfig]
        # The description of the Logstore group.
        self.slsgroup_description = slsgroup_description  # type: str
        # The name of the Logstore group.
        # 
        # For information about how to obtain the name of a Logstore group, see [DescribeHybridMonitorSLSGroup](~~429526~~).
        self.slsgroup_name = slsgroup_name  # type: str

    def validate(self):
        if self.slsgroup_config:
            for k in self.slsgroup_config:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorSLSGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['SLSGroupConfig'] = []
        if self.slsgroup_config is not None:
            for k in self.slsgroup_config:
                result['SLSGroupConfig'].append(k.to_map() if k else None)
        if self.slsgroup_description is not None:
            result['SLSGroupDescription'] = self.slsgroup_description
        if self.slsgroup_name is not None:
            result['SLSGroupName'] = self.slsgroup_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.slsgroup_config = []
        if m.get('SLSGroupConfig') is not None:
            for k in m.get('SLSGroupConfig'):
                temp_model = ModifyHybridMonitorSLSGroupRequestSLSGroupConfig()
                self.slsgroup_config.append(temp_model.from_map(k))
        if m.get('SLSGroupDescription') is not None:
            self.slsgroup_description = m.get('SLSGroupDescription')
        if m.get('SLSGroupName') is not None:
            self.slsgroup_name = m.get('SLSGroupName')
        return self


class ModifyHybridMonitorSLSGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorSLSGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyHybridMonitorSLSGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHybridMonitorSLSGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorSLSGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHybridMonitorSLSGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyHybridMonitorTaskRequestAttachLabels(TeaModel):
    def __init__(self, name=None, value=None):
        # The tag key of the metric.
        self.name = name  # type: str
        # The tag value of the metric.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestAttachLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfigExpress(TeaModel):
    def __init__(self, alias=None, express=None):
        # The alias of the extended field that specifies the result of basic operations performed on aggregation results.
        self.alias = alias  # type: str
        # The extended field that specifies the result of basic operations performed on aggregation results.
        self.express = express  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfigExpress, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.express is not None:
            result['Express'] = self.express
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Express') is not None:
            self.express = m.get('Express')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters(TeaModel):
    def __init__(self, operator=None, slskey_name=None, value=None):
        # The method that is used to filter logs imported from Log Service. Valid values:
        # 
        # *   `contain`: contains
        # *   `notContain`: does not contain
        # *   `>`: greater than
        # *   `<`: less than
        # *   `=`: equal to
        # *   `! =`: not equal to
        # *   `>=`: greater than or equal to
        # *   `<=`: less than or equal to
        self.operator = operator  # type: str
        # The name of the key that is used to filter logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str
        # The value of the key that is used to filter logs imported from Log Service.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfigFilter(TeaModel):
    def __init__(self, filters=None, relation=None):
        # None
        self.filters = filters  # type: list[ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters]
        # The relationship between multiple filter conditions. Valid values:
        # 
        # *   and (default): Logs are processed only if all filter conditions are met.
        # *   or: Logs are processed if one of the filter conditions is met.
        self.relation = relation  # type: str

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfigFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['Filters'].append(k.to_map() if k else None)
        if self.relation is not None:
            result['Relation'] = self.relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.filters = []
        if m.get('Filters') is not None:
            for k in m.get('Filters'):
                temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfigFilterFilters()
                self.filters.append(temp_model.from_map(k))
        if m.get('Relation') is not None:
            self.relation = m.get('Relation')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy(TeaModel):
    def __init__(self, alias=None, slskey_name=None):
        # The alias of the aggregation result.
        self.alias = alias  # type: str
        # The name of the key that is used to aggregate logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics(TeaModel):
    def __init__(self, alias=None, function=None, parameter_1=None, parameter_2=None, slskey_name=None):
        # The alias of the aggregation result.
        self.alias = alias  # type: str
        # The function that is used to aggregate the log data of a statistical period. Valid values:
        # 
        # *   count: counts the number.
        # *   sum: calculates the total value.
        # *   avg: calculates the average value.
        # *   max: calculates the maximum value.
        # *   min: calculates the minimum value.
        # *   value: collects samples within the statistical period.
        # *   countps: calculates the counted number of the specified field divided by the total number of seconds within the statistical period.
        # *   sumps: calculates the total value of the specified field divided by the total number of seconds within the statistical period.
        # *   distinct: counts the number of logs where the specified field appears within the statistical period.
        # *   distribution: counts the number of logs that meet a specified condition within the statistical period.
        # *   percentile: sorts the values of the specified field in ascending order, and then returns the value that is at the specified percentile within the statistical period. Example: P50.
        self.function = function  # type: str
        # The value of the function that is used to aggregate logs imported from Log Service.
        # 
        # *   If the `Function` parameter is set to `distribution`, this parameter specifies the lower limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 200.
        # *   If you set the `Function` parameter to `percentile`, this parameter specifies the percentile at which the expected value is. For example, 0.5 specifies P50.
        self.parameter_1 = parameter_1  # type: str
        # The value of the function that is used to aggregate logs imported from Log Service.
        # 
        # > This parameter must be specified when `Function` is set to `distribution`. This parameter specifies the upper limit of the statistical interval. For example, if you want to calculate the number of HTTP requests whose status code is 2XX, set this parameter to 299.
        self.parameter_2 = parameter_2  # type: str
        # The name of the key that is used to aggregate logs imported from Log Service.
        self.slskey_name = slskey_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.function is not None:
            result['Function'] = self.function
        if self.parameter_1 is not None:
            result['Parameter1'] = self.parameter_1
        if self.parameter_2 is not None:
            result['Parameter2'] = self.parameter_2
        if self.slskey_name is not None:
            result['SLSKeyName'] = self.slskey_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Parameter1') is not None:
            self.parameter_1 = m.get('Parameter1')
        if m.get('Parameter2') is not None:
            self.parameter_2 = m.get('Parameter2')
        if m.get('SLSKeyName') is not None:
            self.slskey_name = m.get('SLSKeyName')
        return self


class ModifyHybridMonitorTaskRequestSLSProcessConfig(TeaModel):
    def __init__(self, express=None, filter=None, group_by=None, statistics=None):
        # The extended fields that specify the results of basic operations performed on aggregation results.
        self.express = express  # type: list[ModifyHybridMonitorTaskRequestSLSProcessConfigExpress]
        # The conditions that are used to filter logs imported from Log Service.
        self.filter = filter  # type: ModifyHybridMonitorTaskRequestSLSProcessConfigFilter
        # The dimensions based on which data is aggregated. This parameter is equivalent to the GROUP BY clause in SQL.
        self.group_by = group_by  # type: list[ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy]
        # None
        self.statistics = statistics  # type: list[ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics]

    def validate(self):
        if self.express:
            for k in self.express:
                if k:
                    k.validate()
        if self.filter:
            self.filter.validate()
        if self.group_by:
            for k in self.group_by:
                if k:
                    k.validate()
        if self.statistics:
            for k in self.statistics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequestSLSProcessConfig, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Express'] = []
        if self.express is not None:
            for k in self.express:
                result['Express'].append(k.to_map() if k else None)
        if self.filter is not None:
            result['Filter'] = self.filter.to_map()
        result['GroupBy'] = []
        if self.group_by is not None:
            for k in self.group_by:
                result['GroupBy'].append(k.to_map() if k else None)
        result['Statistics'] = []
        if self.statistics is not None:
            for k in self.statistics:
                result['Statistics'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.express = []
        if m.get('Express') is not None:
            for k in m.get('Express'):
                temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfigExpress()
                self.express.append(temp_model.from_map(k))
        if m.get('Filter') is not None:
            temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfigFilter()
            self.filter = temp_model.from_map(m['Filter'])
        self.group_by = []
        if m.get('GroupBy') is not None:
            for k in m.get('GroupBy'):
                temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfigGroupBy()
                self.group_by.append(temp_model.from_map(k))
        self.statistics = []
        if m.get('Statistics') is not None:
            for k in m.get('Statistics'):
                temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfigStatistics()
                self.statistics.append(temp_model.from_map(k))
        return self


class ModifyHybridMonitorTaskRequest(TeaModel):
    def __init__(self, attach_labels=None, collect_interval=None, description=None, region_id=None,
                 slsprocess_config=None, task_id=None, task_name=None):
        # The tags of the metric.
        self.attach_labels = attach_labels  # type: list[ModifyHybridMonitorTaskRequestAttachLabels]
        # The collection period of the metric. Valid values:
        # 
        # *   15
        # *   60
        # 
        # Unit: seconds.
        self.collect_interval = collect_interval  # type: str
        # The description of the metric import task.
        self.description = description  # type: str
        self.region_id = region_id  # type: str
        # The configurations of the logs that are imported from Log Service.
        self.slsprocess_config = slsprocess_config  # type: ModifyHybridMonitorTaskRequestSLSProcessConfig
        # The ID of the metric import task.
        # 
        # For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](~~428624~~).
        self.task_id = task_id  # type: str
        # The name of the metric import task.
        # 
        # For information about how to obtain the ID of a metric import task, see [DescribeHybridMonitorTaskList](~~428624~~).
        self.task_name = task_name  # type: str

    def validate(self):
        if self.attach_labels:
            for k in self.attach_labels:
                if k:
                    k.validate()
        if self.slsprocess_config:
            self.slsprocess_config.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AttachLabels'] = []
        if self.attach_labels is not None:
            for k in self.attach_labels:
                result['AttachLabels'].append(k.to_map() if k else None)
        if self.collect_interval is not None:
            result['CollectInterval'] = self.collect_interval
        if self.description is not None:
            result['Description'] = self.description
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.slsprocess_config is not None:
            result['SLSProcessConfig'] = self.slsprocess_config.to_map()
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.attach_labels = []
        if m.get('AttachLabels') is not None:
            for k in m.get('AttachLabels'):
                temp_model = ModifyHybridMonitorTaskRequestAttachLabels()
                self.attach_labels.append(temp_model.from_map(k))
        if m.get('CollectInterval') is not None:
            self.collect_interval = m.get('CollectInterval')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SLSProcessConfig') is not None:
            temp_model = ModifyHybridMonitorTaskRequestSLSProcessConfig()
            self.slsprocess_config = temp_model.from_map(m['SLSProcessConfig'])
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class ModifyHybridMonitorTaskResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyHybridMonitorTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyHybridMonitorTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyHybridMonitorTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyHybridMonitorTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyMetricRuleBlackListRequestMetrics(TeaModel):
    def __init__(self, metric_name=None, resource=None):
        # The name of the metric.
        # 
        # Valid values of N: 1 to 10.
        self.metric_name = metric_name  # type: str
        # The extended dimension of the instance. For example, `{"device":"C:"}` specifies that the blacklist policy is applied to all C disks of the specified Elastic Compute Service (ECS) instance.
        # 
        # Valid values of N: 1 to 10.
        self.resource = resource  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleBlackListRequestMetrics, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.resource is not None:
            result['Resource'] = self.resource
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Resource') is not None:
            self.resource = m.get('Resource')
        return self


class ModifyMetricRuleBlackListRequest(TeaModel):
    def __init__(self, category=None, effective_time=None, enable_end_time=None, enable_start_time=None, id=None,
                 instances=None, metrics=None, name=None, namespace=None, region_id=None, scope_type=None, scope_value=None):
        # The category of the Alibaba Cloud service. For example, ApsaraDB for Redis includes the following categories: ApsaraDB for Redis (standard architecture), ApsaraDB for Redis (cluster architecture), and ApsaraDB for Redis (read/write splitting architecture). In this case, the valid values of this parameter for ApsaraDB for Redis include `kvstore_standard`, `kvstore_sharding`, and `kvstore_splitrw`.
        self.category = category  # type: str
        # The time range within which the blacklist policy is effective. Take note of the following information:
        # 
        # *   If you do not configure this parameter, the blacklist policy is permanently effective.
        # 
        # *   If you configure this parameter, the blacklist policy is effective only within the specified time range. Examples:
        # 
        #     *   `03:00-04:59`: The blacklist policy is effective from 03:00 to 05:00 local time. 05:00 local time is excluded.
        #     *   `03:00-04:59 UTC+0700`: The blacklist policy is effective from 03:00 to 05:00 (UTC+7). 05:00 (UTC+7) is excluded.
        self.effective_time = effective_time  # type: str
        # The timestamp when the blacklist policy expires.
        # 
        # Unit: milliseconds.
        self.enable_end_time = enable_end_time  # type: str
        # The timestamp when the blacklist policy starts to take effect.
        # 
        # Unit: milliseconds.
        self.enable_start_time = enable_start_time  # type: str
        # The ID of the blacklist policy.
        # 
        # For information about how to obtain the ID of a blacklist policy, see [DescribeMetricRuleBlackList](~~457257~~).
        self.id = id  # type: str
        # The IDs of the instances that belong to the specified cloud service.
        self.instances = instances  # type: list[str]
        # The metrics of the instance.
        # 
        # *   If you do not configure this parameter, the blacklist policy applies to all metrics of the specified cloud service.
        # *   If you configure this parameter, the blacklist policy applies only to the current metric.
        self.metrics = metrics  # type: list[ModifyMetricRuleBlackListRequestMetrics]
        # The name of the blacklist policy.
        self.name = name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about the namespaces of different cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The effective scope of the blacklist policy. Valid values:
        # 
        # *   USER: The blacklist policy takes effect only within the current Alibaba Cloud account.
        # *   GROUP (default): The blacklist policy takes effect only within the specified application group. For information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.scope_type = scope_type  # type: str
        # The IDs of the application groups. Specify a JSON array.
        # 
        # > This parameter must be specified when `ScopeType` is set to `GROUP`.
        self.scope_value = scope_value  # type: str

    def validate(self):
        if self.metrics:
            for k in self.metrics:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleBlackListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.effective_time is not None:
            result['EffectiveTime'] = self.effective_time
        if self.enable_end_time is not None:
            result['EnableEndTime'] = self.enable_end_time
        if self.enable_start_time is not None:
            result['EnableStartTime'] = self.enable_start_time
        if self.id is not None:
            result['Id'] = self.id
        if self.instances is not None:
            result['Instances'] = self.instances
        result['Metrics'] = []
        if self.metrics is not None:
            for k in self.metrics:
                result['Metrics'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scope_type is not None:
            result['ScopeType'] = self.scope_type
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('EffectiveTime') is not None:
            self.effective_time = m.get('EffectiveTime')
        if m.get('EnableEndTime') is not None:
            self.enable_end_time = m.get('EnableEndTime')
        if m.get('EnableStartTime') is not None:
            self.enable_start_time = m.get('EnableStartTime')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Instances') is not None:
            self.instances = m.get('Instances')
        self.metrics = []
        if m.get('Metrics') is not None:
            for k in m.get('Metrics'):
                temp_model = ModifyMetricRuleBlackListRequestMetrics()
                self.metrics.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ScopeType') is not None:
            self.scope_type = m.get('ScopeType')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        return self


class ModifyMetricRuleBlackListResponseBody(TeaModel):
    def __init__(self, code=None, count=None, message=None, request_id=None, success=None):
        # The error code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The number of blacklist policies that are modified.
        self.count = count  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleBlackListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyMetricRuleBlackListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyMetricRuleBlackListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleBlackListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyMetricRuleBlackListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, n=None, statistics=None, threshold=None, times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class ModifyMetricRuleTemplateRequestAlertTemplatesEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical
        self.info = info  # type: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo
        self.warn = warn  # type: ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequestAlertTemplatesEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = ModifyMetricRuleTemplateRequestAlertTemplatesEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class ModifyMetricRuleTemplateRequestAlertTemplates(TeaModel):
    def __init__(self, escalations=None, category=None, metric_name=None, namespace=None, period=None,
                 rule_name=None, selector=None, webhook=None):
        self.escalations = escalations  # type: ModifyMetricRuleTemplateRequestAlertTemplatesEscalations
        # The abbreviation of the cloud service name.
        # 
        # Valid values of N: 1 to 200.
        # 
        # For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](~~114916~~) operation.
        self.category = category  # type: str
        # The metric name.
        # 
        # Valid values of N: 1 to 200.
        # 
        # For information about how to obtain metrics, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # Valid values of N: 1 to 200.
        # 
        # For information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The statistical period of the monitoring data.
        # 
        # Valid values of N: 1 to 200.
        # 
        # > If the value is set to 300 seconds, the monitoring data is collected every 300 seconds. If the monitoring data is reported every 1 minute, the alert system calculates the average, maximum, and minimum values of the monitoring data of 5 minutes and checks whether the aggregated values exceed the threshold. To prevent unexpected alerts, we recommend that you set this parameter together with other parameters.
        self.period = period  # type: int
        # The name of the alert rule.
        # 
        # Valid values of N: 1 to 200.
        self.rule_name = rule_name  # type: str
        # The dimension of the alert. It is an extended field.
        # 
        # Valid values of N: 1 to 200.
        # 
        # For example, an alert template is applied to an application group, this parameter is set to `{"disk":"/"}`, and the MetricName parameter is set to `DiskUtilization`. In this case, the generated alert rule is applied to the root disk partition (`"/"`) of all instances in the application group to which the alert template is applied.
        # 
        # > For more information about the values of extended fields, see [DescribeMetricRuleTemplateAttribute](~~114979~~).
        self.selector = selector  # type: str
        # The callback URL.
        # 
        # Valid values of N: 1 to 200.
        # 
        # The callback URL must be accessible over the Internet. CloudMonitor pushes an alert notification to the specified callback URL by sending an HTTP POST request. Only the HTTP protocol is supported.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequestAlertTemplates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.category is not None:
            result['Category'] = self.category
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.selector is not None:
            result['Selector'] = self.selector
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = ModifyMetricRuleTemplateRequestAlertTemplatesEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Selector') is not None:
            self.selector = m.get('Selector')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class ModifyMetricRuleTemplateRequest(TeaModel):
    def __init__(self, alert_templates=None, description=None, name=None, region_id=None, rest_version=None,
                 template_id=None):
        # The details of the alert template.
        self.alert_templates = alert_templates  # type: list[ModifyMetricRuleTemplateRequestAlertTemplates]
        # The description of the alert template.
        self.description = description  # type: str
        # The name of the alert template.
        # 
        # For information about how to obtain the name of an alert template, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.name = name  # type: str
        self.region_id = region_id  # type: str
        # The version of the alert template. The version changes with the number of times that the alert template is modified.
        # 
        # For information about how to obtain the version of an alert template, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.rest_version = rest_version  # type: long
        # The ID of the alert template.
        # 
        # For information about how to obtain the ID of an alert template, see [DescribeMetricRuleTemplateList](~~114982~~).
        self.template_id = template_id  # type: long

    def validate(self):
        if self.alert_templates:
            for k in self.alert_templates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AlertTemplates'] = []
        if self.alert_templates is not None:
            for k in self.alert_templates:
                result['AlertTemplates'].append(k.to_map() if k else None)
        if self.description is not None:
            result['Description'] = self.description
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rest_version is not None:
            result['RestVersion'] = self.rest_version
        if self.template_id is not None:
            result['TemplateId'] = self.template_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.alert_templates = []
        if m.get('AlertTemplates') is not None:
            for k in m.get('AlertTemplates'):
                temp_model = ModifyMetricRuleTemplateRequestAlertTemplates()
                self.alert_templates.append(temp_model.from_map(k))
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RestVersion') is not None:
            self.rest_version = m.get('RestVersion')
        if m.get('TemplateId') is not None:
            self.template_id = m.get('TemplateId')
        return self


class ModifyMetricRuleTemplateResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyMetricRuleTemplateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyMetricRuleTemplateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyMetricRuleTemplateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyMetricRuleTemplateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyMonitorGroupRequest(TeaModel):
    def __init__(self, contact_groups=None, group_id=None, group_name=None, region_id=None):
        # The alert groups that can receive alert notifications for the application group.
        self.contact_groups = contact_groups  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the application group.
        self.group_name = group_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMonitorGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyMonitorGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMonitorGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyMonitorGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyMonitorGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyMonitorGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyMonitorGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyMonitorGroupInstancesRequestInstances(TeaModel):
    def __init__(self, category=None, instance_id=None, instance_name=None, region_id=None):
        # The abbreviation of the name of the service to which the instances to be added to the application group belong. Valid values:
        # 
        # *   ECS: Elastic Compute Service (ECS) instances provided by Alibaba Cloud and hosts not provided by Alibaba Cloud
        # 
        # *   RDS: ApsaraDB for RDS
        # 
        # *   ADS: AnalyticDB
        # 
        # *   SLB: Server Load Balancer (SLB)
        # 
        # *   VPC: Virtual Private Cloud (VPC)
        # 
        # *   APIGATEWAY: API Gateway
        # 
        # *   CDN: Alibaba Cloud Content Delivery Network (CDN)
        # 
        # *   CS: Container Service for Swarm
        # 
        # *   DCDN: Dynamic Route for CDN
        # 
        # *   DDoS: Anti-DDoS Pro
        # 
        # *   EIP: Elastic IP Address (EIP)
        # 
        # *   ELASTICSEARCH: Elasticsearch
        # 
        # *   EMR: E-MapReduce
        # 
        # *   ESS: Auto Scaling
        # 
        # *   HBASE: ApsaraDB for Hbase
        # 
        # *   IOT_EDGE: IoT Edge
        # 
        # *   K8S_POD: pods in Container Service for Kubernetes
        # 
        # *   KVSTORE_SHARDING: ApsaraDB for Redis of the cluster architecture
        # 
        # *   KVSTORE_SPLITRW: ApsaraDB for Redis of the read/write splitting architecture
        # 
        # *   KVSTORE_STANDARD: ApsaraDB for Redis of the standard architecture
        # 
        # *   MEMCACHE: ApsaraDB for Memcache
        # 
        # *   MNS: Message Service (MNS)
        # 
        # *   MONGODB: ApsaraDB for MongoDB of the replica set architecture
        # 
        # *   MONGODB_CLUSTER: ApsaraDB for MongoDB of the cluster architecture
        # 
        # *   MONGODB_SHARDING: ApsaraDB for MongoDB of the sharded cluster architecture
        # 
        # *   MQ_TOPIC: MNS topics
        # 
        # *   OCS: ApsaraDB for Memcache of earlier versions
        # 
        # *   OPENSEARCH: Open Search
        # 
        # *   OSS: Object Storage Service (OSS)
        # 
        # *   POLARDB: PolarDB
        # 
        # *   PETADATA: HybridDB for MySQL
        # 
        # *   SCDN: Secure Content Delivery Network (SCDN)
        # 
        # *   SHAREBANDWIDTHPACKAGES: EIP Bandwidth Plan
        # 
        # *   SLS: Log Service
        # 
        # *   VPN: VPN Gateway
        # 
        #     Valid values of N: 1 to 2000.
        self.category = category  # type: str
        # The ID of the instance. Valid values of N: 1 to 2000.
        self.instance_id = instance_id  # type: str
        # The name of the instance. Valid values of N: 1 to 2000.
        self.instance_name = instance_name  # type: str
        # The ID of the region where the instance resides. Valid values of N: 1 to 2000.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMonitorGroupInstancesRequestInstances, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_name is not None:
            result['InstanceName'] = self.instance_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceName') is not None:
            self.instance_name = m.get('InstanceName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyMonitorGroupInstancesRequest(TeaModel):
    def __init__(self, group_id=None, instances=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        self.instances = instances  # type: list[ModifyMonitorGroupInstancesRequestInstances]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.instances:
            for k in self.instances:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyMonitorGroupInstancesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['Instances'] = []
        if self.instances is not None:
            for k in self.instances:
                result['Instances'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.instances = []
        if m.get('Instances') is not None:
            for k in m.get('Instances'):
                temp_model = ModifyMonitorGroupInstancesRequestInstances()
                self.instances.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyMonitorGroupInstancesResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. The value true indicates a success. The value false indicates a failure.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyMonitorGroupInstancesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyMonitorGroupInstancesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyMonitorGroupInstancesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyMonitorGroupInstancesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyMonitorGroupInstancesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifySiteMonitorRequest(TeaModel):
    def __init__(self, address=None, alert_ids=None, custom_schedule=None, interval=None, interval_unit=None,
                 isp_cities=None, options_json=None, region_id=None, task_id=None, task_name=None):
        # The URL or IP address that is monitored by the task.
        self.address = address  # type: str
        # The ID of the alert rule. You can call the DescribeMetricRuleList operation to query the IDs of existing alert rules in CloudMonitor. For more information, see [DescribeMetricRuleList](~~114941~~).
        self.alert_ids = alert_ids  # type: str
        # The custom detection period. You can only select a time period from Monday to Sunday for detection.
        self.custom_schedule = custom_schedule  # type: str
        # The interval at which detection requests are sent. Valid values: 1, 5, and 15. Unit: minutes. Default value: 1.
        self.interval = interval  # type: str
        # The unit of the metric.
        # 
        # Unit: milliseconds.
        self.interval_unit = interval_unit  # type: str
        # The information of the detection points. The value is a JSON array. Example: `[{"city":"546","isp":"465"},{"city":"572","isp":"465"},{"city":"738","isp":"465"}]`. The values of the `city` field indicate Beijing, Hangzhou, and Qingdao.
        # 
        # > You can call the DescribeSiteMonitorISPCityList operation to query the detection points. For more information, see [DescribeSiteMonitorISPCityList](~~115045~~). If you leave this parameter empty, the system randomly selects three detection points.
        self.isp_cities = isp_cities  # type: str
        # The extended options of the protocol that is used by the site monitoring task. The options vary based on the protocol.
        self.options_json = options_json  # type: str
        self.region_id = region_id  # type: str
        # The ID of the site monitoring task.
        self.task_id = task_id  # type: str
        # The name of the site monitoring task. The name must be 4 to 100 characters in length, and can contain letters, digits, and underscores (\_).
        self.task_name = task_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySiteMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        if self.alert_ids is not None:
            result['AlertIds'] = self.alert_ids
        if self.custom_schedule is not None:
            result['CustomSchedule'] = self.custom_schedule
        if self.interval is not None:
            result['Interval'] = self.interval
        if self.interval_unit is not None:
            result['IntervalUnit'] = self.interval_unit
        if self.isp_cities is not None:
            result['IspCities'] = self.isp_cities
        if self.options_json is not None:
            result['OptionsJson'] = self.options_json
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_name is not None:
            result['TaskName'] = self.task_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        if m.get('AlertIds') is not None:
            self.alert_ids = m.get('AlertIds')
        if m.get('CustomSchedule') is not None:
            self.custom_schedule = m.get('CustomSchedule')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        if m.get('IntervalUnit') is not None:
            self.interval_unit = m.get('IntervalUnit')
        if m.get('IspCities') is not None:
            self.isp_cities = m.get('IspCities')
        if m.get('OptionsJson') is not None:
            self.options_json = m.get('OptionsJson')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskName') is not None:
            self.task_name = m.get('TaskName')
        return self


class ModifySiteMonitorResponseBodyData(TeaModel):
    def __init__(self, count=None):
        # The number of site monitoring tasks.
        self.count = count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifySiteMonitorResponseBodyData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.count is not None:
            result['count'] = self.count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('count') is not None:
            self.count = m.get('count')
        return self


class ModifySiteMonitorResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The result of modifying the task.
        self.data = data  # type: ModifySiteMonitorResponseBodyData
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: str

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(ModifySiteMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = ModifySiteMonitorResponseBodyData()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifySiteMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifySiteMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifySiteMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifySiteMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OpenCmsServiceResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OpenCmsServiceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OpenCmsServiceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OpenCmsServiceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OpenCmsServiceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OpenCmsServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutContactRequestChannels(TeaModel):
    def __init__(self, ali_im=None, ding_web_hook=None, mail=None, sms=None):
        # The TradeManager ID of the alert contact.
        # 
        # Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
        self.ali_im = ali_im  # type: str
        # The webhook URL of the DingTalk chatbot.
        # 
        # Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
        self.ding_web_hook = ding_web_hook  # type: str
        # The email address of the alert contact. After you add or modify an email address, the recipient receives an email that contains an activation link. The system adds the recipient to the list of alert contacts only after the recipient activates the email address.
        # 
        # Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
        self.mail = mail  # type: str
        # The phone number of the alert contact. After you add or modify a phone number, the recipient receives a text message that contains an activation link. The system adds the recipient to the list of alert contacts only after the recipient activates the phone number.
        # 
        # Specify at least one of the following alert notification targets: email address or webhook URL of the DingTalk chatbot.
        self.sms = sms  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutContactRequestChannels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_im is not None:
            result['AliIM'] = self.ali_im
        if self.ding_web_hook is not None:
            result['DingWebHook'] = self.ding_web_hook
        if self.mail is not None:
            result['Mail'] = self.mail
        if self.sms is not None:
            result['SMS'] = self.sms
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliIM') is not None:
            self.ali_im = m.get('AliIM')
        if m.get('DingWebHook') is not None:
            self.ding_web_hook = m.get('DingWebHook')
        if m.get('Mail') is not None:
            self.mail = m.get('Mail')
        if m.get('SMS') is not None:
            self.sms = m.get('SMS')
        return self


class PutContactRequest(TeaModel):
    def __init__(self, channels=None, contact_name=None, describe=None, lang=None):
        self.channels = channels  # type: PutContactRequestChannels
        # The name of the alert contact.
        self.contact_name = contact_name  # type: str
        # The description of the alert contact.
        self.describe = describe  # type: str
        # The language in which the alert information is displayed. Valid values:
        # 
        # *   zh-cn: simplified Chinese
        # *   en: English
        # 
        # >  If you do not specify a value for this parameter, Cloud Monitor identifies the language of the alert information based on the region of your Alibaba Cloud account.
        self.lang = lang  # type: str

    def validate(self):
        if self.channels:
            self.channels.validate()

    def to_map(self):
        _map = super(PutContactRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.channels is not None:
            result['Channels'] = self.channels.to_map()
        if self.contact_name is not None:
            result['ContactName'] = self.contact_name
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.lang is not None:
            result['Lang'] = self.lang
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Channels') is not None:
            temp_model = PutContactRequestChannels()
            self.channels = temp_model.from_map(m['Channels'])
        if m.get('ContactName') is not None:
            self.contact_name = m.get('ContactName')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        return self


class PutContactResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutContactResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutContactResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutContactResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutContactResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutContactResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutContactGroupRequest(TeaModel):
    def __init__(self, contact_group_name=None, contact_names=None, describe=None, enable_subscribed=None):
        # The name of the alert contact group.
        # 
        # For information about how to obtain the name of an alert contact group, see [DescribeContactGroupList](~~114922~~).
        self.contact_group_name = contact_group_name  # type: str
        self.contact_names = contact_names  # type: list[str]
        # The description of the alert contact group.
        self.describe = describe  # type: str
        # Specifies whether to enable the weekly report subscription feature. Valid values:
        # 
        # *   true: The weekly report subscription feature is enabled.
        # *   false: The weekly report subscription feature is disabled.
        # 
        # >  You can enable the weekly report subscription only for an Alibaba Cloud account that has at least five Elastic Compute Service (ECS) instances.
        self.enable_subscribed = enable_subscribed  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutContactGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.contact_names is not None:
            result['ContactNames'] = self.contact_names
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.enable_subscribed is not None:
            result['EnableSubscribed'] = self.enable_subscribed
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('ContactNames') is not None:
            self.contact_names = m.get('ContactNames')
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('EnableSubscribed') is not None:
            self.enable_subscribed = m.get('EnableSubscribed')
        return self


class PutContactGroupResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutContactGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutContactGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutContactGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutContactGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutContactGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutCustomEventRequestEventInfo(TeaModel):
    def __init__(self, content=None, event_name=None, group_id=None, time=None):
        # The content of the custom event. Valid values of N: 1 to 50.
        self.content = content  # type: str
        # The name of the custom event. Valid values of N: 1 to 50.
        self.event_name = event_name  # type: str
        # The ID of the application group. Valid values of N: 0 to 50.
        # 
        # Default value: 0. This value indicates that the custom event to be reported does not belong to any application group.
        self.group_id = group_id  # type: str
        # The time when the custom event occurred.
        # 
        # Format: `yyyyMMddTHHmmss.SSSZ`.
        # 
        # Valid values of N: 1 to 50.
        # 
        # >  You can also specify a UNIX timestamp. Example: 1552199984000. Unit: milliseconds.
        self.time = time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomEventRequestEventInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.time is not None:
            result['Time'] = self.time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        return self


class PutCustomEventRequest(TeaModel):
    def __init__(self, event_info=None, region_id=None):
        self.event_info = event_info  # type: list[PutCustomEventRequestEventInfo]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.event_info:
            for k in self.event_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutCustomEventRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EventInfo'] = []
        if self.event_info is not None:
            for k in self.event_info:
                result['EventInfo'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.event_info = []
        if m.get('EventInfo') is not None:
            for k in m.get('EventInfo'):
                temp_model = PutCustomEventRequestEventInfo()
                self.event_info.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutCustomEventResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomEventResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutCustomEventResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutCustomEventResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutCustomEventResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutCustomEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutCustomEventRuleRequest(TeaModel):
    def __init__(self, contact_groups=None, effective_interval=None, email_subject=None, event_name=None,
                 group_id=None, level=None, period=None, rule_id=None, rule_name=None, threshold=None, webhook=None):
        # The alert contact group that receives alert notifications. Separate multiple contact groups with commas (,).
        self.contact_groups = contact_groups  # type: str
        # The time period during which the alert rule is effective. Valid values: 00:00 to 23:59.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        self.email_subject = email_subject  # type: str
        # The name of the custom event. For more information about how to obtain the event name, see [DescribeCustomEventAttribute](~~115262~~).
        self.event_name = event_name  # type: str
        # The ID of the application group. For more information about how to obtain the group ID, see [DescribeCustomEventAttribute](~~115262~~).
        # 
        # >  The value 0 indicates that the reported custom event does not belong to any application Group.
        self.group_id = group_id  # type: str
        # The level of the alert. Valid values:
        # 
        # *   CRITICAL: critical issue
        # *   WARN: warning
        # *   INFO: information
        self.level = level  # type: str
        # The cycle that is used to aggregate monitoring data of the custom event. Unit: seconds. Set the value to an integral multiple of 60. Default value: 300.
        self.period = period  # type: str
        # The ID of the alert rule.
        # 
        # >  You can specify an existing ID to modify the corresponding alert rule or specify a new ID to create an alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomEventRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutCustomEventRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomEventRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutCustomEventRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutCustomEventRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutCustomEventRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutCustomEventRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutCustomMetricRequestMetricList(TeaModel):
    def __init__(self, dimensions=None, group_id=None, metric_name=None, period=None, time=None, type=None,
                 values=None):
        # The dimensions that specify the resources whose monitoring data you want to query. Valid values of N: 1 to 21.
        # 
        # Set the value to a collection of key-value pairs. Format:`{"Key":"Value"}`.
        # 
        # The key or value must be 1 to 64 bytes in length. Excessive characters are truncated.
        # 
        # The key or value can contain letters, digits, periods (.), hyphens (-), underscores (\_), forward slashes (/), and backslashes (\\).
        # 
        # >  Dimensions must be formatted as a JSON string in a specified order.
        self.dimensions = dimensions  # type: str
        # The ID of the application group. Valid values of N: 1 to 21.
        # 
        # >  If the metric does not belong to any application group, enter 0.
        self.group_id = group_id  # type: str
        # The name of the metric. Valid values of N: 1 to 21. For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The aggregation period. Valid values of N: 1 to 21. Unit: seconds. Valid values: 60 and 300.
        # 
        # >  If the MetricList.N.Type parameter is set to 1, the MetricList.N.Period parameter is required.
        self.period = period  # type: str
        # The timestamp when the metric data is generated. Valid values of N: 1 to 21. The timestamp can be in one of the following formats:
        # 
        # *   The UTC timestamp that is in the YYYY-MM-DDThh:mm:ssZ format. Example: 20171012T132456.888+0800.
        # *   The UNIX timestamp of the LONG type. Example: 1508136760000.
        self.time = time  # type: str
        # The type of the reported data. Valid values of N: 1 to 21. Valid values:
        # 
        # *   0: reports raw data
        # *   1: reports aggregate data
        # 
        # >  We recommend that you report aggregate data in both the aggregation periods of 60s and 300s. Otherwise, you cannot query monitoring data in a time span that is more than seven days.
        self.type = type  # type: str
        # The collection of metric values. Valid values of N: 1 to 21.
        # 
        # >  If the MetricList.N.Type parameter is set to 0, the keys in this parameter must be set to the specified value. CloudMonitor aggregates raw data in each aggregation period to generate multiple statistical values, such as the maximum value, the count, and the total value.
        self.values = values  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomMetricRequestMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.time is not None:
            result['Time'] = self.time
        if self.type is not None:
            result['Type'] = self.type
        if self.values is not None:
            result['Values'] = self.values
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Time') is not None:
            self.time = m.get('Time')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Values') is not None:
            self.values = m.get('Values')
        return self


class PutCustomMetricRequest(TeaModel):
    def __init__(self, metric_list=None, region_id=None):
        self.metric_list = metric_list  # type: list[PutCustomMetricRequestMetricList]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutCustomMetricRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['MetricList'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_list = []
        if m.get('MetricList') is not None:
            for k in m.get('MetricList'):
                temp_model = PutCustomMetricRequestMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutCustomMetricResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomMetricResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutCustomMetricResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutCustomMetricResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutCustomMetricResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutCustomMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutCustomMetricRuleRequest(TeaModel):
    def __init__(self, comparison_operator=None, contact_groups=None, effective_interval=None, email_subject=None,
                 evaluation_count=None, group_id=None, level=None, metric_name=None, period=None, resources=None, rule_id=None,
                 rule_name=None, silence_time=None, statistics=None, threshold=None, webhook=None):
        # The comparison operator before the threshold. Valid values:
        # 
        # *   `>=`
        # *   `=`
        # *   `<=`
        # *   `>`
        # *   `<`
        # *   `!=`
        self.comparison_operator = comparison_operator  # type: str
        # The alert group that receives alert notifications. Separate multiple alert groups with commas (,).
        self.contact_groups = contact_groups  # type: str
        # The time period during which the alert rule is effective. Valid values: 00:00 to 23:59.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        self.email_subject = email_subject  # type: str
        # The consecutive number of times for which the metric value is measured before an alert is triggered.
        self.evaluation_count = evaluation_count  # type: int
        # The ID of the application group to which the custom monitoring data belongs.
        # 
        # >  The value 0 indicates that the reported custom monitoring data does not belong to an application group.
        self.group_id = group_id  # type: str
        # The level of the alert. Valid values:
        # 
        # *   CRITICAL
        # *   WARN
        # *   INFO
        self.level = level  # type: str
        # The name of the metric.
        # 
        # >  For more information about how to obtain the metric name, see [DescribeCustomMetricList](~~115005~~).
        self.metric_name = metric_name  # type: str
        # The cycle that is used to aggregate custom monitoring data. Unit: seconds. Set the value to an integral multiple of 60. The original reporting cycle of custom monitoring data is used by default.
        self.period = period  # type: str
        # The custom monitoring data to which the alert rule applies. The value includes the application group ID to which the custom monitoring data belongs and the dimension to which the metric belongs.
        self.resources = resources  # type: str
        # The ID of the alert rule.
        # 
        # >  You can specify an existing ID to modify the corresponding alert rule or specify a new ID to create an alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which notifications are not repeatedly sent for an alert. Unit: seconds. Default value: 86400. The default value indicates one day.
        # 
        # >  Only one alert notification is sent during each mute period even if the metric value consecutively exceeds the alert threshold several times.
        self.silence_time = silence_time  # type: int
        # The method that is used to calculate the metric values that trigger alerts.
        self.statistics = statistics  # type: str
        # The threshold of the metric value.
        self.threshold = threshold  # type: str
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.evaluation_count is not None:
            result['EvaluationCount'] = self.evaluation_count
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.level is not None:
            result['Level'] = self.level
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('EvaluationCount') is not None:
            self.evaluation_count = m.get('EvaluationCount')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutCustomMetricRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The value 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message. If the call was successful, the return value is null. If the call failed, an error message is returned.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutCustomMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutCustomMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutCustomMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutCustomMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutCustomMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutEventRuleRequestEventPattern(TeaModel):
    def __init__(self, custom_filters=None, event_type_list=None, level_list=None, name_list=None, product=None,
                 sqlfilter=None, status_list=None):
        # The keyword that is used to filter events. If the content of an event contains the specified keyword, an alert is automatically triggered.
        self.custom_filters = custom_filters  # type: str
        self.event_type_list = event_type_list  # type: list[str]
        self.level_list = level_list  # type: list[str]
        self.name_list = name_list  # type: list[str]
        # The type of the cloud service. Valid values of N: 1 to 50.
        # 
        # >  You can call the DescribeSystemEventMetaList operation to query the cloud services that support event-triggered alerts. For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.product = product  # type: str
        # The SQL condition that is used to filter events. If the content of an event meets the specified SQL condition, an alert is automatically triggered.
        # 
        # >  The syntax of SQL event filtering is consistent with the query syntax of Log Service.
        self.sqlfilter = sqlfilter  # type: str
        self.status_list = status_list  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleRequestEventPattern, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.custom_filters is not None:
            result['CustomFilters'] = self.custom_filters
        if self.event_type_list is not None:
            result['EventTypeList'] = self.event_type_list
        if self.level_list is not None:
            result['LevelList'] = self.level_list
        if self.name_list is not None:
            result['NameList'] = self.name_list
        if self.product is not None:
            result['Product'] = self.product
        if self.sqlfilter is not None:
            result['SQLFilter'] = self.sqlfilter
        if self.status_list is not None:
            result['StatusList'] = self.status_list
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CustomFilters') is not None:
            self.custom_filters = m.get('CustomFilters')
        if m.get('EventTypeList') is not None:
            self.event_type_list = m.get('EventTypeList')
        if m.get('LevelList') is not None:
            self.level_list = m.get('LevelList')
        if m.get('NameList') is not None:
            self.name_list = m.get('NameList')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('SQLFilter') is not None:
            self.sqlfilter = m.get('SQLFilter')
        if m.get('StatusList') is not None:
            self.status_list = m.get('StatusList')
        return self


class PutEventRuleRequest(TeaModel):
    def __init__(self, description=None, event_pattern=None, event_type=None, group_id=None, region_id=None,
                 rule_name=None, silence_time=None, state=None):
        # The description of the event-triggered alert rule.
        self.description = description  # type: str
        self.event_pattern = event_pattern  # type: list[PutEventRuleRequestEventPattern]
        # The type of the event-triggered alert rule. Valid values:
        # 
        # *   SYSTEM: system event-triggered alert rule
        # *   CUSTOM: custom event-triggered alert rule
        self.event_type = event_type  # type: str
        # The ID of the application group to which the event-triggered alert rule belongs.
        self.group_id = group_id  # type: str
        self.region_id = region_id  # type: str
        # The name of the event-triggered alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds.
        self.silence_time = silence_time  # type: long
        # The status of the event-triggered alert rule. Valid values:
        # 
        # *   ENABLED: enabled
        # *   DISABLED: disabled
        self.state = state  # type: str

    def validate(self):
        if self.event_pattern:
            for k in self.event_pattern:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutEventRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        result['EventPattern'] = []
        if self.event_pattern is not None:
            for k in self.event_pattern:
                result['EventPattern'].append(k.to_map() if k else None)
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.state is not None:
            result['State'] = self.state
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.event_pattern = []
        if m.get('EventPattern') is not None:
            for k in m.get('EventPattern'):
                temp_model = PutEventRuleRequestEventPattern()
                self.event_pattern.append(temp_model.from_map(k))
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('State') is not None:
            self.state = m.get('State')
        return self


class PutEventRuleResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The number of event-triggered alert rules that were created or modified.
        self.data = data  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutEventRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutEventRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutEventRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutEventRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutEventRuleTargetsRequestContactParameters(TeaModel):
    def __init__(self, contact_group_name=None, id=None, level=None):
        # The name of the alert contact group. Valid values of N: 1 to 5.
        self.contact_group_name = contact_group_name  # type: str
        # The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
        self.id = id  # type: str
        # The alert level and the corresponding notification methods. Valid values of N: 1 to 5. Valid values:
        # 
        # 4: Alert notifications are sent by using DingTalk chatbots and emails.
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestContactParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class PutEventRuleTargetsRequestFcParameters(TeaModel):
    def __init__(self, function_name=None, id=None, region=None, service_name=None):
        # The name of the function. Valid values of N: 1 to 5.
        self.function_name = function_name  # type: str
        # The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
        self.id = id  # type: str
        # The region where Function Compute is deployed. Valid values of N: 1 to 5.
        self.region = region  # type: str
        # The name of the Function Compute service. Valid values of N: 1 to 5.
        self.service_name = service_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestFcParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.id is not None:
            result['Id'] = self.id
        if self.region is not None:
            result['Region'] = self.region
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class PutEventRuleTargetsRequestMnsParameters(TeaModel):
    def __init__(self, id=None, queue=None, region=None, topic=None):
        # The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
        self.id = id  # type: str
        # The name of the MNS queue. Valid values of N: 1 to 5.
        self.queue = queue  # type: str
        # The region where Message Service (MNS) is deployed. Valid values of N: 1 to 5.
        self.region = region  # type: str
        # The MNS topic.
        self.topic = topic  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestMnsParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.region is not None:
            result['Region'] = self.region
        if self.topic is not None:
            result['Topic'] = self.topic
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Topic') is not None:
            self.topic = m.get('Topic')
        return self


class PutEventRuleTargetsRequestOpenApiParameters(TeaModel):
    def __init__(self, action=None, arn=None, id=None, json_params=None, product=None, region=None, role=None,
                 version=None):
        # The API name.
        self.action = action  # type: str
        # The Alibaba Cloud Resource Name (ARN) of the resource. Valid values of N: 1 to 5. Format: `arn:acs:${Service}:${Region}:${Account}:${ResourceType}/${ResourceId}`. Fields:
        # 
        # *   Service: the code of a cloud service
        # *   Region: the region ID
        # *   Account: the ID of an Alibaba Cloud account
        # *   ResourceType: the resource type
        # *   ResourceId: the resource ID
        self.arn = arn  # type: str
        # The ID of the recipient that receives alert notifications sent by an API callback.
        self.id = id  # type: str
        # The parameters of the alert callback. Specify the parameters in the JSON format.
        self.json_params = json_params  # type: str
        # The ID of the cloud service to which the API operation belongs.
        self.product = product  # type: str
        # The region where the resource resides.
        self.region = region  # type: str
        # The name of the role.
        self.role = role  # type: str
        # The version of the API.
        self.version = version  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestOpenApiParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.action is not None:
            result['Action'] = self.action
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.product is not None:
            result['Product'] = self.product
        if self.region is not None:
            result['Region'] = self.region
        if self.role is not None:
            result['Role'] = self.role
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Action') is not None:
            self.action = m.get('Action')
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('Role') is not None:
            self.role = m.get('Role')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class PutEventRuleTargetsRequestSlsParameters(TeaModel):
    def __init__(self, id=None, log_store=None, project=None, region=None):
        # The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
        self.id = id  # type: str
        # The name of the Simple Log Service Logstore. Valid values of N: 1 to 5.
        self.log_store = log_store  # type: str
        # The name of the Simple Log Service project. Valid values of N: 1 to 5.
        self.project = project  # type: str
        # The region where Simple Log Service is deployed. Valid values of N: 1 to 5.
        self.region = region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestSlsParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.log_store is not None:
            result['LogStore'] = self.log_store
        if self.project is not None:
            result['Project'] = self.project
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LogStore') is not None:
            self.log_store = m.get('LogStore')
        if m.get('Project') is not None:
            self.project = m.get('Project')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class PutEventRuleTargetsRequestWebhookParameters(TeaModel):
    def __init__(self, id=None, method=None, protocol=None, url=None):
        # The ID of the recipient that receives alert notifications. Valid values of N: 1 to 5.
        self.id = id  # type: str
        # The HTTP request method. Valid values of N: 1 to 5.
        # 
        # Valid values: GET and POST.
        self.method = method  # type: str
        # The name of the protocol. Valid values of N: 1 to 5. Valid values:
        # 
        # *   http
        # *   telnet
        # *   ping
        self.protocol = protocol  # type: str
        # The callback URL. Valid values of N: 1 to 5.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsRequestWebhookParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.method is not None:
            result['Method'] = self.method
        if self.protocol is not None:
            result['Protocol'] = self.protocol
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Method') is not None:
            self.method = m.get('Method')
        if m.get('Protocol') is not None:
            self.protocol = m.get('Protocol')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class PutEventRuleTargetsRequest(TeaModel):
    def __init__(self, contact_parameters=None, fc_parameters=None, mns_parameters=None, open_api_parameters=None,
                 region_id=None, rule_name=None, sls_parameters=None, webhook_parameters=None):
        # The information about the alert contact groups that receive alert notifications.
        self.contact_parameters = contact_parameters  # type: list[PutEventRuleTargetsRequestContactParameters]
        # The information about the recipients in Function Compute.
        self.fc_parameters = fc_parameters  # type: list[PutEventRuleTargetsRequestFcParameters]
        # The information about the recipients in Message Service (MNS).
        self.mns_parameters = mns_parameters  # type: list[PutEventRuleTargetsRequestMnsParameters]
        # The parameters of API callback notification.
        self.open_api_parameters = open_api_parameters  # type: list[PutEventRuleTargetsRequestOpenApiParameters]
        self.region_id = region_id  # type: str
        # The name of the alert rule.
        self.rule_name = rule_name  # type: str
        # The information about the recipients in Simple Log Service.
        self.sls_parameters = sls_parameters  # type: list[PutEventRuleTargetsRequestSlsParameters]
        # The information about the callback URLs that are used to receive alert notifications.
        self.webhook_parameters = webhook_parameters  # type: list[PutEventRuleTargetsRequestWebhookParameters]

    def validate(self):
        if self.contact_parameters:
            for k in self.contact_parameters:
                if k:
                    k.validate()
        if self.fc_parameters:
            for k in self.fc_parameters:
                if k:
                    k.validate()
        if self.mns_parameters:
            for k in self.mns_parameters:
                if k:
                    k.validate()
        if self.open_api_parameters:
            for k in self.open_api_parameters:
                if k:
                    k.validate()
        if self.sls_parameters:
            for k in self.sls_parameters:
                if k:
                    k.validate()
        if self.webhook_parameters:
            for k in self.webhook_parameters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactParameters'] = []
        if self.contact_parameters is not None:
            for k in self.contact_parameters:
                result['ContactParameters'].append(k.to_map() if k else None)
        result['FcParameters'] = []
        if self.fc_parameters is not None:
            for k in self.fc_parameters:
                result['FcParameters'].append(k.to_map() if k else None)
        result['MnsParameters'] = []
        if self.mns_parameters is not None:
            for k in self.mns_parameters:
                result['MnsParameters'].append(k.to_map() if k else None)
        result['OpenApiParameters'] = []
        if self.open_api_parameters is not None:
            for k in self.open_api_parameters:
                result['OpenApiParameters'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        result['SlsParameters'] = []
        if self.sls_parameters is not None:
            for k in self.sls_parameters:
                result['SlsParameters'].append(k.to_map() if k else None)
        result['WebhookParameters'] = []
        if self.webhook_parameters is not None:
            for k in self.webhook_parameters:
                result['WebhookParameters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_parameters = []
        if m.get('ContactParameters') is not None:
            for k in m.get('ContactParameters'):
                temp_model = PutEventRuleTargetsRequestContactParameters()
                self.contact_parameters.append(temp_model.from_map(k))
        self.fc_parameters = []
        if m.get('FcParameters') is not None:
            for k in m.get('FcParameters'):
                temp_model = PutEventRuleTargetsRequestFcParameters()
                self.fc_parameters.append(temp_model.from_map(k))
        self.mns_parameters = []
        if m.get('MnsParameters') is not None:
            for k in m.get('MnsParameters'):
                temp_model = PutEventRuleTargetsRequestMnsParameters()
                self.mns_parameters.append(temp_model.from_map(k))
        self.open_api_parameters = []
        if m.get('OpenApiParameters') is not None:
            for k in m.get('OpenApiParameters'):
                temp_model = PutEventRuleTargetsRequestOpenApiParameters()
                self.open_api_parameters.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        self.sls_parameters = []
        if m.get('SlsParameters') is not None:
            for k in m.get('SlsParameters'):
                temp_model = PutEventRuleTargetsRequestSlsParameters()
                self.sls_parameters.append(temp_model.from_map(k))
        self.webhook_parameters = []
        if m.get('WebhookParameters') is not None:
            for k in m.get('WebhookParameters'):
                temp_model = PutEventRuleTargetsRequestWebhookParameters()
                self.webhook_parameters.append(temp_model.from_map(k))
        return self


class PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter(TeaModel):
    def __init__(self, contact_group_name=None, id=None, level=None):
        # The name of the alert contact group.
        self.contact_group_name = contact_group_name  # type: str
        # The ID of the recipient.
        self.id = id  # type: int
        # The alert level and the corresponding notification methods. Valid values:
        # 
        # 4: Alert notifications are sent by using DingTalk chatbots and emails.
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.contact_group_name is not None:
            result['ContactGroupName'] = self.contact_group_name
        if self.id is not None:
            result['Id'] = self.id
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ContactGroupName') is not None:
            self.contact_group_name = m.get('ContactGroupName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class PutEventRuleTargetsResponseBodyFailedContactParameters(TeaModel):
    def __init__(self, contact_parameter=None):
        self.contact_parameter = contact_parameter  # type: list[PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter]

    def validate(self):
        if self.contact_parameter:
            for k in self.contact_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedContactParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ContactParameter'] = []
        if self.contact_parameter is not None:
            for k in self.contact_parameter:
                result['ContactParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.contact_parameter = []
        if m.get('ContactParameter') is not None:
            for k in m.get('ContactParameter'):
                temp_model = PutEventRuleTargetsResponseBodyFailedContactParametersContactParameter()
                self.contact_parameter.append(temp_model.from_map(k))
        return self


class PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter(TeaModel):
    def __init__(self, function_name=None, id=None, region=None, service_name=None):
        # The name of the function.
        self.function_name = function_name  # type: str
        # The ID of the recipient.
        self.id = id  # type: int
        # The region ID.
        self.region = region  # type: str
        # The name of the Function Compute service.
        self.service_name = service_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function_name is not None:
            result['FunctionName'] = self.function_name
        if self.id is not None:
            result['Id'] = self.id
        if self.region is not None:
            result['Region'] = self.region
        if self.service_name is not None:
            result['ServiceName'] = self.service_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FunctionName') is not None:
            self.function_name = m.get('FunctionName')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('ServiceName') is not None:
            self.service_name = m.get('ServiceName')
        return self


class PutEventRuleTargetsResponseBodyFailedFcParameters(TeaModel):
    def __init__(self, fc_parameter=None):
        self.fc_parameter = fc_parameter  # type: list[PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter]

    def validate(self):
        if self.fc_parameter:
            for k in self.fc_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedFcParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FcParameter'] = []
        if self.fc_parameter is not None:
            for k in self.fc_parameter:
                result['FcParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fc_parameter = []
        if m.get('FcParameter') is not None:
            for k in m.get('FcParameter'):
                temp_model = PutEventRuleTargetsResponseBodyFailedFcParametersFcParameter()
                self.fc_parameter.append(temp_model.from_map(k))
        return self


class PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter(TeaModel):
    def __init__(self, id=None, queue=None, region=None):
        # The ID of the recipient.
        self.id = id  # type: int
        # The name of the MNS queue.
        self.queue = queue  # type: str
        # The region ID.
        self.region = region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.queue is not None:
            result['Queue'] = self.queue
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Queue') is not None:
            self.queue = m.get('Queue')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class PutEventRuleTargetsResponseBodyFailedMnsParameters(TeaModel):
    def __init__(self, mns_parameter=None):
        self.mns_parameter = mns_parameter  # type: list[PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter]

    def validate(self):
        if self.mns_parameter:
            for k in self.mns_parameter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBodyFailedMnsParameters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MnsParameter'] = []
        if self.mns_parameter is not None:
            for k in self.mns_parameter:
                result['MnsParameter'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.mns_parameter = []
        if m.get('MnsParameter') is not None:
            for k in m.get('MnsParameter'):
                temp_model = PutEventRuleTargetsResponseBodyFailedMnsParametersMnsParameter()
                self.mns_parameter.append(temp_model.from_map(k))
        return self


class PutEventRuleTargetsResponseBody(TeaModel):
    def __init__(self, code=None, failed_contact_parameters=None, failed_fc_parameters=None,
                 failed_mns_parameters=None, failed_parameter_count=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # This parameter is returned if the specified alert contact groups in the request failed to be created or modified.
        self.failed_contact_parameters = failed_contact_parameters  # type: PutEventRuleTargetsResponseBodyFailedContactParameters
        # This parameter is returned if the specified functions in the request failed to be created or modified in Function Compute.
        self.failed_fc_parameters = failed_fc_parameters  # type: PutEventRuleTargetsResponseBodyFailedFcParameters
        # This parameter is returned if the specified queues in the request failed to be created or modified in MNS.
        self.failed_mns_parameters = failed_mns_parameters  # type: PutEventRuleTargetsResponseBodyFailedMnsParameters
        # The number of resources that failed to be created or modified.
        self.failed_parameter_count = failed_parameter_count  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success  # type: bool

    def validate(self):
        if self.failed_contact_parameters:
            self.failed_contact_parameters.validate()
        if self.failed_fc_parameters:
            self.failed_fc_parameters.validate()
        if self.failed_mns_parameters:
            self.failed_mns_parameters.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.failed_contact_parameters is not None:
            result['FailedContactParameters'] = self.failed_contact_parameters.to_map()
        if self.failed_fc_parameters is not None:
            result['FailedFcParameters'] = self.failed_fc_parameters.to_map()
        if self.failed_mns_parameters is not None:
            result['FailedMnsParameters'] = self.failed_mns_parameters.to_map()
        if self.failed_parameter_count is not None:
            result['FailedParameterCount'] = self.failed_parameter_count
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailedContactParameters') is not None:
            temp_model = PutEventRuleTargetsResponseBodyFailedContactParameters()
            self.failed_contact_parameters = temp_model.from_map(m['FailedContactParameters'])
        if m.get('FailedFcParameters') is not None:
            temp_model = PutEventRuleTargetsResponseBodyFailedFcParameters()
            self.failed_fc_parameters = temp_model.from_map(m['FailedFcParameters'])
        if m.get('FailedMnsParameters') is not None:
            temp_model = PutEventRuleTargetsResponseBodyFailedMnsParameters()
            self.failed_mns_parameters = temp_model.from_map(m['FailedMnsParameters'])
        if m.get('FailedParameterCount') is not None:
            self.failed_parameter_count = m.get('FailedParameterCount')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutEventRuleTargetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutEventRuleTargetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutEventRuleTargetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutEventRuleTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutExporterOutputRequest(TeaModel):
    def __init__(self, config_json=None, desc=None, dest_name=None, dest_type=None, region_id=None):
        # The configuration set for exporting monitoring data. It is a JSON object string. The string must include the following fields:
        # 
        # *   endpoint: the endpoint of Log Service.
        # *   project: the Log Service project to which monitoring data is exported.
        # *   logstore: the Log Service Logstore to which the monitoring data is exported.
        # *   ak: the AccessKey ID.
        # *   as: the AccessKey secret.
        self.config_json = config_json  # type: str
        # The description of the configuration set.
        self.desc = desc  # type: str
        # The name of the configuration set.
        self.dest_name = dest_name  # type: str
        # The service to which the monitoring data is exported.
        self.dest_type = dest_type  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutExporterOutputRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.config_json is not None:
            result['ConfigJson'] = self.config_json
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.dest_name is not None:
            result['DestName'] = self.dest_name
        if self.dest_type is not None:
            result['DestType'] = self.dest_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConfigJson') is not None:
            self.config_json = m.get('ConfigJson')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('DestName') is not None:
            self.dest_name = m.get('DestName')
        if m.get('DestType') is not None:
            self.dest_type = m.get('DestType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutExporterOutputResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. true: The request was successful. false: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutExporterOutputResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutExporterOutputResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutExporterOutputResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutExporterOutputResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutExporterOutputResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutExporterRuleRequest(TeaModel):
    def __init__(self, describe=None, dst_names=None, metric_name=None, namespace=None, region_id=None,
                 rule_name=None, target_windows=None):
        # The description of the data export rule.
        self.describe = describe  # type: str
        # The destination to which the data is exported. Valid values of N: 1 to 20.
        self.dst_names = dst_names  # type: list[str]
        # The name of the metric.
        # 
        # > 
        # 
        # For more information, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # > For more information, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str
        # The name of the rule.
        # 
        # > If the specified rule exists, the existing rule is modified. Otherwise, a rule is created.
        self.rule_name = rule_name  # type: str
        # The time window of the exported data. Unit: seconds.
        # 
        # > 
        # 
        # *   Separate multiple time windows with commas (,).
        # 
        # *   Data in a time window of less than 60 seconds cannot be exported.
        self.target_windows = target_windows  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutExporterRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.describe is not None:
            result['Describe'] = self.describe
        if self.dst_names is not None:
            result['DstNames'] = self.dst_names
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.target_windows is not None:
            result['TargetWindows'] = self.target_windows
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Describe') is not None:
            self.describe = m.get('Describe')
        if m.get('DstNames') is not None:
            self.dst_names = m.get('DstNames')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('TargetWindows') is not None:
            self.target_windows = m.get('TargetWindows')
        return self


class PutExporterRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The returned message. If the request was successful, "successful" is returned. If the request failed, an error message is returned.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutExporterRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutExporterRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutExporterRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutExporterRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutExporterRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutGroupMetricRuleRequestEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold for Critical-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Critical-level alerts. Separate multiple statistical methods with commas (,).
        # 
        # The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Critical-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Critical-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutGroupMetricRuleRequestEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutGroupMetricRuleRequestEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold for Info-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Info-level alerts. Separate multiple statistical methods with commas (,).
        # 
        # The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Info-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before an Info-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutGroupMetricRuleRequestEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutGroupMetricRuleRequestEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold for Warn-level alerts. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Warn-level alerts. Separate multiple statistical methods with commas (,).
        # 
        # The value of this parameter is determined by the `Statistics` column corresponding to the `MetricName` parameter of the specified cloud service. The value of this parameter can be Maximum, Minimum, or Average. For more information about how to obtain the value of this parameter, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The threshold for Warn-level alerts.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the alert condition before a Warn-level alert is triggered.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutGroupMetricRuleRequestEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutGroupMetricRuleRequestEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: PutGroupMetricRuleRequestEscalationsCritical
        self.info = info  # type: PutGroupMetricRuleRequestEscalationsInfo
        self.warn = warn  # type: PutGroupMetricRuleRequestEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(PutGroupMetricRuleRequestEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = PutGroupMetricRuleRequestEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = PutGroupMetricRuleRequestEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = PutGroupMetricRuleRequestEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class PutGroupMetricRuleRequestLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the alert rule.
        self.key = key  # type: str
        # The tag value of the alert rule.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutGroupMetricRuleRequestLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutGroupMetricRuleRequest(TeaModel):
    def __init__(self, escalations=None, category=None, contact_groups=None, dimensions=None,
                 effective_interval=None, email_subject=None, extra_dimension_json=None, group_id=None, interval=None, labels=None,
                 metric_name=None, namespace=None, no_data_policy=None, no_effective_interval=None, period=None, rule_id=None,
                 rule_name=None, silence_time=None, webhook=None):
        self.escalations = escalations  # type: PutGroupMetricRuleRequestEscalations
        # The abbreviation of the cloud service name.
        # 
        # For more information about how to obtain the abbreviation of a cloud service name, see `metricCategory` in the response parameter `Labels` of the [DescribeProjectMeta](~~114916~~) operation.
        self.category = category  # type: str
        # The alert contact group.
        self.contact_groups = contact_groups  # type: str
        # The first-level dimension of the alert rule in the application group.
        # 
        # Set the value to a set of key-value pairs, for example, `userId:120886317861****` or `instanceId:i-m5e1qg6uo38rztr4****`.
        self.dimensions = dimensions  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        self.email_subject = email_subject  # type: str
        # The second-level or third-level dimension of the alert rule in the application group.
        # 
        # Set the value to a set of key-value pairs, for example, `port:80` or `/dev/xvda:d-m5e6yphgzn3aprwu****`.
        # 
        # If the first-level dimension of the alert rule is `instanceId:i-m5e1qg6uo38rztr4****`, its second-level dimension is the `/dev/xvda:d-m5e6yphgzn3aprwu****` disk in the instance.
        self.extra_dimension_json = extra_dimension_json  # type: str
        # The application group ID.
        # 
        # For more information about how to obtain the ID of an application group, see [DescribeMonitorGroups](~~115032~~).
        self.group_id = group_id  # type: str
        # The interval at which CloudMonitor checks whether the alert rule is triggered. Unit: seconds.
        # 
        # >  We recommend that you set the interval to the data aggregation period. If the interval is shorter than the data aggregation period, alerts cannot be triggered due to insufficient data.
        self.interval = interval  # type: str
        # The tags of the alert rule.
        # 
        # The specified tag is contained in alert notifications.
        self.labels = labels  # type: list[PutGroupMetricRuleRequestLabels]
        # The metric name.
        # 
        # For more information about how to obtain the name of a metric, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # For more information about how to obtain the namespace of a cloud service, see [DescribeMetricMetaList](~~98846~~) or [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The method that is used to handle alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The status is considered normal.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The aggregation period of the metric data.
        # 
        # Set the `Period` parameter to an integral multiple of 60. Unit: seconds. Default value: 300.
        self.period = period  # type: str
        # The ID of the alert rule.
        # 
        # *   When you create an alert rule for the application group, enter the ID of the alert rule.
        # *   When you modify a specified alert rule in the application group, you must obtain the ID of the alert rule. For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        # 
        # *   When you create an alert rule for the application group, enter the name of the alert rule.
        # *   When you modify a specified alert rule in the application group, you must obtain the name of the alert rule. For more information about how to obtain the name of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met.
        # 
        # Unit: seconds. Default value: 86400.
        self.silence_time = silence_time  # type: int
        # The callback URL.
        # 
        # The callback URL must be accessible over the Internet. CloudMonitor sends a POST request to push an alert notification to the callback URL that you specify. Only HTTP requests are supported.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutGroupMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.category is not None:
            result['Category'] = self.category
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.dimensions is not None:
            result['Dimensions'] = self.dimensions
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.extra_dimension_json is not None:
            result['ExtraDimensionJson'] = self.extra_dimension_json
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.interval is not None:
            result['Interval'] = self.interval
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = PutGroupMetricRuleRequestEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('Dimensions') is not None:
            self.dimensions = m.get('Dimensions')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('ExtraDimensionJson') is not None:
            self.extra_dimension_json = m.get('ExtraDimensionJson')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = PutGroupMetricRuleRequestLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutGroupMetricRuleResponseBodyResult(TeaModel):
    def __init__(self, rule_id=None):
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutGroupMetricRuleResponseBodyResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class PutGroupMetricRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, result=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # The result of the request.
        self.result = result  # type: PutGroupMetricRuleResponseBodyResult
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super(PutGroupMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Result') is not None:
            temp_model = PutGroupMetricRuleResponseBodyResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutGroupMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutGroupMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutGroupMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutGroupMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutHybridMonitorMetricDataRequestMetricListLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the metric.
        # 
        # Valid values of N: 1 to 100.
        # 
        # The key can contain letters, digits, and underscores (*). The key must start with a letter or an underscore (*).
        # 
        # >  You must specify both the Key and Value parameters.
        self.key = key  # type: str
        # The tag value of the metric.
        # 
        # Valid values of N: 1 to 100.
        # 
        # >  You must specify both the Key and Value parameters.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataRequestMetricListLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutHybridMonitorMetricDataRequestMetricList(TeaModel):
    def __init__(self, labels=None, name=None, ts=None, value=None):
        # The tags of the metric.
        # 
        # Valid values of N: 1 to 100.
        self.labels = labels  # type: list[PutHybridMonitorMetricDataRequestMetricListLabels]
        # The metric name.
        # 
        # Valid values of N: 1 to 100.
        # 
        # The name can contain letters, digits, and underscores (\_). The name must start with a letter.
        self.name = name  # type: str
        # The timestamp when the monitoring data is imported.
        # 
        # Valid values of N: 1 to 100.
        # 
        # Unit: milliseconds. By default, the current timestamp is used.
        self.ts = ts  # type: long
        # The value of the metric.
        # 
        # Valid values of N: 1 to 100.
        # 
        # The value must be an integer or a floating-point number.
        self.value = value  # type: str

    def validate(self):
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataRequestMetricList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.name is not None:
            result['Name'] = self.name
        if self.ts is not None:
            result['TS'] = self.ts
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = PutHybridMonitorMetricDataRequestMetricListLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('TS') is not None:
            self.ts = m.get('TS')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutHybridMonitorMetricDataRequest(TeaModel):
    def __init__(self, metric_list=None, namespace=None, region_id=None):
        # The monitoring data.
        # 
        # Valid values of N: 1 to 100.
        self.metric_list = metric_list  # type: list[PutHybridMonitorMetricDataRequestMetricList]
        # The name of the namespace.
        # 
        # For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.namespace = namespace  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        if self.metric_list:
            for k in self.metric_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['MetricList'] = []
        if self.metric_list is not None:
            for k in self.metric_list:
                result['MetricList'].append(k.to_map() if k else None)
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.metric_list = []
        if m.get('MetricList') is not None:
            for k in m.get('MetricList'):
                temp_model = PutHybridMonitorMetricDataRequestMetricList()
                self.metric_list.append(temp_model.from_map(k))
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutHybridMonitorMetricDataResponseBodyErrorDetail(TeaModel):
    def __init__(self, error_message=None, index=None):
        # The error message of the invalid parameter.
        self.error_message = error_message  # type: str
        # The position of the error message in the array.
        self.index = index  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataResponseBodyErrorDetail, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_message is not None:
            result['ErrorMessage'] = self.error_message
        if self.index is not None:
            result['Index'] = self.index
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorMessage') is not None:
            self.error_message = m.get('ErrorMessage')
        if m.get('Index') is not None:
            self.index = m.get('Index')
        return self


class PutHybridMonitorMetricDataResponseBody(TeaModel):
    def __init__(self, code=None, error_detail=None, request_id=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The details of invalid parameters.
        # 
        # If a request parameter is invalid, the details of the invalid parameter are returned.
        self.error_detail = error_detail  # type: list[PutHybridMonitorMetricDataResponseBodyErrorDetail]
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.error_detail:
            for k in self.error_detail:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['ErrorDetail'] = []
        if self.error_detail is not None:
            for k in self.error_detail:
                result['ErrorDetail'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.error_detail = []
        if m.get('ErrorDetail') is not None:
            for k in m.get('ErrorDetail'):
                temp_model = PutHybridMonitorMetricDataResponseBodyErrorDetail()
                self.error_detail.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class PutHybridMonitorMetricDataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutHybridMonitorMetricDataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutHybridMonitorMetricDataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutHybridMonitorMetricDataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutLogMonitorRequestAggregates(TeaModel):
    def __init__(self, alias=None, field_name=None, function=None):
        # The alias of the aggregate function. Valid values of N: 1 to 10.
        self.alias = alias  # type: str
        # The name of the field to be aggregated. Valid values of N: 1 to 10.
        self.field_name = field_name  # type: str
        # The function that is used to aggregate the monitoring data of logs within an aggregation period. Valid values of N: 1 to 10. Valid values:
        # 
        # *   count: counts the number.
        # *   sum: calculates the total value.
        # *   avg: calculates the average value.
        # *   max: selects the maximum value.
        # *   min: selects the minimum value.
        # *   countps: calculates the counted number of the specified field divided by the total number of seconds of the aggregation period.
        # *   sumps: calculates the total value of the specified field divided by the total number of seconds of the aggregation period.
        # *   distinct: counts the number of logs where the specified field appears within the aggregation period.
        self.function = function  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutLogMonitorRequestAggregates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        if self.function is not None:
            result['Function'] = self.function
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        if m.get('Function') is not None:
            self.function = m.get('Function')
        return self


class PutLogMonitorRequestGroupbys(TeaModel):
    def __init__(self, alias=None, field_name=None):
        # The alias of the dimension based on which the data is grouped. Valid values of N: 1 to 10.
        self.alias = alias  # type: str
        # The name of the field that is specified as the dimension. Valid values of N: 1 to 10.
        self.field_name = field_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutLogMonitorRequestGroupbys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.field_name is not None:
            result['FieldName'] = self.field_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('FieldName') is not None:
            self.field_name = m.get('FieldName')
        return self


class PutLogMonitorRequestValueFilter(TeaModel):
    def __init__(self, key=None, operator=None, value=None):
        # The name of the log field that is used for matching in the filter condition. Valid values of N: 1 to 10.
        self.key = key  # type: str
        # The method that is used to match the field value. Valid values of N: 1 to 10. Valid values:
        # 
        # *   `contain`: contains
        # *   `notContain`: does not contain
        # *   `>`: be greater than
        # *   `<`: be less than
        # *   `>=`: be greater than or equal to
        # *   `<=`: be less than or equal to
        self.operator = operator  # type: str
        # The field value to be matched in the filter condition. Valid values of N: 1 to 10.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutLogMonitorRequestValueFilter, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.operator is not None:
            result['Operator'] = self.operator
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Operator') is not None:
            self.operator = m.get('Operator')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutLogMonitorRequest(TeaModel):
    def __init__(self, aggregates=None, group_id=None, groupbys=None, log_id=None, metric_express=None,
                 metric_name=None, region_id=None, sls_logstore=None, sls_project=None, sls_region_id=None,
                 tumblingwindows=None, unit=None, value_filter=None, value_filter_relation=None):
        self.aggregates = aggregates  # type: list[PutLogMonitorRequestAggregates]
        # The ID of the application group.
        self.group_id = group_id  # type: str
        self.groupbys = groupbys  # type: list[PutLogMonitorRequestGroupbys]
        # The ID of the log monitoring metric.
        self.log_id = log_id  # type: str
        # The extended field. The extended field allows you to perform basic operations on the aggregation results.
        # 
        # For example, if you have calculated TotalNumber and 5XXNumber by aggregating the data. TotalNumber indicates the total number of HTTP requests, and 5XXNumber indicates the number of HTTP requests whose status code is greater than 499. You can calculate the server error rate by adding the following formula to the extended field: 5XXNumber/TotalNumber\*100.
        # 
        # JSON format: {"extend":{"errorPercent":"5XXNumber/TotalNumber\*100"}}. Description:
        # 
        # *   extend: required.
        # *   errorPercent: the alias of the field generated in the calculation result. You can specify the alias as needed.
        # *   5XXNumber/TotalNumber\*100: the calculation expression.
        self.metric_express = metric_express  # type: str
        # The name of the metric. For more information about the metrics for cloud services, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        self.region_id = region_id  # type: str
        # The name of the Log Service Logstore.
        self.sls_logstore = sls_logstore  # type: str
        # The name of the Log Service project.
        self.sls_project = sls_project  # type: str
        # The region in which the Log Service project resides.
        self.sls_region_id = sls_region_id  # type: str
        # The size of the tumbling window for calculation. Unit: seconds. CloudMonitor performs aggregation for each tumbling window.
        self.tumblingwindows = tumblingwindows  # type: str
        # The unit.
        self.unit = unit  # type: str
        self.value_filter = value_filter  # type: list[PutLogMonitorRequestValueFilter]
        # The logical operator that is used between log filter conditions. Valid values:
        # 
        # *   and
        # *   or
        # 
        # >  The ValueFilterRelation and `ValueFilter.N.Key` parameters must be used in pair.
        self.value_filter_relation = value_filter_relation  # type: str

    def validate(self):
        if self.aggregates:
            for k in self.aggregates:
                if k:
                    k.validate()
        if self.groupbys:
            for k in self.groupbys:
                if k:
                    k.validate()
        if self.value_filter:
            for k in self.value_filter:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutLogMonitorRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Aggregates'] = []
        if self.aggregates is not None:
            for k in self.aggregates:
                result['Aggregates'].append(k.to_map() if k else None)
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['Groupbys'] = []
        if self.groupbys is not None:
            for k in self.groupbys:
                result['Groupbys'].append(k.to_map() if k else None)
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.metric_express is not None:
            result['MetricExpress'] = self.metric_express
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sls_logstore is not None:
            result['SlsLogstore'] = self.sls_logstore
        if self.sls_project is not None:
            result['SlsProject'] = self.sls_project
        if self.sls_region_id is not None:
            result['SlsRegionId'] = self.sls_region_id
        if self.tumblingwindows is not None:
            result['Tumblingwindows'] = self.tumblingwindows
        if self.unit is not None:
            result['Unit'] = self.unit
        result['ValueFilter'] = []
        if self.value_filter is not None:
            for k in self.value_filter:
                result['ValueFilter'].append(k.to_map() if k else None)
        if self.value_filter_relation is not None:
            result['ValueFilterRelation'] = self.value_filter_relation
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.aggregates = []
        if m.get('Aggregates') is not None:
            for k in m.get('Aggregates'):
                temp_model = PutLogMonitorRequestAggregates()
                self.aggregates.append(temp_model.from_map(k))
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.groupbys = []
        if m.get('Groupbys') is not None:
            for k in m.get('Groupbys'):
                temp_model = PutLogMonitorRequestGroupbys()
                self.groupbys.append(temp_model.from_map(k))
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('MetricExpress') is not None:
            self.metric_express = m.get('MetricExpress')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SlsLogstore') is not None:
            self.sls_logstore = m.get('SlsLogstore')
        if m.get('SlsProject') is not None:
            self.sls_project = m.get('SlsProject')
        if m.get('SlsRegionId') is not None:
            self.sls_region_id = m.get('SlsRegionId')
        if m.get('Tumblingwindows') is not None:
            self.tumblingwindows = m.get('Tumblingwindows')
        if m.get('Unit') is not None:
            self.unit = m.get('Unit')
        self.value_filter = []
        if m.get('ValueFilter') is not None:
            for k in m.get('ValueFilter'):
                temp_model = PutLogMonitorRequestValueFilter()
                self.value_filter.append(temp_model.from_map(k))
        if m.get('ValueFilterRelation') is not None:
            self.value_filter_relation = m.get('ValueFilterRelation')
        return self


class PutLogMonitorResponseBody(TeaModel):
    def __init__(self, code=None, log_id=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The ID of the log monitoring metric.
        self.log_id = log_id  # type: str
        # The returned message.
        # 
        # *   If the call is successful, the value `successful` is returned.
        # *   If the call fails, an error message is returned. Example: `alias of aggreate must be set value.`
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutLogMonitorResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.log_id is not None:
            result['LogId'] = self.log_id
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('LogId') is not None:
            self.log_id = m.get('LogId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutLogMonitorResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutLogMonitorResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutLogMonitorResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutLogMonitorResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutMetricRuleTargetsRequestTargets(TeaModel):
    def __init__(self, arn=None, id=None, json_params=None, level=None):
        # The ARN of the resource.
        # 
        # For information about how to obtain the ARN of a resource, see [DescribeMetricRuleTargets](~~121592~~).
        # 
        # Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # *   {userId}: the ID of the Alibaba Cloud account.
        # *   {regionId}: the region ID of the message queue or topic.
        # *   {Resource type}`: the type of the resource for which alerts are triggered. Valid values: - **queues** - **topics** {Resource name}: the name of the resource. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.`
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        # 
        # For information about how to obtain the ID of a resource for which alerts are triggered, see [DescribeMetricRuleTargets](~~121592~~).
        self.id = id  # type: str
        # The parameters of the alert callback. The parameters are in the JSON format.
        self.json_params = json_params  # type: str
        # The level of the alert. Valid values:
        # 
        # *   INFO: information
        # *   WARN: warning
        # *   CRITICAL: critical
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMetricRuleTargetsRequestTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.json_params is not None:
            result['JsonParams'] = self.json_params
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('JsonParams') is not None:
            self.json_params = m.get('JsonParams')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class PutMetricRuleTargetsRequest(TeaModel):
    def __init__(self, region_id=None, rule_id=None, targets=None):
        self.region_id = region_id  # type: str
        # The ID of the alert rule.
        # 
        # For information about how to obtain the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        self.rule_id = rule_id  # type: str
        self.targets = targets  # type: list[PutMetricRuleTargetsRequestTargets]

    def validate(self):
        if self.targets:
            for k in self.targets:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutMetricRuleTargetsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        result['Targets'] = []
        if self.targets is not None:
            for k in self.targets:
                result['Targets'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        self.targets = []
        if m.get('Targets') is not None:
            for k in m.get('Targets'):
                temp_model = PutMetricRuleTargetsRequestTargets()
                self.targets.append(temp_model.from_map(k))
        return self


class PutMetricRuleTargetsResponseBodyFailDataTargetsTarget(TeaModel):
    def __init__(self, arn=None, id=None, level=None):
        # The ARN of the resource.
        # 
        # Format: `acs:{Service name abbreviation}:{regionId}:{userId}:/{Resource type}/{Resource name}/message`. Example: `acs:mns:cn-hangzhou:120886317861****:/queues/test123/message`. Fields:
        # 
        # *   {Service name abbreviation}: the abbreviation of the service name. Valid value: mns.
        # *   {userId}: the ID of the Alibaba Cloud account.
        # *   {regionId}: the region ID of the message queue or topic.
        # *   {Resource type}`: the type of the resource for which alerts are triggered. Valid values: - **queues** - **topics** {Resource name}: the name of the resource. - If the resource type is set to **queues**, the resource name is the name of the message queue. - If the resource type is set to **topics**, the resource name is the name of the topic.`
        self.arn = arn  # type: str
        # The ID of the resource for which alerts are triggered.
        self.id = id  # type: str
        # The level of the alert. Valid values:
        # 
        # *   INFO: information
        # *   WARN: warning
        # *   CRITICAL: critical
        self.level = level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMetricRuleTargetsResponseBodyFailDataTargetsTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.id is not None:
            result['Id'] = self.id
        if self.level is not None:
            result['Level'] = self.level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        return self


class PutMetricRuleTargetsResponseBodyFailDataTargets(TeaModel):
    def __init__(self, target=None):
        self.target = target  # type: list[PutMetricRuleTargetsResponseBodyFailDataTargetsTarget]

    def validate(self):
        if self.target:
            for k in self.target:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutMetricRuleTargetsResponseBodyFailDataTargets, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Target'] = []
        if self.target is not None:
            for k in self.target:
                result['Target'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target = []
        if m.get('Target') is not None:
            for k in m.get('Target'):
                temp_model = PutMetricRuleTargetsResponseBodyFailDataTargetsTarget()
                self.target.append(temp_model.from_map(k))
        return self


class PutMetricRuleTargetsResponseBodyFailData(TeaModel):
    def __init__(self, targets=None):
        # The information about the resource for which alerts are triggered.
        self.targets = targets  # type: PutMetricRuleTargetsResponseBodyFailDataTargets

    def validate(self):
        if self.targets:
            self.targets.validate()

    def to_map(self):
        _map = super(PutMetricRuleTargetsResponseBodyFailData, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.targets is not None:
            result['Targets'] = self.targets.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Targets') is not None:
            temp_model = PutMetricRuleTargetsResponseBodyFailDataTargets()
            self.targets = temp_model.from_map(m['Targets'])
        return self


class PutMetricRuleTargetsResponseBody(TeaModel):
    def __init__(self, code=None, fail_data=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The list of resources that failed to be created or modified.
        self.fail_data = fail_data  # type: PutMetricRuleTargetsResponseBodyFailData
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.fail_data:
            self.fail_data.validate()

    def to_map(self):
        _map = super(PutMetricRuleTargetsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.fail_data is not None:
            result['FailData'] = self.fail_data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailData') is not None:
            temp_model = PutMetricRuleTargetsResponseBodyFailData()
            self.fail_data = temp_model.from_map(m['FailData'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutMetricRuleTargetsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutMetricRuleTargetsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutMetricRuleTargetsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutMetricRuleTargetsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutMonitorGroupDynamicRuleRequestGroupRulesFilters(TeaModel):
    def __init__(self, function=None, name=None, value=None):
        # The method that is used to filter instances. Valid values of N: 1 to 3. Valid values:
        # 
        # *   contains: contains
        # *   notContains: does not contain
        # *   startWith: starts with a prefix
        # *   endWith: ends with a suffix
        self.function = function  # type: str
        # The name of the field based on which instances are filtered. Valid values of N: 1 to 3.
        # 
        # Only hostnames are supported. Example: hostName.
        self.name = name  # type: str
        # The value to be matched with the specified field. Valid values of N: 1 to 3.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMonitorGroupDynamicRuleRequestGroupRulesFilters, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.function is not None:
            result['Function'] = self.function
        if self.name is not None:
            result['Name'] = self.name
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Function') is not None:
            self.function = m.get('Function')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutMonitorGroupDynamicRuleRequestGroupRules(TeaModel):
    def __init__(self, category=None, filter_relation=None, filters=None):
        # The cloud service to which the alert rule is applied. Valid values of N: 1 to 3. Valid values:
        # 
        # *   ecs: Elastic Compute Service (ECS)
        # *   rds: ApsaraDB RDS
        # *   slb: Server Load Balancer (SLB)
        self.category = category  # type: str
        # The logical operator used between conditional expressions in the alert rule. Valid values of N: 1 to 3. Valid values:
        # 
        # *   and: The instances that meet all the conditional expressions are automatically added to the application group.
        # *   or: The instances that meet one of the conditional expressions are automatically added to the application group.
        self.filter_relation = filter_relation  # type: str
        # None.
        self.filters = filters  # type: list[PutMonitorGroupDynamicRuleRequestGroupRulesFilters]

    def validate(self):
        if self.filters:
            for k in self.filters:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutMonitorGroupDynamicRuleRequestGroupRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.filter_relation is not None:
            result['FilterRelation'] = self.filter_relation
        result['Filters'] = []
        if self.filters is not None:
            for k in self.filters:
                result['Filters'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('FilterRelation') is not None:
            self.filter_relation = m.get('FilterRelation')
        self.filters = []
        if m.get('Filters') is not None:
            for k in m.get('Filters'):
                temp_model = PutMonitorGroupDynamicRuleRequestGroupRulesFilters()
                self.filters.append(temp_model.from_map(k))
        return self


class PutMonitorGroupDynamicRuleRequest(TeaModel):
    def __init__(self, group_id=None, group_rules=None, is_async=None, region_id=None):
        # The ID of the application group.
        self.group_id = group_id  # type: long
        # None.
        self.group_rules = group_rules  # type: list[PutMonitorGroupDynamicRuleRequestGroupRules]
        # The mode for creating the alert rule. Valid values:
        # 
        # *   true: creates asynchronously
        # *   false (default): creates synchronously
        self.is_async = is_async  # type: bool
        self.region_id = region_id  # type: str

    def validate(self):
        if self.group_rules:
            for k in self.group_rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutMonitorGroupDynamicRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        result['GroupRules'] = []
        if self.group_rules is not None:
            for k in self.group_rules:
                result['GroupRules'].append(k.to_map() if k else None)
        if self.is_async is not None:
            result['IsAsync'] = self.is_async
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        self.group_rules = []
        if m.get('GroupRules') is not None:
            for k in m.get('GroupRules'):
                temp_model = PutMonitorGroupDynamicRuleRequestGroupRules()
                self.group_rules.append(temp_model.from_map(k))
        if m.get('IsAsync') is not None:
            self.is_async = m.get('IsAsync')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutMonitorGroupDynamicRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMonitorGroupDynamicRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutMonitorGroupDynamicRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutMonitorGroupDynamicRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutMonitorGroupDynamicRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutMonitorGroupDynamicRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutMonitoringConfigRequest(TeaModel):
    def __init__(self, auto_install=None, enable_install_agent_new_ecs=None, region_id=None):
        # Specifies whether to automatically install the CloudMonitor agent on existing Elastic Compute Service (ECS) instances. Valid values:
        # 
        # *   true (default value)
        # *   false
        self.auto_install = auto_install  # type: bool
        # Specifies whether to automatically install the CloudMonitor agent on new ECS instances. Valid values:
        # 
        # *   true (default value)
        # *   false
        self.enable_install_agent_new_ecs = enable_install_agent_new_ecs  # type: bool
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMonitoringConfigRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_install is not None:
            result['AutoInstall'] = self.auto_install
        if self.enable_install_agent_new_ecs is not None:
            result['EnableInstallAgentNewECS'] = self.enable_install_agent_new_ecs
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoInstall') is not None:
            self.auto_install = m.get('AutoInstall')
        if m.get('EnableInstallAgentNewECS') is not None:
            self.enable_install_agent_new_ecs = m.get('EnableInstallAgentNewECS')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class PutMonitoringConfigResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: int
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutMonitoringConfigResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutMonitoringConfigResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutMonitoringConfigResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutMonitoringConfigResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutMonitoringConfigResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutResourceMetricRuleRequestEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Critical-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Critical-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleRequestEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Info-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Info-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before an Info-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleRequestEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Warn-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Warn-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before a Warn-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleRequestEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: PutResourceMetricRuleRequestEscalationsCritical
        self.info = info  # type: PutResourceMetricRuleRequestEscalationsInfo
        self.warn = warn  # type: PutResourceMetricRuleRequestEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = PutResourceMetricRuleRequestEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = PutResourceMetricRuleRequestEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = PutResourceMetricRuleRequestEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class PutResourceMetricRuleRequestCompositeExpressionExpressionList(TeaModel):
    def __init__(self, comparison_operator=None, metric_name=None, period=None, statistics=None, threshold=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        self.comparison_operator = comparison_operator  # type: str
        # The metric that is used to monitor the cloud service.
        self.metric_name = metric_name  # type: str
        # The aggregation period of the metric.
        # 
        # Unit: seconds.
        self.period = period  # type: long
        # The statistical method of the metric. Valid values:
        # 
        # *   $Maximum: the maximum value
        # *   $Minimum: the minimum value
        # *   $Average: the average value
        # *   $Availability: the availability rate (usually used for site monitoring)
        # 
        # >  `$` is the prefix of the metric. For information about the Alibaba Cloud services that are supported by CloudMonitor, see [Appendix 1: Metrics](~~163515~~).
        self.statistics = statistics  # type: str
        # The alert threshold.
        self.threshold = threshold  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestCompositeExpressionExpressionList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.period is not None:
            result['Period'] = self.period
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        return self


class PutResourceMetricRuleRequestCompositeExpression(TeaModel):
    def __init__(self, expression_list=None, expression_list_join=None, expression_raw=None, level=None, times=None):
        # The trigger conditions that are created in standard mode.
        self.expression_list = expression_list  # type: list[PutResourceMetricRuleRequestCompositeExpressionExpressionList]
        # The relationship between the trigger conditions for multiple metrics. Valid values:
        # 
        # *   `&&`: An alert is triggered only if all metrics meet the trigger conditions. An alert is triggered only if the results of all expressions specified in the ExpressionList parameter are `true`.
        # *   `||`: If one of the metrics meets the trigger conditions, an alert is triggered.
        self.expression_list_join = expression_list_join  # type: str
        # The trigger conditions that are created by using expressions. You can use expressions to create trigger conditions in the following scenarios:
        # 
        # *   Set an alert blacklist for specific resources. For example, if you specify ` $instanceId != \"i-io8kfvcpp7x5****\"  ``&&``  $Average > 50 `, no alert is generated even when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 50.
        # *   Set a special alert threshold for a specified instance in the rule. For example, if you specify `$Average > ($instanceId == \"i-io8kfvcpp7x5****\"? 80: 50)`, an alert is triggered when the `average metric value` of the `i-io8kfvcpp7x5****` instance exceeds 80 or the `average metric value` of other instances exceeds 50.
        # *   Limits the number of instances whose metric values exceed the threshold. For example, if you specify `count($Average > 20) > 3`, an alert is triggered only when the number of instances whose `average metric value` exceeds 20 exceeds three.
        self.expression_raw = expression_raw  # type: str
        # The level of the alert. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        self.level = level  # type: str
        # The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        self.times = times  # type: int

    def validate(self):
        if self.expression_list:
            for k in self.expression_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestCompositeExpression, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ExpressionList'] = []
        if self.expression_list is not None:
            for k in self.expression_list:
                result['ExpressionList'].append(k.to_map() if k else None)
        if self.expression_list_join is not None:
            result['ExpressionListJoin'] = self.expression_list_join
        if self.expression_raw is not None:
            result['ExpressionRaw'] = self.expression_raw
        if self.level is not None:
            result['Level'] = self.level
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.expression_list = []
        if m.get('ExpressionList') is not None:
            for k in m.get('ExpressionList'):
                temp_model = PutResourceMetricRuleRequestCompositeExpressionExpressionList()
                self.expression_list.append(temp_model.from_map(k))
        if m.get('ExpressionListJoin') is not None:
            self.expression_list_join = m.get('ExpressionListJoin')
        if m.get('ExpressionRaw') is not None:
            self.expression_raw = m.get('ExpressionRaw')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleRequestLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag.
        self.key = key  # type: str
        # The value of the tag.
        # 
        # >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutResourceMetricRuleRequestPrometheusAnnotations(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the annotation.
        self.key = key  # type: str
        # The value of the annotation.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestPrometheusAnnotations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutResourceMetricRuleRequestPrometheus(TeaModel):
    def __init__(self, annotations=None, level=None, prom_ql=None, times=None):
        # The annotations of the Prometheus alert rule. When a Prometheus alert is triggered, the system renders the annotated keys and values to help you understand the metrics and alert rule.
        # 
        # >  This parameter is equivalent to the annotations parameter of open source Prometheus.
        self.annotations = annotations  # type: list[PutResourceMetricRuleRequestPrometheusAnnotations]
        # The level of the alert. Valid values:
        # 
        # *   Critical
        # *   Warn
        # *   Info
        self.level = level  # type: str
        # The PromQL query statement.
        # 
        # >  The data obtained by using the PromQL query statement is the monitoring data. You must include the alert threshold in this statement.
        self.prom_ql = prom_ql  # type: str
        # The number of consecutive triggers. If the number of times that the metric values meet the trigger conditions reaches the value of this parameter, CloudMonitor sends alert notifications.
        self.times = times  # type: int

    def validate(self):
        if self.annotations:
            for k in self.annotations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleRequestPrometheus, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Annotations'] = []
        if self.annotations is not None:
            for k in self.annotations:
                result['Annotations'].append(k.to_map() if k else None)
        if self.level is not None:
            result['Level'] = self.level
        if self.prom_ql is not None:
            result['PromQL'] = self.prom_ql
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.annotations = []
        if m.get('Annotations') is not None:
            for k in m.get('Annotations'):
                temp_model = PutResourceMetricRuleRequestPrometheusAnnotations()
                self.annotations.append(temp_model.from_map(k))
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('PromQL') is not None:
            self.prom_ql = m.get('PromQL')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleRequest(TeaModel):
    def __init__(self, escalations=None, composite_expression=None, contact_groups=None, effective_interval=None,
                 email_subject=None, interval=None, labels=None, metric_name=None, namespace=None, no_data_policy=None,
                 no_effective_interval=None, period=None, prometheus=None, resources=None, rule_id=None, rule_name=None, silence_time=None,
                 webhook=None):
        self.escalations = escalations  # type: PutResourceMetricRuleRequestEscalations
        # The trigger conditions for multiple metrics.
        # 
        # >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
        self.composite_expression = composite_expression  # type: PutResourceMetricRuleRequestCompositeExpression
        # The alert contact group. The alert notifications are sent to the contacts that belong to the alert contact group.
        # 
        # >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~).
        self.contact_groups = contact_groups  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        self.email_subject = email_subject  # type: str
        # The interval at which the alert is triggered. Unit: seconds.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.interval = interval  # type: str
        # The tags.
        self.labels = labels  # type: list[PutResourceMetricRuleRequestLabels]
        # The name of the metric. For information about how to query the name of a metric, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to the name of the namespace. For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service. For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to `acs_prometheus`.
        self.namespace = namespace  # type: str
        # The processing method of alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The status is considered normal.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        # The Prometheus alert rule.
        # 
        # >  This parameter is required only when you create a Prometheus alert rule for Hybrid Cloud Monitoring.
        self.prometheus = prometheus  # type: PutResourceMetricRuleRequestPrometheus
        # The information about the resource. Examples: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` and `[{"userId":"100931896542****"}]`.
        # 
        # For information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](~~163515~~).
        self.resources = resources  # type: str
        # The ID of the alert rule.
        # 
        # You can specify a new ID or the ID of an existing alert rule. For information about how to query the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new ID, a threshold-triggered alert rule is created.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        # 
        # You can specify a new name or the name of an existing alert rule. For information about how to query the name of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new name, a threshold-triggered alert rule is created.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
        # 
        # >  If an alert is not cleared within the mute period, a new alert notification is sent when the mute period ends.
        self.silence_time = silence_time  # type: int
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.composite_expression:
            self.composite_expression.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()
        if self.prometheus:
            self.prometheus.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.composite_expression is not None:
            result['CompositeExpression'] = self.composite_expression.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.interval is not None:
            result['Interval'] = self.interval
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.prometheus is not None:
            result['Prometheus'] = self.prometheus.to_map()
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = PutResourceMetricRuleRequestEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('CompositeExpression') is not None:
            temp_model = PutResourceMetricRuleRequestCompositeExpression()
            self.composite_expression = temp_model.from_map(m['CompositeExpression'])
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = PutResourceMetricRuleRequestLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Prometheus') is not None:
            temp_model = PutResourceMetricRuleRequestPrometheus()
            self.prometheus = temp_model.from_map(m['Prometheus'])
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutResourceMetricRuleShrinkRequestEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Critical-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Critical-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before a Critical-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequestEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleShrinkRequestEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Info-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Info-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before an Info-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequestEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleShrinkRequestEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, statistics=None, threshold=None, times=None):
        # The operator that is used to compare the metric value with the threshold. Valid values:
        # 
        # *   GreaterThanOrEqualToThreshold: greater than or equal to the threshold
        # *   GreaterThanThreshold: greater than the threshold
        # *   LessThanOrEqualToThreshold: less than or equal to the threshold
        # *   LessThanThreshold: less than the threshold
        # *   NotEqualToThreshold: not equal to the threshold
        # *   GreaterThanYesterday: greater than the metric value at the same time yesterday
        # *   LessThanYesterday: less than the metric value at the same time yesterday
        # *   GreaterThanLastWeek: greater than the metric value at the same time last week
        # *   LessThanLastWeek: less than the metric value at the same time last week
        # *   GreaterThanLastPeriod: greater than the metric value in the last monitoring cycle
        # *   LessThanLastPeriod: less than the metric value in the last monitoring cycle
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.comparison_operator = comparison_operator  # type: str
        # The statistical methods for Warn-level alerts. Valid values:
        # 
        # *   Maximum: the maximum value
        # *   Minimum: the minimum value
        # *   Average: the average value
        # *   Availability: the availability rate
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.statistics = statistics  # type: str
        # The threshold for Warn-level alerts.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.threshold = threshold  # type: str
        # The consecutive number of times for which the metric value meets the trigger condition before a Warn-level alert is triggered.
        # 
        # >  You must select at least one of the Critical, Warn, and Info alert levels and specify the Statistics, ComparisonOperator, Threshold, and Times parameters for the selected alert level.
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequestEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRuleShrinkRequestEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: PutResourceMetricRuleShrinkRequestEscalationsCritical
        self.info = info  # type: PutResourceMetricRuleShrinkRequestEscalationsInfo
        self.warn = warn  # type: PutResourceMetricRuleShrinkRequestEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequestEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = PutResourceMetricRuleShrinkRequestEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = PutResourceMetricRuleShrinkRequestEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = PutResourceMetricRuleShrinkRequestEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class PutResourceMetricRuleShrinkRequestLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag.
        self.key = key  # type: str
        # The value of the tag.
        # 
        # >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequestLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutResourceMetricRuleShrinkRequest(TeaModel):
    def __init__(self, escalations=None, composite_expression_shrink=None, contact_groups=None,
                 effective_interval=None, email_subject=None, interval=None, labels=None, metric_name=None, namespace=None,
                 no_data_policy=None, no_effective_interval=None, period=None, prometheus_shrink=None, resources=None,
                 rule_id=None, rule_name=None, silence_time=None, webhook=None):
        self.escalations = escalations  # type: PutResourceMetricRuleShrinkRequestEscalations
        # The trigger conditions for multiple metrics.
        # 
        # >  The trigger conditions for a single metric and multiple metrics are mutually exclusive. You cannot specify trigger conditions for a single metric and multiple metrics at the same time.
        self.composite_expression_shrink = composite_expression_shrink  # type: str
        # The alert contact group. The alert notifications are sent to the contacts that belong to the alert contact group.
        # 
        # >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~).
        self.contact_groups = contact_groups  # type: str
        # The time period during which the alert rule is effective.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        self.email_subject = email_subject  # type: str
        # The interval at which the alert is triggered. Unit: seconds.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.interval = interval  # type: str
        # The tags.
        self.labels = labels  # type: list[PutResourceMetricRuleShrinkRequestLabels]
        # The name of the metric. For information about how to query the name of a metric, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to the name of the namespace. For information about how to obtain the name of a namespace, see [DescribeHybridMonitorNamespaceList](~~428880~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service. For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](~~163515~~).
        # 
        # >  If you create a Prometheus alert rule for Hybrid Cloud Monitoring, you must set this parameter to `acs_prometheus`.
        self.namespace = namespace  # type: str
        # The processing method of alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The status is considered normal.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective.
        self.no_effective_interval = no_effective_interval  # type: str
        # The statistical period of the metric. Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        # The Prometheus alert rule.
        # 
        # >  This parameter is required only when you create a Prometheus alert rule for Hybrid Cloud Monitoring.
        self.prometheus_shrink = prometheus_shrink  # type: str
        # The information about the resource. Examples: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` and `[{"userId":"100931896542****"}]`.
        # 
        # For information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](~~163515~~).
        self.resources = resources  # type: str
        # The ID of the alert rule.
        # 
        # You can specify a new ID or the ID of an existing alert rule. For information about how to query the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new ID, a threshold-triggered alert rule is created.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        # 
        # You can specify a new name or the name of an existing alert rule. For information about how to query the name of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new name, a threshold-triggered alert rule is created.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met. Unit: seconds. Default value: 86400.
        # 
        # >  If an alert is not cleared within the mute period, a new alert notification is sent when the mute period ends.
        self.silence_time = silence_time  # type: int
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.composite_expression_shrink is not None:
            result['CompositeExpression'] = self.composite_expression_shrink
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.interval is not None:
            result['Interval'] = self.interval
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.prometheus_shrink is not None:
            result['Prometheus'] = self.prometheus_shrink
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = PutResourceMetricRuleShrinkRequestEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('CompositeExpression') is not None:
            self.composite_expression_shrink = m.get('CompositeExpression')
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = PutResourceMetricRuleShrinkRequestLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Prometheus') is not None:
            self.prometheus_shrink = m.get('Prometheus')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutResourceMetricRuleResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call is successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call is successful. Valid values:
        # 
        # *   true: The call is successful.
        # *   false: The call fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRuleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutResourceMetricRuleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutResourceMetricRuleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutResourceMetricRuleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutResourceMetricRuleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class PutResourceMetricRulesRequestRulesEscalationsCritical(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRulesEscalationsCritical, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRulesRequestRulesEscalationsInfo(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRulesEscalationsInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRulesRequestRulesEscalationsWarn(TeaModel):
    def __init__(self, comparison_operator=None, n=None, pre_condition=None, statistics=None, threshold=None,
                 times=None):
        self.comparison_operator = comparison_operator  # type: str
        self.n = n  # type: int
        self.pre_condition = pre_condition  # type: str
        self.statistics = statistics  # type: str
        self.threshold = threshold  # type: str
        self.times = times  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRulesEscalationsWarn, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.comparison_operator is not None:
            result['ComparisonOperator'] = self.comparison_operator
        if self.n is not None:
            result['N'] = self.n
        if self.pre_condition is not None:
            result['PreCondition'] = self.pre_condition
        if self.statistics is not None:
            result['Statistics'] = self.statistics
        if self.threshold is not None:
            result['Threshold'] = self.threshold
        if self.times is not None:
            result['Times'] = self.times
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ComparisonOperator') is not None:
            self.comparison_operator = m.get('ComparisonOperator')
        if m.get('N') is not None:
            self.n = m.get('N')
        if m.get('PreCondition') is not None:
            self.pre_condition = m.get('PreCondition')
        if m.get('Statistics') is not None:
            self.statistics = m.get('Statistics')
        if m.get('Threshold') is not None:
            self.threshold = m.get('Threshold')
        if m.get('Times') is not None:
            self.times = m.get('Times')
        return self


class PutResourceMetricRulesRequestRulesEscalations(TeaModel):
    def __init__(self, critical=None, info=None, warn=None):
        self.critical = critical  # type: PutResourceMetricRulesRequestRulesEscalationsCritical
        self.info = info  # type: PutResourceMetricRulesRequestRulesEscalationsInfo
        self.warn = warn  # type: PutResourceMetricRulesRequestRulesEscalationsWarn

    def validate(self):
        if self.critical:
            self.critical.validate()
        if self.info:
            self.info.validate()
        if self.warn:
            self.warn.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRulesEscalations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.critical is not None:
            result['Critical'] = self.critical.to_map()
        if self.info is not None:
            result['Info'] = self.info.to_map()
        if self.warn is not None:
            result['Warn'] = self.warn.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Critical') is not None:
            temp_model = PutResourceMetricRulesRequestRulesEscalationsCritical()
            self.critical = temp_model.from_map(m['Critical'])
        if m.get('Info') is not None:
            temp_model = PutResourceMetricRulesRequestRulesEscalationsInfo()
            self.info = temp_model.from_map(m['Info'])
        if m.get('Warn') is not None:
            temp_model = PutResourceMetricRulesRequestRulesEscalationsWarn()
            self.warn = temp_model.from_map(m['Warn'])
        return self


class PutResourceMetricRulesRequestRulesLabels(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag.
        self.key = key  # type: str
        # The value of the tag.
        # 
        # >  You can use a template parameter to specify a tag value. CloudMonitor replaces the value of the template parameter with an actual tag value.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRulesLabels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class PutResourceMetricRulesRequestRules(TeaModel):
    def __init__(self, escalations=None, contact_groups=None, effective_interval=None, email_subject=None,
                 interval=None, labels=None, metric_name=None, namespace=None, no_data_policy=None,
                 no_effective_interval=None, period=None, resources=None, rule_id=None, rule_name=None, silence_time=None, webhook=None):
        self.escalations = escalations  # type: PutResourceMetricRulesRequestRulesEscalations
        # The alert contact group. The alert notifications are sent to the alert contacts in the alert contact group.
        # 
        # Valid values of N: 1 to 500.
        # 
        # >  An alert contact group can contain one or more alert contacts. For information about how to create alert contacts and alert contact groups, see [PutContact](~~114923~~) and [PutContactGroup](~~114929~~).
        self.contact_groups = contact_groups  # type: str
        # The time period during which the alert rule is effective.
        # 
        # Valid values of N: 1 to 500.
        self.effective_interval = effective_interval  # type: str
        # The subject of the alert notification email.
        # 
        # Valid values of N: 1 to 500.
        self.email_subject = email_subject  # type: str
        # The interval at which the alert rule is executed.
        # 
        # Unit: seconds.
        # 
        # Valid values of N: 1 to 500.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.interval = interval  # type: str
        self.labels = labels  # type: list[PutResourceMetricRulesRequestRulesLabels]
        # The name of the metric.
        # 
        # Valid values of N: 1 to 500.
        # 
        # For information about how to query the name of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.metric_name = metric_name  # type: str
        # The namespace of the cloud service.
        # 
        # Valid values of N: 1 to 500.
        # 
        # For information about how to query the namespace of a cloud service, see [Appendix 1: Metrics](~~163515~~).
        self.namespace = namespace  # type: str
        # The method that is used to handle alerts when no monitoring data is found. Valid values:
        # 
        # *   KEEP_LAST_STATE (default value): No operation is performed.
        # *   INSUFFICIENT_DATA: An alert whose content is "Insufficient data" is triggered.
        # *   OK: The status is considered normal.
        # 
        # Valid values of N: 1 to 500.
        self.no_data_policy = no_data_policy  # type: str
        # The time period during which the alert rule is ineffective.
        # 
        # Valid values of N: 1 to 500.
        self.no_effective_interval = no_effective_interval  # type: str
        # The statistical period of the metric.
        # 
        # Unit: seconds. The default value is the interval at which the monitoring data of the metric is collected.
        # 
        # Valid values of N: 1 to 500.
        # 
        # >  For information about how to query the statistical period of a metric, see [Appendix 1: Metrics](~~163515~~).
        self.period = period  # type: str
        # The information about the resource. Examples: `[{"instanceId":"i-uf6j91r34rnwawoo****"}]` and `[{"userId":"100931896542****"}]`.
        # 
        # Valid values of N: 1 to 500.
        # 
        # For more information about the supported dimensions that are used to query resources, see [Appendix 1: Metrics](~~163515~~).
        self.resources = resources  # type: str
        # The ID of the alert rule.
        # 
        # Valid values of N: 1 to 500.
        # 
        # You can specify a new ID or the ID of an existing alert rule. For information about how to query the ID of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new ID, you create a threshold-triggered alert rule.
        self.rule_id = rule_id  # type: str
        # The name of the alert rule.
        # 
        # Valid values of N: 1 to 500.
        # 
        # You can specify a new name or the name of an existing alert rule. For information about how to query the name of an alert rule, see [DescribeMetricRuleList](~~114941~~).
        # 
        # >  If you specify a new name, you create a threshold-triggered alert rule.
        self.rule_name = rule_name  # type: str
        # The mute period during which new alerts are not sent even if the trigger conditions are met.
        # 
        # Unit: seconds. Default value: 86400.
        # 
        # Valid values of N: 1 to 500.
        # 
        # >  If an alert is not cleared after the mute period ends, CloudMonitor resends an alert notification.
        self.silence_time = silence_time  # type: int
        # The callback URL to which a POST request is sent when an alert is triggered based on the alert rule.
        # 
        # Valid values of N: 1 to 500.
        self.webhook = webhook  # type: str

    def validate(self):
        if self.escalations:
            self.escalations.validate()
        if self.labels:
            for k in self.labels:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesRequestRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.escalations is not None:
            result['Escalations'] = self.escalations.to_map()
        if self.contact_groups is not None:
            result['ContactGroups'] = self.contact_groups
        if self.effective_interval is not None:
            result['EffectiveInterval'] = self.effective_interval
        if self.email_subject is not None:
            result['EmailSubject'] = self.email_subject
        if self.interval is not None:
            result['Interval'] = self.interval
        result['Labels'] = []
        if self.labels is not None:
            for k in self.labels:
                result['Labels'].append(k.to_map() if k else None)
        if self.metric_name is not None:
            result['MetricName'] = self.metric_name
        if self.namespace is not None:
            result['Namespace'] = self.namespace
        if self.no_data_policy is not None:
            result['NoDataPolicy'] = self.no_data_policy
        if self.no_effective_interval is not None:
            result['NoEffectiveInterval'] = self.no_effective_interval
        if self.period is not None:
            result['Period'] = self.period
        if self.resources is not None:
            result['Resources'] = self.resources
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        if self.rule_name is not None:
            result['RuleName'] = self.rule_name
        if self.silence_time is not None:
            result['SilenceTime'] = self.silence_time
        if self.webhook is not None:
            result['Webhook'] = self.webhook
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Escalations') is not None:
            temp_model = PutResourceMetricRulesRequestRulesEscalations()
            self.escalations = temp_model.from_map(m['Escalations'])
        if m.get('ContactGroups') is not None:
            self.contact_groups = m.get('ContactGroups')
        if m.get('EffectiveInterval') is not None:
            self.effective_interval = m.get('EffectiveInterval')
        if m.get('EmailSubject') is not None:
            self.email_subject = m.get('EmailSubject')
        if m.get('Interval') is not None:
            self.interval = m.get('Interval')
        self.labels = []
        if m.get('Labels') is not None:
            for k in m.get('Labels'):
                temp_model = PutResourceMetricRulesRequestRulesLabels()
                self.labels.append(temp_model.from_map(k))
        if m.get('MetricName') is not None:
            self.metric_name = m.get('MetricName')
        if m.get('Namespace') is not None:
            self.namespace = m.get('Namespace')
        if m.get('NoDataPolicy') is not None:
            self.no_data_policy = m.get('NoDataPolicy')
        if m.get('NoEffectiveInterval') is not None:
            self.no_effective_interval = m.get('NoEffectiveInterval')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('Resources') is not None:
            self.resources = m.get('Resources')
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        if m.get('RuleName') is not None:
            self.rule_name = m.get('RuleName')
        if m.get('SilenceTime') is not None:
            self.silence_time = m.get('SilenceTime')
        if m.get('Webhook') is not None:
            self.webhook = m.get('Webhook')
        return self


class PutResourceMetricRulesRequest(TeaModel):
    def __init__(self, rules=None):
        self.rules = rules  # type: list[PutResourceMetricRulesRequestRules]

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = PutResourceMetricRulesRequestRules()
                self.rules.append(temp_model.from_map(k))
        return self


class PutResourceMetricRulesResponseBodyFailedListResultTargetResult(TeaModel):
    def __init__(self, code=None, message=None, success=None):
        # The HTTP status code.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(PutResourceMetricRulesResponseBodyFailedListResultTargetResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutResourceMetricRulesResponseBodyFailedListResultTarget(TeaModel):
    def __init__(self, result=None, rule_id=None):
        # The alert rule that failed to be created.
        self.result = result  # type: PutResourceMetricRulesResponseBodyFailedListResultTargetResult
        # The ID of the alert rule.
        self.rule_id = rule_id  # type: str

    def validate(self):
        if self.result:
            self.result.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesResponseBodyFailedListResultTarget, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.result is not None:
            result['Result'] = self.result.to_map()
        if self.rule_id is not None:
            result['RuleId'] = self.rule_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Result') is not None:
            temp_model = PutResourceMetricRulesResponseBodyFailedListResultTargetResult()
            self.result = temp_model.from_map(m['Result'])
        if m.get('RuleId') is not None:
            self.rule_id = m.get('RuleId')
        return self


class PutResourceMetricRulesResponseBodyFailedListResult(TeaModel):
    def __init__(self, target=None):
        self.target = target  # type: list[PutResourceMetricRulesResponseBodyFailedListResultTarget]

    def validate(self):
        if self.target:
            for k in self.target:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesResponseBodyFailedListResult, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Target'] = []
        if self.target is not None:
            for k in self.target:
                result['Target'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.target = []
        if m.get('Target') is not None:
            for k in m.get('Target'):
                temp_model = PutResourceMetricRulesResponseBodyFailedListResultTarget()
                self.target.append(temp_model.from_map(k))
        return self


class PutResourceMetricRulesResponseBody(TeaModel):
    def __init__(self, code=None, failed_list_result=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The alert rules that failed to be created for the resource.
        self.failed_list_result = failed_list_result  # type: PutResourceMetricRulesResponseBodyFailedListResult
        # The error message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        if self.failed_list_result:
            self.failed_list_result.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.failed_list_result is not None:
            result['FailedListResult'] = self.failed_list_result.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('FailedListResult') is not None:
            temp_model = PutResourceMetricRulesResponseBodyFailedListResult()
            self.failed_list_result = temp_model.from_map(m['FailedListResult'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class PutResourceMetricRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: PutResourceMetricRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(PutResourceMetricRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = PutResourceMetricRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveTagsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key.
        # 
        # > The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
        self.key = key  # type: str
        # The tag value.
        # 
        # > The tag key (`Tag.N.Key`) and tag value (`Tag.N.Value`) must be specified at the same time.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveTagsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class RemoveTagsRequest(TeaModel):
    def __init__(self, group_ids=None, region_id=None, tag=None):
        # The IDs of the application groups.
        self.group_ids = group_ids  # type: list[str]
        self.region_id = region_id  # type: str
        # The tags.
        self.tag = tag  # type: list[RemoveTagsRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RemoveTagsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.group_ids is not None:
            result['GroupIds'] = self.group_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('GroupIds') is not None:
            self.group_ids = m.get('GroupIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = RemoveTagsRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class RemoveTagsResponseBodyTag(TeaModel):
    def __init__(self, tags=None):
        self.tags = tags  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveTagsResponseBodyTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.tags is not None:
            result['Tags'] = self.tags
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        return self


class RemoveTagsResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None, tag=None):
        # The status code.
        # 
        # > The status code 200 indicates that the request was successful.
        self.code = code  # type: str
        # The error message.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   true
        # *   false
        self.success = success  # type: bool
        # The deleted tags.
        self.tag = tag  # type: RemoveTagsResponseBodyTag

    def validate(self):
        if self.tag:
            self.tag.validate()

    def to_map(self):
        _map = super(RemoveTagsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        if self.tag is not None:
            result['Tag'] = self.tag.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        if m.get('Tag') is not None:
            temp_model = RemoveTagsResponseBodyTag()
            self.tag = temp_model.from_map(m['Tag'])
        return self


class RemoveTagsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveTagsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveTagsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveTagsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendDryRunSystemEventRequest(TeaModel):
    def __init__(self, event_content=None, event_name=None, group_id=None, product=None, region_id=None):
        # The content of the system event.
        # 
        # >  The value of this parameter is a JSON object. We recommend that you include the `product`, `resourceId`, and `regionId` fields in the JSON object.
        self.event_content = event_content  # type: str
        # The name of the system event.
        # 
        # >  For more information, see [DescribeSystemEventMetaList](~~114972~~).
        self.event_name = event_name  # type: str
        # The ID of the application group.
        self.group_id = group_id  # type: str
        # The name of the cloud service.
        # 
        # >  For information about the system events supported by Cloud Monitor for Alibaba Cloud services, see [System events](~~167388~~).
        self.product = product  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendDryRunSystemEventRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.event_content is not None:
            result['EventContent'] = self.event_content
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.product is not None:
            result['Product'] = self.product
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EventContent') is not None:
            self.event_content = m.get('EventContent')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Product') is not None:
            self.product = m.get('Product')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SendDryRunSystemEventResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendDryRunSystemEventResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class SendDryRunSystemEventResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SendDryRunSystemEventResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SendDryRunSystemEventResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendDryRunSystemEventResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UninstallMonitoringAgentRequest(TeaModel):
    def __init__(self, instance_id=None, region_id=None):
        # The ID of the host.
        self.instance_id = instance_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallMonitoringAgentRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UninstallMonitoringAgentResponseBody(TeaModel):
    def __init__(self, code=None, message=None, request_id=None, success=None):
        # The HTTP status code.
        # 
        # >  The HTTP status code 200 indicates that the call was successful.
        self.code = code  # type: str
        # The returned message.
        self.message = message  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the call was successful. Valid values:
        # 
        # *   true: The call was successful.
        # *   false: The call failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(UninstallMonitoringAgentResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class UninstallMonitoringAgentResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UninstallMonitoringAgentResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UninstallMonitoringAgentResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UninstallMonitoringAgentResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


