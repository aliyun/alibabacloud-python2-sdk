# -*- coding: utf-8 -*-
# This file is auto-generated, don't edit it. Thanks.
from Tea.model import TeaModel


class CdsFileShareLinkModel(TeaModel):
    def __init__(self, access_count=None, create_time=None, creator=None, description=None, disable_download=None,
                 disable_preview=None, disable_save=None, download_count=None, download_limit=None, drive_id=None, expiration=None,
                 expired=None, file_ids=None, modifiy_time=None, preview_count=None, preview_limit=None, report_count=None,
                 save_count=None, save_limit=None, share_id=None, share_link=None, share_name=None, share_pwd=None, status=None,
                 video_preview_count=None):
        self.access_count = access_count  # type: long
        self.create_time = create_time  # type: str
        self.creator = creator  # type: str
        self.description = description  # type: str
        self.disable_download = disable_download  # type: bool
        self.disable_preview = disable_preview  # type: bool
        self.disable_save = disable_save  # type: bool
        self.download_count = download_count  # type: long
        self.download_limit = download_limit  # type: long
        self.drive_id = drive_id  # type: str
        self.expiration = expiration  # type: str
        self.expired = expired  # type: bool
        self.file_ids = file_ids  # type: str
        self.modifiy_time = modifiy_time  # type: str
        self.preview_count = preview_count  # type: long
        self.preview_limit = preview_limit  # type: long
        self.report_count = report_count  # type: long
        self.save_count = save_count  # type: long
        self.save_limit = save_limit  # type: long
        self.share_id = share_id  # type: str
        self.share_link = share_link  # type: str
        self.share_name = share_name  # type: str
        self.share_pwd = share_pwd  # type: str
        self.status = status  # type: str
        self.video_preview_count = video_preview_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(CdsFileShareLinkModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.access_count is not None:
            result['AccessCount'] = self.access_count
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.description is not None:
            result['Description'] = self.description
        if self.disable_download is not None:
            result['DisableDownload'] = self.disable_download
        if self.disable_preview is not None:
            result['DisablePreview'] = self.disable_preview
        if self.disable_save is not None:
            result['DisableSave'] = self.disable_save
        if self.download_count is not None:
            result['DownloadCount'] = self.download_count
        if self.download_limit is not None:
            result['DownloadLimit'] = self.download_limit
        if self.drive_id is not None:
            result['DriveId'] = self.drive_id
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.expired is not None:
            result['Expired'] = self.expired
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.modifiy_time is not None:
            result['ModifiyTime'] = self.modifiy_time
        if self.preview_count is not None:
            result['PreviewCount'] = self.preview_count
        if self.preview_limit is not None:
            result['PreviewLimit'] = self.preview_limit
        if self.report_count is not None:
            result['ReportCount'] = self.report_count
        if self.save_count is not None:
            result['SaveCount'] = self.save_count
        if self.save_limit is not None:
            result['SaveLimit'] = self.save_limit
        if self.share_id is not None:
            result['ShareId'] = self.share_id
        if self.share_link is not None:
            result['ShareLink'] = self.share_link
        if self.share_name is not None:
            result['ShareName'] = self.share_name
        if self.share_pwd is not None:
            result['SharePwd'] = self.share_pwd
        if self.status is not None:
            result['Status'] = self.status
        if self.video_preview_count is not None:
            result['VideoPreviewCount'] = self.video_preview_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AccessCount') is not None:
            self.access_count = m.get('AccessCount')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisableDownload') is not None:
            self.disable_download = m.get('DisableDownload')
        if m.get('DisablePreview') is not None:
            self.disable_preview = m.get('DisablePreview')
        if m.get('DisableSave') is not None:
            self.disable_save = m.get('DisableSave')
        if m.get('DownloadCount') is not None:
            self.download_count = m.get('DownloadCount')
        if m.get('DownloadLimit') is not None:
            self.download_limit = m.get('DownloadLimit')
        if m.get('DriveId') is not None:
            self.drive_id = m.get('DriveId')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('Expired') is not None:
            self.expired = m.get('Expired')
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('ModifiyTime') is not None:
            self.modifiy_time = m.get('ModifiyTime')
        if m.get('PreviewCount') is not None:
            self.preview_count = m.get('PreviewCount')
        if m.get('PreviewLimit') is not None:
            self.preview_limit = m.get('PreviewLimit')
        if m.get('ReportCount') is not None:
            self.report_count = m.get('ReportCount')
        if m.get('SaveCount') is not None:
            self.save_count = m.get('SaveCount')
        if m.get('SaveLimit') is not None:
            self.save_limit = m.get('SaveLimit')
        if m.get('ShareId') is not None:
            self.share_id = m.get('ShareId')
        if m.get('ShareLink') is not None:
            self.share_link = m.get('ShareLink')
        if m.get('ShareName') is not None:
            self.share_name = m.get('ShareName')
        if m.get('SharePwd') is not None:
            self.share_pwd = m.get('SharePwd')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VideoPreviewCount') is not None:
            self.video_preview_count = m.get('VideoPreviewCount')
        return self


class FilePermissionMemberCdsIdentity(TeaModel):
    def __init__(self, id=None, type=None):
        self.id = id  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(FilePermissionMemberCdsIdentity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class FilePermissionMember(TeaModel):
    def __init__(self, cds_identity=None, disinherit_sub_group=None, expire_time=None, role_id=None):
        self.cds_identity = cds_identity  # type: FilePermissionMemberCdsIdentity
        self.disinherit_sub_group = disinherit_sub_group  # type: bool
        self.expire_time = expire_time  # type: long
        self.role_id = role_id  # type: str

    def validate(self):
        if self.cds_identity:
            self.cds_identity.validate()

    def to_map(self):
        _map = super(FilePermissionMember, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_identity is not None:
            result['CdsIdentity'] = self.cds_identity.to_map()
        if self.disinherit_sub_group is not None:
            result['DisinheritSubGroup'] = self.disinherit_sub_group
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsIdentity') is not None:
            temp_model = FilePermissionMemberCdsIdentity()
            self.cds_identity = temp_model.from_map(m['CdsIdentity'])
        if m.get('DisinheritSubGroup') is not None:
            self.disinherit_sub_group = m.get('DisinheritSubGroup')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class ActivateOfficeSiteRequest(TeaModel):
    def __init__(self, office_site_id=None, region_id=None):
        # The ID of the convenience workspace that is locked.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ActivateOfficeSiteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ActivateOfficeSiteResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ActivateOfficeSiteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ActivateOfficeSiteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ActivateOfficeSiteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ActivateOfficeSiteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ActivateOfficeSiteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddDevicesRequest(TeaModel):
    def __init__(self, client_type=None, device_ids=None, region_id=None):
        # The type of the Alibaba Cloud Workspace client that runs on the device.
        # 
        # *   1: the hardware client
        # *   2: the software client
        self.client_type = client_type  # type: int
        # The list of devices.
        self.device_ids = device_ids  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddDevicesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.device_ids is not None:
            result['DeviceIds'] = self.device_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('DeviceIds') is not None:
            self.device_ids = m.get('DeviceIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddDevicesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddDevicesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddDevicesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddDevicesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddDevicesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddFilePermissionRequestMemberListCdsIdentity(TeaModel):
    def __init__(self, id=None, type=None):
        self.id = id  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddFilePermissionRequestMemberListCdsIdentity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class AddFilePermissionRequestMemberList(TeaModel):
    def __init__(self, cds_identity=None, disinherit_sub_group=None, expire_time=None, role_id=None):
        self.cds_identity = cds_identity  # type: AddFilePermissionRequestMemberListCdsIdentity
        self.disinherit_sub_group = disinherit_sub_group  # type: bool
        self.expire_time = expire_time  # type: long
        self.role_id = role_id  # type: str

    def validate(self):
        if self.cds_identity:
            self.cds_identity.validate()

    def to_map(self):
        _map = super(AddFilePermissionRequestMemberList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_identity is not None:
            result['CdsIdentity'] = self.cds_identity.to_map()
        if self.disinherit_sub_group is not None:
            result['DisinheritSubGroup'] = self.disinherit_sub_group
        if self.expire_time is not None:
            result['ExpireTime'] = self.expire_time
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsIdentity') is not None:
            temp_model = AddFilePermissionRequestMemberListCdsIdentity()
            self.cds_identity = temp_model.from_map(m['CdsIdentity'])
        if m.get('DisinheritSubGroup') is not None:
            self.disinherit_sub_group = m.get('DisinheritSubGroup')
        if m.get('ExpireTime') is not None:
            self.expire_time = m.get('ExpireTime')
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class AddFilePermissionRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, member_list=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.member_list = member_list  # type: list[AddFilePermissionRequestMemberList]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.member_list:
            for k in self.member_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(AddFilePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        result['MemberList'] = []
        if self.member_list is not None:
            for k in self.member_list:
                result['MemberList'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        self.member_list = []
        if m.get('MemberList') is not None:
            for k in m.get('MemberList'):
                temp_model = AddFilePermissionRequestMemberList()
                self.member_list.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddFilePermissionShrinkRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, member_list_shrink=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.member_list_shrink = member_list_shrink  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddFilePermissionShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.member_list_shrink is not None:
            result['MemberList'] = self.member_list_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('MemberList') is not None:
            self.member_list_shrink = m.get('MemberList')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddFilePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddFilePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddFilePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddFilePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddFilePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddFilePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AddUserToDesktopGroupRequest(TeaModel):
    def __init__(self, client_token=None, desktop_group_id=None, desktop_group_ids=None, end_user_ids=None,
                 region_id=None):
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).
        self.client_token = client_token  # type: str
        # The ID of the desktop group that you want to assign to more regular users.
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the desktop groups.
        self.desktop_group_ids = desktop_group_ids  # type: list[str]
        # The regular users to whom you want to assign the desktop group.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The ID of the region
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddUserToDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_ids is not None:
            result['DesktopGroupIds'] = self.desktop_group_ids
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupIds') is not None:
            self.desktop_group_ids = m.get('DesktopGroupIds')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AddUserToDesktopGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AddUserToDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AddUserToDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AddUserToDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AddUserToDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AddUserToDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, desktop_id=None, policy_id=None, region_id=None):
        # The IDs of cloud desktops. You can specify 1 to 20 cloud desktops.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ApplyAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ApplyAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApplyAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApplyAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyCoordinatePrivilegeRequest(TeaModel):
    def __init__(self, co_id=None, end_user_id=None, region_id=None, user_type=None, uuid=None):
        # The ID of the application for the coordinate permissions.
        self.co_id = co_id  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of user who requires the coordinate permissions.
        # 
        # Valid value: TENANT_ADMIN.
        self.user_type = user_type  # type: str
        # The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyCoordinatePrivilegeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_id is not None:
            result['CoId'] = self.co_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoId') is not None:
            self.co_id = m.get('CoId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ApplyCoordinatePrivilegeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyCoordinatePrivilegeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ApplyCoordinatePrivilegeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApplyCoordinatePrivilegeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApplyCoordinatePrivilegeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyCoordinatePrivilegeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApplyCoordinationForMonitoringRequestResourceCandidates(TeaModel):
    def __init__(self, owner_ali_uid=None, owner_end_user_id=None, resource_id=None, resource_name=None,
                 resource_properties=None, resource_region_id=None, resource_type=None):
        self.owner_ali_uid = owner_ali_uid  # type: long
        self.owner_end_user_id = owner_end_user_id  # type: str
        self.resource_id = resource_id  # type: str
        self.resource_name = resource_name  # type: str
        self.resource_properties = resource_properties  # type: str
        self.resource_region_id = resource_region_id  # type: str
        self.resource_type = resource_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyCoordinationForMonitoringRequestResourceCandidates, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.owner_ali_uid is not None:
            result['OwnerAliUid'] = self.owner_ali_uid
        if self.owner_end_user_id is not None:
            result['OwnerEndUserId'] = self.owner_end_user_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        if self.resource_properties is not None:
            result['ResourceProperties'] = self.resource_properties
        if self.resource_region_id is not None:
            result['ResourceRegionId'] = self.resource_region_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OwnerAliUid') is not None:
            self.owner_ali_uid = m.get('OwnerAliUid')
        if m.get('OwnerEndUserId') is not None:
            self.owner_end_user_id = m.get('OwnerEndUserId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        if m.get('ResourceProperties') is not None:
            self.resource_properties = m.get('ResourceProperties')
        if m.get('ResourceRegionId') is not None:
            self.resource_region_id = m.get('ResourceRegionId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        return self


class ApplyCoordinationForMonitoringRequest(TeaModel):
    def __init__(self, coordinate_policy_type=None, end_user_id=None, initiator_type=None, region_id=None,
                 resource_candidates=None, uuid=None):
        self.coordinate_policy_type = coordinate_policy_type  # type: str
        self.end_user_id = end_user_id  # type: str
        self.initiator_type = initiator_type  # type: str
        self.region_id = region_id  # type: str
        self.resource_candidates = resource_candidates  # type: list[ApplyCoordinationForMonitoringRequestResourceCandidates]
        self.uuid = uuid  # type: str

    def validate(self):
        if self.resource_candidates:
            for k in self.resource_candidates:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ApplyCoordinationForMonitoringRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.coordinate_policy_type is not None:
            result['CoordinatePolicyType'] = self.coordinate_policy_type
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.initiator_type is not None:
            result['InitiatorType'] = self.initiator_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['ResourceCandidates'] = []
        if self.resource_candidates is not None:
            for k in self.resource_candidates:
                result['ResourceCandidates'].append(k.to_map() if k else None)
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoordinatePolicyType') is not None:
            self.coordinate_policy_type = m.get('CoordinatePolicyType')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('InitiatorType') is not None:
            self.initiator_type = m.get('InitiatorType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.resource_candidates = []
        if m.get('ResourceCandidates') is not None:
            for k in m.get('ResourceCandidates'):
                temp_model = ApplyCoordinationForMonitoringRequestResourceCandidates()
                self.resource_candidates.append(temp_model.from_map(k))
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels(TeaModel):
    def __init__(self, co_id=None, coordinate_status=None, coordinate_ticket=None, initiator_type=None,
                 owner_user_id=None, resource_id=None, resource_name=None):
        self.co_id = co_id  # type: str
        self.coordinate_status = coordinate_status  # type: str
        self.coordinate_ticket = coordinate_ticket  # type: str
        self.initiator_type = initiator_type  # type: str
        self.owner_user_id = owner_user_id  # type: str
        self.resource_id = resource_id  # type: str
        self.resource_name = resource_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_id is not None:
            result['CoId'] = self.co_id
        if self.coordinate_status is not None:
            result['CoordinateStatus'] = self.coordinate_status
        if self.coordinate_ticket is not None:
            result['CoordinateTicket'] = self.coordinate_ticket
        if self.initiator_type is not None:
            result['InitiatorType'] = self.initiator_type
        if self.owner_user_id is not None:
            result['OwnerUserId'] = self.owner_user_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_name is not None:
            result['ResourceName'] = self.resource_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoId') is not None:
            self.co_id = m.get('CoId')
        if m.get('CoordinateStatus') is not None:
            self.coordinate_status = m.get('CoordinateStatus')
        if m.get('CoordinateTicket') is not None:
            self.coordinate_ticket = m.get('CoordinateTicket')
        if m.get('InitiatorType') is not None:
            self.initiator_type = m.get('InitiatorType')
        if m.get('OwnerUserId') is not None:
            self.owner_user_id = m.get('OwnerUserId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceName') is not None:
            self.resource_name = m.get('ResourceName')
        return self


class ApplyCoordinationForMonitoringResponseBody(TeaModel):
    def __init__(self, coordinate_flow_models=None, request_id=None):
        self.coordinate_flow_models = coordinate_flow_models  # type: list[ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.coordinate_flow_models:
            for k in self.coordinate_flow_models:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ApplyCoordinationForMonitoringResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CoordinateFlowModels'] = []
        if self.coordinate_flow_models is not None:
            for k in self.coordinate_flow_models:
                result['CoordinateFlowModels'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.coordinate_flow_models = []
        if m.get('CoordinateFlowModels') is not None:
            for k in m.get('CoordinateFlowModels'):
                temp_model = ApplyCoordinationForMonitoringResponseBodyCoordinateFlowModels()
                self.coordinate_flow_models.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ApplyCoordinationForMonitoringResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApplyCoordinationForMonitoringResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApplyCoordinationForMonitoringResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApplyCoordinationForMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ApproveFotaUpdateRequest(TeaModel):
    def __init__(self, app_version=None, desktop_id=None, region_id=None):
        # The version of the custom image. You can call the [DescribeImages](~~188895~~) operation to obtain the value of this parameter.
        self.app_version = app_version  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApproveFotaUpdateRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_version is not None:
            result['AppVersion'] = self.app_version
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppVersion') is not None:
            self.app_version = m.get('AppVersion')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ApproveFotaUpdateResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ApproveFotaUpdateResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ApproveFotaUpdateResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ApproveFotaUpdateResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ApproveFotaUpdateResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ApproveFotaUpdateResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AssociateNetworkPackageRequest(TeaModel):
    def __init__(self, network_package_id=None, office_site_id=None, region_id=None):
        # The ID of the Internet access package. You can call the [DescribeNetworkPackages](~~216079~~) operation to query the ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the workspace. You can call the [DescribeOfficeSites](~~216071~~) operation to query the ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateNetworkPackageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class AssociateNetworkPackageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AssociateNetworkPackageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AssociateNetworkPackageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AssociateNetworkPackageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AssociateNetworkPackageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AssociateNetworkPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachCenRequest(TeaModel):
    def __init__(self, cen_id=None, cen_owner_id=None, office_site_id=None, region_id=None, verify_code=None):
        # The ID of the CEN instance.
        self.cen_id = cen_id  # type: str
        # The ID of the Alibaba Cloud account to which the CEN instance belongs.
        # 
        # *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to the Alibaba Cloud account, skip this parameter.
        # *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account.
        self.cen_owner_id = cen_owner_id  # type: long
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
        self.verify_code = verify_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachCenRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.cen_owner_id is not None:
            result['CenOwnerId'] = self.cen_owner_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.verify_code is not None:
            result['VerifyCode'] = self.verify_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CenOwnerId') is not None:
            self.cen_owner_id = m.get('CenOwnerId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VerifyCode') is not None:
            self.verify_code = m.get('VerifyCode')
        return self


class AttachCenResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachCenResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachCenResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachCenResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachCenResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachCenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class AttachEndUserRequest(TeaModel):
    def __init__(self, ad_domain=None, client_type=None, device_id=None, directory_id=None, end_user_id=None,
                 region_id=None, user_type=None):
        # The address of the Active Directory (AD) workspace.
        self.ad_domain = ad_domain  # type: str
        # The type of the Alibaba Cloud Workspace client that runs on the device.
        # 
        # *   1: the hardware client
        # *   2: the software client
        self.client_type = client_type  # type: int
        # The ID of the device.
        self.device_id = device_id  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The ID of the user.
        self.end_user_id = end_user_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The account type of the user.
        # 
        # *   SIMPLE: the convenience user
        # *   AD: the AD user
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachEndUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_domain is not None:
            result['AdDomain'] = self.ad_domain
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdDomain') is not None:
            self.ad_domain = m.get('AdDomain')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class AttachEndUserResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(AttachEndUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class AttachEndUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: AttachEndUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(AttachEndUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = AttachEndUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, desktop_id=None, policy_id=None, region_id=None):
        # The IDs of the cloud desktops. Valid values of N: 1 to 50. You cannot leave this parameter empty. The value can be up to 64 characters in length and cannot start with acs: or aliyun. It cannot contain [http:// or https://.](http://https://。)
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The region ID of the automatic snapshot policy. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CancelAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelCdsFileShareLinkRequest(TeaModel):
    def __init__(self, cds_id=None, share_id=None):
        self.cds_id = cds_id  # type: str
        self.share_id = share_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCdsFileShareLinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.share_id is not None:
            result['ShareId'] = self.share_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('ShareId') is not None:
            self.share_id = m.get('ShareId')
        return self


class CancelCdsFileShareLinkResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: bool
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCdsFileShareLinkResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CancelCdsFileShareLinkResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelCdsFileShareLinkResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelCdsFileShareLinkResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelCdsFileShareLinkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelCoordinationForMonitoringRequest(TeaModel):
    def __init__(self, co_ids=None, end_user_id=None, region_id=None, user_type=None):
        self.co_ids = co_ids  # type: list[str]
        self.end_user_id = end_user_id  # type: str
        self.region_id = region_id  # type: str
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCoordinationForMonitoringRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_ids is not None:
            result['CoIds'] = self.co_ids
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoIds') is not None:
            self.co_ids = m.get('CoIds')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class CancelCoordinationForMonitoringResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCoordinationForMonitoringResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelCoordinationForMonitoringResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelCoordinationForMonitoringResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelCoordinationForMonitoringResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelCoordinationForMonitoringResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CancelCopyImageRequest(TeaModel):
    def __init__(self, image_id=None, region_id=None):
        self.image_id = image_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCopyImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CancelCopyImageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CancelCopyImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CancelCopyImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CancelCopyImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CancelCopyImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CancelCopyImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ClonePolicyGroupRequest(TeaModel):
    def __init__(self, name=None, policy_group_id=None, region_id=None):
        # The name of the policy.
        self.name = name  # type: str
        # The ID of the policy that you want to clone.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ClonePolicyGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ClonePolicyGroupResponseBody(TeaModel):
    def __init__(self, policy_group_id=None, request_id=None):
        # The ID of the new policy.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ClonePolicyGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ClonePolicyGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ClonePolicyGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ClonePolicyGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ClonePolicyGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CompleteCdsFileRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, region_id=None, upload_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.region_id = region_id  # type: str
        self.upload_id = upload_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CompleteCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.upload_id is not None:
            result['UploadId'] = self.upload_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UploadId') is not None:
            self.upload_id = m.get('UploadId')
        return self


class CompleteCdsFileResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CompleteCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CompleteCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CompleteCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CompleteCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CompleteCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfigADConnectorTrustRequest(TeaModel):
    def __init__(self, office_site_id=None, rds_license_domain=None, region_id=None, trust_key=None):
        # The ID of the AD workspace.
        self.office_site_id = office_site_id  # type: str
        self.rds_license_domain = rds_license_domain  # type: bool
        # The region ID.
        self.region_id = region_id  # type: str
        # The trust password. You can specify the password when you configure a trust relationship between the AD domain and the ecd.acs domain.
        self.trust_key = trust_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfigADConnectorTrustRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.rds_license_domain is not None:
            result['RdsLicenseDomain'] = self.rds_license_domain
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.trust_key is not None:
            result['TrustKey'] = self.trust_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RdsLicenseDomain') is not None:
            self.rds_license_domain = m.get('RdsLicenseDomain')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TrustKey') is not None:
            self.trust_key = m.get('TrustKey')
        return self


class ConfigADConnectorTrustResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfigADConnectorTrustResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConfigADConnectorTrustResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ConfigADConnectorTrustResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ConfigADConnectorTrustResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfigADConnectorTrustResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ConfigADConnectorUserRequest(TeaModel):
    def __init__(self, domain_password=None, domain_user_name=None, ouname=None, office_site_id=None,
                 region_id=None):
        # The password of the AD user that has the permissions to join computers to domains.
        self.domain_password = domain_password  # type: str
        # The username of the AD user that has the permissions to join computers to domains.
        # 
        # After the username is configured, the cloud desktops in the same AD workspace are joined to the specified OU.
        self.domain_user_name = domain_user_name  # type: str
        # The name of the OU in the AD domain. You can call the [ListUserAdOrganizationUnits](~~311259~~) to obtain the OU name.
        self.ouname = ouname  # type: str
        # The ID of the AD workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfigADConnectorUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.ouname is not None:
            result['OUName'] = self.ouname
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('OUName') is not None:
            self.ouname = m.get('OUName')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ConfigADConnectorUserResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ConfigADConnectorUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ConfigADConnectorUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ConfigADConnectorUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ConfigADConnectorUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ConfigADConnectorUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyCdsFileRequest(TeaModel):
    def __init__(self, auto_rename=None, cds_id=None, end_user_id=None, file_id=None, parent_folder_id=None,
                 region_id=None):
        self.auto_rename = auto_rename  # type: bool
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.parent_folder_id = parent_folder_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_rename is not None:
            result['AutoRename'] = self.auto_rename
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.parent_folder_id is not None:
            result['ParentFolderId'] = self.parent_folder_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoRename') is not None:
            self.auto_rename = m.get('AutoRename')
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('ParentFolderId') is not None:
            self.parent_folder_id = m.get('ParentFolderId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CopyCdsFileResponseBodyCopyCdsFileModel(TeaModel):
    def __init__(self, async_task_id=None, file_id=None):
        self.async_task_id = async_task_id  # type: str
        self.file_id = file_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyCdsFileResponseBodyCopyCdsFileModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        return self


class CopyCdsFileResponseBody(TeaModel):
    def __init__(self, code=None, copy_cds_file_model=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.copy_cds_file_model = copy_cds_file_model  # type: CopyCdsFileResponseBodyCopyCdsFileModel
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: str

    def validate(self):
        if self.copy_cds_file_model:
            self.copy_cds_file_model.validate()

    def to_map(self):
        _map = super(CopyCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.copy_cds_file_model is not None:
            result['CopyCdsFileModel'] = self.copy_cds_file_model.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('CopyCdsFileModel') is not None:
            temp_model = CopyCdsFileResponseBodyCopyCdsFileModel()
            self.copy_cds_file_model = temp_model.from_map(m['CopyCdsFileModel'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CopyCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CopyCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CopyCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CopyImageRequest(TeaModel):
    def __init__(self, destination_description=None, destination_image_name=None, destination_region_id=None,
                 image_id=None, region_id=None):
        self.destination_description = destination_description  # type: str
        self.destination_image_name = destination_image_name  # type: str
        self.destination_region_id = destination_region_id  # type: str
        self.image_id = image_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_description is not None:
            result['DestinationDescription'] = self.destination_description
        if self.destination_image_name is not None:
            result['DestinationImageName'] = self.destination_image_name
        if self.destination_region_id is not None:
            result['DestinationRegionId'] = self.destination_region_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestinationDescription') is not None:
            self.destination_description = m.get('DestinationDescription')
        if m.get('DestinationImageName') is not None:
            self.destination_image_name = m.get('DestinationImageName')
        if m.get('DestinationRegionId') is not None:
            self.destination_region_id = m.get('DestinationRegionId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CopyImageResponseBody(TeaModel):
    def __init__(self, image_id=None, request_id=None):
        self.image_id = image_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CopyImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CopyImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CopyImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CopyImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CopyImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateADConnectorDirectoryRequest(TeaModel):
    def __init__(self, desktop_access_type=None, directory_name=None, dns_address=None, domain_name=None,
                 domain_password=None, domain_user_name=None, enable_admin_access=None, mfa_enabled=None, region_id=None,
                 specification=None, sub_domain_dns_address=None, sub_domain_name=None, v_switch_id=None):
        # The method that is used to connect the client to cloud desktops.
        self.desktop_access_type = desktop_access_type  # type: str
        # The name of the AD directory. The name must be 2 to 255 characters in length, and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
        self.directory_name = directory_name  # type: str
        # Details of the IP addresses of the Domain Name System (DNS) servers of the enterprise AD system. You can specify only one IP address. Make sure that the specified IP address is accessible in the network of the selected vSwitch.
        self.dns_address = dns_address  # type: list[str]
        # The fully qualified domain name (FQDN) of the enterprise AD system. The value must contain the hostname and the domain name. You can register each FQDN only once.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator. The password can be up to 64 characters in length.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator. The username can be up to 64 characters in length.
        self.domain_user_name = domain_user_name  # type: str
        # Specifies whether to grant the permissions of the local administrator to the regular user of the cloud desktop.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Specifies whether to enable multi-factor authentication (MFA). If you enable MFA, all AD users in the AD directory must enter the password and the dynamic verification code generated by the MFA device when they log on to a cloud desktop.
        # 
        # >  The first time you log on to the Elastic Desktop Service (EDS) client as a regular user, you must bind an MFA device.
        self.mfa_enabled = mfa_enabled  # type: bool
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of the AD connector.
        self.specification = specification  # type: long
        # The DNS address of the enterprise AD subdomain.\
        # If you specify the `SubDomainName` parameter but you do not specify this parameter, the DNS address of the subdomain is the same as the DNS address of the parent domain.
        self.sub_domain_dns_address = sub_domain_dns_address  # type: list[str]
        # The FQDN of the enterprise AD subdomain. The value must contain the hostname and the subdomain name.
        self.sub_domain_name = sub_domain_name  # type: str
        # Details of the vSwitch IDs. You can specify only one vSwitch ID.
        self.v_switch_id = v_switch_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateADConnectorDirectoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.directory_name is not None:
            result['DirectoryName'] = self.directory_name
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.sub_domain_dns_address is not None:
            result['SubDomainDnsAddress'] = self.sub_domain_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('DirectoryName') is not None:
            self.directory_name = m.get('DirectoryName')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('SubDomainDnsAddress') is not None:
            self.sub_domain_dns_address = m.get('SubDomainDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateADConnectorDirectoryResponseBodyAdConnectors(TeaModel):
    def __init__(self, address=None):
        # The IP address of the AD connector.
        self.address = address  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateADConnectorDirectoryResponseBodyAdConnectors, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.address is not None:
            result['Address'] = self.address
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Address') is not None:
            self.address = m.get('Address')
        return self


class CreateADConnectorDirectoryResponseBody(TeaModel):
    def __init__(self, ad_connectors=None, directory_id=None, request_id=None, trust_password=None):
        # Details of the AD connectors.
        self.ad_connectors = ad_connectors  # type: list[CreateADConnectorDirectoryResponseBodyAdConnectors]
        # The ID of the AD directory.
        self.directory_id = directory_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The AD trust password.
        self.trust_password = trust_password  # type: str

    def validate(self):
        if self.ad_connectors:
            for k in self.ad_connectors:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateADConnectorDirectoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AdConnectors'] = []
        if self.ad_connectors is not None:
            for k in self.ad_connectors:
                result['AdConnectors'].append(k.to_map() if k else None)
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.trust_password is not None:
            result['TrustPassword'] = self.trust_password
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.ad_connectors = []
        if m.get('AdConnectors') is not None:
            for k in m.get('AdConnectors'):
                temp_model = CreateADConnectorDirectoryResponseBodyAdConnectors()
                self.ad_connectors.append(temp_model.from_map(k))
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TrustPassword') is not None:
            self.trust_password = m.get('TrustPassword')
        return self


class CreateADConnectorDirectoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateADConnectorDirectoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateADConnectorDirectoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateADConnectorDirectoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateADConnectorOfficeSiteRequest(TeaModel):
    def __init__(self, ad_hostname=None, bandwidth=None, cen_id=None, cen_owner_id=None, cidr_block=None,
                 desktop_access_type=None, dns_address=None, domain_name=None, domain_password=None, domain_user_name=None,
                 enable_admin_access=None, enable_internet_access=None, mfa_enabled=None, office_site_name=None, protocol_type=None,
                 region_id=None, specification=None, sub_domain_dns_address=None, sub_domain_name=None, verify_code=None):
        # Host name. The host name must comply with the Windows host convention.
        self.ad_hostname = ad_hostname  # type: str
        # The maximum public bandwidth value. Valid values: 0 to 200.
        # 
        # If you do not specify this parameter or you set this parameter to 0, Internet access is disabled.
        self.bandwidth = bandwidth  # type: int
        # The ID of the CEN instance.
        self.cen_id = cen_id  # type: str
        # The ID of the Alibaba Cloud account to which the Cloud Enterprise Network (CEN) instance belongs.
        # 
        # *   If you do not specify the CenId parameter, or the CEN instance that you specify for the CenId parameter belongs to the current Alibaba Cloud account, skip this parameter.
        # *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account.
        self.cen_owner_id = cen_owner_id  # type: long
        # The IPv4 CIDR block in the secure office network of the workspace. The system creates a virtual private cloud (VPC) based on the IPv4 CIDR block that you specify. We recommend that you set the IPv4 CIDR block to 10.0.0.0/12, 172.16.0.0/12, 192.168.0.0/16, or a subnet of these CIDR blocks. If you set the IPv4 CIDR block to 10.0.0.0/12 or 172.16.0.0/12, the mask is 12 to 24 bits in length. If you set the IPv4 CIDR block to 192.168.0.0/16, the mask is 16 to 24 bits in length.
        self.cidr_block = cidr_block  # type: str
        # The method that you use to connect to cloud desktops. Valid values:
        # 
        # *   Internet: connects clients to cloud desktops only over the Internet.
        # *   VPC: connects clients to cloud desktops only over a VPC.
        # *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method when you use a client to connect to the cloud desktop.
        # 
        # Default value: Internet.
        # 
        # >  The VPC connection method is provided by Alibaba Cloud PrivateLink. You are not charged for PrivateLink. When you set this parameter to VPC or Any, PrivateLink is automatically activated.
        self.desktop_access_type = desktop_access_type  # type: str
        self.dns_address = dns_address  # type: list[str]
        # The domain name of the enterprise AD system. You can register each domain name only once.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator. The password can be up to 64 characters in length.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator. The username can be up to 64 characters in length.
        # 
        # >  Specify the value of the sAMAccountName parameter instead of the value of the userPrincipalName parameter as the username.
        self.domain_user_name = domain_user_name  # type: str
        # Specifies whether to grant the permissions of the local administrator to the desktop users. Default value: true.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Specifies whether to enable Internet access.
        self.enable_internet_access = enable_internet_access  # type: bool
        # Specifies whether to enable multi-factor authentication (MFA).
        self.mfa_enabled = mfa_enabled  # type: bool
        # The name of the workspace. The name must be 2 to 255 characters in length. It must start with a letter and cannot start with `http://` or `https://`. It can contain digits, colons (:), underscores (\_), and hyphens (-).
        # 
        # Default value: null.
        self.office_site_name = office_site_name  # type: str
        # Protocol Type. Valid values: ASP.
        self.protocol_type = protocol_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # Specification of AD Connector.
        # 
        # *   1: General.
        # *   2: High.
        self.specification = specification  # type: long
        self.sub_domain_dns_address = sub_domain_dns_address  # type: list[str]
        # The domain name of the enterprise AD subdomain.
        self.sub_domain_name = sub_domain_name  # type: str
        # The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
        self.verify_code = verify_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateADConnectorOfficeSiteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.cen_owner_id is not None:
            result['CenOwnerId'] = self.cen_owner_id
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.enable_internet_access is not None:
            result['EnableInternetAccess'] = self.enable_internet_access
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.sub_domain_dns_address is not None:
            result['SubDomainDnsAddress'] = self.sub_domain_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        if self.verify_code is not None:
            result['VerifyCode'] = self.verify_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CenOwnerId') is not None:
            self.cen_owner_id = m.get('CenOwnerId')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('EnableInternetAccess') is not None:
            self.enable_internet_access = m.get('EnableInternetAccess')
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('SubDomainDnsAddress') is not None:
            self.sub_domain_dns_address = m.get('SubDomainDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        if m.get('VerifyCode') is not None:
            self.verify_code = m.get('VerifyCode')
        return self


class CreateADConnectorOfficeSiteResponseBody(TeaModel):
    def __init__(self, office_site_id=None, request_id=None):
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateADConnectorOfficeSiteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateADConnectorOfficeSiteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateADConnectorOfficeSiteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateADConnectorOfficeSiteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateADConnectorOfficeSiteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAndBindNasFileSystemRequest(TeaModel):
    def __init__(self, description=None, desktop_group_id=None, encrypt_type=None, end_user_ids=None,
                 file_system_name=None, office_site_id=None, region_id=None, storage_type=None):
        self.description = description  # type: str
        self.desktop_group_id = desktop_group_id  # type: str
        self.encrypt_type = encrypt_type  # type: int
        self.end_user_ids = end_user_ids  # type: list[str]
        self.file_system_name = file_system_name  # type: str
        self.office_site_id = office_site_id  # type: str
        self.region_id = region_id  # type: str
        self.storage_type = storage_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAndBindNasFileSystemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class CreateAndBindNasFileSystemResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAndBindNasFileSystemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAndBindNasFileSystemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAndBindNasFileSystemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAndBindNasFileSystemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAndBindNasFileSystemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, cron_expression=None, policy_name=None, region_id=None, retention_days=None):
        # The CRON expression for periodic scheduling.
        self.cron_expression = cron_expression  # type: str
        # The name of the automatic snapshot policy.
        self.policy_name = policy_name  # type: str
        # The ID of the region where the automatic snapshot policy is created. You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The retention period of automatic snapshots. Unit: days. Valid values:
        # 
        # *   \-1: Automatic snapshots are retained until they are deleted.
        # *   1 to 65536: Automatic snapshots are retained for the specified number of days.
        self.retention_days = retention_days  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_expression is not None:
            result['CronExpression'] = self.cron_expression
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronExpression') is not None:
            self.cron_expression = m.get('CronExpression')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        return self


class CreateAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, policy_id=None, request_id=None):
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateBundleRequest(TeaModel):
    def __init__(self, bundle_name=None, description=None, desktop_type=None, image_id=None, language=None,
                 region_id=None, root_disk_performance_level=None, root_disk_size_gib=None,
                 user_disk_performance_level=None, user_disk_size_gib=None):
        # The name of the desktop template.
        self.bundle_name = bundle_name  # type: str
        # The description of the desktop template.
        self.description = description  # type: str
        # The type of the cloud desktop. You can call the DescribeBundles operation to query the cloud desktop templates and obtain the supported desktop type from the value of the DesktopType parameter.
        # 
        # >  You can select GPU-accelerated desktop types only when you use GPU-accelerated images.
        self.desktop_type = desktop_type  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The language of the OS. This parameter is available only for system images. Valid values:
        # 
        # *   zh-CN: Simplified Chinese
        # *   zh-HK: Traditional Chinese (Hong Kong)
        # *   en-US: English
        # *   ja-JP: Japanese
        self.language = language  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The performance level (PL) of the system disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the system disk. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        # 
        # For more information about the differences between disks at different PLs, see [Enhanced SSDs](~~122389~~).
        self.root_disk_performance_level = root_disk_performance_level  # type: str
        # The size of the system disk. Unit: GiB.
        # 
        # The value of this parameter must be consistent with the system disk size supported by the cloud desktop type. For more information, see [Cloud desktop types](~~188609~~).
        self.root_disk_size_gib = root_disk_size_gib  # type: int
        # The PL of the data disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the data disk. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        # 
        # For more information about the differences between disks at different PLs, see [Enhanced SSDs](~~122389~~).
        self.user_disk_performance_level = user_disk_performance_level  # type: str
        self.user_disk_size_gib = user_disk_size_gib  # type: list[int]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateBundleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_name is not None:
            result['BundleName'] = self.bundle_name
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_type is not None:
            result['DesktopType'] = self.desktop_type
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.language is not None:
            result['Language'] = self.language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.root_disk_performance_level is not None:
            result['RootDiskPerformanceLevel'] = self.root_disk_performance_level
        if self.root_disk_size_gib is not None:
            result['RootDiskSizeGib'] = self.root_disk_size_gib
        if self.user_disk_performance_level is not None:
            result['UserDiskPerformanceLevel'] = self.user_disk_performance_level
        if self.user_disk_size_gib is not None:
            result['UserDiskSizeGib'] = self.user_disk_size_gib
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleName') is not None:
            self.bundle_name = m.get('BundleName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopType') is not None:
            self.desktop_type = m.get('DesktopType')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RootDiskPerformanceLevel') is not None:
            self.root_disk_performance_level = m.get('RootDiskPerformanceLevel')
        if m.get('RootDiskSizeGib') is not None:
            self.root_disk_size_gib = m.get('RootDiskSizeGib')
        if m.get('UserDiskPerformanceLevel') is not None:
            self.user_disk_performance_level = m.get('UserDiskPerformanceLevel')
        if m.get('UserDiskSizeGib') is not None:
            self.user_disk_size_gib = m.get('UserDiskSizeGib')
        return self


class CreateBundleResponseBody(TeaModel):
    def __init__(self, bundle_id=None, request_id=None):
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateBundleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateBundleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateBundleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateBundleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateBundleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCdsFileRequest(TeaModel):
    def __init__(self, cds_id=None, conflict_policy=None, end_user_id=None, file_hash=None, file_length=None,
                 file_name=None, file_type=None, parent_file_id=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.conflict_policy = conflict_policy  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_hash = file_hash  # type: str
        self.file_length = file_length  # type: long
        self.file_name = file_name  # type: str
        self.file_type = file_type  # type: str
        self.parent_file_id = parent_file_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.conflict_policy is not None:
            result['ConflictPolicy'] = self.conflict_policy
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_hash is not None:
            result['FileHash'] = self.file_hash
        if self.file_length is not None:
            result['FileLength'] = self.file_length
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.parent_file_id is not None:
            result['ParentFileId'] = self.parent_file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('ConflictPolicy') is not None:
            self.conflict_policy = m.get('ConflictPolicy')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileHash') is not None:
            self.file_hash = m.get('FileHash')
        if m.get('FileLength') is not None:
            self.file_length = m.get('FileLength')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('ParentFileId') is not None:
            self.parent_file_id = m.get('ParentFileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateCdsFileResponseBodyFileModel(TeaModel):
    def __init__(self, file_id=None, upload_id=None, upload_url=None):
        self.file_id = file_id  # type: str
        self.upload_id = upload_id  # type: str
        self.upload_url = upload_url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCdsFileResponseBodyFileModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.upload_id is not None:
            result['UploadId'] = self.upload_id
        if self.upload_url is not None:
            result['UploadUrl'] = self.upload_url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('UploadId') is not None:
            self.upload_id = m.get('UploadId')
        if m.get('UploadUrl') is not None:
            self.upload_url = m.get('UploadUrl')
        return self


class CreateCdsFileResponseBody(TeaModel):
    def __init__(self, file_model=None, request_id=None):
        self.file_model = file_model  # type: CreateCdsFileResponseBodyFileModel
        self.request_id = request_id  # type: str

    def validate(self):
        if self.file_model:
            self.file_model.validate()

    def to_map(self):
        _map = super(CreateCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_model is not None:
            result['FileModel'] = self.file_model.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileModel') is not None:
            temp_model = CreateCdsFileResponseBodyFileModel()
            self.file_model = temp_model.from_map(m['FileModel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateCdsFileShareLinkRequest(TeaModel):
    def __init__(self, cds_id=None, description=None, disable_download=None, disable_preview=None,
                 disable_save=None, download_limit=None, end_user_id=None, expiration=None, file_ids=None, preview_limit=None,
                 save_limit=None, share_name=None, share_pwd=None):
        self.cds_id = cds_id  # type: str
        self.description = description  # type: str
        self.disable_download = disable_download  # type: bool
        self.disable_preview = disable_preview  # type: bool
        self.disable_save = disable_save  # type: bool
        self.download_limit = download_limit  # type: long
        self.end_user_id = end_user_id  # type: str
        self.expiration = expiration  # type: str
        self.file_ids = file_ids  # type: list[str]
        self.preview_limit = preview_limit  # type: long
        self.save_limit = save_limit  # type: long
        self.share_name = share_name  # type: str
        self.share_pwd = share_pwd  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateCdsFileShareLinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.description is not None:
            result['Description'] = self.description
        if self.disable_download is not None:
            result['DisableDownload'] = self.disable_download
        if self.disable_preview is not None:
            result['DisablePreview'] = self.disable_preview
        if self.disable_save is not None:
            result['DisableSave'] = self.disable_save
        if self.download_limit is not None:
            result['DownloadLimit'] = self.download_limit
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.preview_limit is not None:
            result['PreviewLimit'] = self.preview_limit
        if self.save_limit is not None:
            result['SaveLimit'] = self.save_limit
        if self.share_name is not None:
            result['ShareName'] = self.share_name
        if self.share_pwd is not None:
            result['SharePwd'] = self.share_pwd
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisableDownload') is not None:
            self.disable_download = m.get('DisableDownload')
        if m.get('DisablePreview') is not None:
            self.disable_preview = m.get('DisablePreview')
        if m.get('DisableSave') is not None:
            self.disable_save = m.get('DisableSave')
        if m.get('DownloadLimit') is not None:
            self.download_limit = m.get('DownloadLimit')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('PreviewLimit') is not None:
            self.preview_limit = m.get('PreviewLimit')
        if m.get('SaveLimit') is not None:
            self.save_limit = m.get('SaveLimit')
        if m.get('ShareName') is not None:
            self.share_name = m.get('ShareName')
        if m.get('SharePwd') is not None:
            self.share_pwd = m.get('SharePwd')
        return self


class CreateCdsFileShareLinkResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: CdsFileShareLinkModel
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(CreateCdsFileShareLinkResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CdsFileShareLinkModel()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateCdsFileShareLinkResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateCdsFileShareLinkResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateCdsFileShareLinkResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateCdsFileShareLinkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDesktopGroupRequest(TeaModel):
    def __init__(self, all_classify_users=None, allow_auto_setup=None, allow_buffer_count=None, auto_pay=None,
                 auto_renew=None, bind_amount=None, bundle_id=None, buy_desktops_count=None, charge_type=None, classify=None,
                 client_token=None, comments=None, connect_duration=None, default_init_desktop_count=None,
                 desktop_group_name=None, directory_id=None, end_user_ids=None, file_system_id=None, group_version=None,
                 idle_disconnect_duration=None, keep_duration=None, load_policy=None, max_desktops_count=None, min_desktops_count=None,
                 office_site_id=None, own_type=None, period=None, period_unit=None, policy_group_id=None,
                 profile_follow_switch=None, ratio_threshold=None, region_id=None, reset_type=None, scale_strategy_id=None,
                 stop_duration=None, volume_encryption_enabled=None, volume_encryption_key=None, vpc_id=None):
        # The end users whom you want to add to all types of desktop groups.
        self.all_classify_users = all_classify_users  # type: bool
        # Specifies whether to automatically create cloud desktops in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required.
        self.allow_auto_setup = allow_auto_setup  # type: int
        # Specifies whether to reserve cloud desktops if you set the billing method to pay-as-you-go. If you set the ChargeType parameter to PostPaid, this parameter is required. Valid values: 0: does not allow the system to reserve cloud desktops. N: allows the system to reserve N cloud desktops. The variable N must be an integer that ranges from 1 to 100.
        self.allow_buffer_count = allow_buffer_count  # type: int
        # Specifies whether to enable automatic payment.
        self.auto_pay = auto_pay  # type: bool
        # 是否自动续费。
        self.auto_renew = auto_renew  # type: bool
        # The number of sessions that are allowed per cloud desktop in a multi-session desktop group.
        self.bind_amount = bind_amount  # type: long
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The number of cloud desktops that you want to purchase. Valid values: 0 to 200.
        self.buy_desktops_count = buy_desktops_count  # type: int
        # The billing method of the cloud desktops in the desktop group.
        self.charge_type = charge_type  # type: str
        # The type of the desktop group.
        self.classify = classify  # type: str
        # The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
        self.client_token = client_token  # type: str
        # The remarks on the desktop group.
        self.comments = comments  # type: str
        # The maximum period of time during which the session is connected. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
        self.connect_duration = connect_duration  # type: long
        # The default number of cloud desktops to create when you create the desktop group. Default value: 1.
        self.default_init_desktop_count = default_init_desktop_count  # type: int
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # The ID of the directory.
        self.directory_id = directory_id  # type: str
        # The end users that can use the desktop group.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The Apsara File Storage NAS (NAS) file system that is used after data roaming is enabled.
        self.file_system_id = file_system_id  # type: str
        # 桌面组版本。
        self.group_version = group_version  # type: int
        # The maximum period of time for which a session remains idle. If an end user performs no operations on a cloud desktop by using keyboards or mouses during a session, the session becomes idle. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
        self.idle_disconnect_duration = idle_disconnect_duration  # type: long
        # The retention period of the cloud desktop after the end user disconnects from the cloud desktop. Unit: milliseconds.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy of the multi-session desktop group.
        self.load_policy = load_policy  # type: long
        # The maximum number of cloud desktops that the desktop group can contain. Valid values: 0 to 200.
        self.max_desktops_count = max_desktops_count  # type: int
        # The minimum number of cloud desktops that must be contained in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values: 0 to the value of MaxDesktopsCount. Default value: 1.
        self.min_desktops_count = min_desktops_count  # type: int
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The type of the desktop group.
        self.own_type = own_type  # type: int
        # The subscription period of the cloud desktops in the desktop group. The unit is specified by the PeriodUnit parameter. The Period parameter takes effect only if you set the ChargeType parameter to PrePaid.
        # 
        # *   Valid values if you set the PeriodUnit parameter to Month:
        # 
        #     *   1
        #     *   2
        #     *   3
        #     *   6
        # 
        # *   Valid values if you set the PeriodUnit parameter to Year:
        # 
        #     *   1
        #     *   2
        #     *   3
        #     *   4
        #     *   5
        self.period = period  # type: int
        # The unit of the subscription duration.
        self.period_unit = period_unit  # type: str
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # Specifies whether to enable data roaming.
        self.profile_follow_switch = profile_follow_switch  # type: bool
        # The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops × Maximum number of sessions allowed for each cloud desktop) × 100%`. When the specified threshold is reached, new cloud desktops are automatically created. When the specified threshold is not reached, idle cloud desktops are released.
        self.ratio_threshold = ratio_threshold  # type: float
        # The ID of the region.
        self.region_id = region_id  # type: str
        # Specifies which type of the disk to reset for cloud desktops in the desktop group.
        self.reset_type = reset_type  # type: long
        # The ID of the scaling policy.
        # 
        # > This parameter is unavailable.
        self.scale_strategy_id = scale_strategy_id  # type: str
        # The period of time before the idle cloud desktop is stopped. When the specified period of time is reached, the idle cloud desktop automatically stops. If an end user connects to a stopped cloud desktop, the cloud desktop automatically starts. Unit: milliseconds.
        self.stop_duration = stop_duration  # type: long
        # Specifies whether to enable disk encryption.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str
        # The ID of the virtual private cloud (VPC) in which you want to create the desktop group.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all_classify_users is not None:
            result['AllClassifyUsers'] = self.all_classify_users
        if self.allow_auto_setup is not None:
            result['AllowAutoSetup'] = self.allow_auto_setup
        if self.allow_buffer_count is not None:
            result['AllowBufferCount'] = self.allow_buffer_count
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.bind_amount is not None:
            result['BindAmount'] = self.bind_amount
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.buy_desktops_count is not None:
            result['BuyDesktopsCount'] = self.buy_desktops_count
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.client_token is not None:
            result['ClientToken'] = self.client_token
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.connect_duration is not None:
            result['ConnectDuration'] = self.connect_duration
        if self.default_init_desktop_count is not None:
            result['DefaultInitDesktopCount'] = self.default_init_desktop_count
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.group_version is not None:
            result['GroupVersion'] = self.group_version
        if self.idle_disconnect_duration is not None:
            result['IdleDisconnectDuration'] = self.idle_disconnect_duration
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_desktops_count is not None:
            result['MaxDesktopsCount'] = self.max_desktops_count
        if self.min_desktops_count is not None:
            result['MinDesktopsCount'] = self.min_desktops_count
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.own_type is not None:
            result['OwnType'] = self.own_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.profile_follow_switch is not None:
            result['ProfileFollowSwitch'] = self.profile_follow_switch
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        if self.scale_strategy_id is not None:
            result['ScaleStrategyId'] = self.scale_strategy_id
        if self.stop_duration is not None:
            result['StopDuration'] = self.stop_duration
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllClassifyUsers') is not None:
            self.all_classify_users = m.get('AllClassifyUsers')
        if m.get('AllowAutoSetup') is not None:
            self.allow_auto_setup = m.get('AllowAutoSetup')
        if m.get('AllowBufferCount') is not None:
            self.allow_buffer_count = m.get('AllowBufferCount')
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('BindAmount') is not None:
            self.bind_amount = m.get('BindAmount')
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('BuyDesktopsCount') is not None:
            self.buy_desktops_count = m.get('BuyDesktopsCount')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('ClientToken') is not None:
            self.client_token = m.get('ClientToken')
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('ConnectDuration') is not None:
            self.connect_duration = m.get('ConnectDuration')
        if m.get('DefaultInitDesktopCount') is not None:
            self.default_init_desktop_count = m.get('DefaultInitDesktopCount')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('GroupVersion') is not None:
            self.group_version = m.get('GroupVersion')
        if m.get('IdleDisconnectDuration') is not None:
            self.idle_disconnect_duration = m.get('IdleDisconnectDuration')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxDesktopsCount') is not None:
            self.max_desktops_count = m.get('MaxDesktopsCount')
        if m.get('MinDesktopsCount') is not None:
            self.min_desktops_count = m.get('MinDesktopsCount')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OwnType') is not None:
            self.own_type = m.get('OwnType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('ProfileFollowSwitch') is not None:
            self.profile_follow_switch = m.get('ProfileFollowSwitch')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        if m.get('ScaleStrategyId') is not None:
            self.scale_strategy_id = m.get('ScaleStrategyId')
        if m.get('StopDuration') is not None:
            self.stop_duration = m.get('StopDuration')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateDesktopGroupResponseBody(TeaModel):
    def __init__(self, desktop_group_id=None, order_ids=None, request_id=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the orders.
        self.order_ids = order_ids  # type: list[str]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.order_ids is not None:
            result['OrderIds'] = self.order_ids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('OrderIds') is not None:
            self.order_ids = m.get('OrderIds')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDesktopsRequestBundleModels(TeaModel):
    def __init__(self, amount=None, bundle_id=None, desktop_name=None, end_user_ids=None, hostname=None,
                 volume_encryption_enabled=None, volume_encryption_key=None):
        # The number of cloud desktops that you want to create. Valid values: 1 to 300. Default value: 0.
        self.amount = amount  # type: int
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The users to whom you want to assign the cloud desktops.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The hostname that you specify for the cloud desktop. You can only specify the hostname of a Windows cloud desktop in the workspace of the enterprise AD account type.
        # 
        # The hostname must meet the following requirements:
        # 
        # *   It must be 2 to 15 characters in length.
        # *   It can contain letters, digits, and hyphens (-). The hostname cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
        # 
        # If you create multiple cloud desktops, you can use the`  name_prefix[begin_number,bits]name_suffix ` format to determine the hostnames of the cloud desktops. For example, if you set Hostname to ecd-\[1,4]-test, the hostname of the first cloud desktop is ecd-0001-test and the hostname of the second cloud desktop is ecd-0002-test. Other hostnames follow the same rule.
        # 
        # *   `name_prefix`: the prefix of the hostname.
        # *   `[begin_number,bits]`: the ordered numbers in the hostname. begin_number: the start number. Valid values: 0 to 999999. Default value: 0. bits: the digit. Valid values: 1 to 6. Default value: 6.
        # *   `name_suffix`: the suffix of the hostname.
        self.hostname = hostname  # type: str
        # Specifies whether to enable disk encryption.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopsRequestBundleModels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.hostname is not None:
            result['Hostname'] = self.hostname
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('Hostname') is not None:
            self.hostname = m.get('Hostname')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        return self


class CreateDesktopsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag. You can specify 1 to 20 keys for a tag.
        self.key = key  # type: str
        # The value of the tag. You can specify 1 to 20 values for a tag.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class CreateDesktopsRequestUserCommands(TeaModel):
    def __init__(self, content=None, content_encoding=None, content_type=None):
        # The content of the command.
        self.content = content  # type: str
        # The encoding mode of the command content (CommandContent).
        self.content_encoding = content_encoding  # type: str
        # The language type of the command.
        self.content_type = content_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopsRequestUserCommands, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.content is not None:
            result['Content'] = self.content
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Content') is not None:
            self.content = m.get('Content')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        return self


class CreateDesktopsRequest(TeaModel):
    def __init__(self, amount=None, auto_pay=None, auto_renew=None, bundle_id=None, bundle_models=None,
                 charge_type=None, desktop_name=None, desktop_name_suffix=None, directory_id=None, end_user_id=None,
                 group_id=None, hostname=None, office_site_id=None, period=None, period_unit=None, policy_group_id=None,
                 promotion_id=None, region_id=None, tag=None, user_assign_mode=None, user_commands=None, user_name=None,
                 volume_encryption_enabled=None, volume_encryption_key=None, vpc_id=None):
        # The number of cloud desktops that you want to create. Valid values: 1 to 300. Default value: 1.
        self.amount = amount  # type: int
        # Specifies whether to enable automatic payment.
        self.auto_pay = auto_pay  # type: bool
        # Specifies whether to enable auto-renewal. This parameter takes effect only when the ChargeType parameter is set to PrePaid.````
        self.auto_renew = auto_renew  # type: bool
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The desktop templates that you want to use.
        self.bundle_models = bundle_models  # type: list[CreateDesktopsRequestBundleModels]
        # The billing method of the cloud desktop.
        self.charge_type = charge_type  # type: str
        # The name of the cloud desktop. The name must meet the following requirements:
        # 
        # *   The name must be 1 to 64 characters in length.
        # *   The name can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-). It must start with a letter but cannot start with http:// or https://.
        self.desktop_name = desktop_name  # type: str
        # Specifies whether to automatically add a suffix to the cloud desktop name when you create multiple cloud desktops at a time.
        self.desktop_name_suffix = desktop_name_suffix  # type: bool
        # This parameter is not available.
        self.directory_id = directory_id  # type: str
        # The IDs of the users that you want to authorize to use the cloud desktop. The cloud desktop is assigned to the users. You can specify IDs of 1 to 100 users.
        # 
        # *   Only one user can use the cloud desktop at a time.
        # *   If you do not specify the `EndUserId` parameter, the cloud desktop that you create is not assigned to users.
        self.end_user_id = end_user_id  # type: list[str]
        # The ID of the desktop group.
        self.group_id = group_id  # type: str
        # The hostname that you specify for the cloud desktop. You can specify only the hostname of a Windows cloud desktop in the workspace of the enterprise AD account type.
        # 
        # The hostname must meet the following requirements:
        # 
        # *   It must be 2 to 15 characters in length.
        # *   It can contain letters, digits, and hyphens (-). The hostname cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
        # 
        # If you create multiple cloud desktops, you can use the`  name_prefix[begin_number,bits]name_suffix ` format to determine the hostnames of the cloud desktops. For example, if you set Hostname to ecd-\[1,4]-test, the hostname of the first cloud desktop is ecd-0001-test and the hostname of the second cloud desktop is ecd-0002-test. Other hostnames follow the same rule.
        # 
        # *   `name_prefix`: the prefix of the hostname.
        # *   `[begin_number,bits]`: the ordered numbers in the hostname. begin_number: the start number. Valid values: 0 to 999999. Default value: 0. bits: the digit. Valid values: 1 to 6. Default value: 6.
        # *   `name_suffix`: the suffix of the hostname.
        self.hostname = hostname  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The subscription duration of the cloud desktop that you want to create. The unit is specified by the `PeriodUnit` parameter. This parameter takes effect and is required only when the `ChargeType` parameter is set to `PrePaid`.
        # 
        # *   Valid values if the `PeriodUnit` parameter is set to `Month`:
        # 
        #     *   1
        #     *   2
        #     *   3
        #     *   6
        # 
        # *   Valid values if the `PeriodUnit` parameter is set to `Year`:
        # 
        #     *   1
        #     *   2
        #     *   3
        #     *   4
        #     *   5
        self.period = period  # type: int
        # The unit of the subscription duration.
        self.period_unit = period_unit  # type: str
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the sales promotion.
        self.promotion_id = promotion_id  # type: str
        # The region ID. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The tags that you want to add to the cloud desktop.
        self.tag = tag  # type: list[CreateDesktopsRequestTag]
        # The assignment mode of the cloud desktop.
        # 
        # > If you do not specify the `EndUserId` parameter, the cloud desktop that you create is not assigned to users.
        self.user_assign_mode = user_assign_mode  # type: str
        # The custom command scripts of the user.
        self.user_commands = user_commands  # type: list[CreateDesktopsRequestUserCommands]
        # This parameter is not available.
        self.user_name = user_name  # type: str
        # Specifies whether to enable disk encryption.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that you want to use when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str
        # This parameter is not available.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.bundle_models:
            for k in self.bundle_models:
                if k:
                    k.validate()
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()
        if self.user_commands:
            for k in self.user_commands:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreateDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.amount is not None:
            result['Amount'] = self.amount
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        result['BundleModels'] = []
        if self.bundle_models is not None:
            for k in self.bundle_models:
                result['BundleModels'].append(k.to_map() if k else None)
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_name_suffix is not None:
            result['DesktopNameSuffix'] = self.desktop_name_suffix
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.hostname is not None:
            result['Hostname'] = self.hostname
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.user_assign_mode is not None:
            result['UserAssignMode'] = self.user_assign_mode
        result['UserCommands'] = []
        if self.user_commands is not None:
            for k in self.user_commands:
                result['UserCommands'].append(k.to_map() if k else None)
        if self.user_name is not None:
            result['UserName'] = self.user_name
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Amount') is not None:
            self.amount = m.get('Amount')
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        self.bundle_models = []
        if m.get('BundleModels') is not None:
            for k in m.get('BundleModels'):
                temp_model = CreateDesktopsRequestBundleModels()
                self.bundle_models.append(temp_model.from_map(k))
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopNameSuffix') is not None:
            self.desktop_name_suffix = m.get('DesktopNameSuffix')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('Hostname') is not None:
            self.hostname = m.get('Hostname')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = CreateDesktopsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UserAssignMode') is not None:
            self.user_assign_mode = m.get('UserAssignMode')
        self.user_commands = []
        if m.get('UserCommands') is not None:
            for k in m.get('UserCommands'):
                temp_model = CreateDesktopsRequestUserCommands()
                self.user_commands.append(temp_model.from_map(k))
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class CreateDesktopsResponseBody(TeaModel):
    def __init__(self, desktop_id=None, order_id=None, request_id=None):
        # If multiple cloud desktops are created in a call, the IDs of the cloud desktops are returned.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the order.
        # 
        # > This parameter is returned only when you set the ChargeType parameter to PrePaid.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateDiskEncryptionServiceRequest(TeaModel):
    def __init__(self, region_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiskEncryptionServiceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateDiskEncryptionServiceResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None, success=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values:
        # 
        # *   `true`: The request was successful.
        # *   `false`: The request failed.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateDiskEncryptionServiceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class CreateDiskEncryptionServiceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateDiskEncryptionServiceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateDiskEncryptionServiceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateDiskEncryptionServiceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateImageRequest(TeaModel):
    def __init__(self, auto_clean_userdata=None, description=None, desktop_id=None, disk_type=None, image_name=None,
                 image_resource_type=None, region_id=None, snapshot_id=None, snapshot_ids=None):
        # Specifies whether to clear private data of users. If you set AutoCleanUserdata to `true`, the custom image clears the data directories, excluding the `Administrator` and `Public` directories, in the `C:\Users` directory.
        self.auto_clean_userdata = auto_clean_userdata  # type: bool
        # The description of the custom image. The description must be 2 to 256 characters in length. It cannot start with `http://` or `https://`.
        self.description = description  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The disk data that is contained in the custom image.
        self.disk_type = disk_type  # type: str
        # The name of the custom image. The name must be 2 to 128 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
        self.image_name = image_name  # type: str
        # This parameter is not available to the public.
        self.image_resource_type = image_resource_type  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The ID of the snapshot.
        self.snapshot_ids = snapshot_ids  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_clean_userdata is not None:
            result['AutoCleanUserdata'] = self.auto_clean_userdata
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_resource_type is not None:
            result['ImageResourceType'] = self.image_resource_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_ids is not None:
            result['SnapshotIds'] = self.snapshot_ids
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoCleanUserdata') is not None:
            self.auto_clean_userdata = m.get('AutoCleanUserdata')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageResourceType') is not None:
            self.image_resource_type = m.get('ImageResourceType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotIds') is not None:
            self.snapshot_ids = m.get('SnapshotIds')
        return self


class CreateImageResponseBody(TeaModel):
    def __init__(self, image_id=None, request_id=None):
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNASFileSystemRequest(TeaModel):
    def __init__(self, description=None, encrypt_type=None, name=None, office_site_id=None, region_id=None,
                 storage_type=None):
        # The description of the NAS file system.
        self.description = description  # type: str
        # Specifies whether to encrypt the data in the NAS file system. You can use keys that are managed by Key Management Service (KMS) to encrypt the data that is stored in a NAS file system. When you read and write the encrypted data, the data is automatically decrypted. Valid values:
        # 
        # *   0: does not encrypt the data in the NAS file system.
        # *   1: encrypts the data in the NAS file system by using NAS-managed keys.
        # 
        # Default value: 0.
        self.encrypt_type = encrypt_type  # type: str
        self.name = name  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The storage type of the NAS file system. Valid values:
        # 
        # *   Capacity
        # *   Performance
        # 
        # Default value: Capacity.
        self.storage_type = storage_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNASFileSystemRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.encrypt_type is not None:
            result['EncryptType'] = self.encrypt_type
        if self.name is not None:
            result['Name'] = self.name
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EncryptType') is not None:
            self.encrypt_type = m.get('EncryptType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        return self


class CreateNASFileSystemResponseBody(TeaModel):
    def __init__(self, file_system_id=None, file_system_name=None, mount_target_domain=None, office_site_id=None,
                 request_id=None):
        # The ID of the NAS file system.
        self.file_system_id = file_system_id  # type: str
        # The name of the NAS file system.
        self.file_system_name = file_system_name  # type: str
        # The domain name of the mount target.
        self.mount_target_domain = mount_target_domain  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNASFileSystemResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNASFileSystemResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateNASFileSystemResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateNASFileSystemResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNASFileSystemResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateNetworkPackageRequest(TeaModel):
    def __init__(self, auto_pay=None, auto_renew=None, bandwidth=None, internet_charge_type=None,
                 office_site_id=None, pay_type=None, period=None, period_unit=None, promotion_id=None, region_id=None):
        # Specifies whether to enable automatic payment.
        self.auto_pay = auto_pay  # type: bool
        # Specifies whether to enable auto-renewal.
        self.auto_renew = auto_renew  # type: bool
        # The maximum public bandwidth. Unit: Mbit/s.\
        # Valid values for the pay-by-data-transfer type (PayByTraffic): 10 to 200. Valid values for the pay-by-bandwith type (PayByBandwidth): 10 to 1000.
        self.bandwidth = bandwidth  # type: int
        # The metering method of the pay-as-you-go Internet access package. Valid values: PayByTraffic: pay-by-data-transfer. PayByBandwidth: pay-by-bandwidth. Default value: PayByTraffic.
        self.internet_charge_type = internet_charge_type  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The billing method of the Internet access package.
        self.pay_type = pay_type  # type: str
        # The duration of the Internet access package.
        self.period = period  # type: int
        # The unit of duration that you want to use for the Internet access package.
        self.period_unit = period_unit  # type: str
        # The ID of the sales promotion.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkPackageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.auto_renew is not None:
            result['AutoRenew'] = self.auto_renew
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('AutoRenew') is not None:
            self.auto_renew = m.get('AutoRenew')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class CreateNetworkPackageResponseBody(TeaModel):
    def __init__(self, network_package_id=None, order_id=None, request_id=None):
        # The ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the bill.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateNetworkPackageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateNetworkPackageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateNetworkPackageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateNetworkPackageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateNetworkPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreatePolicyGroupRequestAuthorizeAccessPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None):
        # The IPv4 CIDR block that you want to access from the client. The value is an IPv4 CIDR block.
        self.cidr_ip = cidr_ip  # type: str
        # The description of the client IP address whitelist.
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePolicyGroupRequestAuthorizeAccessPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class CreatePolicyGroupRequestAuthorizeSecurityPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None, ip_protocol=None, policy=None, port_range=None, priority=None,
                 type=None):
        # The IPv4 CIDR block of the security group rule.
        self.cidr_ip = cidr_ip  # type: str
        # The description of the security group rule.
        self.description = description  # type: str
        # The protocol type of the security group rule.
        # 
        # Valid values:
        # 
        # *   TCP
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   UDP
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   ALL: all protocols
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   GRE
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   ICMP: ICMP (IPv4)
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.ip_protocol = ip_protocol  # type: str
        # The authorization policy of the security group rule.
        # 
        # Valid values:
        # 
        # *   drop: denies all access requests
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     If no denied messages are returned, the requests timed out or failed.
        # 
        #     <!-- -->
        # 
        # *   accept: accepts all access requests
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     This value is the default value.
        # 
        #     <!-- -->
        self.policy = policy  # type: str
        # The port range of the security group rule. The value range of this parameter varies based on the value of the IpProtocol parameter.
        # 
        # *   If you set the IpProtocol parameter to TCP or UDP, the value range is 1 to 65535. Separate the start port number and the end port number with a forward slash (/). Example: 1/200.
        # *   If you set the IpProtocol parameter to ICMP, the start port number and the end port number are -1/-1.
        # *   If you set the IpProtocol parameter to GRE, the start port number and the end port number are -1/-1.
        # *   If you set the IpProtocol parameter to ALL, the start port number and the end port number are -1/-1.
        # 
        # For more information about the common ports of applications, see [Common ports](~~40724~~).
        self.port_range = port_range  # type: str
        # The priority of the security group rule. A smaller value specifies a higher priority.\
        # Valid values: 1 to 60.\
        # Default value: 1.
        self.priority = priority  # type: str
        # The direction of the security group rule.
        # 
        # Valid values:
        # 
        # *   outflow: outbound
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   inflow: inbound
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePolicyGroupRequestAuthorizeSecurityPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class CreatePolicyGroupRequestClientType(TeaModel):
    def __init__(self, client_type=None, status=None):
        # The type of the client.
        # 
        # > By default, if you do not specify the ClientType parameter, all types of clients can be used to connect to cloud desktops.
        # 
        # Valid values:
        # 
        # *   html5: web clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   android: Android clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   linux: Alibaba Cloud Workspace clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   ios: iOS clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   windows: Windows clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   macos: macOS clients
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.client_type = client_type  # type: str
        # Specifies whether a specific client type can be used to connect to the cloud desktop.
        # 
        # > By default, if you do not specify the ClientType parameter, all types of clients can be used to connect to cloud desktops.
        # 
        # Valid values:
        # 
        # *   OFF: Clients of the specified type cannot be used to connect to cloud desktops.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   ON: Clients of the specified type can be used to connect to cloud desktops.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePolicyGroupRequestClientType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class CreatePolicyGroupRequestUsbSupplyRedirectRule(TeaModel):
    def __init__(self, description=None, device_class=None, device_subclass=None, product_id=None,
                 usb_redirect_type=None, usb_rule_type=None, vendor_id=None):
        # The description of the rule.
        self.description = description  # type: str
        # The class of the device. If you set the `usbRuleType` parameter to 1, you must specify this parameter. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
        self.device_class = device_class  # type: str
        # The subclass of the device. If you set the `usbRuleType` parameter to 1, you must specify this parameter. For more information, see [Defined Class Codes](https://www.usb.org/defined-class-codes).
        self.device_subclass = device_subclass  # type: str
        # The ID of the service.
        self.product_id = product_id  # type: str
        # The type of USB redirection.
        # 
        # Valid values:
        # 
        # *   1: allows USB redirection
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   2: forbids USB redirection
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.usb_redirect_type = usb_redirect_type  # type: long
        # The type of the USB redirection rule.
        # 
        # Valid values:
        # 
        # *   1: by device class
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   2: by device vendor
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.usb_rule_type = usb_rule_type  # type: long
        # The ID of the vendor. For more information, see [Valid USB Vendor IDs (VIDs)](https://www.usb.org/sites/default/files/vendor_ids032322.pdf\_1.pdf).
        self.vendor_id = vendor_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePolicyGroupRequestUsbSupplyRedirectRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device_class is not None:
            result['DeviceClass'] = self.device_class
        if self.device_subclass is not None:
            result['DeviceSubclass'] = self.device_subclass
        if self.product_id is not None:
            result['ProductId'] = self.product_id
        if self.usb_redirect_type is not None:
            result['UsbRedirectType'] = self.usb_redirect_type
        if self.usb_rule_type is not None:
            result['UsbRuleType'] = self.usb_rule_type
        if self.vendor_id is not None:
            result['VendorId'] = self.vendor_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceClass') is not None:
            self.device_class = m.get('DeviceClass')
        if m.get('DeviceSubclass') is not None:
            self.device_subclass = m.get('DeviceSubclass')
        if m.get('ProductId') is not None:
            self.product_id = m.get('ProductId')
        if m.get('UsbRedirectType') is not None:
            self.usb_redirect_type = m.get('UsbRedirectType')
        if m.get('UsbRuleType') is not None:
            self.usb_rule_type = m.get('UsbRuleType')
        if m.get('VendorId') is not None:
            self.vendor_id = m.get('VendorId')
        return self


class CreatePolicyGroupRequest(TeaModel):
    def __init__(self, app_content_protection=None, authorize_access_policy_rule=None,
                 authorize_security_policy_rule=None, camera_redirect=None, client_type=None, clipboard=None, domain_list=None,
                 end_user_apply_admin_coordinate=None, end_user_group_coordinate=None, gpu_acceleration=None, html_5access=None,
                 html_5file_transfer=None, internet_communication_protocol=None, local_drive=None, name=None, net_redirect=None,
                 preempt_login=None, preempt_login_user=None, printer_redirection=None, record_content=None,
                 record_content_expires=None, recording=None, recording_audio=None, recording_duration=None, recording_end_time=None,
                 recording_expires=None, recording_fps=None, recording_start_time=None, region_id=None, remote_coordinate=None,
                 scope=None, scope_value=None, usb_redirect=None, usb_supply_redirect_rule=None, video_redirect=None,
                 visual_quality=None, watermark=None, watermark_color=None, watermark_degree=None, watermark_font_size=None,
                 watermark_font_style=None, watermark_row_amount=None, watermark_transparency=None, watermark_transparency_value=None,
                 watermark_type=None):
        # Specifies whether to enable the anti-screenshot feature.
        # 
        # Valid values:
        # 
        # *   off: Anti-screenshot is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Anti-screenshot is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.app_content_protection = app_content_protection  # type: str
        # The client IP address whitelists. Only the client IP addresses in whitelists can access the cloud desktop.
        self.authorize_access_policy_rule = authorize_access_policy_rule  # type: list[CreatePolicyGroupRequestAuthorizeAccessPolicyRule]
        # The security group rules.
        self.authorize_security_policy_rule = authorize_security_policy_rule  # type: list[CreatePolicyGroupRequestAuthorizeSecurityPolicyRule]
        # Specifies whether to enable the webcam redirection feature.
        # 
        # Valid values:
        # 
        # *   off: Webcam redirection is disabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Webcam redirection is enabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.camera_redirect = camera_redirect  # type: str
        # The logon methods. You can use this parameter to determine which clients can be used to connect to the cloud desktop.
        self.client_type = client_type  # type: list[CreatePolicyGroupRequestClientType]
        # The permissions on the clipboard.
        # 
        # Valid values:
        # 
        # *   read: specifies one-way transfer
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     You can copy data from your local computer to the cloud desktop, but cannot copy data from the cloud desktop to your local computer.
        # 
        #     <!-- -->
        # 
        # *   readwrite: specifies two-way transfer
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     You can copy data between your local computer and the cloud desktop.
        # 
        #     <!-- -->
        # 
        # *   off: disables both one-way and two-way transfer
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     You cannot copy data between your local computer and the cloud desktop. This value is the default value.
        # 
        #     <!-- -->
        self.clipboard = clipboard  # type: str
        # Access control for domain names. The wildcard character (\*) is supported for domain names. Separate multiple domain names with commas (,). Valid values:
        # 
        # *   off
        # *   on
        self.domain_list = domain_list  # type: str
        # Specifies whether to allow end users to seek assistance from the administrator. Valid values: ON OFF
        self.end_user_apply_admin_coordinate = end_user_apply_admin_coordinate  # type: str
        # The switch for collaboration between end users. Valid values: ON OFF
        self.end_user_group_coordinate = end_user_group_coordinate  # type: str
        # Specifies whether to enable the image display quality feature for the Graphics cloud desktop. If you have high requirements for desktop performance and user experience, we recommend that you enable this feature. For example, you can enable this feature in professional design scenarios.
        # 
        # Valid values:
        # 
        # *   off
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.gpu_acceleration = gpu_acceleration  # type: str
        # The policy for HTML5 client access.
        # 
        # > We recommend that you use the ClientType parameter to manage the type of Alibaba Cloud Workspace clients for desktop connection.
        # 
        # Valid values:
        # 
        # *   off: HTML5 client access is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: HTML5 client access is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.html_5access = html_5access  # type: str
        # The file transfer policy for HTML5 clients.
        # 
        # Valid values:
        # 
        # *   all: Files can be uploaded and downloaded between your computer and HTML5 clients.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   download: Files on HTML5 clients can be downloaded to your computer.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   upload: Files on your computer can be uploaded to HTML5 clients.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   off: File transfer between HTML5 clients and your computer is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.html_5file_transfer = html_5file_transfer  # type: str
        # The protocol that you want to use for network communication. Valid values: -TCP: Only TCP is allowed. -BOTH: Automatic switch between TCP and UDP is allowed. Default value: TCP.
        self.internet_communication_protocol = internet_communication_protocol  # type: str
        # The permissions on local disk mapping.
        # 
        # Valid values:
        # 
        # *   read: read-only
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     The disks on your local computer are mapped to the cloud desktop. You can only read (copy) files on the local computer.
        # 
        #     <!-- -->
        # 
        # *   readwrite: read and write
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     The disks on your local computer are mapped to the cloud desktop. You can read (copy) and modify files on your local computer.
        # 
        #     <!-- -->
        # 
        # *   off:
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     The disks on your local computer are not mapped to the cloud desktop. This value is the default value.
        # 
        #     <!-- -->
        self.local_drive = local_drive  # type: str
        # The name of the policy.
        self.name = name  # type: str
        # Specifies whether to enable the network redirection feature.
        # 
        # Valid values:
        # 
        # *   off: Network redirection is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Network redirection is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.net_redirect = net_redirect  # type: str
        # Specifies whether to allow user preemption.
        # 
        # > To improve user experience and ensure data security, multiple end users cannot connect to the same cloud desktop at the same time. The default value of this parameter is `off`, and the value cannot be changed.
        self.preempt_login = preempt_login  # type: str
        # The names of the users that are allowed to connect to the same cloud desktop at the same time. You can specify up to five usernames.
        # 
        # > To improve user experience and ensure data security, we recommend that you disable the user preemption feature.
        self.preempt_login_user = preempt_login_user  # type: list[str]
        # The policy for printer redirection.
        # 
        # Valid values:
        # 
        # *   off: Printer redirection is disabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Printer redirection is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.printer_redirection = printer_redirection  # type: str
        # Specifies whether to enable the custom screen recording feature.
        # 
        # Valid values:
        # 
        # *   off: Custom screen recording is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Custom screen recording is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.record_content = record_content  # type: str
        # The duration in which the custom screen recording is valid. Default value: 30. Unit: days.
        self.record_content_expires = record_content_expires  # type: long
        # Specifies whether to enable screen recording.
        # 
        # Valid values:
        # 
        # *   ALLTIME: All operations that are performed by end users on cloud desktops are recorded. The recording starts immediately when end users connect to cloud desktops and ends when the end users disconnect from the cloud desktops.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   PERIOD: The operations that are performed by end users on cloud desktops during a specified period of time are recorded. You must set the start time and end time for the recording period.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   OFF: Screen recording is disabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.recording = recording  # type: str
        # Specifies whether to record audio data during the screen recording. Valid values:
        # 
        # *   on: records audio and video data
        # *   off: records only video data
        self.recording_audio = recording_audio  # type: str
        # The duration from the time when the screen recording starts to the time when the screen recording stops. If you specify the Recording parameter, you must also specify the RecordingDuration parameter. When the specified duration ends, a recording file is generated.
        self.recording_duration = recording_duration  # type: int
        # The time when the screen recording stops. Specify the value in the HH:MM:SS format. The value of this parameter is valid only if you set the Recording parameter to PERIOD.
        self.recording_end_time = recording_end_time  # type: str
        # The duration in which the screen recording is valid. Unit: days.
        self.recording_expires = recording_expires  # type: long
        # The frame rate of screen recording.
        # 
        # Valid values:
        # 
        # *   2
        # 
        # *   5
        # 
        # *  10
        # 
        # *   15
        self.recording_fps = recording_fps  # type: long
        # The time when screen recording starts. Specify the value in the HH:MM:SS format. The value of this parameter is valid only if you set the Recording parameter to PERIOD.
        self.recording_start_time = recording_start_time  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The permission to control the keyboard and the mouse during remote assistance.
        # 
        # Valid values:
        # 
        # *   \-\
        # 
        #     <!-- -->
        # 
        #     optionalControl
        # 
        #     <!-- -->
        # 
        #     : By default, this feature is disabled. You can enable it by applying permissions.
        # 
        #     <!-- -->
        # 
        # *   fullControl: The permission is granted.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   disableControl: The permission is revoked.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.remote_coordinate = remote_coordinate  # type: str
        # The effective scope of the policy. Valid values:
        # 
        # *   GLOBAL: The policy takes effect globally.
        # *   IP: The policy takes effect for specified IP addresses.
        self.scope = scope  # type: str
        # The effective CIDR block ranges. If you set the Scope parameter to IP, you must specify this parameter.
        self.scope_value = scope_value  # type: list[str]
        # Specifies whether to enable USB redirection.
        # 
        # Valid values:
        # 
        # *   off: USB redirection is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: USB redirection is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.usb_redirect = usb_redirect  # type: str
        # The USB redirection rules.
        self.usb_supply_redirect_rule = usb_supply_redirect_rule  # type: list[CreatePolicyGroupRequestUsbSupplyRedirectRule]
        # Specifies whether to enable the multimedia redirection feature. Valid values:
        # 
        # *   on: Multimedia redirection is enabled.
        # *   off: Multimedia redirection is disabled.
        self.video_redirect = video_redirect  # type: str
        # The policy for image display quality.
        # 
        # Valid values:
        # 
        # *   high
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   low
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   lossless
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   medium: adaptive. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.visual_quality = visual_quality  # type: str
        # Specifies whether to enable watermarking.
        # 
        # Valid values:
        # 
        # *   off: Watermarking is disabled. This value is the default value.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   on: Watermarking is enabled.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.watermark = watermark  # type: str
        # The font color of the watermark. Valid values: 0 to 16777215.
        self.watermark_color = watermark_color  # type: int
        # The inclination angle of the watermark. Valid values: -10 to -30.
        self.watermark_degree = watermark_degree  # type: float
        # The font size of the watermark. Valid values: 10 to 20.
        self.watermark_font_size = watermark_font_size  # type: int
        # The font style of the watermark. Valid values:
        # 
        # *   plain
        # *   bold
        self.watermark_font_style = watermark_font_style  # type: str
        # The number of watermark rows. This parameter is now invalid.
        self.watermark_row_amount = watermark_row_amount  # type: int
        # The transparency of the watermark.
        # 
        # Valid values:
        # 
        # *   LIGHT
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   DARK
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   MIDDLE
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.watermark_transparency = watermark_transparency  # type: str
        # The transparency of the watermark. A larger value specifies that the watermark is less transparent. Valid values: 10 to 100.
        self.watermark_transparency_value = watermark_transparency_value  # type: int
        # The type of the watermark. You can specify multiple types of watermarks at the same time. Separate multiple watermark types with commas (,).
        # 
        # Valid values:
        # 
        # *   EndUserId: The ID of the end user is displayed.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   HostName: The rightmost 15 characters of the cloud desktop ID are displayed.
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.watermark_type = watermark_type  # type: str

    def validate(self):
        if self.authorize_access_policy_rule:
            for k in self.authorize_access_policy_rule:
                if k:
                    k.validate()
        if self.authorize_security_policy_rule:
            for k in self.authorize_security_policy_rule:
                if k:
                    k.validate()
        if self.client_type:
            for k in self.client_type:
                if k:
                    k.validate()
        if self.usb_supply_redirect_rule:
            for k in self.usb_supply_redirect_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(CreatePolicyGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_content_protection is not None:
            result['AppContentProtection'] = self.app_content_protection
        result['AuthorizeAccessPolicyRule'] = []
        if self.authorize_access_policy_rule is not None:
            for k in self.authorize_access_policy_rule:
                result['AuthorizeAccessPolicyRule'].append(k.to_map() if k else None)
        result['AuthorizeSecurityPolicyRule'] = []
        if self.authorize_security_policy_rule is not None:
            for k in self.authorize_security_policy_rule:
                result['AuthorizeSecurityPolicyRule'].append(k.to_map() if k else None)
        if self.camera_redirect is not None:
            result['CameraRedirect'] = self.camera_redirect
        result['ClientType'] = []
        if self.client_type is not None:
            for k in self.client_type:
                result['ClientType'].append(k.to_map() if k else None)
        if self.clipboard is not None:
            result['Clipboard'] = self.clipboard
        if self.domain_list is not None:
            result['DomainList'] = self.domain_list
        if self.end_user_apply_admin_coordinate is not None:
            result['EndUserApplyAdminCoordinate'] = self.end_user_apply_admin_coordinate
        if self.end_user_group_coordinate is not None:
            result['EndUserGroupCoordinate'] = self.end_user_group_coordinate
        if self.gpu_acceleration is not None:
            result['GpuAcceleration'] = self.gpu_acceleration
        if self.html_5access is not None:
            result['Html5Access'] = self.html_5access
        if self.html_5file_transfer is not None:
            result['Html5FileTransfer'] = self.html_5file_transfer
        if self.internet_communication_protocol is not None:
            result['InternetCommunicationProtocol'] = self.internet_communication_protocol
        if self.local_drive is not None:
            result['LocalDrive'] = self.local_drive
        if self.name is not None:
            result['Name'] = self.name
        if self.net_redirect is not None:
            result['NetRedirect'] = self.net_redirect
        if self.preempt_login is not None:
            result['PreemptLogin'] = self.preempt_login
        if self.preempt_login_user is not None:
            result['PreemptLoginUser'] = self.preempt_login_user
        if self.printer_redirection is not None:
            result['PrinterRedirection'] = self.printer_redirection
        if self.record_content is not None:
            result['RecordContent'] = self.record_content
        if self.record_content_expires is not None:
            result['RecordContentExpires'] = self.record_content_expires
        if self.recording is not None:
            result['Recording'] = self.recording
        if self.recording_audio is not None:
            result['RecordingAudio'] = self.recording_audio
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.recording_end_time is not None:
            result['RecordingEndTime'] = self.recording_end_time
        if self.recording_expires is not None:
            result['RecordingExpires'] = self.recording_expires
        if self.recording_fps is not None:
            result['RecordingFps'] = self.recording_fps
        if self.recording_start_time is not None:
            result['RecordingStartTime'] = self.recording_start_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remote_coordinate is not None:
            result['RemoteCoordinate'] = self.remote_coordinate
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        if self.usb_redirect is not None:
            result['UsbRedirect'] = self.usb_redirect
        result['UsbSupplyRedirectRule'] = []
        if self.usb_supply_redirect_rule is not None:
            for k in self.usb_supply_redirect_rule:
                result['UsbSupplyRedirectRule'].append(k.to_map() if k else None)
        if self.video_redirect is not None:
            result['VideoRedirect'] = self.video_redirect
        if self.visual_quality is not None:
            result['VisualQuality'] = self.visual_quality
        if self.watermark is not None:
            result['Watermark'] = self.watermark
        if self.watermark_color is not None:
            result['WatermarkColor'] = self.watermark_color
        if self.watermark_degree is not None:
            result['WatermarkDegree'] = self.watermark_degree
        if self.watermark_font_size is not None:
            result['WatermarkFontSize'] = self.watermark_font_size
        if self.watermark_font_style is not None:
            result['WatermarkFontStyle'] = self.watermark_font_style
        if self.watermark_row_amount is not None:
            result['WatermarkRowAmount'] = self.watermark_row_amount
        if self.watermark_transparency is not None:
            result['WatermarkTransparency'] = self.watermark_transparency
        if self.watermark_transparency_value is not None:
            result['WatermarkTransparencyValue'] = self.watermark_transparency_value
        if self.watermark_type is not None:
            result['WatermarkType'] = self.watermark_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppContentProtection') is not None:
            self.app_content_protection = m.get('AppContentProtection')
        self.authorize_access_policy_rule = []
        if m.get('AuthorizeAccessPolicyRule') is not None:
            for k in m.get('AuthorizeAccessPolicyRule'):
                temp_model = CreatePolicyGroupRequestAuthorizeAccessPolicyRule()
                self.authorize_access_policy_rule.append(temp_model.from_map(k))
        self.authorize_security_policy_rule = []
        if m.get('AuthorizeSecurityPolicyRule') is not None:
            for k in m.get('AuthorizeSecurityPolicyRule'):
                temp_model = CreatePolicyGroupRequestAuthorizeSecurityPolicyRule()
                self.authorize_security_policy_rule.append(temp_model.from_map(k))
        if m.get('CameraRedirect') is not None:
            self.camera_redirect = m.get('CameraRedirect')
        self.client_type = []
        if m.get('ClientType') is not None:
            for k in m.get('ClientType'):
                temp_model = CreatePolicyGroupRequestClientType()
                self.client_type.append(temp_model.from_map(k))
        if m.get('Clipboard') is not None:
            self.clipboard = m.get('Clipboard')
        if m.get('DomainList') is not None:
            self.domain_list = m.get('DomainList')
        if m.get('EndUserApplyAdminCoordinate') is not None:
            self.end_user_apply_admin_coordinate = m.get('EndUserApplyAdminCoordinate')
        if m.get('EndUserGroupCoordinate') is not None:
            self.end_user_group_coordinate = m.get('EndUserGroupCoordinate')
        if m.get('GpuAcceleration') is not None:
            self.gpu_acceleration = m.get('GpuAcceleration')
        if m.get('Html5Access') is not None:
            self.html_5access = m.get('Html5Access')
        if m.get('Html5FileTransfer') is not None:
            self.html_5file_transfer = m.get('Html5FileTransfer')
        if m.get('InternetCommunicationProtocol') is not None:
            self.internet_communication_protocol = m.get('InternetCommunicationProtocol')
        if m.get('LocalDrive') is not None:
            self.local_drive = m.get('LocalDrive')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetRedirect') is not None:
            self.net_redirect = m.get('NetRedirect')
        if m.get('PreemptLogin') is not None:
            self.preempt_login = m.get('PreemptLogin')
        if m.get('PreemptLoginUser') is not None:
            self.preempt_login_user = m.get('PreemptLoginUser')
        if m.get('PrinterRedirection') is not None:
            self.printer_redirection = m.get('PrinterRedirection')
        if m.get('RecordContent') is not None:
            self.record_content = m.get('RecordContent')
        if m.get('RecordContentExpires') is not None:
            self.record_content_expires = m.get('RecordContentExpires')
        if m.get('Recording') is not None:
            self.recording = m.get('Recording')
        if m.get('RecordingAudio') is not None:
            self.recording_audio = m.get('RecordingAudio')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('RecordingEndTime') is not None:
            self.recording_end_time = m.get('RecordingEndTime')
        if m.get('RecordingExpires') is not None:
            self.recording_expires = m.get('RecordingExpires')
        if m.get('RecordingFps') is not None:
            self.recording_fps = m.get('RecordingFps')
        if m.get('RecordingStartTime') is not None:
            self.recording_start_time = m.get('RecordingStartTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoteCoordinate') is not None:
            self.remote_coordinate = m.get('RemoteCoordinate')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        if m.get('UsbRedirect') is not None:
            self.usb_redirect = m.get('UsbRedirect')
        self.usb_supply_redirect_rule = []
        if m.get('UsbSupplyRedirectRule') is not None:
            for k in m.get('UsbSupplyRedirectRule'):
                temp_model = CreatePolicyGroupRequestUsbSupplyRedirectRule()
                self.usb_supply_redirect_rule.append(temp_model.from_map(k))
        if m.get('VideoRedirect') is not None:
            self.video_redirect = m.get('VideoRedirect')
        if m.get('VisualQuality') is not None:
            self.visual_quality = m.get('VisualQuality')
        if m.get('Watermark') is not None:
            self.watermark = m.get('Watermark')
        if m.get('WatermarkColor') is not None:
            self.watermark_color = m.get('WatermarkColor')
        if m.get('WatermarkDegree') is not None:
            self.watermark_degree = m.get('WatermarkDegree')
        if m.get('WatermarkFontSize') is not None:
            self.watermark_font_size = m.get('WatermarkFontSize')
        if m.get('WatermarkFontStyle') is not None:
            self.watermark_font_style = m.get('WatermarkFontStyle')
        if m.get('WatermarkRowAmount') is not None:
            self.watermark_row_amount = m.get('WatermarkRowAmount')
        if m.get('WatermarkTransparency') is not None:
            self.watermark_transparency = m.get('WatermarkTransparency')
        if m.get('WatermarkTransparencyValue') is not None:
            self.watermark_transparency_value = m.get('WatermarkTransparencyValue')
        if m.get('WatermarkType') is not None:
            self.watermark_type = m.get('WatermarkType')
        return self


class CreatePolicyGroupResponseBody(TeaModel):
    def __init__(self, policy_group_id=None, request_id=None):
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreatePolicyGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreatePolicyGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreatePolicyGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreatePolicyGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreatePolicyGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateRAMDirectoryRequest(TeaModel):
    def __init__(self, desktop_access_type=None, directory_name=None, enable_admin_access=None,
                 enable_internet_access=None, region_id=None, v_switch_id=None):
        # The method that you use to connect clients to cloud desktops. Valid values:
        # 
        # *   Internet: connects clients to cloud desktops only over the Internet.
        # *   VPC: connects clients to cloud desktops only over a VPC.
        # *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method when you connect clients to cloud desktops.
        # 
        # Default value: Internet.
        # 
        # 
        # > The VPC connection method is provided by Alibaba Cloud PrivateLink. You are not charged for PrivateLink. If you set this parameter to VPC or Any, PrivateLink is automatically activated.
        self.desktop_access_type = desktop_access_type  # type: str
        # The name of the directory. The name must be 2 to 255 characters in length and can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`.
        # 
        # This parameter is empty by default.
        self.directory_name = directory_name  # type: str
        # Specifies whether to grant the permissions of the local administrator to the desktop users.
        # 
        # Default value: true.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Specifies whether to enable the Internet access feature.
        self.enable_internet_access = enable_internet_access  # type: bool
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The IDs of vSwitches. You can configure only one vSwitch.
        self.v_switch_id = v_switch_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRAMDirectoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.directory_name is not None:
            result['DirectoryName'] = self.directory_name
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.enable_internet_access is not None:
            result['EnableInternetAccess'] = self.enable_internet_access
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('DirectoryName') is not None:
            self.directory_name = m.get('DirectoryName')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('EnableInternetAccess') is not None:
            self.enable_internet_access = m.get('EnableInternetAccess')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class CreateRAMDirectoryResponseBody(TeaModel):
    def __init__(self, directory_id=None, request_id=None):
        # The ID of the RAM directory.
        self.directory_id = directory_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateRAMDirectoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateRAMDirectoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateRAMDirectoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateRAMDirectoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateRAMDirectoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSimpleOfficeSiteRequest(TeaModel):
    def __init__(self, bandwidth=None, cen_id=None, cen_owner_id=None, cidr_block=None, cloud_box_office_site=None,
                 desktop_access_type=None, enable_admin_access=None, enable_internet_access=None, need_verify_zero_device=None,
                 office_site_name=None, region_id=None, v_switch_id=None, verify_code=None):
        # The maximum public bandwidth. Value range: 10 to 200. Unit: Mbit/s. This parameter is available if you set `EnableInternetAccess` to `true`.
        self.bandwidth = bandwidth  # type: int
        # The ID of the Cloud Enterprise Network (CEN) instance.
        # 
        # > If you want to connect to your cloud desktops over a VPC, you can attach the network of the workspace to the CEN instance. The CEN instance is connected to the on-premises network over VPN Gateway or Express Connect.
        self.cen_id = cen_id  # type: str
        # The ID of the Alibaba Cloud account to which the Cloud Enterprise Network (CEN) instance belongs.
        # 
        # - If you do not specify the CenId parameter, or the CEN instance that is specified by the CenId parameter belongs to the current Alibaba Cloud account, skip this parameter.
        # - If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the Alibaba Cloud account.
        self.cen_owner_id = cen_owner_id  # type: long
        # The IPv4 CIDR block in the secure office network of the workspace. The IPv4 CIDR block that the system uses to create a virtual private cloud (VPC) for the workspace. We recommend that you set the IPv4 CIDR block to 10.0.0.0/12, 172.16.0.0/12, 192.168.0.0/16, or a subnet of these CIDR blocks. If you set the IPv4 CIDR block to 10.0.0.0/12 or 172.16.0.0/12, the mask is 1224 bits in length. If you set the IPv4 CIDR block to 192.168.0.0/16, the mask is 1624 bits in length.
        self.cidr_block = cidr_block  # type: str
        # Specifies whether the workspace is a CloudBox-based workspace.
        self.cloud_box_office_site = cloud_box_office_site  # type: bool
        # The method that is used to connect the client to cloud desktops.
        # 
        # > VPC connections are established by using Alibaba Cloud PrivateLink. You can use PrivateLink for free. When you set this parameter to VPC or Any, PrivateLink is automatically activated.
        self.desktop_access_type = desktop_access_type  # type: str
        # Specifies whether to grant the permissions of the local administrator to the regular user of the cloud desktop.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Specifies whether to enable Internet access. By default, Internet access is not enabled.
        self.enable_internet_access = enable_internet_access  # type: bool
        # Specifies whether to enable trusted device verification.
        self.need_verify_zero_device = need_verify_zero_device  # type: bool
        # The name of the workspace. The name must be 2 to 255 characters in length. It must start with a letter and cannot start with `http://` or `https://`. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-).
        self.office_site_name = office_site_name  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The IDs of the vSwitches in the VPC. This parameter is required when you create a CloudBox-based workspace.
        self.v_switch_id = v_switch_id  # type: list[str]
        # The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the [SendVerifyCode](~~335132~~) operation to obtain the verification code.
        self.verify_code = verify_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimpleOfficeSiteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.cen_owner_id is not None:
            result['CenOwnerId'] = self.cen_owner_id
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.cloud_box_office_site is not None:
            result['CloudBoxOfficeSite'] = self.cloud_box_office_site
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.enable_internet_access is not None:
            result['EnableInternetAccess'] = self.enable_internet_access
        if self.need_verify_zero_device is not None:
            result['NeedVerifyZeroDevice'] = self.need_verify_zero_device
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        if self.verify_code is not None:
            result['VerifyCode'] = self.verify_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CenOwnerId') is not None:
            self.cen_owner_id = m.get('CenOwnerId')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CloudBoxOfficeSite') is not None:
            self.cloud_box_office_site = m.get('CloudBoxOfficeSite')
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('EnableInternetAccess') is not None:
            self.enable_internet_access = m.get('EnableInternetAccess')
        if m.get('NeedVerifyZeroDevice') is not None:
            self.need_verify_zero_device = m.get('NeedVerifyZeroDevice')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        if m.get('VerifyCode') is not None:
            self.verify_code = m.get('VerifyCode')
        return self


class CreateSimpleOfficeSiteResponseBody(TeaModel):
    def __init__(self, office_site_id=None, request_id=None):
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSimpleOfficeSiteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class CreateSimpleOfficeSiteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSimpleOfficeSiteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSimpleOfficeSiteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSimpleOfficeSiteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class CreateSnapshotRequest(TeaModel):
    def __init__(self, description=None, desktop_id=None, region_id=None, snapshot_name=None, source_disk_type=None):
        # The description of the snapshot. The description can be up to 128 characters in length.
        self.description = description  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The region ID.
        self.region_id = region_id  # type: str
        # The name of the snapshot. The name must be 2 to 128 characters in length.\
        # The name cannot start with auto because snapshots whose names start with auto are recognized as automatic snapshots.
        self.snapshot_name = snapshot_name  # type: str
        # The type of the disk for which to create a snapshot. Valid values:
        # 
        # *   system: system disk
        # *   data: data disk
        self.source_disk_type = source_disk_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        return self


class CreateSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None, snapshot_id=None):
        # The ID of the region.
        self.request_id = request_id  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(CreateSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class CreateSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: CreateSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(CreateSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = CreateSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, policy_id=None, region_id=None):
        # The ID of the policy template that you want to manage.
        # 
        # > You can call the [ListDefensePolicies](~~195814~~) operation to query the IDs of all policy templates.
        self.policy_id = policy_id  # type: list[str]
        # The ID of the region where the automatic snapshot policy is created.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteBundlesRequest(TeaModel):
    def __init__(self, bundle_id=None, region_id=None):
        # The desktop bundles that you want to delete.
        self.bundle_id = bundle_id  # type: list[str]
        # The ID of the region where the desktop bundles to delete are located.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBundlesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteBundlesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteBundlesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteBundlesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteBundlesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteBundlesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteBundlesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCdsFileRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCdsFileResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudDriveGroupsRequest(TeaModel):
    def __init__(self, cds_id=None, group_id=None, region_id=None):
        # The ID of the cloud disk in Cloud Drive Service.
        self.cds_id = cds_id  # type: str
        # The IDs of the teams that you want to delete. You can delete multiple teams at a time.
        self.group_id = group_id  # type: list[str]
        # The region ID.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCloudDriveGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCloudDriveGroupsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The result of the operation. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
        self.code = code  # type: str
        # The data information.
        self.data = data  # type: str
        # The error message returned. This parameter is not returned if the value of Code is `success`.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values: true: The request is successful. false: The request fails.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCloudDriveGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DeleteCloudDriveGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCloudDriveGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCloudDriveGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudDriveGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteCloudDriveUsersRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: list[str]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCloudDriveUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteCloudDriveUsersResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteCloudDriveUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteCloudDriveUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteCloudDriveUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteCloudDriveUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteCloudDriveUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDesktopGroupRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDesktopGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None):
        # The IDs of the cloud desktops that you want to release. You can configure up to 100 desktop IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the region where the cloud desktops to release are located.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDevicesRequest(TeaModel):
    def __init__(self, client_type=None, device_ids=None, force=None, region_id=None):
        # The type of the device.
        # 
        # *   1: the hardware client device
        # *   2: the software client device
        self.client_type = client_type  # type: int
        # The list of universally unique identifiers (UUIDs) of devices.
        self.device_ids = device_ids  # type: list[str]
        # Specifies whether to forcefully delete the device.
        # 
        # *   1: forcefully deletes the device.
        # *   0: does not forcefully delete the device. (You cannot delete a device to which a user is bound.)
        self.force = force  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDevicesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.device_ids is not None:
            result['DeviceIds'] = self.device_ids
        if self.force is not None:
            result['Force'] = self.force
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('DeviceIds') is not None:
            self.device_ids = m.get('DeviceIds')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDevicesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDevicesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDevicesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDevicesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDevicesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteDirectoriesRequest(TeaModel):
    def __init__(self, directory_id=None, region_id=None):
        # The IDs of directories.
        self.directory_id = directory_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDirectoriesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteDirectoriesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteDirectoriesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteDirectoriesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteDirectoriesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteDirectoriesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteDirectoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteImagesRequest(TeaModel):
    def __init__(self, delete_cascaded_bundle=None, image_id=None, region_id=None):
        self.delete_cascaded_bundle = delete_cascaded_bundle  # type: bool
        # The IDs of the images that you want to delete.
        self.image_id = image_id  # type: list[str]
        # The ID of the region where the images to delete are located.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.delete_cascaded_bundle is not None:
            result['DeleteCascadedBundle'] = self.delete_cascaded_bundle
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeleteCascadedBundle') is not None:
            self.delete_cascaded_bundle = m.get('DeleteCascadedBundle')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteImagesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteImagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteImagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteImagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteImagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNASFileSystemsRequest(TeaModel):
    def __init__(self, file_system_id=None, region_id=None):
        # The IDs of the NAS file systems.
        self.file_system_id = file_system_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNASFileSystemsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteNASFileSystemsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNASFileSystemsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNASFileSystemsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteNASFileSystemsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteNASFileSystemsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNASFileSystemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteNetworkPackagesRequest(TeaModel):
    def __init__(self, network_package_id=None, region_id=None):
        # The IDs of Internet access packages.
        self.network_package_id = network_package_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkPackagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteNetworkPackagesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteNetworkPackagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteNetworkPackagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteNetworkPackagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteNetworkPackagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteNetworkPackagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteOfficeSitesRequest(TeaModel):
    def __init__(self, office_site_id=None, region_id=None):
        # The IDs of the workspaces. You can specify up to 100 workspace IDs.
        self.office_site_id = office_site_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteOfficeSitesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeleteOfficeSitesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteOfficeSitesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteOfficeSitesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteOfficeSitesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteOfficeSitesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteOfficeSitesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeletePolicyGroupsRequest(TeaModel):
    def __init__(self, policy_group_id=None, region_id=None):
        # The ID of the policy. You can specify 1 to 100 policy IDs.
        self.policy_group_id = policy_group_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePolicyGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DeletePolicyGroupsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeletePolicyGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeletePolicyGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeletePolicyGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeletePolicyGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeletePolicyGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteSnapshotRequest(TeaModel):
    def __init__(self, region_id=None, snapshot_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The IDs of the snapshots. You can specify 1 to 100 IDs of snapshots.
        self.snapshot_id = snapshot_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class DeleteSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DeleteVirtualMFADeviceRequest(TeaModel):
    def __init__(self, region_id=None, serial_number=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The serial number of the virtual MFA device, which is a unique identifier.
        # 
        # You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound to AD users.
        self.serial_number = serial_number  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVirtualMFADeviceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        return self


class DeleteVirtualMFADeviceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DeleteVirtualMFADeviceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DeleteVirtualMFADeviceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DeleteVirtualMFADeviceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DeleteVirtualMFADeviceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DeleteVirtualMFADeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAlarmEventStackInfoRequest(TeaModel):
    def __init__(self, desktop_id=None, event_name=None, lang=None, region_id=None, unique_info=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the alert event.
        self.event_name = event_name  # type: str
        # The natural language of the request and response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the alert event.
        self.unique_info = unique_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        return self


class DescribeAlarmEventStackInfoResponseBody(TeaModel):
    def __init__(self, request_id=None, stack_info=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The stack information of the alert details.
        self.stack_info = stack_info  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.stack_info is not None:
            result['StackInfo'] = self.stack_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('StackInfo') is not None:
            self.stack_info = m.get('StackInfo')
        return self


class DescribeAlarmEventStackInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAlarmEventStackInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAlarmEventStackInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAlarmEventStackInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, policy_id=None, policy_name=None, region_id=None):
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 20
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The name of the automatic snapshot policy.
        self.policy_name = policy_name  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies(TeaModel):
    def __init__(self, creation_time=None, cron_expression=None, desktop_num=None, policy_id=None, policy_name=None,
                 region_id=None, retention_days=None, status=None, time_points=None):
        # The time when the automatic snapshot policy was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The CRON expression that is used to create the snapshot.
        self.cron_expression = cron_expression  # type: str
        # The number of cloud desktops that are associated with the automatic snapshot policy.
        self.desktop_num = desktop_num  # type: int
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The name of the automatic snapshot policy.
        self.policy_name = policy_name  # type: str
        # The ID of the region where the automatic snapshot policy resides.
        self.region_id = region_id  # type: str
        # The retention period of the automatic snapshot. Unit: days. Valid values:
        # 
        # *   \-1: The snapshot is permanently retained.
        # *   1 to 65536: The automatic snapshot is retained for the specified number of days.
        self.retention_days = retention_days  # type: str
        # The state of the automatic snapshot policy. Valid values:
        # 
        # *   Normal: The automatic snapshot policy is normal.
        # *   Expire: The automatic snapshot policy cannot be used because your account has an overdue payment.
        self.status = status  # type: str
        # The points in time at which automatic snapshots are created.
        # 
        # The time is displayed in UTC+8. Unit: hours. Valid values are 0 to 23, which correspond to the 24 points in time on the hour from 00:00:00 to 23:00:00. 1 indicates 01:00:00. Multiple points in time can be specified.
        # 
        # The parameter value is a JSON array that contains up to 24 points in time separated by commas (,). Example: `["0", "1", ... "23"]`.
        self.time_points = time_points  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.cron_expression is not None:
            result['CronExpression'] = self.cron_expression
        if self.desktop_num is not None:
            result['DesktopNum'] = self.desktop_num
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        if self.status is not None:
            result['Status'] = self.status
        if self.time_points is not None:
            result['TimePoints'] = self.time_points
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('CronExpression') is not None:
            self.cron_expression = m.get('CronExpression')
        if m.get('DesktopNum') is not None:
            self.desktop_num = m.get('DesktopNum')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimePoints') is not None:
            self.time_points = m.get('TimePoints')
        return self


class DescribeAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, auto_snapshot_policies=None, next_token=None, request_id=None):
        # Details of the automatic snapshot policies.
        self.auto_snapshot_policies = auto_snapshot_policies  # type: list[DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies]
        # The token that is used to start the next query. If this parameter is empty, all results haven been returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.auto_snapshot_policies:
            for k in self.auto_snapshot_policies:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['AutoSnapshotPolicies'] = []
        if self.auto_snapshot_policies is not None:
            for k in self.auto_snapshot_policies:
                result['AutoSnapshotPolicies'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.auto_snapshot_policies = []
        if m.get('AutoSnapshotPolicies') is not None:
            for k in m.get('AutoSnapshotPolicies'):
                temp_model = DescribeAutoSnapshotPolicyResponseBodyAutoSnapshotPolicies()
                self.auto_snapshot_policies.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeBundlesRequest(TeaModel):
    def __init__(self, bundle_id=None, bundle_type=None, check_stock=None, cpu_count=None, desktop_type_family=None,
                 fota_channel=None, from_desktop_group=None, gpu_count=None, image_id=None, max_results=None, memory_size=None,
                 next_token=None, protocol_type=None, region_id=None, selected_bundle=None, session_type=None,
                 support_multi_session=None, volume_encryption_enabled=None):
        # The IDs of the desktop templates. You can specify 1 to 100 desktop templates.
        self.bundle_id = bundle_id  # type: list[str]
        # The type of the desktop template.
        self.bundle_type = bundle_type  # type: str
        # Specifies whether to query the inventory status of the desktop type.
        self.check_stock = check_stock  # type: bool
        # The number of vCPUs of the desktop type.
        self.cpu_count = cpu_count  # type: int
        # The family of the desktop type.
        self.desktop_type_family = desktop_type_family  # type: str
        # This parameter is now in invitational preview and unavailable.
        self.fota_channel = fota_channel  # type: str
        # Specifies whether the cloud desktop that uses the desktop template belongs to the desktop group. Default value: `false`.
        self.from_desktop_group = from_desktop_group  # type: bool
        # The number of GPUs of the desktop type.
        self.gpu_count = gpu_count  # type: float
        self.image_id = image_id  # type: list[str]
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The memory size of the desktop type. Unit: GiB.
        self.memory_size = memory_size  # type: int
        # The token that determines the start point of the next query.
        self.next_token = next_token  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The desktop template that is selected based on specific criteria.
        self.selected_bundle = selected_bundle  # type: bool
        # The type of the session.
        self.session_type = session_type  # type: str
        # Specifies whether to return multi-session desktop templates in this call. Default value: false.
        self.support_multi_session = support_multi_session  # type: bool
        # Specifies whether to enable disk encryption.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBundlesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.bundle_type is not None:
            result['BundleType'] = self.bundle_type
        if self.check_stock is not None:
            result['CheckStock'] = self.check_stock
        if self.cpu_count is not None:
            result['CpuCount'] = self.cpu_count
        if self.desktop_type_family is not None:
            result['DesktopTypeFamily'] = self.desktop_type_family
        if self.fota_channel is not None:
            result['FotaChannel'] = self.fota_channel
        if self.from_desktop_group is not None:
            result['FromDesktopGroup'] = self.from_desktop_group
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.selected_bundle is not None:
            result['SelectedBundle'] = self.selected_bundle
        if self.session_type is not None:
            result['SessionType'] = self.session_type
        if self.support_multi_session is not None:
            result['SupportMultiSession'] = self.support_multi_session
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('BundleType') is not None:
            self.bundle_type = m.get('BundleType')
        if m.get('CheckStock') is not None:
            self.check_stock = m.get('CheckStock')
        if m.get('CpuCount') is not None:
            self.cpu_count = m.get('CpuCount')
        if m.get('DesktopTypeFamily') is not None:
            self.desktop_type_family = m.get('DesktopTypeFamily')
        if m.get('FotaChannel') is not None:
            self.fota_channel = m.get('FotaChannel')
        if m.get('FromDesktopGroup') is not None:
            self.from_desktop_group = m.get('FromDesktopGroup')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SelectedBundle') is not None:
            self.selected_bundle = m.get('SelectedBundle')
        if m.get('SessionType') is not None:
            self.session_type = m.get('SessionType')
        if m.get('SupportMultiSession') is not None:
            self.support_multi_session = m.get('SupportMultiSession')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        return self


class DescribeBundlesResponseBodyBundlesDesktopTypeAttribute(TeaModel):
    def __init__(self, cpu_count=None, gpu_count=None, gpu_spec=None, memory_size=None):
        # The number of vCPUs.
        self.cpu_count = cpu_count  # type: int
        # The number of GPUs.
        self.gpu_count = gpu_count  # type: float
        # The type of the GPU.
        self.gpu_spec = gpu_spec  # type: str
        # The size of the memory. Unit: MB.
        self.memory_size = memory_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBundlesResponseBodyBundlesDesktopTypeAttribute, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_count is not None:
            result['CpuCount'] = self.cpu_count
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuCount') is not None:
            self.cpu_count = m.get('CpuCount')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        return self


class DescribeBundlesResponseBodyBundlesDisks(TeaModel):
    def __init__(self, disk_performance_level=None, disk_size=None, disk_type=None):
        # The performance level (PL) of the disk.
        self.disk_performance_level = disk_performance_level  # type: str
        # The size of the disk. Unit: GiB.
        self.disk_size = disk_size  # type: int
        # The type of the disk.
        self.disk_type = disk_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeBundlesResponseBodyBundlesDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_performance_level is not None:
            result['DiskPerformanceLevel'] = self.disk_performance_level
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskPerformanceLevel') is not None:
            self.disk_performance_level = m.get('DiskPerformanceLevel')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        return self


class DescribeBundlesResponseBodyBundles(TeaModel):
    def __init__(self, bundle_id=None, bundle_name=None, bundle_type=None, creation_time=None, description=None,
                 desktop_type=None, desktop_type_attribute=None, desktop_type_family=None, disks=None, image_id=None,
                 image_name=None, image_status=None, language=None, os_type=None, platform=None, protocol_type=None,
                 session_type=None, stock_state=None, volume_encryption_enabled=None, volume_encryption_key=None):
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The name of the desktop template.
        self.bundle_name = bundle_name  # type: str
        # The type of the desktop template.
        self.bundle_type = bundle_type  # type: str
        # The time when the desktop template was created.
        self.creation_time = creation_time  # type: str
        # The description of the desktop template.
        self.description = description  # type: str
        # The desktop type.
        self.desktop_type = desktop_type  # type: str
        # Details of the desktop type.
        self.desktop_type_attribute = desktop_type_attribute  # type: DescribeBundlesResponseBodyBundlesDesktopTypeAttribute
        # The family of the desktop type.
        self.desktop_type_family = desktop_type_family  # type: str
        # Details of the disks.
        self.disks = disks  # type: list[DescribeBundlesResponseBodyBundlesDisks]
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The name of the image.
        self.image_name = image_name  # type: str
        self.image_status = image_status  # type: str
        # The OS language of the image.
        self.language = language  # type: str
        # The type of the OS.
        self.os_type = os_type  # type: str
        # The information about the OS platform. Valid values:
        # 
        # *   CentOS
        # *   Ubuntu
        # *   Windows Server 2016
        # *   Windows Server 2019
        # *   UOS
        self.platform = platform  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # The type of the session.
        self.session_type = session_type  # type: str
        # The inventory status of the desktop type. This parameter is returned only if you set the `CheckStock` parameter to `True`.
        self.stock_state = stock_state  # type: str
        # Indicates whether disk encryption is enabled.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled.
        self.volume_encryption_key = volume_encryption_key  # type: str

    def validate(self):
        if self.desktop_type_attribute:
            self.desktop_type_attribute.validate()
        if self.disks:
            for k in self.disks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBundlesResponseBodyBundles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.bundle_name is not None:
            result['BundleName'] = self.bundle_name
        if self.bundle_type is not None:
            result['BundleType'] = self.bundle_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_type is not None:
            result['DesktopType'] = self.desktop_type
        if self.desktop_type_attribute is not None:
            result['DesktopTypeAttribute'] = self.desktop_type_attribute.to_map()
        if self.desktop_type_family is not None:
            result['DesktopTypeFamily'] = self.desktop_type_family
        result['Disks'] = []
        if self.disks is not None:
            for k in self.disks:
                result['Disks'].append(k.to_map() if k else None)
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.image_status is not None:
            result['ImageStatus'] = self.image_status
        if self.language is not None:
            result['Language'] = self.language
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.session_type is not None:
            result['SessionType'] = self.session_type
        if self.stock_state is not None:
            result['StockState'] = self.stock_state
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('BundleName') is not None:
            self.bundle_name = m.get('BundleName')
        if m.get('BundleType') is not None:
            self.bundle_type = m.get('BundleType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopType') is not None:
            self.desktop_type = m.get('DesktopType')
        if m.get('DesktopTypeAttribute') is not None:
            temp_model = DescribeBundlesResponseBodyBundlesDesktopTypeAttribute()
            self.desktop_type_attribute = temp_model.from_map(m['DesktopTypeAttribute'])
        if m.get('DesktopTypeFamily') is not None:
            self.desktop_type_family = m.get('DesktopTypeFamily')
        self.disks = []
        if m.get('Disks') is not None:
            for k in m.get('Disks'):
                temp_model = DescribeBundlesResponseBodyBundlesDisks()
                self.disks.append(temp_model.from_map(k))
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ImageStatus') is not None:
            self.image_status = m.get('ImageStatus')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('SessionType') is not None:
            self.session_type = m.get('SessionType')
        if m.get('StockState') is not None:
            self.stock_state = m.get('StockState')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        return self


class DescribeBundlesResponseBody(TeaModel):
    def __init__(self, bundles=None, next_token=None, request_id=None):
        # Details of the desktop templates.
        self.bundles = bundles  # type: list[DescribeBundlesResponseBodyBundles]
        # The token that is used to start the next query. If null is returned, the next query is not required.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.bundles:
            for k in self.bundles:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeBundlesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Bundles'] = []
        if self.bundles is not None:
            for k in self.bundles:
                result['Bundles'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.bundles = []
        if m.get('Bundles') is not None:
            for k in m.get('Bundles'):
                temp_model = DescribeBundlesResponseBodyBundles()
                self.bundles.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeBundlesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeBundlesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeBundlesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeBundlesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCdsFileShareLinksRequest(TeaModel):
    def __init__(self, cds_id=None, creators=None, max_results=None, next_token=None, share_id=None, share_name=None,
                 status=None):
        self.cds_id = cds_id  # type: str
        self.creators = creators  # type: list[str]
        self.max_results = max_results  # type: int
        self.next_token = next_token  # type: str
        self.share_id = share_id  # type: str
        self.share_name = share_name  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCdsFileShareLinksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.creators is not None:
            result['Creators'] = self.creators
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.share_id is not None:
            result['ShareId'] = self.share_id
        if self.share_name is not None:
            result['ShareName'] = self.share_name
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('Creators') is not None:
            self.creators = m.get('Creators')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ShareId') is not None:
            self.share_id = m.get('ShareId')
        if m.get('ShareName') is not None:
            self.share_name = m.get('ShareName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeCdsFileShareLinksResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, next_token=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: list[CdsFileShareLinkModel]
        self.message = message  # type: str
        self.next_token = next_token  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            for k in self.data:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCdsFileShareLinksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        result['Data'] = []
        if self.data is not None:
            for k in self.data:
                result['Data'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        self.data = []
        if m.get('Data') is not None:
            for k in m.get('Data'):
                temp_model = CdsFileShareLinkModel()
                self.data.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCdsFileShareLinksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCdsFileShareLinksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCdsFileShareLinksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCdsFileShareLinksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCensRequest(TeaModel):
    def __init__(self, page_number=None, page_size=None, region_id=None):
        # The number of the page to return.
        # 
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The maximum number of entries to return on each page.
        # 
        # Default value: 50.
        self.page_size = page_size  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCensRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCensResponseBodyCensPackageIds(TeaModel):
    def __init__(self, package_id=None):
        # The ID of the bandwidth plan that is associated with the CEN instance.
        self.package_id = package_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCensResponseBodyCensPackageIds, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.package_id is not None:
            result['PackageId'] = self.package_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PackageId') is not None:
            self.package_id = m.get('PackageId')
        return self


class DescribeCensResponseBodyCensTags(TeaModel):
    def __init__(self, key=None, value=None):
        # The tag key of the CEN instance.
        self.key = key  # type: str
        # The tag value of the CEN instance.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCensResponseBodyCensTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeCensResponseBodyCens(TeaModel):
    def __init__(self, cen_id=None, creation_time=None, description=None, ipv_6level=None, name=None,
                 package_ids=None, protection_level=None, status=None, tags=None):
        # The ID of the CEN instance.
        self.cen_id = cen_id  # type: str
        # The time when the CEN instance was created.
        self.creation_time = creation_time  # type: str
        # The description of the CEN instance.
        self.description = description  # type: str
        # Indicates whether IPv6 is supported. Valid value: DISABLED. This value indicates that IPv6 is not supported.
        # 
        # >  IPv6 is not supported.
        self.ipv_6level = ipv_6level  # type: str
        # The name of the CEN instance.
        self.name = name  # type: str
        # The IDs of the bandwidth plans that are associated with the CEN instance.
        self.package_ids = package_ids  # type: list[DescribeCensResponseBodyCensPackageIds]
        # The level of CIDR block overlapping. Valid value: REDUCED. This value indicates that the CIDR blocks can overlap with each other but must not be the same.
        self.protection_level = protection_level  # type: str
        # The status of the CEN instance. Valid values:
        # 
        # *   Creating: The CEN instance is being created.
        # *   Active: The CEN instance is running.
        # *   Deleting: The CEN instance is being deleted.
        self.status = status  # type: str
        # The tags of the CEN instance.
        self.tags = tags  # type: list[DescribeCensResponseBodyCensTags]

    def validate(self):
        if self.package_ids:
            for k in self.package_ids:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCensResponseBodyCens, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.description is not None:
            result['Description'] = self.description
        if self.ipv_6level is not None:
            result['Ipv6Level'] = self.ipv_6level
        if self.name is not None:
            result['Name'] = self.name
        result['PackageIds'] = []
        if self.package_ids is not None:
            for k in self.package_ids:
                result['PackageIds'].append(k.to_map() if k else None)
        if self.protection_level is not None:
            result['ProtectionLevel'] = self.protection_level
        if self.status is not None:
            result['Status'] = self.status
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Ipv6Level') is not None:
            self.ipv_6level = m.get('Ipv6Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        self.package_ids = []
        if m.get('PackageIds') is not None:
            for k in m.get('PackageIds'):
                temp_model = DescribeCensResponseBodyCensPackageIds()
                self.package_ids.append(temp_model.from_map(k))
        if m.get('ProtectionLevel') is not None:
            self.protection_level = m.get('ProtectionLevel')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeCensResponseBodyCensTags()
                self.tags.append(temp_model.from_map(k))
        return self


class DescribeCensResponseBody(TeaModel):
    def __init__(self, cens=None, page_number=None, page_size=None, request_id=None, total_count=None):
        # Details about CEN instances.
        self.cens = cens  # type: list[DescribeCensResponseBodyCens]
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of CEN instances returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.cens:
            for k in self.cens:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCensResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cens'] = []
        if self.cens is not None:
            for k in self.cens:
                result['Cens'].append(k.to_map() if k else None)
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cens = []
        if m.get('Cens') is not None:
            for k in m.get('Cens'):
                temp_model = DescribeCensResponseBodyCens()
                self.cens.append(temp_model.from_map(k))
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeCensResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCensResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCensResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCensResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeClientEventsRequest(TeaModel):
    def __init__(self, desktop_id=None, desktop_ip=None, desktop_name=None, directory_id=None, end_time=None,
                 end_user_id=None, event_type=None, event_types=None, max_results=None, next_token=None, office_site_id=None,
                 office_site_name=None, region_id=None, start_time=None):
        # The ID of the cloud desktop. If you do not specify a value for this parameter, events of all cloud desktops in the specified region are queried.
        self.desktop_id = desktop_id  # type: str
        # The IP address of the cloud desktop. If you do not specify a value for this parameter, events of all cloud desktops in the specified region are queried.
        self.desktop_ip = desktop_ip  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The ID of the directory to which the cloud desktop belongs.
        self.directory_id = directory_id  # type: str
        # The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        # 
        # If you do not specify a value for this parameter, the current time is used.
        self.end_time = end_time  # type: str
        # The information about the regular user that connects to the cloud desktop from the EDS client. The information can be the RAM user ID or Active Directory (AD) username. If you do not specify a value for this parameter, events of all regular users in the specified region are queried.
        self.end_user_id = end_user_id  # type: str
        # The type of event that you want to query. Valid values:
        # 
        # *   DESKTOP_CONNECT: The desktop session is established.
        # *   DESKTOP_DISCONNECT: The desktop session is disconnected.
        # *   DESKTOP_REBOOT: The cloud desktop is restarted.
        # *   CLIENT_AD_LOGIN: The AD user logs on to the client.
        # *   GET_CONNECTION_TICKET: The request to connect to the cloud desktop is sent.
        # *   DESKTOP_START: The cloud desktop is started.
        # *   DESKTOP_STOP: The cloud desktop is stopped.
        # 
        # If you do not specify a value for this parameter, events of all types are queried.
        self.event_type = event_type  # type: str
        # The types of event.
        self.event_types = event_types  # type: list[str]
        # The number of entries to return on each page.
        # 
        # Default value: 100.
        self.max_results = max_results  # type: int
        # The query token. Set the value to the NextToken value that is returned from the last call to the DescribeClientEvents operation.
        self.next_token = next_token  # type: str
        # The ID of the workspace to which the cloud desktop belongs. If you do not specify a value for this parameter, events of all workspaces in the specified region are queried.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The ID of the region where the cloud desktop resides.
        self.region_id = region_id  # type: str
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.
        # 
        # If you do not specify a value for this parameter, all events that occurred before the point in time that you specify for `EndTime` are queried.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_ip is not None:
            result['DesktopIp'] = self.desktop_ip
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.event_types is not None:
            result['EventTypes'] = self.event_types
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopIp') is not None:
            self.desktop_ip = m.get('DesktopIp')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('EventTypes') is not None:
            self.event_types = m.get('EventTypes')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeClientEventsResponseBodyEvents(TeaModel):
    def __init__(self, ali_uid=None, bytes_received=None, bytes_send=None, client_ip=None, client_os=None,
                 client_version=None, desktop_group_id=None, desktop_group_name=None, desktop_id=None, desktop_ip=None,
                 desktop_name=None, directory_id=None, directory_type=None, end_user_id=None, event_id=None, event_time=None,
                 event_type=None, office_site_id=None, office_site_name=None, office_site_type=None, region_id=None,
                 status=None):
        # The ID of the Alibaba Cloud account with which the event is associated.
        self.ali_uid = ali_uid  # type: str
        # The number of bytes that are received.
        self.bytes_received = bytes_received  # type: str
        # The number of bytes that are sent.
        self.bytes_send = bytes_send  # type: str
        # The IP address of the client.
        self.client_ip = client_ip  # type: str
        # The OS that the client runs.
        self.client_os = client_os  # type: str
        # The version of the client.
        self.client_version = client_version  # type: str
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The IP address of the cloud desktop.
        self.desktop_ip = desktop_ip  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The ID of the directory to which the cloud desktop belongs.
        self.directory_id = directory_id  # type: str
        # The type of the directory.
        self.directory_type = directory_type  # type: str
        # The information about the regular user that connects to the cloud desktop from the EDS client. The information can be the RAM user ID or AD username.
        self.end_user_id = end_user_id  # type: str
        # The ID of the event.
        self.event_id = event_id  # type: str
        # The time when the event occurred.
        self.event_time = event_time  # type: str
        # The type of the event.
        self.event_type = event_type  # type: str
        # The ID of the workspace to which the cloud desktop belongs.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The account type of the workspace. Valid values:
        # 
        # *   SIMPLE: convenience account
        # *   AD_CONNECTOR: enterprise AD account
        self.office_site_type = office_site_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The status of the event. This parameter is returned if you set the EventType parameter to DESKTOP_DISCONNECT or GET_CONNECTION_TICKET. Valid values:
        # 
        # *   200\. The value indicates that the request is successful.
        # *   An error message. The value indicates that the request failed. Example: FailedToGetConnectionTicket.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeClientEventsResponseBodyEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uid is not None:
            result['AliUid'] = self.ali_uid
        if self.bytes_received is not None:
            result['BytesReceived'] = self.bytes_received
        if self.bytes_send is not None:
            result['BytesSend'] = self.bytes_send
        if self.client_ip is not None:
            result['ClientIp'] = self.client_ip
        if self.client_os is not None:
            result['ClientOS'] = self.client_os
        if self.client_version is not None:
            result['ClientVersion'] = self.client_version
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_ip is not None:
            result['DesktopIp'] = self.desktop_ip
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_type is not None:
            result['DirectoryType'] = self.directory_type
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.event_id is not None:
            result['EventId'] = self.event_id
        if self.event_time is not None:
            result['EventTime'] = self.event_time
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUid') is not None:
            self.ali_uid = m.get('AliUid')
        if m.get('BytesReceived') is not None:
            self.bytes_received = m.get('BytesReceived')
        if m.get('BytesSend') is not None:
            self.bytes_send = m.get('BytesSend')
        if m.get('ClientIp') is not None:
            self.client_ip = m.get('ClientIp')
        if m.get('ClientOS') is not None:
            self.client_os = m.get('ClientOS')
        if m.get('ClientVersion') is not None:
            self.client_version = m.get('ClientVersion')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopIp') is not None:
            self.desktop_ip = m.get('DesktopIp')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryType') is not None:
            self.directory_type = m.get('DirectoryType')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EventId') is not None:
            self.event_id = m.get('EventId')
        if m.get('EventTime') is not None:
            self.event_time = m.get('EventTime')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeClientEventsResponseBody(TeaModel):
    def __init__(self, events=None, next_token=None, request_id=None):
        # Details about the events.
        self.events = events  # type: list[DescribeClientEventsResponseBodyEvents]
        # The query token that is returned in this call.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.events:
            for k in self.events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeClientEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Events'] = []
        if self.events is not None:
            for k in self.events:
                result['Events'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.events = []
        if m.get('Events') is not None:
            for k in m.get('Events'):
                temp_model = DescribeClientEventsResponseBodyEvents()
                self.events.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeClientEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeClientEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeClientEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeClientEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudDriveGroupsRequest(TeaModel):
    def __init__(self, cds_id=None, directory_id=None, directory_name=None, drive_status=None, drive_type=None,
                 group_id=None, group_name=None, group_type=None, max_results=None, next_token=None, parent_group_id=None,
                 region_id=None):
        # The ID of the cloud disk in Cloud Drive Service.
        self.cds_id = cds_id  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The name of the workspace.
        self.directory_name = directory_name  # type: str
        # The status of the team space. Valid values:
        # 
        # *   enabled
        # *   disabled
        # 
        # Default value: enabled.
        self.drive_status = drive_status  # type: str
        # Specifies whether space is increased.
        # 
        # *   binding: Space is increased.
        # *   unbound: Space is not increased.
        # 
        # Default value: null. This value indicates that all results are queried.
        self.drive_type = drive_type  # type: str
        # The IDs of the teams.
        self.group_id = group_id  # type: list[str]
        # The name of the team for fuzzy search.
        self.group_name = group_name  # type: str
        # The type of the team.
        # 
        # *   org: organizational structure
        # *   directory: workspace
        # 
        # Default value: null. This value indicates that all results are queried.
        self.group_type = group_type  # type: str
        # The maximum number of entries to return on each page.
        # 
        # *   Valid values: 1 to 100
        # *   Default value: 20
        self.max_results = max_results  # type: int
        # The pagination token that is used in the next request to retrieve a new page of results.
        self.next_token = next_token  # type: str
        # The ID of the parent ID. If a parent node ID is specified, the subnode list is queried. If you set the value of this parameter to root, the root nodes are queried. Default value: null. This value indicates that all results are queried.
        self.parent_group_id = parent_group_id  # type: str
        # The region ID.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudDriveGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_name is not None:
            result['DirectoryName'] = self.directory_name
        if self.drive_status is not None:
            result['DriveStatus'] = self.drive_status
        if self.drive_type is not None:
            result['DriveType'] = self.drive_type
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.group_type is not None:
            result['GroupType'] = self.group_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.parent_group_id is not None:
            result['ParentGroupId'] = self.parent_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryName') is not None:
            self.directory_name = m.get('DirectoryName')
        if m.get('DriveStatus') is not None:
            self.drive_status = m.get('DriveStatus')
        if m.get('DriveType') is not None:
            self.drive_type = m.get('DriveType')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('GroupType') is not None:
            self.group_type = m.get('GroupType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('ParentGroupId') is not None:
            self.parent_group_id = m.get('ParentGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCloudDriveGroupsResponseBodyCloudDriveGroups(TeaModel):
    def __init__(self, create_time=None, directory_id=None, drive_id=None, group_id=None, group_name=None,
                 status=None, total_size=None, used_size=None):
        # The time when the team space was created.
        self.create_time = create_time  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The ID of the team space.
        self.drive_id = drive_id  # type: str
        # The ID of the team.
        self.group_id = group_id  # type: str
        # The name of the team space.
        self.group_name = group_name  # type: str
        # The status of the team space. Valid values:
        # 
        # *   enabled
        # *   disabled
        # 
        # Default value: enabled.
        self.status = status  # type: str
        # The total capacity of the team space.
        self.total_size = total_size  # type: long
        # The size of the used space. Unit: bytes.
        self.used_size = used_size  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudDriveGroupsResponseBodyCloudDriveGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.drive_id is not None:
            result['DriveId'] = self.drive_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.group_name is not None:
            result['GroupName'] = self.group_name
        if self.status is not None:
            result['Status'] = self.status
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        if self.used_size is not None:
            result['UsedSize'] = self.used_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DriveId') is not None:
            self.drive_id = m.get('DriveId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('GroupName') is not None:
            self.group_name = m.get('GroupName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        if m.get('UsedSize') is not None:
            self.used_size = m.get('UsedSize')
        return self


class DescribeCloudDriveGroupsResponseBody(TeaModel):
    def __init__(self, cloud_drive_groups=None, count=None, next_token=None, request_id=None, success=None):
        # The list of team spaces.
        self.cloud_drive_groups = cloud_drive_groups  # type: list[DescribeCloudDriveGroupsResponseBodyCloudDriveGroups]
        # The total number of entries returned.
        self.count = count  # type: long
        # The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_token = next_token  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful.
        self.success = success  # type: bool

    def validate(self):
        if self.cloud_drive_groups:
            for k in self.cloud_drive_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCloudDriveGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudDriveGroups'] = []
        if self.cloud_drive_groups is not None:
            for k in self.cloud_drive_groups:
                result['CloudDriveGroups'].append(k.to_map() if k else None)
        if self.count is not None:
            result['Count'] = self.count
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cloud_drive_groups = []
        if m.get('CloudDriveGroups') is not None:
            for k in m.get('CloudDriveGroups'):
                temp_model = DescribeCloudDriveGroupsResponseBodyCloudDriveGroups()
                self.cloud_drive_groups.append(temp_model.from_map(k))
        if m.get('Count') is not None:
            self.count = m.get('Count')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class DescribeCloudDriveGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCloudDriveGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCloudDriveGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudDriveGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCloudDrivePermissionsRequest(TeaModel):
    def __init__(self, cds_id=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudDrivePermissionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels(TeaModel):
    def __init__(self, end_users=None, permission=None):
        self.end_users = end_users  # type: list[str]
        self.permission = permission  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_users is not None:
            result['EndUsers'] = self.end_users
        if self.permission is not None:
            result['Permission'] = self.permission
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndUsers') is not None:
            self.end_users = m.get('EndUsers')
        if m.get('Permission') is not None:
            self.permission = m.get('Permission')
        return self


class DescribeCloudDrivePermissionsResponseBody(TeaModel):
    def __init__(self, cloud_drive_permission_models=None, request_id=None):
        self.cloud_drive_permission_models = cloud_drive_permission_models  # type: list[DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cloud_drive_permission_models:
            for k in self.cloud_drive_permission_models:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCloudDrivePermissionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['CloudDrivePermissionModels'] = []
        if self.cloud_drive_permission_models is not None:
            for k in self.cloud_drive_permission_models:
                result['CloudDrivePermissionModels'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cloud_drive_permission_models = []
        if m.get('CloudDrivePermissionModels') is not None:
            for k in m.get('CloudDrivePermissionModels'):
                temp_model = DescribeCloudDrivePermissionsResponseBodyCloudDrivePermissionModels()
                self.cloud_drive_permission_models.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCloudDrivePermissionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCloudDrivePermissionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCloudDrivePermissionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCloudDrivePermissionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeCustomizedListHeadersRequest(TeaModel):
    def __init__(self, lang_type=None, list_type=None, region_id=None):
        # The language in which the exported cloud desktop list is displayed.
        self.lang_type = lang_type  # type: str
        # The type of the list.
        self.list_type = list_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomizedListHeadersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.lang_type is not None:
            result['LangType'] = self.lang_type
        if self.list_type is not None:
            result['ListType'] = self.list_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LangType') is not None:
            self.lang_type = m.get('LangType')
        if m.get('ListType') is not None:
            self.list_type = m.get('ListType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeCustomizedListHeadersResponseBodyHeaders(TeaModel):
    def __init__(self, display_type=None, header_key=None, header_name=None):
        # The display type of the header. You can call the `ModifyCustomizedListHeaders` operation to modify the display type of the header.
        self.display_type = display_type  # type: str
        # The key of the header.
        self.header_key = header_key  # type: str
        # The name of the header.
        self.header_name = header_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeCustomizedListHeadersResponseBodyHeaders, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_type is not None:
            result['DisplayType'] = self.display_type
        if self.header_key is not None:
            result['HeaderKey'] = self.header_key
        if self.header_name is not None:
            result['HeaderName'] = self.header_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayType') is not None:
            self.display_type = m.get('DisplayType')
        if m.get('HeaderKey') is not None:
            self.header_key = m.get('HeaderKey')
        if m.get('HeaderName') is not None:
            self.header_name = m.get('HeaderName')
        return self


class DescribeCustomizedListHeadersResponseBody(TeaModel):
    def __init__(self, headers=None, request_id=None):
        # The headers.
        self.headers = headers  # type: list[DescribeCustomizedListHeadersResponseBodyHeaders]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeCustomizedListHeadersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = DescribeCustomizedListHeadersResponseBodyHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeCustomizedListHeadersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeCustomizedListHeadersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeCustomizedListHeadersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeCustomizedListHeadersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDesktopGroupsRequest(TeaModel):
    def __init__(self, bundle_id=None, desktop_group_id=None, desktop_group_name=None, end_user_ids=None,
                 excluded_end_user_ids=None, image_id=None, max_results=None, next_token=None, office_site_id=None, own_type=None,
                 period=None, period_unit=None, policy_group_id=None, protocol_type=None, region_id=None, status=None):
        self.bundle_id = bundle_id  # type: list[str]
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group that you want to query. Fuzzy search is supported.
        self.desktop_group_name = desktop_group_name  # type: str
        # The IDs of the end users who have the permissions on the desktop group.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The IDs of the end users that you want to exclude. The end users have the permissions on the desktop group.
        self.excluded_end_user_ids = excluded_end_user_ids  # type: list[str]
        self.image_id = image_id  # type: list[str]
        # The maximum number of entries to return on each page. Maximum value: 100. Default value: 10.
        self.max_results = max_results  # type: int
        # The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
        self.next_token = next_token  # type: str
        # The workspace ID of the desktop groups that you want to query.
        self.office_site_id = office_site_id  # type: str
        # The type of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     personal desktop group.
        # 
        #     <!-- -->
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     shared desktop group (multi-session)
        # 
        #     <!-- -->
        # 
        #     .
        self.own_type = own_type  # type: long
        # The validity period of the desktop group. The unit is specified by the PeriodUnit parameter.
        self.period = period  # type: int
        # The unit of the validity period of the desktop group.
        # 
        # Valid values:
        # 
        # *   Month
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   Year
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        # *   Day
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        # 
        #     <!-- -->
        self.period_unit = period_unit  # type: str
        # The ID of the policy with which you want to associate the desktop group.
        self.policy_group_id = policy_group_id  # type: str
        # The type of the protocol. Valid values:
        # 
        # *   ASP
        # *   HDX
        self.protocol_type = protocol_type  # type: str
        # The region ID of the desktop groups that you want to query.
        self.region_id = region_id  # type: str
        # The payment status of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is unpaid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is paid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group has an overdue payment or expired
        # 
        #     <!-- -->
        # 
        #     .
        self.status = status  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.excluded_end_user_ids is not None:
            result['ExcludedEndUserIds'] = self.excluded_end_user_ids
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.own_type is not None:
            result['OwnType'] = self.own_type
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('ExcludedEndUserIds') is not None:
            self.excluded_end_user_ids = m.get('ExcludedEndUserIds')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OwnType') is not None:
            self.own_type = m.get('OwnType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDesktopGroupsResponseBodyDesktopGroups(TeaModel):
    def __init__(self, bind_amount=None, buy_desktops_count=None, comments=None, connect_duration=None, cpu=None,
                 create_time=None, creator=None, data_disk_category=None, data_disk_size=None, desktop_group_id=None,
                 desktop_group_name=None, end_user_count=None, expired_time=None, gpu_count=None, gpu_spec=None,
                 idle_disconnect_duration=None, image_id=None, keep_duration=None, load_policy=None, max_desktops_count=None, memory=None,
                 min_desktops_count=None, office_site_id=None, office_site_name=None, office_site_type=None, os_type=None,
                 own_bundle_id=None, own_bundle_name=None, own_type=None, pay_type=None, policy_group_id=None,
                 policy_group_name=None, protocol_type=None, ratio_threshold=None, reset_type=None, status=None, stop_duration=None,
                 system_disk_category=None, system_disk_size=None, version=None, volume_encryption_enabled=None,
                 volume_encryption_key=None):
        # The number of sessions that are allowed for each cloud desktop in the multi-session desktop group.
        self.bind_amount = bind_amount  # type: long
        # The number of purchased cloud desktops. Valid values: 0 to 200.
        self.buy_desktops_count = buy_desktops_count  # type: int
        # The remarks on the desktop group.
        self.comments = comments  # type: str
        # The maximum period of time during which a session is connected. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
        self.connect_duration = connect_duration  # type: long
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # The time when the cloud desktop was created.
        self.create_time = create_time  # type: str
        # The ID of the Alibaba Cloud account in which the desktop group is created.
        self.creator = creator  # type: str
        # The category of the data disk.
        # 
        # Valid values:
        # 
        # *   cloud_efficiency
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     ultra disk
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   cloud_ssd
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     standard SSD
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   cloud_essd
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Enhanced SSD (ESSD)
        # 
        #     <!-- -->
        # 
        #     .
        self.data_disk_category = data_disk_category  # type: str
        # The size of the data disk. Unit: GiB.
        self.data_disk_size = data_disk_size  # type: str
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # The number of end users who are granted the permissions on the desktop group.
        self.end_user_count = end_user_count  # type: int
        # The expiration time of the subscription cloud desktop.
        self.expired_time = expired_time  # type: str
        # The number of GPUs.
        self.gpu_count = gpu_count  # type: float
        # The GPU memory.
        self.gpu_spec = gpu_spec  # type: str
        # The maximum period of time during which a session is idle. When a session is idle, you cannot perform operations by using a keyboard or a mouse. When the specified maximum period of time is reached, the session automatically disconnects. Unit: milliseconds. This parameter is required only for cloud desktops in the same desktop group.
        self.idle_disconnect_duration = idle_disconnect_duration  # type: long
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The keep-alive duration of a cloud desktop after the end user disconnects from the cloud desktop. Unit: milliseconds.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy for the multi-session desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     depth first
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     breadth first
        # 
        #     <!-- -->
        # 
        #     .
        self.load_policy = load_policy  # type: long
        # The maximum number of cloud desktops that the desktop group can contain.
        self.max_desktops_count = max_desktops_count  # type: int
        # The memory size. Unit: MiB.
        self.memory = memory  # type: long
        # The minimum number of cloud desktops that the desktop group must contain.
        self.min_desktops_count = min_desktops_count  # type: int
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The account type of the workspace.
        # 
        # Valid values:
        # 
        # *   PERSONAL
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     personal account type
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   SIMPLE
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     convenience account type
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   AD_CONNECTOR
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     enterprise AD account type
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   RAM
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Resource Access Management (RAM) account type
        # 
        #     <!-- -->
        # 
        #     .
        self.office_site_type = office_site_type  # type: str
        # The OS. Valid values:
        # 
        # *   Windows
        # *   Linux
        self.os_type = os_type  # type: str
        # The ID of the desktop template.
        self.own_bundle_id = own_bundle_id  # type: str
        # The name of the desktop template.
        self.own_bundle_name = own_bundle_name  # type: str
        # The type of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     personal desktop group
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     shared desktop group (multi-session)
        # 
        #     <!-- -->
        # 
        #     .
        self.own_type = own_type  # type: long
        # The billing method of the desktop group.
        # 
        # Valid values:
        # 
        # *   PostPaid
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     pay-as-you-go
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   PrePaid
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     subscription
        # 
        #     <!-- -->
        # 
        #     .
        self.pay_type = pay_type  # type: str
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The name of the policy.
        self.policy_group_name = policy_group_name  # type: str
        # The type of the protocol. Valid values:
        # 
        # *   ASP
        # *   HDX
        self.protocol_type = protocol_type  # type: str
        # The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops × Maximum number of sessions allowed for each cloud desktop) × 100%`. If the specified threshold is reached, new cloud desktops are automatically created. If the specified threshold is not reached, idle cloud desktops are released.
        self.ratio_threshold = ratio_threshold  # type: float
        # Indicates which type of disk is reset for the cloud desktops in the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     No disks are reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Only the system disk is reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Only the data disk is reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   3
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The system disk and data disk are reset
        # 
        #     <!-- -->
        # 
        #     .
        self.reset_type = reset_type  # type: long
        # The payment status of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is unpaid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is paid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group has an overdue payment or expired
        # 
        #     <!-- -->
        # 
        #     .
        self.status = status  # type: int
        # The period of time before an idle cloud desktop stops. When the specified period of time is reached, the idle cloud desktop automatically stops. If an end user connects to a stopped cloud desktop, the cloud desktop automatically starts. Unit: milliseconds.
        self.stop_duration = stop_duration  # type: long
        # The category of the system disk.
        # 
        # Valid values:
        # 
        # *   cloud_efficiency
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     ultra disk
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   cloud_ssd
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     standard SSD
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   cloud_essd
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     ESSD
        # 
        #     <!-- -->
        # 
        #     .
        self.system_disk_category = system_disk_category  # type: str
        # The size of the system disk. Unit: GiB.
        self.system_disk_size = system_disk_size  # type: int
        # The version number of the desktop group.
        self.version = version  # type: int
        # Indicates whether disk encryption is enabled.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled.
        self.volume_encryption_key = volume_encryption_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopGroupsResponseBodyDesktopGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_amount is not None:
            result['BindAmount'] = self.bind_amount
        if self.buy_desktops_count is not None:
            result['BuyDesktopsCount'] = self.buy_desktops_count
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.connect_duration is not None:
            result['ConnectDuration'] = self.connect_duration
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.end_user_count is not None:
            result['EndUserCount'] = self.end_user_count
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.idle_disconnect_duration is not None:
            result['IdleDisconnectDuration'] = self.idle_disconnect_duration
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_desktops_count is not None:
            result['MaxDesktopsCount'] = self.max_desktops_count
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.min_desktops_count is not None:
            result['MinDesktopsCount'] = self.min_desktops_count
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.own_bundle_id is not None:
            result['OwnBundleId'] = self.own_bundle_id
        if self.own_bundle_name is not None:
            result['OwnBundleName'] = self.own_bundle_name
        if self.own_type is not None:
            result['OwnType'] = self.own_type
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_name is not None:
            result['PolicyGroupName'] = self.policy_group_name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        if self.status is not None:
            result['Status'] = self.status
        if self.stop_duration is not None:
            result['StopDuration'] = self.stop_duration
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        if self.version is not None:
            result['Version'] = self.version
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindAmount') is not None:
            self.bind_amount = m.get('BindAmount')
        if m.get('BuyDesktopsCount') is not None:
            self.buy_desktops_count = m.get('BuyDesktopsCount')
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('ConnectDuration') is not None:
            self.connect_duration = m.get('ConnectDuration')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('EndUserCount') is not None:
            self.end_user_count = m.get('EndUserCount')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('IdleDisconnectDuration') is not None:
            self.idle_disconnect_duration = m.get('IdleDisconnectDuration')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxDesktopsCount') is not None:
            self.max_desktops_count = m.get('MaxDesktopsCount')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MinDesktopsCount') is not None:
            self.min_desktops_count = m.get('MinDesktopsCount')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('OwnBundleId') is not None:
            self.own_bundle_id = m.get('OwnBundleId')
        if m.get('OwnBundleName') is not None:
            self.own_bundle_name = m.get('OwnBundleName')
        if m.get('OwnType') is not None:
            self.own_type = m.get('OwnType')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupName') is not None:
            self.policy_group_name = m.get('PolicyGroupName')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StopDuration') is not None:
            self.stop_duration = m.get('StopDuration')
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        return self


class DescribeDesktopGroupsResponseBody(TeaModel):
    def __init__(self, desktop_groups=None, next_token=None, request_id=None):
        # Details of the desktop groups.
        self.desktop_groups = desktop_groups  # type: list[DescribeDesktopGroupsResponseBodyDesktopGroups]
        # The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktop_groups:
            for k in self.desktop_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesktopGroups'] = []
        if self.desktop_groups is not None:
            for k in self.desktop_groups:
                result['DesktopGroups'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desktop_groups = []
        if m.get('DesktopGroups') is not None:
            for k in m.get('DesktopGroups'):
                temp_model = DescribeDesktopGroupsResponseBodyDesktopGroups()
                self.desktop_groups.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDesktopGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDesktopGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDesktopGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDesktopGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDesktopIdsByVulNamesRequest(TeaModel):
    def __init__(self, necessity=None, office_site_id=None, region_id=None, type=None, vul_name=None):
        # The priority to fix the vulnerability or the risk level of the vulnerability. Valid values:
        # 
        # *   asap: high
        # *   later: medium
        # *   nntf: low
        self.necessity = necessity  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: Linux software vulnerability
        # *   sys: Windows system vulnerability
        self.type = type  # type: str
        self.vul_name = vul_name  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopIdsByVulNamesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        if self.vul_name is not None:
            result['VulName'] = self.vul_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VulName') is not None:
            self.vul_name = m.get('VulName')
        return self


class DescribeDesktopIdsByVulNamesResponseBodyDesktopItems(TeaModel):
    def __init__(self, desktop_id=None, desktop_name=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopIdsByVulNamesResponseBodyDesktopItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        return self


class DescribeDesktopIdsByVulNamesResponseBody(TeaModel):
    def __init__(self, desktop_items=None, request_id=None):
        # Details about cloud desktops.
        self.desktop_items = desktop_items  # type: list[DescribeDesktopIdsByVulNamesResponseBodyDesktopItems]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktop_items:
            for k in self.desktop_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopIdsByVulNamesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesktopItems'] = []
        if self.desktop_items is not None:
            for k in self.desktop_items:
                result['DesktopItems'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desktop_items = []
        if m.get('DesktopItems') is not None:
            for k in m.get('DesktopItems'):
                temp_model = DescribeDesktopIdsByVulNamesResponseBodyDesktopItems()
                self.desktop_items.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDesktopIdsByVulNamesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDesktopIdsByVulNamesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDesktopIdsByVulNamesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDesktopIdsByVulNamesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDesktopTypesRequest(TeaModel):
    def __init__(self, applied_scope=None, cpu_count=None, desktop_id_for_modify=None, desktop_type_id=None,
                 gpu_count=None, instance_type_family=None, memory_size=None, order_type=None, region_id=None):
        # The applicable scope of the desktop type. Default value: `Public`.
        self.applied_scope = applied_scope  # type: str
        # The number of vCPUs.
        self.cpu_count = cpu_count  # type: int
        # The ID of the cloud desktop whose desktop type that you want to modify. If you specify this parameter, the information that is returned includes whether the desktop type is compatible with the cloud desktop.
        self.desktop_id_for_modify = desktop_id_for_modify  # type: str
        # The ID of the desktop type. Valid values:
        # 
        # *   eds.graphics.16c1t4
        # *   eds.graphics.24c1t4
        # *   eds.hf.12c24g
        # *   eds.hf.8c16g
        # *   eds.hf.4c8g
        # *   eds.general.8c32g
        # *   eds.general.16c32g
        # *   eds.general.8c16g
        # *   eds.general.4c16g
        # *   eds.general.4c8g
        # *   eds.general.2c8g
        # *   eds.general.2c4g
        # *   eds.general.2c2g
        # *   ecd.graphics.xlarge
        # *   ecd.graphics.2xlarge
        # *   ecd.performance.2xlarge
        # *   ecd.advanced.xlarge
        # *   ecd.advanced.large
        # *   ecd.basic.large
        # *   ecd.basic.small
        # 
        # > When no values are specified for the `InstanceTypeFamily` and `DesktopTypeId` parameters for a cloud desktop, all desktop types are queried.
        self.desktop_type_id = desktop_type_id  # type: str
        # The number of GPUs.
        self.gpu_count = gpu_count  # type: float
        # The family of the cloud desktop type. Valid values:
        # 
        # *   eds.graphics
        # *   eds.hf
        # *   eds.general
        # *   ecd.graphics
        # *   ecd.performance
        # *   ecd.advanced
        # *   ecd.basic
        # 
        # > When no values are specified for the `InstanceTypeFamily` and `DesktopTypeId` parameters for a cloud desktop, all desktop types are queried.
        self.instance_type_family = instance_type_family  # type: str
        # The size of the memory. Unit: GiB.
        self.memory_size = memory_size  # type: int
        # The type of the order that you want to place.
        self.order_type = order_type  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopTypesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.applied_scope is not None:
            result['AppliedScope'] = self.applied_scope
        if self.cpu_count is not None:
            result['CpuCount'] = self.cpu_count
        if self.desktop_id_for_modify is not None:
            result['DesktopIdForModify'] = self.desktop_id_for_modify
        if self.desktop_type_id is not None:
            result['DesktopTypeId'] = self.desktop_type_id
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppliedScope') is not None:
            self.applied_scope = m.get('AppliedScope')
        if m.get('CpuCount') is not None:
            self.cpu_count = m.get('CpuCount')
        if m.get('DesktopIdForModify') is not None:
            self.desktop_id_for_modify = m.get('DesktopIdForModify')
        if m.get('DesktopTypeId') is not None:
            self.desktop_type_id = m.get('DesktopTypeId')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeDesktopTypesResponseBodyDesktopTypes(TeaModel):
    def __init__(self, cpu_count=None, data_disk_size=None, desktop_type_id=None, desktop_type_status=None,
                 gpu_count=None, gpu_spec=None, instance_type_family=None, memory_size=None, system_disk_size=None):
        # The number of vCPUs.
        self.cpu_count = cpu_count  # type: str
        # The size of the data disk. Unit: GiB.
        self.data_disk_size = data_disk_size  # type: str
        # The ID of the desktop type.
        self.desktop_type_id = desktop_type_id  # type: str
        # The status of the desktop type. If `SUFFICIENT` is returned, the number of cloud desktops of the specified desktop type is sufficient.
        self.desktop_type_status = desktop_type_status  # type: str
        # The number of GPUs.
        self.gpu_count = gpu_count  # type: float
        # The GPU memory.
        self.gpu_spec = gpu_spec  # type: str
        # The family of the desktop type.
        self.instance_type_family = instance_type_family  # type: str
        # The size of the memory. Unit: MiB.
        self.memory_size = memory_size  # type: str
        # The size of the system disk. Unit: GiB.
        self.system_disk_size = system_disk_size  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopTypesResponseBodyDesktopTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cpu_count is not None:
            result['CpuCount'] = self.cpu_count
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.desktop_type_id is not None:
            result['DesktopTypeId'] = self.desktop_type_id
        if self.desktop_type_status is not None:
            result['DesktopTypeStatus'] = self.desktop_type_status
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.instance_type_family is not None:
            result['InstanceTypeFamily'] = self.instance_type_family
        if self.memory_size is not None:
            result['MemorySize'] = self.memory_size
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CpuCount') is not None:
            self.cpu_count = m.get('CpuCount')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DesktopTypeId') is not None:
            self.desktop_type_id = m.get('DesktopTypeId')
        if m.get('DesktopTypeStatus') is not None:
            self.desktop_type_status = m.get('DesktopTypeStatus')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('InstanceTypeFamily') is not None:
            self.instance_type_family = m.get('InstanceTypeFamily')
        if m.get('MemorySize') is not None:
            self.memory_size = m.get('MemorySize')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribeDesktopTypesResponseBody(TeaModel):
    def __init__(self, desktop_types=None, request_id=None):
        # Details of the desktop types.
        self.desktop_types = desktop_types  # type: list[DescribeDesktopTypesResponseBodyDesktopTypes]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktop_types:
            for k in self.desktop_types:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopTypesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesktopTypes'] = []
        if self.desktop_types is not None:
            for k in self.desktop_types:
                result['DesktopTypes'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desktop_types = []
        if m.get('DesktopTypes') is not None:
            for k in m.get('DesktopTypes'):
                temp_model = DescribeDesktopTypesResponseBodyDesktopTypes()
                self.desktop_types.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDesktopTypesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDesktopTypesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDesktopTypesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDesktopTypesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDesktopsRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag. If you specify the `Tag` parameter, you must also specify the `Key` parameter. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`. You cannot specify an empty string as a tag key.
        self.key = key  # type: str
        # The value of the tag. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `aliyun` or `acs:`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDesktopsRequest(TeaModel):
    def __init__(self, charge_type=None, desktop_group_id=None, desktop_id=None, desktop_name=None,
                 desktop_status=None, desktop_type=None, directory_id=None, end_user_id=None, excluded_end_user_id=None,
                 expired_time=None, filter_desktop_group=None, group_id=None, image_id=None, management_flag=None,
                 max_results=None, next_token=None, office_site_id=None, office_site_name=None, only_desktop_group=None,
                 os_types=None, policy_group_id=None, protocol_type=None, query_fota_update=None, region_id=None,
                 snapshot_policy_id=None, tag=None, user_name=None):
        # The billing method of the cloud desktop.
        self.charge_type = charge_type  # type: str
        # The ID of the desktop group. If you specify the `DesktopId` parameter, ignore the `DesktopGroupId` parameter. If you do not specify the `DesktopId` parameter, specify the `DesktopGroupId` parameter in the call to request all IDs of the cloud desktops in the specified desktop group.``
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the cloud desktops. You can specify 1 to 100 IDs of cloud desktops.
        self.desktop_id = desktop_id  # type: list[str]
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The state of the cloud desktop.
        self.desktop_status = desktop_status  # type: str
        # The new desktop type. You can call the [DescribeDesktopTypes](~~188882~~) operation to query the IDs of supported desktop types.
        self.desktop_type = desktop_type  # type: str
        # The ID of the directory. The ID is the same as the workspace ID.
        self.directory_id = directory_id  # type: str
        # The IDs of the users that are assigned the cloud desktop. You can specify IDs of 1 to 100 users.
        # 
        # > Only one user can use the cloud desktop at a time.
        self.end_user_id = end_user_id  # type: list[str]
        # The IDs of the users that are excluded from the users that are assigned the cloud desktop. You can specify IDs of 1 to 100 users.
        self.excluded_end_user_id = excluded_end_user_id  # type: list[str]
        # The time when the subscription cloud desktop expires.
        self.expired_time = expired_time  # type: str
        # Specifies whether to filter cloud desktops in the desktop group.
        self.filter_desktop_group = filter_desktop_group  # type: bool
        # The ID of the desktop group.
        self.group_id = group_id  # type: str
        # 镜像ID列表。
        self.image_id = image_id  # type: list[str]
        # The flag that is used for management.
        self.management_flag = management_flag  # type: str
        # The maximum number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 10
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # Specifies whether to query cloud desktops in the desktop group.
        self.only_desktop_group = only_desktop_group  # type: bool
        # The types of the OSs.
        self.os_types = os_types  # type: list[str]
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # Specifies whether to query the information about image version of the cloud desktop.
        self.query_fota_update = query_fota_update  # type: bool
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the automatic snapshot policy.
        self.snapshot_policy_id = snapshot_policy_id  # type: str
        # The tags that you want to add. A tag is a key-value pair that consists of a tag key and a tag value. Tags are used to identify resources. You can use tags to manage cloud desktops by group for easy searching and batch operations. For more information, see [Use tags to manage cloud desktops](~~203781~~).
        self.tag = tag  # type: list[DescribeDesktopsRequestTag]
        # The name of the user.
        self.user_name = user_name  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.desktop_type is not None:
            result['DesktopType'] = self.desktop_type
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.excluded_end_user_id is not None:
            result['ExcludedEndUserId'] = self.excluded_end_user_id
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.filter_desktop_group is not None:
            result['FilterDesktopGroup'] = self.filter_desktop_group
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.management_flag is not None:
            result['ManagementFlag'] = self.management_flag
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.only_desktop_group is not None:
            result['OnlyDesktopGroup'] = self.only_desktop_group
        if self.os_types is not None:
            result['OsTypes'] = self.os_types
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.query_fota_update is not None:
            result['QueryFotaUpdate'] = self.query_fota_update
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_policy_id is not None:
            result['SnapshotPolicyId'] = self.snapshot_policy_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('DesktopType') is not None:
            self.desktop_type = m.get('DesktopType')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('ExcludedEndUserId') is not None:
            self.excluded_end_user_id = m.get('ExcludedEndUserId')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('FilterDesktopGroup') is not None:
            self.filter_desktop_group = m.get('FilterDesktopGroup')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ManagementFlag') is not None:
            self.management_flag = m.get('ManagementFlag')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OnlyDesktopGroup') is not None:
            self.only_desktop_group = m.get('OnlyDesktopGroup')
        if m.get('OsTypes') is not None:
            self.os_types = m.get('OsTypes')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('QueryFotaUpdate') is not None:
            self.query_fota_update = m.get('QueryFotaUpdate')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotPolicyId') is not None:
            self.snapshot_policy_id = m.get('SnapshotPolicyId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = DescribeDesktopsRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeDesktopsResponseBodyDesktopsDisks(TeaModel):
    def __init__(self, disk_id=None, disk_size=None, disk_type=None, performance_level=None):
        # The ID of the disk.
        self.disk_id = disk_id  # type: str
        # The size of the disk. Unit: GiB.
        self.disk_size = disk_size  # type: int
        # The type of the disk.
        self.disk_type = disk_type  # type: str
        # The performance level (PL) of the disk that is an enhanced SSD (ESSD). Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        # 
        # For more information about the differences between disks of different PLs, see [Enhanced SSDs](~~122389~~).
        self.performance_level = performance_level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsResponseBodyDesktopsDisks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.disk_id is not None:
            result['DiskId'] = self.disk_id
        if self.disk_size is not None:
            result['DiskSize'] = self.disk_size
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.performance_level is not None:
            result['PerformanceLevel'] = self.performance_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DiskId') is not None:
            self.disk_id = m.get('DiskId')
        if m.get('DiskSize') is not None:
            self.disk_size = m.get('DiskSize')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('PerformanceLevel') is not None:
            self.performance_level = m.get('PerformanceLevel')
        return self


class DescribeDesktopsResponseBodyDesktopsFotaUpdate(TeaModel):
    def __init__(self, current_app_version=None, new_app_version=None, release_note=None, size=None):
        # The current version of the cloud desktop.
        self.current_app_version = current_app_version  # type: str
        # The version to which the cloud desktop can be updated.
        self.new_app_version = new_app_version  # type: str
        # The description of the version to which the cloud desktop can be updated.
        self.release_note = release_note  # type: str
        # The size of the installation package for the version to which the cloud desktop can be updated. Unit: KB.
        self.size = size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsResponseBodyDesktopsFotaUpdate, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_app_version is not None:
            result['CurrentAppVersion'] = self.current_app_version
        if self.new_app_version is not None:
            result['NewAppVersion'] = self.new_app_version
        if self.release_note is not None:
            result['ReleaseNote'] = self.release_note
        if self.size is not None:
            result['Size'] = self.size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentAppVersion') is not None:
            self.current_app_version = m.get('CurrentAppVersion')
        if m.get('NewAppVersion') is not None:
            self.new_app_version = m.get('NewAppVersion')
        if m.get('ReleaseNote') is not None:
            self.release_note = m.get('ReleaseNote')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        return self


class DescribeDesktopsResponseBodyDesktopsSessions(TeaModel):
    def __init__(self, end_user_id=None, establishment_time=None, external_user_name=None):
        # The ID of the user that logged on to the cloud desktop.
        self.end_user_id = end_user_id  # type: str
        # The time when the desktop session was established.
        self.establishment_time = establishment_time  # type: str
        # The name of the external user.
        self.external_user_name = external_user_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsResponseBodyDesktopsSessions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.establishment_time is not None:
            result['EstablishmentTime'] = self.establishment_time
        if self.external_user_name is not None:
            result['ExternalUserName'] = self.external_user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EstablishmentTime') is not None:
            self.establishment_time = m.get('EstablishmentTime')
        if m.get('ExternalUserName') is not None:
            self.external_user_name = m.get('ExternalUserName')
        return self


class DescribeDesktopsResponseBodyDesktopsTags(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag.
        self.key = key  # type: str
        # The value of the tag.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsResponseBodyDesktopsTags, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class DescribeDesktopsResponseBodyDesktops(TeaModel):
    def __init__(self, bind_amount=None, bundle_id=None, bundle_name=None, charge_type=None, connection_status=None,
                 cpu=None, creation_time=None, data_disk_category=None, data_disk_size=None, desktop_group_id=None,
                 desktop_id=None, desktop_name=None, desktop_status=None, desktop_type=None, directory_id=None,
                 directory_type=None, disks=None, downgrade_quota=None, downgraded_times=None, end_user_ids=None,
                 expired_time=None, fota_update=None, gpu_category=None, gpu_count=None, gpu_driver_version=None, gpu_spec=None,
                 hibernation_options_configured=None, host_name=None, image_id=None, management_flag=None, memory=None, network_interface_id=None,
                 network_interface_ip=None, office_site_id=None, office_site_name=None, office_site_type=None,
                 office_site_vpc_type=None, os_type=None, platform=None, policy_group_id=None, policy_group_id_list=None,
                 policy_group_name=None, policy_group_name_list=None, progress=None, protocol_type=None, session_type=None,
                 sessions=None, snapshot_policy_id=None, snapshot_policy_name=None, start_time=None,
                 support_hibernation=None, system_disk_category=None, system_disk_size=None, tags=None, volume_encryption_enabled=None,
                 volume_encryption_key=None, zone_type=None):
        # The number of sessions allowed for each cloud desktop in the multi-session desktop group.
        self.bind_amount = bind_amount  # type: int
        # The ID of the desktop template that is used to create the cloud desktop.
        self.bundle_id = bundle_id  # type: str
        # The name of the desktop template that is used to create the cloud desktop.
        self.bundle_name = bundle_name  # type: str
        # The billing method of the cloud desktop.
        self.charge_type = charge_type  # type: str
        # The connection status of the user.
        self.connection_status = connection_status  # type: str
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # The time when the cloud desktop was created.
        self.creation_time = creation_time  # type: str
        # > This parameter is in invitational preview and is unavailable to the public.
        self.data_disk_category = data_disk_category  # type: str
        # > This parameter is in invitational preview and is unavailable to the public.
        self.data_disk_size = data_disk_size  # type: str
        # The ID of the group to which the cloud desktop belongs. Default value: null.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The state of the cloud desktop.
        self.desktop_status = desktop_status  # type: str
        # The desktop type.
        self.desktop_type = desktop_type  # type: str
        # The ID is the same as the workspace ID that is indicated by the value of the OfficeSiteId parameter.
        self.directory_id = directory_id  # type: str
        # This parameter is in invitational preview and unavailable for general users.
        self.directory_type = directory_type  # type: str
        # Details of the disks.
        self.disks = disks  # type: list[DescribeDesktopsResponseBodyDesktopsDisks]
        # The number of times for which the cloud desktop can be downgraded.
        self.downgrade_quota = downgrade_quota  # type: long
        # The number of times for which the cloud desktop is downgraded.
        self.downgraded_times = downgraded_times  # type: long
        # The IDs of the users that have the permissions to connect to the cloud desktops.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The time when the subscription cloud desktop expires.
        self.expired_time = expired_time  # type: str
        # The information about the image version that the cloud desktop uses.
        self.fota_update = fota_update  # type: DescribeDesktopsResponseBodyDesktopsFotaUpdate
        # Indicates whether the cloud desktop is of the GPU-accelerated type.
        self.gpu_category = gpu_category  # type: long
        # The number of GPUs.
        self.gpu_count = gpu_count  # type: float
        # The version of the GPU driver with which the cloud desktop is equipped.
        self.gpu_driver_version = gpu_driver_version  # type: str
        # The GPU model.
        self.gpu_spec = gpu_spec  # type: str
        # > This parameter is in invitational preview and is unavailable to the public.
        self.hibernation_options_configured = hibernation_options_configured  # type: bool
        # The hostname of the cloud desktop.
        self.host_name = host_name  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The flag that is used for management.
        self.management_flag = management_flag  # type: str
        # The memory size. Unit: MiB.
        self.memory = memory  # type: long
        # The ID of the secondary network interface controller (NIC) created by the RAM user or Active Directory (AD) user in EDS. You do not have the permissions to modify this ID.
        self.network_interface_id = network_interface_id  # type: str
        # The IP address of the secondary NIC that is created by the RAM user or AD user in EDS.
        self.network_interface_ip = network_interface_ip  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The account type of the workspace.
        self.office_site_type = office_site_type  # type: str
        # The virtual private cloud (VPC) type of the workspace.
        self.office_site_vpc_type = office_site_vpc_type  # type: str
        # The type of the OS.
        self.os_type = os_type  # type: str
        # The information about the OS platform. Valid values:
        # 
        # *   CentOS
        # *   Ubuntu
        # *   Windows Server 2016
        # *   Windows Server 2019
        # *   UOS
        self.platform = platform  # type: str
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The IDs of the policies.
        self.policy_group_id_list = policy_group_id_list  # type: list[str]
        # The name of the policy.
        self.policy_group_name = policy_group_name  # type: str
        # The names of the policies.
        self.policy_group_name_list = policy_group_name_list  # type: list[str]
        # The progress when the cloud desktop was created.
        self.progress = progress  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # The type of the session.
        self.session_type = session_type  # type: str
        # Details of the desktop sessions that users hold.
        self.sessions = sessions  # type: list[DescribeDesktopsResponseBodyDesktopsSessions]
        # The ID of the snapshot policy.
        self.snapshot_policy_id = snapshot_policy_id  # type: str
        # The name of the snapshot policy.
        self.snapshot_policy_name = snapshot_policy_name  # type: str
        # The first time when the cloud desktop was started.
        self.start_time = start_time  # type: str
        # Indicates whether hibernation is supported for the cloud desktop.
        self.support_hibernation = support_hibernation  # type: bool
        # > This parameter is in invitational preview and is unavailable to the public.
        self.system_disk_category = system_disk_category  # type: str
        # > This parameter is in invitational preview and is unavailable to the public.
        self.system_disk_size = system_disk_size  # type: int
        # Details of the tags.
        self.tags = tags  # type: list[DescribeDesktopsResponseBodyDesktopsTags]
        # Indicates whether disk encryption is enabled.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str
        # The type of the zone. Default value: **AvailabilityZone**. This value indicates Alibaba Cloud zones.
        self.zone_type = zone_type  # type: str

    def validate(self):
        if self.disks:
            for k in self.disks:
                if k:
                    k.validate()
        if self.fota_update:
            self.fota_update.validate()
        if self.sessions:
            for k in self.sessions:
                if k:
                    k.validate()
        if self.tags:
            for k in self.tags:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopsResponseBodyDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bind_amount is not None:
            result['BindAmount'] = self.bind_amount
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.bundle_name is not None:
            result['BundleName'] = self.bundle_name
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.connection_status is not None:
            result['ConnectionStatus'] = self.connection_status
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.desktop_type is not None:
            result['DesktopType'] = self.desktop_type
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_type is not None:
            result['DirectoryType'] = self.directory_type
        result['Disks'] = []
        if self.disks is not None:
            for k in self.disks:
                result['Disks'].append(k.to_map() if k else None)
        if self.downgrade_quota is not None:
            result['DowngradeQuota'] = self.downgrade_quota
        if self.downgraded_times is not None:
            result['DowngradedTimes'] = self.downgraded_times
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.fota_update is not None:
            result['FotaUpdate'] = self.fota_update.to_map()
        if self.gpu_category is not None:
            result['GpuCategory'] = self.gpu_category
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_driver_version is not None:
            result['GpuDriverVersion'] = self.gpu_driver_version
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.hibernation_options_configured is not None:
            result['HibernationOptionsConfigured'] = self.hibernation_options_configured
        if self.host_name is not None:
            result['HostName'] = self.host_name
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.management_flag is not None:
            result['ManagementFlag'] = self.management_flag
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.network_interface_ip is not None:
            result['NetworkInterfaceIp'] = self.network_interface_ip
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.office_site_vpc_type is not None:
            result['OfficeSiteVpcType'] = self.office_site_vpc_type
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_id_list is not None:
            result['PolicyGroupIdList'] = self.policy_group_id_list
        if self.policy_group_name is not None:
            result['PolicyGroupName'] = self.policy_group_name
        if self.policy_group_name_list is not None:
            result['PolicyGroupNameList'] = self.policy_group_name_list
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.session_type is not None:
            result['SessionType'] = self.session_type
        result['Sessions'] = []
        if self.sessions is not None:
            for k in self.sessions:
                result['Sessions'].append(k.to_map() if k else None)
        if self.snapshot_policy_id is not None:
            result['SnapshotPolicyId'] = self.snapshot_policy_id
        if self.snapshot_policy_name is not None:
            result['SnapshotPolicyName'] = self.snapshot_policy_name
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.support_hibernation is not None:
            result['SupportHibernation'] = self.support_hibernation
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        result['Tags'] = []
        if self.tags is not None:
            for k in self.tags:
                result['Tags'].append(k.to_map() if k else None)
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        if self.zone_type is not None:
            result['ZoneType'] = self.zone_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BindAmount') is not None:
            self.bind_amount = m.get('BindAmount')
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('BundleName') is not None:
            self.bundle_name = m.get('BundleName')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('ConnectionStatus') is not None:
            self.connection_status = m.get('ConnectionStatus')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('DesktopType') is not None:
            self.desktop_type = m.get('DesktopType')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryType') is not None:
            self.directory_type = m.get('DirectoryType')
        self.disks = []
        if m.get('Disks') is not None:
            for k in m.get('Disks'):
                temp_model = DescribeDesktopsResponseBodyDesktopsDisks()
                self.disks.append(temp_model.from_map(k))
        if m.get('DowngradeQuota') is not None:
            self.downgrade_quota = m.get('DowngradeQuota')
        if m.get('DowngradedTimes') is not None:
            self.downgraded_times = m.get('DowngradedTimes')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('FotaUpdate') is not None:
            temp_model = DescribeDesktopsResponseBodyDesktopsFotaUpdate()
            self.fota_update = temp_model.from_map(m['FotaUpdate'])
        if m.get('GpuCategory') is not None:
            self.gpu_category = m.get('GpuCategory')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuDriverVersion') is not None:
            self.gpu_driver_version = m.get('GpuDriverVersion')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('HibernationOptionsConfigured') is not None:
            self.hibernation_options_configured = m.get('HibernationOptionsConfigured')
        if m.get('HostName') is not None:
            self.host_name = m.get('HostName')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ManagementFlag') is not None:
            self.management_flag = m.get('ManagementFlag')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('NetworkInterfaceIp') is not None:
            self.network_interface_ip = m.get('NetworkInterfaceIp')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('OfficeSiteVpcType') is not None:
            self.office_site_vpc_type = m.get('OfficeSiteVpcType')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupIdList') is not None:
            self.policy_group_id_list = m.get('PolicyGroupIdList')
        if m.get('PolicyGroupName') is not None:
            self.policy_group_name = m.get('PolicyGroupName')
        if m.get('PolicyGroupNameList') is not None:
            self.policy_group_name_list = m.get('PolicyGroupNameList')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('SessionType') is not None:
            self.session_type = m.get('SessionType')
        self.sessions = []
        if m.get('Sessions') is not None:
            for k in m.get('Sessions'):
                temp_model = DescribeDesktopsResponseBodyDesktopsSessions()
                self.sessions.append(temp_model.from_map(k))
        if m.get('SnapshotPolicyId') is not None:
            self.snapshot_policy_id = m.get('SnapshotPolicyId')
        if m.get('SnapshotPolicyName') is not None:
            self.snapshot_policy_name = m.get('SnapshotPolicyName')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('SupportHibernation') is not None:
            self.support_hibernation = m.get('SupportHibernation')
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        self.tags = []
        if m.get('Tags') is not None:
            for k in m.get('Tags'):
                temp_model = DescribeDesktopsResponseBodyDesktopsTags()
                self.tags.append(temp_model.from_map(k))
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        if m.get('ZoneType') is not None:
            self.zone_type = m.get('ZoneType')
        return self


class DescribeDesktopsResponseBody(TeaModel):
    def __init__(self, desktops=None, next_token=None, request_id=None, total_count=None):
        # Details of the cloud desktops.
        self.desktops = desktops  # type: list[DescribeDesktopsResponseBodyDesktops]
        # The token that is used for the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of cloud desktops.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.desktops:
            for k in self.desktops:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Desktops'] = []
        if self.desktops is not None:
            for k in self.desktops:
                result['Desktops'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desktops = []
        if m.get('Desktops') is not None:
            for k in m.get('Desktops'):
                temp_model = DescribeDesktopsResponseBodyDesktops()
                self.desktops.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDesktopsInGroupRequest(TeaModel):
    def __init__(self, desktop_group_id=None, ignore_deleted=None, max_results=None, next_token=None, pay_type=None,
                 region_id=None):
        # The desktop group ID.
        self.desktop_group_id = desktop_group_id  # type: str
        # Specifies whether to ignore the deleted cloud desktops.
        self.ignore_deleted = ignore_deleted  # type: bool
        # The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
        self.max_results = max_results  # type: int
        # The pagination token that is used in the next request to retrieve a new page of results. If the NextToken parameter is empty, no next page exists.
        self.next_token = next_token  # type: str
        # The billing method of the desktop group.
        self.pay_type = pay_type  # type: str
        # The region ID.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsInGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.ignore_deleted is not None:
            result['IgnoreDeleted'] = self.ignore_deleted
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('IgnoreDeleted') is not None:
            self.ignore_deleted = m.get('IgnoreDeleted')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeDesktopsInGroupResponseBodyPaidDesktops(TeaModel):
    def __init__(self, connection_status=None, desktop_id=None, desktop_name=None, desktop_status=None,
                 disk_type=None, end_user_id=None, end_user_ids=None, end_user_name=None, end_user_names=None,
                 fota_version=None, gpu_driver_version=None, image_id=None, image_name=None, management_flag=None,
                 management_flags=None, member_eni_ip=None, os_type=None, primary_eni_ip=None, protocol_type=None, reset_time=None,
                 system_disk_size=None):
        # The connection status of the cloud desktop.
        self.connection_status = connection_status  # type: str
        # The cloud desktop ID.
        self.desktop_id = desktop_id  # type: str
        # The cloud desktop name.
        self.desktop_name = desktop_name  # type: str
        # The state of the cloud desktop.
        self.desktop_status = desktop_status  # type: str
        # The disk type.
        self.disk_type = disk_type  # type: str
        # The authorized user.
        self.end_user_id = end_user_id  # type: str
        # The IDs of users that are connected to cloud desktops. If no users are connected, null is returned.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The username of the authorized user.
        self.end_user_name = end_user_name  # type: str
        # The usernames of users that are connected to cloud desktops. If no users are connected, null is returned.
        self.end_user_names = end_user_names  # type: list[str]
        # The image version.
        self.fota_version = fota_version  # type: str
        # The GPU driver version.
        self.gpu_driver_version = gpu_driver_version  # type: str
        # The image ID.
        self.image_id = image_id  # type: str
        # The image name.
        self.image_name = image_name  # type: str
        # The flag that is used for management.
        self.management_flag = management_flag  # type: str
        # The flags that are used for management.
        self.management_flags = management_flags  # type: list[str]
        # The IP address of the member Elastic Network Interface (ENI).
        self.member_eni_ip = member_eni_ip  # type: str
        # The OS type.
        self.os_type = os_type  # type: str
        # The IP address of the primary ENI.
        self.primary_eni_ip = primary_eni_ip  # type: str
        # The protocol. Valid values:
        # 
        # *   ASP
        # *   HDX
        self.protocol_type = protocol_type  # type: str
        # The point in time when the cloud desktop was reset.
        self.reset_time = reset_time  # type: str
        # The system disk size. Unit: GiB.
        self.system_disk_size = system_disk_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsInGroupResponseBodyPaidDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_status is not None:
            result['ConnectionStatus'] = self.connection_status
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.end_user_name is not None:
            result['EndUserName'] = self.end_user_name
        if self.end_user_names is not None:
            result['EndUserNames'] = self.end_user_names
        if self.fota_version is not None:
            result['FotaVersion'] = self.fota_version
        if self.gpu_driver_version is not None:
            result['GpuDriverVersion'] = self.gpu_driver_version
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.management_flag is not None:
            result['ManagementFlag'] = self.management_flag
        if self.management_flags is not None:
            result['ManagementFlags'] = self.management_flags
        if self.member_eni_ip is not None:
            result['MemberEniIp'] = self.member_eni_ip
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.primary_eni_ip is not None:
            result['PrimaryEniIp'] = self.primary_eni_ip
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectionStatus') is not None:
            self.connection_status = m.get('ConnectionStatus')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('EndUserName') is not None:
            self.end_user_name = m.get('EndUserName')
        if m.get('EndUserNames') is not None:
            self.end_user_names = m.get('EndUserNames')
        if m.get('FotaVersion') is not None:
            self.fota_version = m.get('FotaVersion')
        if m.get('GpuDriverVersion') is not None:
            self.gpu_driver_version = m.get('GpuDriverVersion')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ManagementFlag') is not None:
            self.management_flag = m.get('ManagementFlag')
        if m.get('ManagementFlags') is not None:
            self.management_flags = m.get('ManagementFlags')
        if m.get('MemberEniIp') is not None:
            self.member_eni_ip = m.get('MemberEniIp')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('PrimaryEniIp') is not None:
            self.primary_eni_ip = m.get('PrimaryEniIp')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribeDesktopsInGroupResponseBodyPostPaidDesktops(TeaModel):
    def __init__(self, connection_status=None, create_duration=None, create_time=None, desktop_id=None,
                 desktop_name=None, desktop_status=None, disk_type=None, end_user_id=None, end_user_ids=None, end_user_name=None,
                 end_user_names=None, fota_version=None, gpu_driver_version=None, image_id=None, image_name=None,
                 management_flag=None, management_flags=None, member_eni_ip=None, os_type=None, primary_eni_ip=None,
                 protocol_type=None, release_time=None, reset_time=None, system_disk_size=None):
        # The connection status of the cloud desktop.
        self.connection_status = connection_status  # type: str
        # The retention period.
        self.create_duration = create_duration  # type: str
        # The time when the cloud desktop was created.
        self.create_time = create_time  # type: str
        # The cloud desktop ID.
        self.desktop_id = desktop_id  # type: str
        # The cloud desktop name.
        self.desktop_name = desktop_name  # type: str
        # The state of the cloud desktop.
        self.desktop_status = desktop_status  # type: str
        # The disk type.
        self.disk_type = disk_type  # type: str
        # The authorized user.
        self.end_user_id = end_user_id  # type: str
        # The IDs of users that are connected to cloud desktops. If no users are connected, null is returned.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The username of the authorized user.
        self.end_user_name = end_user_name  # type: str
        # The usernames of users that are connected to cloud desktops. If no users are connected, null is returned.
        self.end_user_names = end_user_names  # type: list[str]
        # The image version.
        self.fota_version = fota_version  # type: str
        # The GPU driver version.
        self.gpu_driver_version = gpu_driver_version  # type: str
        # The image ID.
        self.image_id = image_id  # type: str
        # The image name.
        self.image_name = image_name  # type: str
        # The flag that is used for management.
        self.management_flag = management_flag  # type: str
        # The flags that are used for management.
        self.management_flags = management_flags  # type: list[str]
        # The IP address of the member Elastic Network Interface (ENI).
        self.member_eni_ip = member_eni_ip  # type: str
        # The OS type.
        self.os_type = os_type  # type: str
        # The IP address of the primary ENI.
        self.primary_eni_ip = primary_eni_ip  # type: str
        # The protocol. Valid values:
        # 
        # *   ASP
        # *   HDX
        self.protocol_type = protocol_type  # type: str
        # The time when the cloud desktop was released.
        self.release_time = release_time  # type: str
        # The point in time when the cloud desktop was reset.
        self.reset_time = reset_time  # type: str
        # The system disk size. Unit: GiB.
        self.system_disk_size = system_disk_size  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDesktopsInGroupResponseBodyPostPaidDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_status is not None:
            result['ConnectionStatus'] = self.connection_status
        if self.create_duration is not None:
            result['CreateDuration'] = self.create_duration
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.disk_type is not None:
            result['DiskType'] = self.disk_type
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.end_user_name is not None:
            result['EndUserName'] = self.end_user_name
        if self.end_user_names is not None:
            result['EndUserNames'] = self.end_user_names
        if self.fota_version is not None:
            result['FotaVersion'] = self.fota_version
        if self.gpu_driver_version is not None:
            result['GpuDriverVersion'] = self.gpu_driver_version
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.management_flag is not None:
            result['ManagementFlag'] = self.management_flag
        if self.management_flags is not None:
            result['ManagementFlags'] = self.management_flags
        if self.member_eni_ip is not None:
            result['MemberEniIp'] = self.member_eni_ip
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.primary_eni_ip is not None:
            result['PrimaryEniIp'] = self.primary_eni_ip
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.release_time is not None:
            result['ReleaseTime'] = self.release_time
        if self.reset_time is not None:
            result['ResetTime'] = self.reset_time
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectionStatus') is not None:
            self.connection_status = m.get('ConnectionStatus')
        if m.get('CreateDuration') is not None:
            self.create_duration = m.get('CreateDuration')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('DiskType') is not None:
            self.disk_type = m.get('DiskType')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('EndUserName') is not None:
            self.end_user_name = m.get('EndUserName')
        if m.get('EndUserNames') is not None:
            self.end_user_names = m.get('EndUserNames')
        if m.get('FotaVersion') is not None:
            self.fota_version = m.get('FotaVersion')
        if m.get('GpuDriverVersion') is not None:
            self.gpu_driver_version = m.get('GpuDriverVersion')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('ManagementFlag') is not None:
            self.management_flag = m.get('ManagementFlag')
        if m.get('ManagementFlags') is not None:
            self.management_flags = m.get('ManagementFlags')
        if m.get('MemberEniIp') is not None:
            self.member_eni_ip = m.get('MemberEniIp')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('PrimaryEniIp') is not None:
            self.primary_eni_ip = m.get('PrimaryEniIp')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('ReleaseTime') is not None:
            self.release_time = m.get('ReleaseTime')
        if m.get('ResetTime') is not None:
            self.reset_time = m.get('ResetTime')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        return self


class DescribeDesktopsInGroupResponseBody(TeaModel):
    def __init__(self, next_token=None, online_pre_paid_desktops_count=None, paid_desktops=None,
                 paid_desktops_count=None, post_paid_desktops=None, post_paid_desktops_count=None,
                 post_paid_desktops_total_amount=None, request_id=None, running_pre_paid_desktops_count=None, stoped_pre_paid_desktops_count=None):
        # The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
        self.next_token = next_token  # type: str
        # The number of subscription cloud desktops that are connected.
        self.online_pre_paid_desktops_count = online_pre_paid_desktops_count  # type: int
        # The subscription cloud desktops.
        self.paid_desktops = paid_desktops  # type: list[DescribeDesktopsInGroupResponseBodyPaidDesktops]
        # The total number of subscription cloud desktops.
        self.paid_desktops_count = paid_desktops_count  # type: int
        # The pay-as-you-go cloud desktops.
        self.post_paid_desktops = post_paid_desktops  # type: list[DescribeDesktopsInGroupResponseBodyPostPaidDesktops]
        # The total number of pay-as-you-go cloud desktops.
        self.post_paid_desktops_count = post_paid_desktops_count  # type: int
        # The total bill amount for the pay-as-you-go cloud desktops.
        self.post_paid_desktops_total_amount = post_paid_desktops_total_amount  # type: int
        # The request ID.
        self.request_id = request_id  # type: str
        # The number of subscription cloud desktops that are running.
        self.running_pre_paid_desktops_count = running_pre_paid_desktops_count  # type: int
        # The number of subscription cloud desktops that are stopped.
        self.stoped_pre_paid_desktops_count = stoped_pre_paid_desktops_count  # type: int

    def validate(self):
        if self.paid_desktops:
            for k in self.paid_desktops:
                if k:
                    k.validate()
        if self.post_paid_desktops:
            for k in self.post_paid_desktops:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDesktopsInGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.online_pre_paid_desktops_count is not None:
            result['OnlinePrePaidDesktopsCount'] = self.online_pre_paid_desktops_count
        result['PaidDesktops'] = []
        if self.paid_desktops is not None:
            for k in self.paid_desktops:
                result['PaidDesktops'].append(k.to_map() if k else None)
        if self.paid_desktops_count is not None:
            result['PaidDesktopsCount'] = self.paid_desktops_count
        result['PostPaidDesktops'] = []
        if self.post_paid_desktops is not None:
            for k in self.post_paid_desktops:
                result['PostPaidDesktops'].append(k.to_map() if k else None)
        if self.post_paid_desktops_count is not None:
            result['PostPaidDesktopsCount'] = self.post_paid_desktops_count
        if self.post_paid_desktops_total_amount is not None:
            result['PostPaidDesktopsTotalAmount'] = self.post_paid_desktops_total_amount
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.running_pre_paid_desktops_count is not None:
            result['RunningPrePaidDesktopsCount'] = self.running_pre_paid_desktops_count
        if self.stoped_pre_paid_desktops_count is not None:
            result['StopedPrePaidDesktopsCount'] = self.stoped_pre_paid_desktops_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OnlinePrePaidDesktopsCount') is not None:
            self.online_pre_paid_desktops_count = m.get('OnlinePrePaidDesktopsCount')
        self.paid_desktops = []
        if m.get('PaidDesktops') is not None:
            for k in m.get('PaidDesktops'):
                temp_model = DescribeDesktopsInGroupResponseBodyPaidDesktops()
                self.paid_desktops.append(temp_model.from_map(k))
        if m.get('PaidDesktopsCount') is not None:
            self.paid_desktops_count = m.get('PaidDesktopsCount')
        self.post_paid_desktops = []
        if m.get('PostPaidDesktops') is not None:
            for k in m.get('PostPaidDesktops'):
                temp_model = DescribeDesktopsInGroupResponseBodyPostPaidDesktops()
                self.post_paid_desktops.append(temp_model.from_map(k))
        if m.get('PostPaidDesktopsCount') is not None:
            self.post_paid_desktops_count = m.get('PostPaidDesktopsCount')
        if m.get('PostPaidDesktopsTotalAmount') is not None:
            self.post_paid_desktops_total_amount = m.get('PostPaidDesktopsTotalAmount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('RunningPrePaidDesktopsCount') is not None:
            self.running_pre_paid_desktops_count = m.get('RunningPrePaidDesktopsCount')
        if m.get('StopedPrePaidDesktopsCount') is not None:
            self.stoped_pre_paid_desktops_count = m.get('StopedPrePaidDesktopsCount')
        return self


class DescribeDesktopsInGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDesktopsInGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDesktopsInGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDesktopsInGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDevicesRequest(TeaModel):
    def __init__(self, ad_domain=None, client_type=None, device_id=None, directory_id=None, end_user_id=None,
                 page_number=None, page_size=None, region=None, user_type=None):
        # The address of the Active Directory (AD) workspace.
        self.ad_domain = ad_domain  # type: str
        # The type of the Alibaba Cloud Workspace client.
        # 
        # *   1: hardware client.
        # *   2: software client.
        self.client_type = client_type  # type: str
        # The ID of the device.
        self.device_id = device_id  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The ID of the convenience user to whom you want to bind the device.
        self.end_user_id = end_user_id  # type: str
        # The number of the page to return.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The ID of the region.
        self.region = region  # type: str
        # The type of the user account.
        # 
        # *   SIMPLE: convenience account.
        # *   AD: AD account.
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDevicesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_domain is not None:
            result['AdDomain'] = self.ad_domain
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region is not None:
            result['Region'] = self.region
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdDomain') is not None:
            self.ad_domain = m.get('AdDomain')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeDevicesResponseBodyDevicesEndUserList(TeaModel):
    def __init__(self, ad_domain=None, directory_id=None, end_user_id=None, user_type=None):
        # The address of the AD workspace.
        self.ad_domain = ad_domain  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The ID of the user.
        self.end_user_id = end_user_id  # type: str
        # The type of the account.
        self.user_type = user_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDevicesResponseBodyDevicesEndUserList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_domain is not None:
            result['AdDomain'] = self.ad_domain
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdDomain') is not None:
            self.ad_domain = m.get('AdDomain')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        return self


class DescribeDevicesResponseBodyDevices(TeaModel):
    def __init__(self, device_id=None, end_user_list=None):
        # The ID of the device.
        self.device_id = device_id  # type: str
        # The users who are bound to the device.
        self.end_user_list = end_user_list  # type: list[DescribeDevicesResponseBodyDevicesEndUserList]

    def validate(self):
        if self.end_user_list:
            for k in self.end_user_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDevicesResponseBodyDevices, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        result['EndUserList'] = []
        if self.end_user_list is not None:
            for k in self.end_user_list:
                result['EndUserList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        self.end_user_list = []
        if m.get('EndUserList') is not None:
            for k in m.get('EndUserList'):
                temp_model = DescribeDevicesResponseBodyDevicesEndUserList()
                self.end_user_list.append(temp_model.from_map(k))
        return self


class DescribeDevicesResponseBody(TeaModel):
    def __init__(self, devices=None, request_id=None):
        # Details of the devices that are returned.
        self.devices = devices  # type: list[DescribeDevicesResponseBodyDevices]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.devices:
            for k in self.devices:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDevicesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Devices'] = []
        if self.devices is not None:
            for k in self.devices:
                result['Devices'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.devices = []
        if m.get('Devices') is not None:
            for k in m.get('Devices'):
                temp_model = DescribeDevicesResponseBodyDevices()
                self.devices.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDevicesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDevicesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDevicesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeDirectoriesRequest(TeaModel):
    def __init__(self, directory_id=None, directory_status=None, directory_type=None, max_results=None,
                 next_token=None, region_id=None, status=None):
        # Details of directory IDs. You can specify one or more directory IDs.
        self.directory_id = directory_id  # type: list[str]
        # The status of the directory. The value of this parameter is the same as the value of the `Status` parameter.
        self.directory_status = directory_status  # type: str
        # The type of the directory.
        self.directory_type = directory_type  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The status of the workspace.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDirectoriesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_status is not None:
            result['DirectoryStatus'] = self.directory_status
        if self.directory_type is not None:
            result['DirectoryType'] = self.directory_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryStatus') is not None:
            self.directory_status = m.get('DirectoryStatus')
        if m.get('DirectoryType') is not None:
            self.directory_type = m.get('DirectoryType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeDirectoriesResponseBodyDirectoriesADConnectors(TeaModel):
    def __init__(self, adconnector_address=None, connector_status=None, network_interface_id=None,
                 specification=None, trust_key=None, v_switch_id=None):
        # The address of the AD connector.
        self.adconnector_address = adconnector_address  # type: str
        # The status of the AD connector.
        self.connector_status = connector_status  # type: str
        # The ID of the network interface controller (NIC) with which the AD connector is associated.
        self.network_interface_id = network_interface_id  # type: str
        # The type of the AD connector.
        self.specification = specification  # type: str
        # The trust password of the AD domain controller.
        self.trust_key = trust_key  # type: str
        # The ID of the vSwitch with which the AD connector is associated.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDirectoriesResponseBodyDirectoriesADConnectors, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adconnector_address is not None:
            result['ADConnectorAddress'] = self.adconnector_address
        if self.connector_status is not None:
            result['ConnectorStatus'] = self.connector_status
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.trust_key is not None:
            result['TrustKey'] = self.trust_key
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ADConnectorAddress') is not None:
            self.adconnector_address = m.get('ADConnectorAddress')
        if m.get('ConnectorStatus') is not None:
            self.connector_status = m.get('ConnectorStatus')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('TrustKey') is not None:
            self.trust_key = m.get('TrustKey')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeDirectoriesResponseBodyDirectoriesLogs(TeaModel):
    def __init__(self, level=None, message=None, step=None, time_stamp=None):
        # The level of the log entry.
        self.level = level  # type: str
        # Details of the log entry.
        self.message = message  # type: str
        # The step that corresponds to the log entry.
        self.step = step  # type: str
        # The time when the log entry was printed.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeDirectoriesResponseBodyDirectoriesLogs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.step is not None:
            result['Step'] = self.step
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeDirectoriesResponseBodyDirectories(TeaModel):
    def __init__(self, adconnectors=None, creation_time=None, custom_security_group_id=None,
                 desktop_access_type=None, desktop_vpc_endpoint=None, directory_id=None, directory_type=None, dns_address=None,
                 dns_user_name=None, domain_name=None, domain_password=None, domain_user_name=None, enable_admin_access=None,
                 enable_cross_desktop_access=None, enable_internet_access=None, file_system_ids=None, logs=None, mfa_enabled=None, name=None,
                 need_verify_login_risk=None, ou_name=None, sso_enabled=None, status=None, sub_dns_address=None, sub_domain_name=None,
                 trust_password=None, v_switch_ids=None, vpc_id=None):
        # Details of the AD connectors.
        self.adconnectors = adconnectors  # type: list[DescribeDirectoriesResponseBodyDirectoriesADConnectors]
        # The time when the directory was created.
        self.creation_time = creation_time  # type: str
        # The ID of the security group.
        self.custom_security_group_id = custom_security_group_id  # type: str
        # The method that is used to connect the client to cloud desktops.
        self.desktop_access_type = desktop_access_type  # type: str
        # The endpoint that is used to connect to cloud desktops over a VPC.
        self.desktop_vpc_endpoint = desktop_vpc_endpoint  # type: str
        # The ID of the directory.
        self.directory_id = directory_id  # type: str
        # The type of the directory.
        self.directory_type = directory_type  # type: str
        # Details of the DNS addresses of the directory.
        self.dns_address = dns_address  # type: list[str]
        # The username of the Domain Name System (DNS) user.
        self.dns_user_name = dns_user_name  # type: str
        # The name of the domain.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator.
        self.domain_user_name = domain_user_name  # type: str
        # Indicates whether the permissions of the local administrator are granted to the regular user of the cloud desktop.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Indicates whether the desktop communication feature is enabled for cloud desktops in the same workspace.
        # 
        # If the feature is enabled, the cloud desktops in the same workspace can access each other.
        self.enable_cross_desktop_access = enable_cross_desktop_access  # type: bool
        # Indicates whether access over the Internet is allowed.
        # 
        # >  This parameter is unavailable.
        self.enable_internet_access = enable_internet_access  # type: bool
        # Details of the IDs of the Apsara File Storage NAS (NAS) file systems.
        self.file_system_ids = file_system_ids  # type: list[str]
        # Details of the registration logs.
        self.logs = logs  # type: list[DescribeDirectoriesResponseBodyDirectoriesLogs]
        # Indicates whether multi-factor authentication (MFA) is enabled.
        self.mfa_enabled = mfa_enabled  # type: bool
        # The name of the directory.
        self.name = name  # type: str
        # Indicates whether two-factor verification for logons is enabled. This parameter is returned only for workspaces of the convenience account type.\
        # If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to the Elastic Desktop Service (EDS) client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the user enters the correct verification code.
        self.need_verify_login_risk = need_verify_login_risk  # type: bool
        # The name of the organizational unit (OU) that you specified when you add cloud desktops to domains.
        self.ou_name = ou_name  # type: str
        # Indicates whether single sign-on (SSO) is enabled.
        self.sso_enabled = sso_enabled  # type: bool
        # The status of the AD directory. Valid values:
        # 
        # *   REGISTERING
        # *   REGISTERED
        self.status = status  # type: str
        # Details of the DNS addresses of the AD subdomain.
        self.sub_dns_address = sub_dns_address  # type: list[str]
        # The fully qualified domain name (FQDN) of the enterprise AD subdomain. The value must contain the hostname and the subdomain name. Example: child.example.com.
        self.sub_domain_name = sub_domain_name  # type: str
        # The AD trust password.
        self.trust_password = trust_password  # type: str
        # Details of vSwitch IDs that are specified when the directory is being created.
        self.v_switch_ids = v_switch_ids  # type: list[str]
        # The ID of the virtual private cloud (VPC) to which the vSwitch belongs.
        self.vpc_id = vpc_id  # type: str

    def validate(self):
        if self.adconnectors:
            for k in self.adconnectors:
                if k:
                    k.validate()
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDirectoriesResponseBodyDirectories, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ADConnectors'] = []
        if self.adconnectors is not None:
            for k in self.adconnectors:
                result['ADConnectors'].append(k.to_map() if k else None)
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.custom_security_group_id is not None:
            result['CustomSecurityGroupId'] = self.custom_security_group_id
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.desktop_vpc_endpoint is not None:
            result['DesktopVpcEndpoint'] = self.desktop_vpc_endpoint
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_type is not None:
            result['DirectoryType'] = self.directory_type
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.dns_user_name is not None:
            result['DnsUserName'] = self.dns_user_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.enable_cross_desktop_access is not None:
            result['EnableCrossDesktopAccess'] = self.enable_cross_desktop_access
        if self.enable_internet_access is not None:
            result['EnableInternetAccess'] = self.enable_internet_access
        if self.file_system_ids is not None:
            result['FileSystemIds'] = self.file_system_ids
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.need_verify_login_risk is not None:
            result['NeedVerifyLoginRisk'] = self.need_verify_login_risk
        if self.ou_name is not None:
            result['OuName'] = self.ou_name
        if self.sso_enabled is not None:
            result['SsoEnabled'] = self.sso_enabled
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_dns_address is not None:
            result['SubDnsAddress'] = self.sub_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        if self.trust_password is not None:
            result['TrustPassword'] = self.trust_password
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.adconnectors = []
        if m.get('ADConnectors') is not None:
            for k in m.get('ADConnectors'):
                temp_model = DescribeDirectoriesResponseBodyDirectoriesADConnectors()
                self.adconnectors.append(temp_model.from_map(k))
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('CustomSecurityGroupId') is not None:
            self.custom_security_group_id = m.get('CustomSecurityGroupId')
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('DesktopVpcEndpoint') is not None:
            self.desktop_vpc_endpoint = m.get('DesktopVpcEndpoint')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryType') is not None:
            self.directory_type = m.get('DirectoryType')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DnsUserName') is not None:
            self.dns_user_name = m.get('DnsUserName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('EnableCrossDesktopAccess') is not None:
            self.enable_cross_desktop_access = m.get('EnableCrossDesktopAccess')
        if m.get('EnableInternetAccess') is not None:
            self.enable_internet_access = m.get('EnableInternetAccess')
        if m.get('FileSystemIds') is not None:
            self.file_system_ids = m.get('FileSystemIds')
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribeDirectoriesResponseBodyDirectoriesLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedVerifyLoginRisk') is not None:
            self.need_verify_login_risk = m.get('NeedVerifyLoginRisk')
        if m.get('OuName') is not None:
            self.ou_name = m.get('OuName')
        if m.get('SsoEnabled') is not None:
            self.sso_enabled = m.get('SsoEnabled')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubDnsAddress') is not None:
            self.sub_dns_address = m.get('SubDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        if m.get('TrustPassword') is not None:
            self.trust_password = m.get('TrustPassword')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        return self


class DescribeDirectoriesResponseBody(TeaModel):
    def __init__(self, ad_hostname=None, directories=None, next_token=None, request_id=None):
        # The hostname of the domain controller. The hostname must comply with the hostname naming convention of Windows.
        self.ad_hostname = ad_hostname  # type: str
        # Details of the directories.
        self.directories = directories  # type: list[DescribeDirectoriesResponseBodyDirectories]
        # The token that is used for the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.directories:
            for k in self.directories:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeDirectoriesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname
        result['Directories'] = []
        if self.directories is not None:
            for k in self.directories:
                result['Directories'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')
        self.directories = []
        if m.get('Directories') is not None:
            for k in m.get('Directories'):
                temp_model = DescribeDirectoriesResponseBodyDirectories()
                self.directories.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeDirectoriesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeDirectoriesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeDirectoriesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeDirectoriesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFlowMetricRequest(TeaModel):
    def __init__(self, end_time=None, instance_id=None, instance_type=None, metric_type=None, period=None,
                 region_id=None, start_time=None):
        # The end of the time range to query data. The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format.
        self.end_time = end_time  # type: str
        # The ID of the instance. The value can be the ID of the cloud desktop or the ID of the Internet access package.
        self.instance_id = instance_id  # type: str
        # The type of the instance. You can select a cloud desktop or a network package as an instance. If you select a cloud desktop as an instance, you need to configure the `InstanceId` and `MetricType` parameters. If you select a network package as an instance, you also need to must configure the parameters.
        self.instance_type = instance_type  # type: str
        # The type of the monitoring data. The monitoring data includes the inbound bandwidth and the outbound bandwidth of the cloud desktop, or the workspace bandwidth that is originated from or destined for the Internet.
        self.metric_type = metric_type  # type: str
        # The interval at which monitoring data is collected. Unit: seconds.
        self.period = period  # type: int
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The beginning of the time range to query. The following formats are supported:
        # 
        # *   UNIX timestamp: the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
        # *   UTC time: the UTC time that follows the YYYY-MM-DDThh:mm:ssZ format.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFlowMetricRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.instance_id is not None:
            result['InstanceId'] = self.instance_id
        if self.instance_type is not None:
            result['InstanceType'] = self.instance_type
        if self.metric_type is not None:
            result['MetricType'] = self.metric_type
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('InstanceId') is not None:
            self.instance_id = m.get('InstanceId')
        if m.get('InstanceType') is not None:
            self.instance_type = m.get('InstanceType')
        if m.get('MetricType') is not None:
            self.metric_type = m.get('MetricType')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeFlowMetricResponseBody(TeaModel):
    def __init__(self, data=None, request_id=None):
        # The monitoring data.
        self.data = data  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFlowMetricResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data is not None:
            result['Data'] = self.data
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFlowMetricResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFlowMetricResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFlowMetricResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFlowMetricResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFlowStatisticRequest(TeaModel):
    def __init__(self, desktop_id=None, office_site_id=None, page_number=None, page_size=None, period=None,
                 region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The number of the page to return.\
        # Default value: 1.
        self.page_number = page_number  # type: int
        # The number of entries to return on each page.
        self.page_size = page_size  # type: int
        # The interval to query the traffic data. Unit: seconds. Valid values:
        # 
        # *   3600
        # *   10800
        # *   86400
        self.period = period  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFlowStatisticRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.page_number is not None:
            result['PageNumber'] = self.page_number
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.period is not None:
            result['Period'] = self.period
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PageNumber') is not None:
            self.page_number = m.get('PageNumber')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeFlowStatisticResponseBodyDesktopFlowStatistic(TeaModel):
    def __init__(self, desktop_id=None, desktop_name=None, flow_in=None, flow_rank=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The amount of the traffic. Unit: KB.
        self.flow_in = flow_in  # type: str
        # The traffic ranking.
        self.flow_rank = flow_rank  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFlowStatisticResponseBodyDesktopFlowStatistic, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.flow_in is not None:
            result['FlowIn'] = self.flow_in
        if self.flow_rank is not None:
            result['FlowRank'] = self.flow_rank
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('FlowIn') is not None:
            self.flow_in = m.get('FlowIn')
        if m.get('FlowRank') is not None:
            self.flow_rank = m.get('FlowRank')
        return self


class DescribeFlowStatisticResponseBody(TeaModel):
    def __init__(self, desktop_count=None, desktop_flow_statistic=None, request_id=None):
        # The number of available cloud desktops in the workspace.
        self.desktop_count = desktop_count  # type: int
        # Details of the traffic that is consumed by cloud desktops.
        self.desktop_flow_statistic = desktop_flow_statistic  # type: list[DescribeFlowStatisticResponseBodyDesktopFlowStatistic]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktop_flow_statistic:
            for k in self.desktop_flow_statistic:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFlowStatisticResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_count is not None:
            result['DesktopCount'] = self.desktop_count
        result['DesktopFlowStatistic'] = []
        if self.desktop_flow_statistic is not None:
            for k in self.desktop_flow_statistic:
                result['DesktopFlowStatistic'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopCount') is not None:
            self.desktop_count = m.get('DesktopCount')
        self.desktop_flow_statistic = []
        if m.get('DesktopFlowStatistic') is not None:
            for k in m.get('DesktopFlowStatistic'):
                temp_model = DescribeFlowStatisticResponseBodyDesktopFlowStatistic()
                self.desktop_flow_statistic.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFlowStatisticResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFlowStatisticResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFlowStatisticResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFlowStatisticResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFotaPendingDesktopsRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, region_id=None, task_uid=None):
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 20
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the image update task. You can call the DescribeFotaTasks operation to obtain the value of this parameter.
        self.task_uid = task_uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFotaPendingDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_uid is not None:
            result['TaskUid'] = self.task_uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskUid') is not None:
            self.task_uid = m.get('TaskUid')
        return self


class DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops(TeaModel):
    def __init__(self, current_app_version=None, desktop_id=None, desktop_name=None, fota_project=None,
                 office_site_id=None):
        # The image version of the cloud desktop.
        self.current_app_version = current_app_version  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        self.fota_project = fota_project  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_app_version is not None:
            result['CurrentAppVersion'] = self.current_app_version
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.fota_project is not None:
            result['FotaProject'] = self.fota_project
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentAppVersion') is not None:
            self.current_app_version = m.get('CurrentAppVersion')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('FotaProject') is not None:
            self.fota_project = m.get('FotaProject')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        return self


class DescribeFotaPendingDesktopsResponseBody(TeaModel):
    def __init__(self, fota_pending_desktops=None, next_token=None, request_id=None):
        # Details about the cloud desktops whose images have not been updated. The cloud desktops can be updated to the image of a specific version that is described in an image update task (TaskUid).
        self.fota_pending_desktops = fota_pending_desktops  # type: list[DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops]
        # The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.fota_pending_desktops:
            for k in self.fota_pending_desktops:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFotaPendingDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FotaPendingDesktops'] = []
        if self.fota_pending_desktops is not None:
            for k in self.fota_pending_desktops:
                result['FotaPendingDesktops'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fota_pending_desktops = []
        if m.get('FotaPendingDesktops') is not None:
            for k in m.get('FotaPendingDesktops'):
                temp_model = DescribeFotaPendingDesktopsResponseBodyFotaPendingDesktops()
                self.fota_pending_desktops.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFotaPendingDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFotaPendingDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFotaPendingDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFotaPendingDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFotaTasksRequest(TeaModel):
    def __init__(self, fota_status=None, max_results=None, next_token=None, region_id=None, task_uid=None,
                 user_status=None):
        # This parameter is not available to the public.
        self.fota_status = fota_status  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 20
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the image update task. You can call the DescribeFotaTasks operation to obtain the value of this parameter.
        self.task_uid = task_uid  # type: list[str]
        # Specifies whether to automatically push the image update task.
        self.user_status = user_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFotaTasksRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.fota_status is not None:
            result['FotaStatus'] = self.fota_status
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_uid is not None:
            result['TaskUid'] = self.task_uid
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FotaStatus') is not None:
            self.fota_status = m.get('FotaStatus')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskUid') is not None:
            self.task_uid = m.get('TaskUid')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        return self


class DescribeFotaTasksResponseBodyFotaTasks(TeaModel):
    def __init__(self, app_version=None, fota_project=None, pending_custom_image_count=None,
                 pending_desktop_count=None, publish_time=None, release_note=None, size=None, status=None, task_uid=None):
        # The version of the custom image. You can call the [DescribeImages](~~188895~~) operation to obtain the value of this parameter.
        self.app_version = app_version  # type: str
        # This parameter is not available to the public.
        self.fota_project = fota_project  # type: str
        self.pending_custom_image_count = pending_custom_image_count  # type: int
        # The number of cloud desktops for which the images can be updated to this version.
        self.pending_desktop_count = pending_desktop_count  # type: int
        # The time when the updated image was published.
        self.publish_time = publish_time  # type: str
        # The description of the image version to which the original image is updated.
        self.release_note = release_note  # type: str
        # The size of the image update package. Unit: KB.
        self.size = size  # type: int
        # Indicates whether the user can update the image of the cloud desktop.
        self.status = status  # type: str
        # The ID of the image update task.
        self.task_uid = task_uid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFotaTasksResponseBodyFotaTasks, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_version is not None:
            result['AppVersion'] = self.app_version
        if self.fota_project is not None:
            result['FotaProject'] = self.fota_project
        if self.pending_custom_image_count is not None:
            result['PendingCustomImageCount'] = self.pending_custom_image_count
        if self.pending_desktop_count is not None:
            result['PendingDesktopCount'] = self.pending_desktop_count
        if self.publish_time is not None:
            result['PublishTime'] = self.publish_time
        if self.release_note is not None:
            result['ReleaseNote'] = self.release_note
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.task_uid is not None:
            result['TaskUid'] = self.task_uid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppVersion') is not None:
            self.app_version = m.get('AppVersion')
        if m.get('FotaProject') is not None:
            self.fota_project = m.get('FotaProject')
        if m.get('PendingCustomImageCount') is not None:
            self.pending_custom_image_count = m.get('PendingCustomImageCount')
        if m.get('PendingDesktopCount') is not None:
            self.pending_desktop_count = m.get('PendingDesktopCount')
        if m.get('PublishTime') is not None:
            self.publish_time = m.get('PublishTime')
        if m.get('ReleaseNote') is not None:
            self.release_note = m.get('ReleaseNote')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TaskUid') is not None:
            self.task_uid = m.get('TaskUid')
        return self


class DescribeFotaTasksResponseBody(TeaModel):
    def __init__(self, fota_tasks=None, request_id=None):
        # Details about the image update tasks.
        self.fota_tasks = fota_tasks  # type: list[DescribeFotaTasksResponseBodyFotaTasks]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.fota_tasks:
            for k in self.fota_tasks:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFotaTasksResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FotaTasks'] = []
        if self.fota_tasks is not None:
            for k in self.fota_tasks:
                result['FotaTasks'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.fota_tasks = []
        if m.get('FotaTasks') is not None:
            for k in m.get('FotaTasks'):
                temp_model = DescribeFotaTasksResponseBodyFotaTasks()
                self.fota_tasks.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFotaTasksResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFotaTasksResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFotaTasksResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFotaTasksResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeFrontVulPatchListRequestVulInfo(TeaModel):
    def __init__(self, desktop_id=None, name=None, tag=None):
        # The ID of the cloud desktop that is affected by the vulnerability.
        self.desktop_id = desktop_id  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The tag that you want to add to the vulnerability.
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFrontVulPatchListRequestVulInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.name is not None:
            result['Name'] = self.name
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeFrontVulPatchListRequest(TeaModel):
    def __init__(self, operate_type=None, region_id=None, type=None, vul_info=None):
        # The type of the action that you want to perform on the vulnerability. Valid value: vul_fix.
        self.operate_type = operate_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: the Linux software vulnerability
        # *   sys: the Windows system vulnerability
        self.type = type  # type: str
        # Details of the vulnerabilities. You can enter a maximum of 50 vulnerabilities.
        self.vul_info = vul_info  # type: list[DescribeFrontVulPatchListRequestVulInfo]

    def validate(self):
        if self.vul_info:
            for k in self.vul_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        result['VulInfo'] = []
        if self.vul_info is not None:
            for k in self.vul_info:
                result['VulInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.vul_info = []
        if m.get('VulInfo') is not None:
            for k in m.get('VulInfo'):
                temp_model = DescribeFrontVulPatchListRequestVulInfo()
                self.vul_info.append(temp_model.from_map(k))
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList(TeaModel):
    def __init__(self, alias_name=None, name=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.name is not None:
            result['Name'] = self.name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        return self


class DescribeFrontVulPatchListResponseBodyFrontPatchList(TeaModel):
    def __init__(self, desktop_id=None, patch_list=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # Details about patches.
        self.patch_list = patch_list  # type: list[DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList]

    def validate(self):
        if self.patch_list:
            for k in self.patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBodyFrontPatchList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        result['PatchList'] = []
        if self.patch_list is not None:
            for k in self.patch_list:
                result['PatchList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        self.patch_list = []
        if m.get('PatchList') is not None:
            for k in m.get('PatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchListPatchList()
                self.patch_list.append(temp_model.from_map(k))
        return self


class DescribeFrontVulPatchListResponseBody(TeaModel):
    def __init__(self, front_patch_list=None, request_id=None):
        # Details about patches of one or more vulnerabilities before you fix the current vulnerability.
        self.front_patch_list = front_patch_list  # type: list[DescribeFrontVulPatchListResponseBodyFrontPatchList]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.front_patch_list:
            for k in self.front_patch_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FrontPatchList'] = []
        if self.front_patch_list is not None:
            for k in self.front_patch_list:
                result['FrontPatchList'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.front_patch_list = []
        if m.get('FrontPatchList') is not None:
            for k in m.get('FrontPatchList'):
                temp_model = DescribeFrontVulPatchListResponseBodyFrontPatchList()
                self.front_patch_list.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeFrontVulPatchListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeFrontVulPatchListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeFrontVulPatchListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeFrontVulPatchListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeGroupedVulRequest(TeaModel):
    def __init__(self, current_page=None, dealed=None, lang=None, necessity=None, office_site_id=None,
                 page_size=None, region_id=None, type=None):
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.current_page = current_page  # type: int
        # The processing status of the vulnerability. Valid values:
        # 
        # *   y: handled
        # *   n: unhandled
        self.dealed = dealed  # type: str
        # The natural language of the request and response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The priority to fix the vulnerability or the risk level of the vulnerability. Valid values:
        # 
        # *   asap: high
        # *   later: medium
        # *   nntf: low
        self.necessity = necessity  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The maximum number of entries to return on each page.
        # 
        # Default value: 20.
        self.page_size = page_size  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: Linux software vulnerability
        # *   sys: Windows system vulnerability
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeGroupedVulResponseBodyGroupedVulItems(TeaModel):
    def __init__(self, alias_name=None, asap_count=None, gmt_last=None, handled_count=None, later_count=None,
                 name=None, nntf_count=None, tags=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The number of high-risk vulnerabilities.
        self.asap_count = asap_count  # type: int
        # The time when the vulnerability was last detected. The timestamp follows the UNIX time format. It is the number of milliseconds that have elapsed since 00:00:00 Thursday, January 1, 1970.
        self.gmt_last = gmt_last  # type: str
        # The number of vulnerabilities processed.
        self.handled_count = handled_count  # type: int
        # The number of medium-risk vulnerabilities.
        self.later_count = later_count  # type: int
        # The name of the vulnerability.
        self.name = name  # type: str
        # The number of low-risk vulnerabilities.
        self.nntf_count = nntf_count  # type: int
        # The tags of the vulnerability.
        self.tags = tags  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: Linux software vulnerability
        # *   sys: Windows system vulnerability
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeGroupedVulResponseBodyGroupedVulItems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.gmt_last is not None:
            result['GmtLast'] = self.gmt_last
        if self.handled_count is not None:
            result['HandledCount'] = self.handled_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.name is not None:
            result['Name'] = self.name
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.tags is not None:
            result['Tags'] = self.tags
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('GmtLast') is not None:
            self.gmt_last = m.get('GmtLast')
        if m.get('HandledCount') is not None:
            self.handled_count = m.get('HandledCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('Tags') is not None:
            self.tags = m.get('Tags')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeGroupedVulResponseBody(TeaModel):
    def __init__(self, current_page=None, grouped_vul_items=None, page_size=None, request_id=None, total_count=None):
        # The maximum number of entries returned per page.
        self.current_page = current_page  # type: int
        # Details about vulnerabilities.
        self.grouped_vul_items = grouped_vul_items  # type: list[DescribeGroupedVulResponseBodyGroupedVulItems]
        # The page number of the returned page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of entries returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.grouped_vul_items:
            for k in self.grouped_vul_items:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeGroupedVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        result['GroupedVulItems'] = []
        if self.grouped_vul_items is not None:
            for k in self.grouped_vul_items:
                result['GroupedVulItems'].append(k.to_map() if k else None)
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        self.grouped_vul_items = []
        if m.get('GroupedVulItems') is not None:
            for k in m.get('GroupedVulItems'):
                temp_model = DescribeGroupedVulResponseBodyGroupedVulItems()
                self.grouped_vul_items.append(temp_model.from_map(k))
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeGroupedVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeGroupedVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeGroupedVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeGroupedVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImageModifiedRecordsRequest(TeaModel):
    def __init__(self, desktop_id=None, max_results=None, next_token=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the query. Set the value to the NextToken value that is returned from the last call.
        self.next_token = next_token  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageModifiedRecordsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeImageModifiedRecordsResponseBodyImageModifiedRecords(TeaModel):
    def __init__(self, image_id=None, image_name=None, new_image_id=None, new_image_name=None, status=None,
                 update_time=None):
        # The ID of the original image.
        self.image_id = image_id  # type: str
        # The name of the original image.
        self.image_name = image_name  # type: str
        # The ID of the new image.
        self.new_image_id = new_image_id  # type: str
        # The name of the new image.
        self.new_image_name = new_image_name  # type: str
        # The status of the image.
        self.status = status  # type: int
        # The time when the image was last changed.
        self.update_time = update_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImageModifiedRecordsResponseBodyImageModifiedRecords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.new_image_id is not None:
            result['NewImageId'] = self.new_image_id
        if self.new_image_name is not None:
            result['NewImageName'] = self.new_image_name
        if self.status is not None:
            result['Status'] = self.status
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('NewImageId') is not None:
            self.new_image_id = m.get('NewImageId')
        if m.get('NewImageName') is not None:
            self.new_image_name = m.get('NewImageName')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeImageModifiedRecordsResponseBody(TeaModel):
    def __init__(self, image_modified_records=None, next_token=None, request_id=None, total_count=None):
        # The image change records.
        self.image_modified_records = image_modified_records  # type: list[DescribeImageModifiedRecordsResponseBodyImageModifiedRecords]
        # The token that is used for the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of image change records.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.image_modified_records:
            for k in self.image_modified_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImageModifiedRecordsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ImageModifiedRecords'] = []
        if self.image_modified_records is not None:
            for k in self.image_modified_records:
                result['ImageModifiedRecords'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.image_modified_records = []
        if m.get('ImageModifiedRecords') is not None:
            for k in m.get('ImageModifiedRecords'):
                temp_model = DescribeImageModifiedRecordsResponseBodyImageModifiedRecords()
                self.image_modified_records.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeImageModifiedRecordsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImageModifiedRecordsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImageModifiedRecordsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImageModifiedRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagePermissionRequest(TeaModel):
    def __init__(self, image_id=None, region_id=None):
        self.image_id = image_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeImagePermissionResponseBody(TeaModel):
    def __init__(self, ali_uids=None, request_id=None):
        self.ali_uids = ali_uids  # type: list[str]
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ali_uids is not None:
            result['AliUids'] = self.ali_uids
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliUids') is not None:
            self.ali_uids = m.get('AliUids')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImagePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImagePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImagePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeImagesRequest(TeaModel):
    def __init__(self, desktop_instance_type=None, gpu_category=None, gpu_driver_version=None, image_id=None,
                 image_status=None, image_type=None, language_type=None, max_results=None, next_token=None, os_type=None,
                 protocol_type=None, region_id=None, session_type=None):
        # The cloud desktop type. You can call the [DescribeBundles](~~188884~~) operation to query the available cloud desktop types.
        self.desktop_instance_type = desktop_instance_type  # type: str
        # Specifies whether the image is a GPU-accelerated image.
        self.gpu_category = gpu_category  # type: bool
        # The version of the GPU driver.
        self.gpu_driver_version = gpu_driver_version  # type: str
        # The IDs of the images. You can specify one or more image IDs.
        self.image_id = image_id  # type: list[str]
        # The state of the image.
        self.image_status = image_status  # type: str
        # The type of the image.
        self.image_type = image_type  # type: str
        # The language of the OS.
        self.language_type = language_type  # type: str
        # The maximum number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If you do not specify this parameter, all results are returned.
        self.next_token = next_token  # type: str
        # The type of the OS. Default value: `null`.
        self.os_type = os_type  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The session type.
        self.session_type = session_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_instance_type is not None:
            result['DesktopInstanceType'] = self.desktop_instance_type
        if self.gpu_category is not None:
            result['GpuCategory'] = self.gpu_category
        if self.gpu_driver_version is not None:
            result['GpuDriverVersion'] = self.gpu_driver_version
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_status is not None:
            result['ImageStatus'] = self.image_status
        if self.image_type is not None:
            result['ImageType'] = self.image_type
        if self.language_type is not None:
            result['LanguageType'] = self.language_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.session_type is not None:
            result['SessionType'] = self.session_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopInstanceType') is not None:
            self.desktop_instance_type = m.get('DesktopInstanceType')
        if m.get('GpuCategory') is not None:
            self.gpu_category = m.get('GpuCategory')
        if m.get('GpuDriverVersion') is not None:
            self.gpu_driver_version = m.get('GpuDriverVersion')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageStatus') is not None:
            self.image_status = m.get('ImageStatus')
        if m.get('ImageType') is not None:
            self.image_type = m.get('ImageType')
        if m.get('LanguageType') is not None:
            self.language_type = m.get('LanguageType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SessionType') is not None:
            self.session_type = m.get('SessionType')
        return self


class DescribeImagesResponseBodyImages(TeaModel):
    def __init__(self, app_version=None, creation_time=None, data_disk_size=None, description=None,
                 gpu_category=None, gpu_driver_version=None, image_id=None, image_type=None, name=None, os_type=None,
                 platform=None, progress=None, protocol_type=None, session_type=None, shared_count=None, size=None,
                 status=None, supported_languages=None, update_time=None, volume_encryption_enabled=None,
                 volume_encryption_key=None):
        # The version of the image.
        self.app_version = app_version  # type: str
        # The time when the image was created.
        self.creation_time = creation_time  # type: str
        # The size of the data disk. Unit: GiB.
        self.data_disk_size = data_disk_size  # type: int
        # The description of the image.
        self.description = description  # type: str
        # Indicates whether the image is a GPU-accelerated image.
        self.gpu_category = gpu_category  # type: bool
        # The version of the GPU driver.
        self.gpu_driver_version = gpu_driver_version  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The type of the image.
        self.image_type = image_type  # type: str
        # The name of the image.
        self.name = name  # type: str
        # The OS type of the image.
        self.os_type = os_type  # type: str
        # The OS type of the image.
        self.platform = platform  # type: str
        # The progress of image creation. Unit: percentage (%).
        self.progress = progress  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        # The session type of the image. Valid values:
        # 
        # *   SINGLE_SESSION: single-session images
        # *   MULTIPLE_SESSION: multi-session images
        self.session_type = session_type  # type: str
        # The number of shared images.
        self.shared_count = shared_count  # type: int
        # The size of the image. Unit: GiB.
        self.size = size  # type: int
        # The state of the image.
        self.status = status  # type: str
        # The languages of the OS.
        self.supported_languages = supported_languages  # type: list[str]
        # The time when the image was last modified.
        self.update_time = update_time  # type: str
        # Indicates whether disk encryption is enabled.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain the list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeImagesResponseBodyImages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_version is not None:
            result['AppVersion'] = self.app_version
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.description is not None:
            result['Description'] = self.description
        if self.gpu_category is not None:
            result['GpuCategory'] = self.gpu_category
        if self.gpu_driver_version is not None:
            result['GpuDriverVersion'] = self.gpu_driver_version
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.image_type is not None:
            result['ImageType'] = self.image_type
        if self.name is not None:
            result['Name'] = self.name
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.platform is not None:
            result['Platform'] = self.platform
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.session_type is not None:
            result['SessionType'] = self.session_type
        if self.shared_count is not None:
            result['SharedCount'] = self.shared_count
        if self.size is not None:
            result['Size'] = self.size
        if self.status is not None:
            result['Status'] = self.status
        if self.supported_languages is not None:
            result['SupportedLanguages'] = self.supported_languages
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppVersion') is not None:
            self.app_version = m.get('AppVersion')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('GpuCategory') is not None:
            self.gpu_category = m.get('GpuCategory')
        if m.get('GpuDriverVersion') is not None:
            self.gpu_driver_version = m.get('GpuDriverVersion')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('ImageType') is not None:
            self.image_type = m.get('ImageType')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('Platform') is not None:
            self.platform = m.get('Platform')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('SessionType') is not None:
            self.session_type = m.get('SessionType')
        if m.get('SharedCount') is not None:
            self.shared_count = m.get('SharedCount')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SupportedLanguages') is not None:
            self.supported_languages = m.get('SupportedLanguages')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        return self


class DescribeImagesResponseBody(TeaModel):
    def __init__(self, images=None, next_token=None, request_id=None):
        # The details of the images.
        self.images = images  # type: list[DescribeImagesResponseBodyImages]
        # The token that determines the start point of the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.images:
            for k in self.images:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeImagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Images'] = []
        if self.images is not None:
            for k in self.images:
                result['Images'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.images = []
        if m.get('Images') is not None:
            for k in m.get('Images'):
                temp_model = DescribeImagesResponseBodyImages()
                self.images.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeImagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeImagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeImagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeImagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeInvocationsRequest(TeaModel):
    def __init__(self, command_type=None, content_encoding=None, desktop_id=None, desktop_ids=None,
                 end_user_id=None, include_output=None, invoke_id=None, invoke_status=None, max_results=None, next_token=None,
                 region_id=None):
        # The type of the command. Valid values:
        # 
        # *   RunBatScript
        # *   RunPowerShellScript
        self.command_type = command_type  # type: str
        # The encoding method of the command content and outputs. Valid values:
        # 
        # *   PlainText
        # *   Base64
        # 
        # Default value: Base64.
        self.content_encoding = content_encoding  # type: str
        # The ID of the cloud desktop. If you specify a cloud desktop, all execution records of Cloud Assistant commands on the cloud desktop are queried.
        self.desktop_id = desktop_id  # type: str
        # The IDs of the cloud desktops. The DesktopId parameter will be discontinued. We recommend that you use the DesktopIds parameter to specify the IDs of cloud desktops.
        self.desktop_ids = desktop_ids  # type: list[str]
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # Specifies whether to return command outputs in the response. Valid values:
        # 
        # *   true
        # *   false
        # 
        # Default value: false.
        self.include_output = include_output  # type: bool
        # The ID of the execution.
        self.invoke_id = invoke_id  # type: str
        # The overall execution status of the command. The overall execution status is determined by the execution status of the command on one or more cloud desktops. Valid values:
        # 
        # *   Running: The execution is in progress on one or more cloud desktops.
        # *   Finished: The execution is complete on all cloud desktops, or the execution is manually stopped on specific cloud desktops and the execution is complete on other cloud desktops.
        # *   Failed: The execution failed on all cloud desktops.
        # *   PartialFailed: The execution failed on specific cloud desktops.
        # *   Stopped: The execution is stopped.
        # 
        # Default value: Running.
        self.invoke_status = invoke_status  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. Set the value to the NextToken value that is returned from the last call.
        self.next_token = next_token  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_type is not None:
            result['CommandType'] = self.command_type
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_ids is not None:
            result['DesktopIds'] = self.desktop_ids
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.include_output is not None:
            result['IncludeOutput'] = self.include_output
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.invoke_status is not None:
            result['InvokeStatus'] = self.invoke_status
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandType') is not None:
            self.command_type = m.get('CommandType')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopIds') is not None:
            self.desktop_ids = m.get('DesktopIds')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('IncludeOutput') is not None:
            self.include_output = m.get('IncludeOutput')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('InvokeStatus') is not None:
            self.invoke_status = m.get('InvokeStatus')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeInvocationsResponseBodyInvocationsInvokeDesktops(TeaModel):
    def __init__(self, creation_time=None, desktop_id=None, dropped=None, error_code=None, error_info=None,
                 exit_code=None, finish_time=None, invocation_status=None, output=None, repeats=None, start_time=None,
                 stop_time=None, update_time=None):
        # The time when the command execution was created.
        self.creation_time = creation_time  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The size of the text that is truncated and discarded when the value of the Output parameter exceeds 24 KB in size.
        self.dropped = dropped  # type: int
        # The error code that is returned if the command failed to be sent or run.
        # 
        # *   If null is returned, the command is run normally.
        # *   If InstanceNotExists is returned, the specified cloud desktop does not exist or is released.
        # *   If InstanceReleased is returned, the specified cloud desktop is released during the command execution.
        # *   If InstanceNotRunning is returned, the specified cloud desktop is not in the Running state when the execution is created.
        # *   If CommandNotApplicable is returned, the command cannot be run on the specified cloud desktop.
        # *   If ClientNotRunning is returned, Cloud Assistant is not running.
        # *   If ClientNotResponse is returned, Cloud Assistant does not respond to your request.
        # *   If ClientIsUpgrading is returned, Cloud Assistant is being upgraded.
        # *   If ClientNeedUpgrade is returned, you must upgrade Cloud Assistant.
        # *   If DeliveryTimeout is returned, the operation to send the command times out.
        # *   If ExecutionTimeout is returned, the command execution times out.
        # *   If ExecutionException is returned, an execution occurs during the command execution.
        # *   If ExecutionInterrupted is returned, the command execution is interrupted.
        # *   If ExitCodeNonzero is returned, the command execution is complete, but the exit code is not 0.
        self.error_code = error_code  # type: str
        # The error message that is returned if the command failed to be sent or run.
        # 
        # *   If null is returned, the command is run normally.
        # *   If "the specified instance does not exist" is returned, the specified cloud desktop does not exist or is released.
        # *   If "the instance has released when create task" is returned, the specified cloud desktop is released during the command execution.
        # *   If "the instance is not running when create task" is returned, the specified cloud desktop is not in the Running state when the execution is created.
        # *   If "the command is not applicable" is returned, the command cannot be run on the specified cloud desktop.
        # *   If "the aliyun service is not running on the instance" is returned, Cloud Assistant is not running.
        # *   If "the aliyun service in the instance does not response" is returned, Cloud Assistant does not respond to your request.
        # *   If "the aliyun service in the instance is upgrading now" is returned, Cloud Assistant is being upgraded.
        # *   If "the aliyun service in the instance need upgrade" is returned, you must upgrade Cloud Assistant.
        # *   If "the command delivery has been timeout" is returned, the operation to send the command times out.
        # *   If "the command execution has been timeout" is returned, the command execution times out.
        # *   If "the command execution got an exception" is returned, an exception occurs during the command execution.
        # *   If "the command execution has been interrupted" is returned, the command execution is interrupted.
        # *   If "the command execution exit code is not zero" is returned, the command execution is complete, but the exit code is not 0.
        self.error_info = error_info  # type: str
        # The exit code of the execution.
        self.exit_code = exit_code  # type: long
        # The end time of the command execution.
        self.finish_time = finish_time  # type: str
        # The execution status on a cloud desktop.
        self.invocation_status = invocation_status  # type: str
        # The command output.
        # 
        # *   If the IncludeOutput parameter is set to false, no value of the Output parameter is returned.
        # *   If the ContentEncoding parameter is set to Base64, the value of the Output parameter is encoded in Base64.
        self.output = output  # type: str
        # The number of times that the command is run on the cloud desktop.
        self.repeats = repeats  # type: int
        # The start time of the command execution on the cloud desktop.
        self.start_time = start_time  # type: str
        # If you called the [stopInvocation](~~196957~~) operation, the value of this parameter indicates the time when you made the call.
        self.stop_time = stop_time  # type: str
        # The time when the execution status was last updated.
        self.update_time = update_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocationsInvokeDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.dropped is not None:
            result['Dropped'] = self.dropped
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.error_info is not None:
            result['ErrorInfo'] = self.error_info
        if self.exit_code is not None:
            result['ExitCode'] = self.exit_code
        if self.finish_time is not None:
            result['FinishTime'] = self.finish_time
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        if self.output is not None:
            result['Output'] = self.output
        if self.repeats is not None:
            result['Repeats'] = self.repeats
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        if self.stop_time is not None:
            result['StopTime'] = self.stop_time
        if self.update_time is not None:
            result['UpdateTime'] = self.update_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Dropped') is not None:
            self.dropped = m.get('Dropped')
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('ErrorInfo') is not None:
            self.error_info = m.get('ErrorInfo')
        if m.get('ExitCode') is not None:
            self.exit_code = m.get('ExitCode')
        if m.get('FinishTime') is not None:
            self.finish_time = m.get('FinishTime')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        if m.get('Output') is not None:
            self.output = m.get('Output')
        if m.get('Repeats') is not None:
            self.repeats = m.get('Repeats')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        if m.get('StopTime') is not None:
            self.stop_time = m.get('StopTime')
        if m.get('UpdateTime') is not None:
            self.update_time = m.get('UpdateTime')
        return self


class DescribeInvocationsResponseBodyInvocations(TeaModel):
    def __init__(self, command_content=None, command_type=None, creation_time=None, end_user_id=None,
                 invocation_status=None, invoke_desktops=None, invoke_id=None):
        # The command content that is encoded in Base64.
        self.command_content = command_content  # type: str
        # The type of the command.
        self.command_type = command_type  # type: str
        # The time when the task was created.
        self.creation_time = creation_time  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The overall execution status of the command. The overall execution status is determined by the execution status of the command on all related cloud desktops. Valid values:
        # 
        # *   Pending: The system is verifying or sending the command. If the execution status on at least one cloud desktop is Pending, the overall execution status is Pending.
        # 
        # *   Running: The execution is in progress on cloud desktops. If the execution status on at least one cloud desktop is Running, the overall execution status is Running.
        # 
        # *   Success: If the execution status on at least one cloud desktop is Success, and the execution status on other cloud desktops is Success or Stopped, the overall execution status is Success.
        # 
        # *   Failed: If the execution status on all cloud desktops is Stopped or Failed, the overall execution status is Failed. If one or more execution status on a cloud desktop is one of the following values, Failed is returned:
        # 
        #     *   Invalid: The command is invalid.
        #     *   Aborted: The command failed to be sent.
        #     *   Failed: The execution is complete, but the exit code is not 0.
        #     *   Timeout: The execution times out.
        #     *   Error: An error occurs when the execution is in progress.
        # 
        # *   Stopping: The execution is being stopped. If the execution status on at least one cloud desktop is Stopping, the overall execution status is Stopping.
        # 
        # *   Stopped: The execution is stopped. If the execution status on all cloud desktops is Stopped, the overall execution status is Stopped. If the execution status on a cloud desktop is one of the following values, Stopped is returned:
        # 
        #     *   Cancelled: The execution is canceled.
        #     *   Terminated: The execution is terminated.
        # 
        # *   PartialFailed: The execution is successful on specific cloud desktops and failed on other cloud desktops. If the execution status on different cloud desktops includes Success, Failed, and Stopped, the overall execution status is PartialFailed.
        self.invocation_status = invocation_status  # type: str
        # The cloud desktops on which the command is run.
        self.invoke_desktops = invoke_desktops  # type: list[DescribeInvocationsResponseBodyInvocationsInvokeDesktops]
        # The ID of the execution.
        self.invoke_id = invoke_id  # type: str

    def validate(self):
        if self.invoke_desktops:
            for k in self.invoke_desktops:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBodyInvocations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.command_type is not None:
            result['CommandType'] = self.command_type
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.invocation_status is not None:
            result['InvocationStatus'] = self.invocation_status
        result['InvokeDesktops'] = []
        if self.invoke_desktops is not None:
            for k in self.invoke_desktops:
                result['InvokeDesktops'].append(k.to_map() if k else None)
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('CommandType') is not None:
            self.command_type = m.get('CommandType')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('InvocationStatus') is not None:
            self.invocation_status = m.get('InvocationStatus')
        self.invoke_desktops = []
        if m.get('InvokeDesktops') is not None:
            for k in m.get('InvokeDesktops'):
                temp_model = DescribeInvocationsResponseBodyInvocationsInvokeDesktops()
                self.invoke_desktops.append(temp_model.from_map(k))
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        return self


class DescribeInvocationsResponseBody(TeaModel):
    def __init__(self, invocations=None, next_token=None, request_id=None):
        # The command execution records.
        self.invocations = invocations  # type: list[DescribeInvocationsResponseBodyInvocations]
        # The query token that is returned in this call.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.invocations:
            for k in self.invocations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Invocations'] = []
        if self.invocations is not None:
            for k in self.invocations:
                result['Invocations'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.invocations = []
        if m.get('Invocations') is not None:
            for k in m.get('Invocations'):
                temp_model = DescribeInvocationsResponseBodyInvocations()
                self.invocations.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeInvocationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeInvocationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeInvocationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeInvocationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeKmsKeysRequest(TeaModel):
    def __init__(self, region_id=None):
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeKmsKeysRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeKmsKeysResponseBodyKeys(TeaModel):
    def __init__(self, alias=None, arn=None, key_id=None, type=None):
        # The alias of the key.
        self.alias = alias  # type: str
        # The Alibaba Cloud Resource Name (ARN) of the key in KMS.
        self.arn = arn  # type: str
        # The ID of the key.
        self.key_id = key_id  # type: str
        # The type of the key.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeKmsKeysResponseBodyKeys, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias is not None:
            result['Alias'] = self.alias
        if self.arn is not None:
            result['Arn'] = self.arn
        if self.key_id is not None:
            result['KeyId'] = self.key_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Alias') is not None:
            self.alias = m.get('Alias')
        if m.get('Arn') is not None:
            self.arn = m.get('Arn')
        if m.get('KeyId') is not None:
            self.key_id = m.get('KeyId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeKmsKeysResponseBody(TeaModel):
    def __init__(self, authorize_status=None, keys=None, kms_service_status=None, request_id=None):
        # The authorization status.
        self.authorize_status = authorize_status  # type: str
        # Details about the customer master keys (CMKs).
        self.keys = keys  # type: list[DescribeKmsKeysResponseBodyKeys]
        # Indicates whether KMS is activated.
        self.kms_service_status = kms_service_status  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.keys:
            for k in self.keys:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeKmsKeysResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorize_status is not None:
            result['AuthorizeStatus'] = self.authorize_status
        result['Keys'] = []
        if self.keys is not None:
            for k in self.keys:
                result['Keys'].append(k.to_map() if k else None)
        if self.kms_service_status is not None:
            result['KmsServiceStatus'] = self.kms_service_status
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorizeStatus') is not None:
            self.authorize_status = m.get('AuthorizeStatus')
        self.keys = []
        if m.get('Keys') is not None:
            for k in m.get('Keys'):
                temp_model = DescribeKmsKeysResponseBodyKeys()
                self.keys.append(temp_model.from_map(k))
        if m.get('KmsServiceStatus') is not None:
            self.kms_service_status = m.get('KmsServiceStatus')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeKmsKeysResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeKmsKeysResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeKmsKeysResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeKmsKeysResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNASFileSystemsRequest(TeaModel):
    def __init__(self, file_system_id=None, match_compatible_profile=None, max_results=None, next_token=None,
                 office_site_id=None, region_id=None):
        # The IDs of the NAS file systems.
        self.file_system_id = file_system_id  # type: list[str]
        # Specifies whether to filter NAS file systems that only support the user profile management (UPM) feature.
        self.match_compatible_profile = match_compatible_profile  # type: bool
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the query. Set the value to the NextToken value that is returned from the last call.
        self.next_token = next_token  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNASFileSystemsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.match_compatible_profile is not None:
            result['MatchCompatibleProfile'] = self.match_compatible_profile
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MatchCompatibleProfile') is not None:
            self.match_compatible_profile = m.get('MatchCompatibleProfile')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups(TeaModel):
    def __init__(self, desktop_group_id=None, desktop_group_name=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        return self


class DescribeNASFileSystemsResponseBodyFileSystems(TeaModel):
    def __init__(self, capacity=None, create_time=None, description=None, desktop_groups=None,
                 encryption_enabled=None, file_system_id=None, file_system_name=None, file_system_status=None, file_system_type=None,
                 metered_size=None, mount_target_domain=None, mount_target_status=None, office_site_id=None,
                 office_site_name=None, profile_compatible=None, region_id=None, storage_type=None, support_acl=None, zone_id=None):
        # The total capacity of the NAS file system. Unit: GiB.
        # 
        # *   The Capacity type has 10 PiB of storage, which is equal to 10,485,760 GiB.
        # *   The Performance type has 1 PiB of storage, which is equal to 1,048,576 GiB.
        self.capacity = capacity  # type: long
        # The time when the NAS file system was created.
        self.create_time = create_time  # type: str
        # The description of the NAS file system.
        self.description = description  # type: str
        # The desktop groups that are associated with the NAS file systems that support the UPM feature.
        self.desktop_groups = desktop_groups  # type: list[DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups]
        # Indicates whether disk encryption is enabled.
        self.encryption_enabled = encryption_enabled  # type: bool
        # The ID of the NAS file system.
        self.file_system_id = file_system_id  # type: str
        # The name of the NAS file system.
        self.file_system_name = file_system_name  # type: str
        # The status of the NAS file system.
        self.file_system_status = file_system_status  # type: str
        # The type of the NAS file system. Valid value: `standard`.
        self.file_system_type = file_system_type  # type: str
        # The used storage of the NAS file system. Unit: byte.
        self.metered_size = metered_size  # type: long
        # The domain name of the mount target.
        self.mount_target_domain = mount_target_domain  # type: str
        # The status of the mount target.
        self.mount_target_status = mount_target_status  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # Indicates whether the UPM feature is supported.
        self.profile_compatible = profile_compatible  # type: bool
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The storage type of the NAS file system.
        self.storage_type = storage_type  # type: str
        # Indicates whether the Server Message Block (SMB) access control list (ACL) feature is enabled.
        self.support_acl = support_acl  # type: bool
        # The zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        if self.desktop_groups:
            for k in self.desktop_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNASFileSystemsResponseBodyFileSystems, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.capacity is not None:
            result['Capacity'] = self.capacity
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.description is not None:
            result['Description'] = self.description
        result['DesktopGroups'] = []
        if self.desktop_groups is not None:
            for k in self.desktop_groups:
                result['DesktopGroups'].append(k.to_map() if k else None)
        if self.encryption_enabled is not None:
            result['EncryptionEnabled'] = self.encryption_enabled
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.file_system_name is not None:
            result['FileSystemName'] = self.file_system_name
        if self.file_system_status is not None:
            result['FileSystemStatus'] = self.file_system_status
        if self.file_system_type is not None:
            result['FileSystemType'] = self.file_system_type
        if self.metered_size is not None:
            result['MeteredSize'] = self.metered_size
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.mount_target_status is not None:
            result['MountTargetStatus'] = self.mount_target_status
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.profile_compatible is not None:
            result['ProfileCompatible'] = self.profile_compatible
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.storage_type is not None:
            result['StorageType'] = self.storage_type
        if self.support_acl is not None:
            result['SupportAcl'] = self.support_acl
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Capacity') is not None:
            self.capacity = m.get('Capacity')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        self.desktop_groups = []
        if m.get('DesktopGroups') is not None:
            for k in m.get('DesktopGroups'):
                temp_model = DescribeNASFileSystemsResponseBodyFileSystemsDesktopGroups()
                self.desktop_groups.append(temp_model.from_map(k))
        if m.get('EncryptionEnabled') is not None:
            self.encryption_enabled = m.get('EncryptionEnabled')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('FileSystemName') is not None:
            self.file_system_name = m.get('FileSystemName')
        if m.get('FileSystemStatus') is not None:
            self.file_system_status = m.get('FileSystemStatus')
        if m.get('FileSystemType') is not None:
            self.file_system_type = m.get('FileSystemType')
        if m.get('MeteredSize') is not None:
            self.metered_size = m.get('MeteredSize')
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('MountTargetStatus') is not None:
            self.mount_target_status = m.get('MountTargetStatus')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('ProfileCompatible') is not None:
            self.profile_compatible = m.get('ProfileCompatible')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StorageType') is not None:
            self.storage_type = m.get('StorageType')
        if m.get('SupportAcl') is not None:
            self.support_acl = m.get('SupportAcl')
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeNASFileSystemsResponseBody(TeaModel):
    def __init__(self, file_systems=None, next_token=None, request_id=None):
        # Details of the NAS file systems.
        self.file_systems = file_systems  # type: list[DescribeNASFileSystemsResponseBodyFileSystems]
        # The token that is used for the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.file_systems:
            for k in self.file_systems:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNASFileSystemsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FileSystems'] = []
        if self.file_systems is not None:
            for k in self.file_systems:
                result['FileSystems'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_systems = []
        if m.get('FileSystems') is not None:
            for k in m.get('FileSystems'):
                temp_model = DescribeNASFileSystemsResponseBodyFileSystems()
                self.file_systems.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNASFileSystemsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNASFileSystemsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNASFileSystemsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNASFileSystemsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeNetworkPackagesRequest(TeaModel):
    def __init__(self, internet_charge_type=None, max_results=None, network_package_id=None, next_token=None,
                 region_id=None):
        # The billing method of the Internet access package. Valid values:
        # 
        # *   PayByTraffic: pay-by-data-transfer
        # *   PayByBandwidth: pay-by-bandwidth
        self.internet_charge_type = internet_charge_type  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 10
        self.max_results = max_results  # type: int
        # The IDs of the Internet access packages. You can specify 1 to 100 IDs of Internet access packages.
        self.network_package_id = network_package_id  # type: list[str]
        # The token that determines the start point of the next query.
        self.next_token = next_token  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkPackagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeNetworkPackagesResponseBodyNetworkPackages(TeaModel):
    def __init__(self, bandwidth=None, create_time=None, eip_addresses=None, expired_time=None,
                 internet_charge_type=None, network_package_id=None, network_package_status=None, office_site_id=None,
                 office_site_name=None, office_site_vpc_type=None, pay_type=None, reservation_active_time=None,
                 reservation_bandwidth=None, reservation_internet_charge_type=None):
        # The maximum public bandwidth of the Internet access package. Unit: Mbit/s.
        self.bandwidth = bandwidth  # type: int
        # The time when the Internet access package was created.
        self.create_time = create_time  # type: str
        # The elastic IP addresses (EIPs) of the Internet access package for outbound traffic.
        self.eip_addresses = eip_addresses  # type: list[str]
        # The time when the Internet access package expires.
        # 
        # *   If the Internet access package is metered on a pay-by-bandwidth basis, the actual expiration time is returned.
        # *   If the Internet access package is metered on a pay-by-data-transfer basis, 2099-12-31T15:59:59Z is returned.
        self.expired_time = expired_time  # type: str
        # The billing method of the network bandwidth.
        # 
        # *   PayByTraffic: pay-by-data-transfer
        # *   PayByBandwidth: pay-by-bandwidth
        self.internet_charge_type = internet_charge_type  # type: str
        # The ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The state of the Internet access package. Valid values:
        # 
        # *   Creating
        # *   InUse
        # *   Releasing
        # *   Released
        self.network_package_status = network_package_status  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The type of the workspace. Valid values:
        # 
        # *   basic
        # *   standard
        # *   customized
        self.office_site_vpc_type = office_site_vpc_type  # type: str
        # The billing method for the network.
        # 
        # *   PrePaid: subscription
        # *   PostPaid: pay-as-you-go
        self.pay_type = pay_type  # type: str
        # The time when the reserved network bandwidth takes effect.
        self.reservation_active_time = reservation_active_time  # type: str
        # The peak bandwidth of the reserved network bandwidth. Unit: Mbit/s.
        self.reservation_bandwidth = reservation_bandwidth  # type: int
        # The billing method of the reserved network bandwidth.
        # 
        # *   PayByTraffic: pay-by-data-transfer
        # *   PayByBandwidth: pay-by-bandwidth
        self.reservation_internet_charge_type = reservation_internet_charge_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeNetworkPackagesResponseBodyNetworkPackages, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.eip_addresses is not None:
            result['EipAddresses'] = self.eip_addresses
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.internet_charge_type is not None:
            result['InternetChargeType'] = self.internet_charge_type
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.network_package_status is not None:
            result['NetworkPackageStatus'] = self.network_package_status
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_vpc_type is not None:
            result['OfficeSiteVpcType'] = self.office_site_vpc_type
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.reservation_active_time is not None:
            result['ReservationActiveTime'] = self.reservation_active_time
        if self.reservation_bandwidth is not None:
            result['ReservationBandwidth'] = self.reservation_bandwidth
        if self.reservation_internet_charge_type is not None:
            result['ReservationInternetChargeType'] = self.reservation_internet_charge_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('EipAddresses') is not None:
            self.eip_addresses = m.get('EipAddresses')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('InternetChargeType') is not None:
            self.internet_charge_type = m.get('InternetChargeType')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('NetworkPackageStatus') is not None:
            self.network_package_status = m.get('NetworkPackageStatus')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteVpcType') is not None:
            self.office_site_vpc_type = m.get('OfficeSiteVpcType')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('ReservationActiveTime') is not None:
            self.reservation_active_time = m.get('ReservationActiveTime')
        if m.get('ReservationBandwidth') is not None:
            self.reservation_bandwidth = m.get('ReservationBandwidth')
        if m.get('ReservationInternetChargeType') is not None:
            self.reservation_internet_charge_type = m.get('ReservationInternetChargeType')
        return self


class DescribeNetworkPackagesResponseBody(TeaModel):
    def __init__(self, network_packages=None, next_token=None, request_id=None):
        # Details of the Internet access packages.
        self.network_packages = network_packages  # type: list[DescribeNetworkPackagesResponseBodyNetworkPackages]
        # The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.network_packages:
            for k in self.network_packages:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeNetworkPackagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['NetworkPackages'] = []
        if self.network_packages is not None:
            for k in self.network_packages:
                result['NetworkPackages'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.network_packages = []
        if m.get('NetworkPackages') is not None:
            for k in m.get('NetworkPackages'):
                temp_model = DescribeNetworkPackagesResponseBodyNetworkPackages()
                self.network_packages.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeNetworkPackagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeNetworkPackagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeNetworkPackagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeNetworkPackagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeOfficeSitesRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, office_site_id=None, office_site_type=None,
                 region_id=None, status=None):
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query.
        self.next_token = next_token  # type: str
        # The IDs of the workspaces. You can specify 1 to 100 IDs of workspaces.
        self.office_site_id = office_site_id  # type: list[str]
        # The account type of the workspace.
        self.office_site_type = office_site_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The state of the workspace.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOfficeSitesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeOfficeSitesResponseBodyOfficeSitesADConnectors(TeaModel):
    def __init__(self, adconnector_address=None, connector_status=None, network_interface_id=None,
                 specification=None, trust_key=None, v_switch_id=None):
        # The IP address of the AD connector.
        self.adconnector_address = adconnector_address  # type: str
        # The state of the AD connector.
        self.connector_status = connector_status  # type: str
        # The ID of the network interface controller (NIC) that is associated with the AD connector.
        self.network_interface_id = network_interface_id  # type: str
        # The type of the AD connector.
        self.specification = specification  # type: str
        # The trust password that is specified when you configured the AD trust relationship.
        self.trust_key = trust_key  # type: str
        # The ID of the vSwitch that corresponds to the network of the AD connector.
        self.v_switch_id = v_switch_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOfficeSitesResponseBodyOfficeSitesADConnectors, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.adconnector_address is not None:
            result['ADConnectorAddress'] = self.adconnector_address
        if self.connector_status is not None:
            result['ConnectorStatus'] = self.connector_status
        if self.network_interface_id is not None:
            result['NetworkInterfaceId'] = self.network_interface_id
        if self.specification is not None:
            result['Specification'] = self.specification
        if self.trust_key is not None:
            result['TrustKey'] = self.trust_key
        if self.v_switch_id is not None:
            result['VSwitchId'] = self.v_switch_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ADConnectorAddress') is not None:
            self.adconnector_address = m.get('ADConnectorAddress')
        if m.get('ConnectorStatus') is not None:
            self.connector_status = m.get('ConnectorStatus')
        if m.get('NetworkInterfaceId') is not None:
            self.network_interface_id = m.get('NetworkInterfaceId')
        if m.get('Specification') is not None:
            self.specification = m.get('Specification')
        if m.get('TrustKey') is not None:
            self.trust_key = m.get('TrustKey')
        if m.get('VSwitchId') is not None:
            self.v_switch_id = m.get('VSwitchId')
        return self


class DescribeOfficeSitesResponseBodyOfficeSitesLogs(TeaModel):
    def __init__(self, level=None, message=None, step=None, time_stamp=None):
        # The log level.
        self.level = level  # type: str
        # Details of the log entry.
        self.message = message  # type: str
        # The step that corresponds to the log entry.
        self.step = step  # type: str
        # The time when the log entry was printed.
        self.time_stamp = time_stamp  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeOfficeSitesResponseBodyOfficeSitesLogs, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.level is not None:
            result['Level'] = self.level
        if self.message is not None:
            result['Message'] = self.message
        if self.step is not None:
            result['Step'] = self.step
        if self.time_stamp is not None:
            result['TimeStamp'] = self.time_stamp
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('Step') is not None:
            self.step = m.get('Step')
        if m.get('TimeStamp') is not None:
            self.time_stamp = m.get('TimeStamp')
        return self


class DescribeOfficeSitesResponseBodyOfficeSites(TeaModel):
    def __init__(self, adconnectors=None, ad_hostname=None, bandwidth=None, cen_id=None, cidr_block=None,
                 cloud_box_office_site=None, creation_time=None, custom_security_group_id=None, desktop_access_type=None,
                 desktop_count=None, desktop_vpc_endpoint=None, dns_address=None, dns_user_name=None, domain_name=None,
                 domain_password=None, domain_user_name=None, enable_admin_access=None, enable_cross_desktop_access=None,
                 enable_internet_access=None, file_system_ids=None, logs=None, mfa_enabled=None, name=None, need_verify_login_risk=None,
                 need_verify_zero_device=None, network_package_id=None, office_site_id=None, office_site_type=None, ou_name=None,
                 protocol_type=None, rds_license_address=None, rds_license_domain_name=None, rds_license_status=None,
                 sso_enabled=None, sso_type=None, status=None, sub_dns_address=None, sub_domain_name=None, trust_password=None,
                 v_switch_ids=None, vpc_id=None, vpc_type=None):
        # Details of the AD connectors.
        self.adconnectors = adconnectors  # type: list[DescribeOfficeSitesResponseBodyOfficeSitesADConnectors]
        # The hostname of the domain controller. The hostname must comply with the naming conventions for hostnames in Windows.
        self.ad_hostname = ad_hostname  # type: str
        # The maximum public bandwidth of the Internet access package. Valid values: 0 to 1000.\
        # If the value of this parameter is 0, Internet access is disabled.
        self.bandwidth = bandwidth  # type: int
        # The ID of the Cloud Enterprise Network (CEN) instance.
        self.cen_id = cen_id  # type: str
        # The IPv4 CIDR block that is included in the secure office network of the workspace.
        self.cidr_block = cidr_block  # type: str
        # Indicates whether the workspace is created for cloud desktops on a cloud box.
        self.cloud_box_office_site = cloud_box_office_site  # type: bool
        # The time when the workspace was created.
        self.creation_time = creation_time  # type: str
        # The ID of the security group.
        self.custom_security_group_id = custom_security_group_id  # type: str
        # The method used to connect the Alibaba Cloud Workspace client to cloud desktops.
        self.desktop_access_type = desktop_access_type  # type: str
        # The number of cloud desktops that are created.
        self.desktop_count = desktop_count  # type: long
        # The endpoint that is used to connect to cloud desktops over a VPC.
        self.desktop_vpc_endpoint = desktop_vpc_endpoint  # type: str
        # The DNS addresses of the AD domains.
        self.dns_address = dns_address  # type: list[str]
        # The username of the DNS account.
        self.dns_user_name = dns_user_name  # type: str
        # The domain name of the enterprise Active Directory (AD) system.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator.
        self.domain_user_name = domain_user_name  # type: str
        # Indicates whether the permissions of the desktop administrator are granted to the user of the cloud desktop.
        self.enable_admin_access = enable_admin_access  # type: bool
        # Indicates whether the desktop communication feature is enabled for cloud desktops in the same workspace. If the feature is enabled, cloud desktops in the same workspace can access each other.
        self.enable_cross_desktop_access = enable_cross_desktop_access  # type: bool
        # Indicates whether Internet access is enabled.
        self.enable_internet_access = enable_internet_access  # type: bool
        # The IDs of the Apsara File Storage NAS (NAS) file systems.
        self.file_system_ids = file_system_ids  # type: list[str]
        # Details of the registration logs.
        self.logs = logs  # type: list[DescribeOfficeSitesResponseBodyOfficeSitesLogs]
        # Indicates whether multi-factor authentication (MFA) is enabled.
        self.mfa_enabled = mfa_enabled  # type: bool
        # The name of the workspace. The name is unique in the same region.
        self.name = name  # type: str
        # Indicates whether two-factor verification for logons is enabled. This parameter is returned only for workspaces of the convenience account type.\
        # If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to an Alibaba Cloud Workspace client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the user enters the correct verification code.
        self.need_verify_login_risk = need_verify_login_risk  # type: bool
        # Indicates whether trusted device verification is enabled.
        self.need_verify_zero_device = need_verify_zero_device  # type: bool
        # The ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The account type of the workspace.
        self.office_site_type = office_site_type  # type: str
        # The name of the organizational unit (OU) that is connected to the AD domain.
        self.ou_name = ou_name  # type: str
        # The type of the protocol.
        self.protocol_type = protocol_type  # type: str
        self.rds_license_address = rds_license_address  # type: str
        self.rds_license_domain_name = rds_license_domain_name  # type: str
        self.rds_license_status = rds_license_status  # type: str
        # Indicates whether single sign-on (SSO) is enabled.
        self.sso_enabled = sso_enabled  # type: bool
        # The type of SSO.
        self.sso_type = sso_type  # type: str
        # The state of the workspace.
        self.status = status  # type: str
        # The DNS addresses of the AD subdomains.
        self.sub_dns_address = sub_dns_address  # type: list[str]
        # The username of a Domain Name System (DNS) account in the AD subdomain.
        self.sub_domain_name = sub_domain_name  # type: str
        # > This parameter is unavailable.
        self.trust_password = trust_password  # type: str
        # The IDs of the vSwitches.
        self.v_switch_ids = v_switch_ids  # type: list[str]
        # The ID of the secure office network of the workspace. The ID is also the ID of the virtual private cloud (VPC) used by the workspace.
        self.vpc_id = vpc_id  # type: str
        # The VPC type.
        self.vpc_type = vpc_type  # type: str

    def validate(self):
        if self.adconnectors:
            for k in self.adconnectors:
                if k:
                    k.validate()
        if self.logs:
            for k in self.logs:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOfficeSitesResponseBodyOfficeSites, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ADConnectors'] = []
        if self.adconnectors is not None:
            for k in self.adconnectors:
                result['ADConnectors'].append(k.to_map() if k else None)
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.cloud_box_office_site is not None:
            result['CloudBoxOfficeSite'] = self.cloud_box_office_site
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.custom_security_group_id is not None:
            result['CustomSecurityGroupId'] = self.custom_security_group_id
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.desktop_count is not None:
            result['DesktopCount'] = self.desktop_count
        if self.desktop_vpc_endpoint is not None:
            result['DesktopVpcEndpoint'] = self.desktop_vpc_endpoint
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.dns_user_name is not None:
            result['DnsUserName'] = self.dns_user_name
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.enable_cross_desktop_access is not None:
            result['EnableCrossDesktopAccess'] = self.enable_cross_desktop_access
        if self.enable_internet_access is not None:
            result['EnableInternetAccess'] = self.enable_internet_access
        if self.file_system_ids is not None:
            result['FileSystemIds'] = self.file_system_ids
        result['Logs'] = []
        if self.logs is not None:
            for k in self.logs:
                result['Logs'].append(k.to_map() if k else None)
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.name is not None:
            result['Name'] = self.name
        if self.need_verify_login_risk is not None:
            result['NeedVerifyLoginRisk'] = self.need_verify_login_risk
        if self.need_verify_zero_device is not None:
            result['NeedVerifyZeroDevice'] = self.need_verify_zero_device
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.ou_name is not None:
            result['OuName'] = self.ou_name
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.rds_license_address is not None:
            result['RdsLicenseAddress'] = self.rds_license_address
        if self.rds_license_domain_name is not None:
            result['RdsLicenseDomainName'] = self.rds_license_domain_name
        if self.rds_license_status is not None:
            result['RdsLicenseStatus'] = self.rds_license_status
        if self.sso_enabled is not None:
            result['SsoEnabled'] = self.sso_enabled
        if self.sso_type is not None:
            result['SsoType'] = self.sso_type
        if self.status is not None:
            result['Status'] = self.status
        if self.sub_dns_address is not None:
            result['SubDnsAddress'] = self.sub_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        if self.trust_password is not None:
            result['TrustPassword'] = self.trust_password
        if self.v_switch_ids is not None:
            result['VSwitchIds'] = self.v_switch_ids
        if self.vpc_id is not None:
            result['VpcId'] = self.vpc_id
        if self.vpc_type is not None:
            result['VpcType'] = self.vpc_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.adconnectors = []
        if m.get('ADConnectors') is not None:
            for k in m.get('ADConnectors'):
                temp_model = DescribeOfficeSitesResponseBodyOfficeSitesADConnectors()
                self.adconnectors.append(temp_model.from_map(k))
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('CloudBoxOfficeSite') is not None:
            self.cloud_box_office_site = m.get('CloudBoxOfficeSite')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('CustomSecurityGroupId') is not None:
            self.custom_security_group_id = m.get('CustomSecurityGroupId')
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('DesktopCount') is not None:
            self.desktop_count = m.get('DesktopCount')
        if m.get('DesktopVpcEndpoint') is not None:
            self.desktop_vpc_endpoint = m.get('DesktopVpcEndpoint')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DnsUserName') is not None:
            self.dns_user_name = m.get('DnsUserName')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('EnableCrossDesktopAccess') is not None:
            self.enable_cross_desktop_access = m.get('EnableCrossDesktopAccess')
        if m.get('EnableInternetAccess') is not None:
            self.enable_internet_access = m.get('EnableInternetAccess')
        if m.get('FileSystemIds') is not None:
            self.file_system_ids = m.get('FileSystemIds')
        self.logs = []
        if m.get('Logs') is not None:
            for k in m.get('Logs'):
                temp_model = DescribeOfficeSitesResponseBodyOfficeSitesLogs()
                self.logs.append(temp_model.from_map(k))
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NeedVerifyLoginRisk') is not None:
            self.need_verify_login_risk = m.get('NeedVerifyLoginRisk')
        if m.get('NeedVerifyZeroDevice') is not None:
            self.need_verify_zero_device = m.get('NeedVerifyZeroDevice')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('OuName') is not None:
            self.ou_name = m.get('OuName')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RdsLicenseAddress') is not None:
            self.rds_license_address = m.get('RdsLicenseAddress')
        if m.get('RdsLicenseDomainName') is not None:
            self.rds_license_domain_name = m.get('RdsLicenseDomainName')
        if m.get('RdsLicenseStatus') is not None:
            self.rds_license_status = m.get('RdsLicenseStatus')
        if m.get('SsoEnabled') is not None:
            self.sso_enabled = m.get('SsoEnabled')
        if m.get('SsoType') is not None:
            self.sso_type = m.get('SsoType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('SubDnsAddress') is not None:
            self.sub_dns_address = m.get('SubDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        if m.get('TrustPassword') is not None:
            self.trust_password = m.get('TrustPassword')
        if m.get('VSwitchIds') is not None:
            self.v_switch_ids = m.get('VSwitchIds')
        if m.get('VpcId') is not None:
            self.vpc_id = m.get('VpcId')
        if m.get('VpcType') is not None:
            self.vpc_type = m.get('VpcType')
        return self


class DescribeOfficeSitesResponseBody(TeaModel):
    def __init__(self, next_token=None, office_sites=None, request_id=None):
        # The token that determines the start point of the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # Details of the workspaces.
        self.office_sites = office_sites  # type: list[DescribeOfficeSitesResponseBodyOfficeSites]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.office_sites:
            for k in self.office_sites:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeOfficeSitesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['OfficeSites'] = []
        if self.office_sites is not None:
            for k in self.office_sites:
                result['OfficeSites'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.office_sites = []
        if m.get('OfficeSites') is not None:
            for k in m.get('OfficeSites'):
                temp_model = DescribeOfficeSitesResponseBodyOfficeSites()
                self.office_sites.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeOfficeSitesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeOfficeSitesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeOfficeSitesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeOfficeSitesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribePolicyGroupsRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, policy_group_id=None, region_id=None, scope=None):
        self.max_results = max_results  # type: int
        self.next_token = next_token  # type: str
        self.policy_group_id = policy_group_id  # type: list[str]
        self.region_id = region_id  # type: str
        self.scope = scope  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.scope is not None:
            result['Scope'] = self.scope
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules(TeaModel):
    def __init__(self, cidr_ip=None, description=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules(TeaModel):
    def __init__(self, cidr_ip=None, description=None, ip_protocol=None, policy=None, port_range=None, priority=None,
                 type=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.policy = policy  # type: str
        self.port_range = port_range  # type: str
        self.priority = priority  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes(TeaModel):
    def __init__(self, client_type=None, status=None):
        self.client_type = client_type  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule(TeaModel):
    def __init__(self, description=None, domain=None, policy=None):
        self.description = description  # type: str
        self.domain = domain  # type: str
        self.policy = policy  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.policy is not None:
            result['Policy'] = self.policy
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule(TeaModel):
    def __init__(self, domain=None, rule_type=None):
        self.domain = domain  # type: str
        self.rule_type = rule_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.domain is not None:
            result['Domain'] = self.domain
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Domain') is not None:
            self.domain = m.get('Domain')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule(TeaModel):
    def __init__(self, description=None, device_class=None, device_subclass=None, product_id=None,
                 usb_redirect_type=None, usb_rule_type=None, vendor_id=None):
        self.description = description  # type: str
        self.device_class = device_class  # type: str
        self.device_subclass = device_subclass  # type: str
        self.product_id = product_id  # type: str
        self.usb_redirect_type = usb_redirect_type  # type: long
        self.usb_rule_type = usb_rule_type  # type: long
        self.vendor_id = vendor_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device_class is not None:
            result['DeviceClass'] = self.device_class
        if self.device_subclass is not None:
            result['DeviceSubclass'] = self.device_subclass
        if self.product_id is not None:
            result['ProductId'] = self.product_id
        if self.usb_redirect_type is not None:
            result['UsbRedirectType'] = self.usb_redirect_type
        if self.usb_rule_type is not None:
            result['UsbRuleType'] = self.usb_rule_type
        if self.vendor_id is not None:
            result['VendorId'] = self.vendor_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceClass') is not None:
            self.device_class = m.get('DeviceClass')
        if m.get('DeviceSubclass') is not None:
            self.device_subclass = m.get('DeviceSubclass')
        if m.get('ProductId') is not None:
            self.product_id = m.get('ProductId')
        if m.get('UsbRedirectType') is not None:
            self.usb_redirect_type = m.get('UsbRedirectType')
        if m.get('UsbRuleType') is not None:
            self.usb_rule_type = m.get('UsbRuleType')
        if m.get('VendorId') is not None:
            self.vendor_id = m.get('VendorId')
        return self


class DescribePolicyGroupsResponseBodyDescribePolicyGroups(TeaModel):
    def __init__(self, app_content_protection=None, authorize_access_policy_rules=None,
                 authorize_security_policy_rules=None, camera_redirect=None, client_types=None, clipboard=None, domain_list=None,
                 domain_resolve_rule=None, domain_resolve_rule_type=None, eds_count=None, end_user_apply_admin_coordinate=None,
                 end_user_group_coordinate=None, gpu_acceleration=None, html_5access=None, html_5file_transfer=None,
                 internet_communication_protocol=None, local_drive=None, name=None, net_redirect=None, net_redirect_rule=None, policy_group_id=None,
                 policy_group_type=None, policy_status=None, preempt_login=None, preempt_login_users=None, printer_redirection=None,
                 record_content=None, record_content_expires=None, recording=None, recording_audio=None, recording_duration=None,
                 recording_end_time=None, recording_expires=None, recording_fps=None, recording_start_time=None,
                 remote_coordinate=None, scope=None, scope_value=None, usb_redirect=None, usb_supply_redirect_rule=None,
                 video_redirect=None, visual_quality=None, watermark=None, watermark_color=None, watermark_custom_text=None,
                 watermark_degree=None, watermark_font_size=None, watermark_font_style=None, watermark_row_amount=None,
                 watermark_transparency=None, watermark_transparency_value=None, watermark_type=None):
        self.app_content_protection = app_content_protection  # type: str
        self.authorize_access_policy_rules = authorize_access_policy_rules  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules]
        self.authorize_security_policy_rules = authorize_security_policy_rules  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules]
        self.camera_redirect = camera_redirect  # type: str
        self.client_types = client_types  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes]
        self.clipboard = clipboard  # type: str
        self.domain_list = domain_list  # type: str
        self.domain_resolve_rule = domain_resolve_rule  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule]
        self.domain_resolve_rule_type = domain_resolve_rule_type  # type: str
        self.eds_count = eds_count  # type: int
        self.end_user_apply_admin_coordinate = end_user_apply_admin_coordinate  # type: str
        self.end_user_group_coordinate = end_user_group_coordinate  # type: str
        self.gpu_acceleration = gpu_acceleration  # type: str
        self.html_5access = html_5access  # type: str
        self.html_5file_transfer = html_5file_transfer  # type: str
        self.internet_communication_protocol = internet_communication_protocol  # type: str
        self.local_drive = local_drive  # type: str
        self.name = name  # type: str
        self.net_redirect = net_redirect  # type: str
        self.net_redirect_rule = net_redirect_rule  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule]
        self.policy_group_id = policy_group_id  # type: str
        self.policy_group_type = policy_group_type  # type: str
        self.policy_status = policy_status  # type: str
        self.preempt_login = preempt_login  # type: str
        self.preempt_login_users = preempt_login_users  # type: list[str]
        self.printer_redirection = printer_redirection  # type: str
        self.record_content = record_content  # type: str
        self.record_content_expires = record_content_expires  # type: long
        self.recording = recording  # type: str
        self.recording_audio = recording_audio  # type: str
        self.recording_duration = recording_duration  # type: int
        self.recording_end_time = recording_end_time  # type: str
        self.recording_expires = recording_expires  # type: long
        self.recording_fps = recording_fps  # type: long
        self.recording_start_time = recording_start_time  # type: str
        self.remote_coordinate = remote_coordinate  # type: str
        self.scope = scope  # type: str
        self.scope_value = scope_value  # type: list[str]
        self.usb_redirect = usb_redirect  # type: str
        self.usb_supply_redirect_rule = usb_supply_redirect_rule  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule]
        self.video_redirect = video_redirect  # type: str
        self.visual_quality = visual_quality  # type: str
        self.watermark = watermark  # type: str
        self.watermark_color = watermark_color  # type: int
        self.watermark_custom_text = watermark_custom_text  # type: str
        self.watermark_degree = watermark_degree  # type: float
        self.watermark_font_size = watermark_font_size  # type: int
        self.watermark_font_style = watermark_font_style  # type: str
        self.watermark_row_amount = watermark_row_amount  # type: int
        self.watermark_transparency = watermark_transparency  # type: str
        self.watermark_transparency_value = watermark_transparency_value  # type: int
        self.watermark_type = watermark_type  # type: str

    def validate(self):
        if self.authorize_access_policy_rules:
            for k in self.authorize_access_policy_rules:
                if k:
                    k.validate()
        if self.authorize_security_policy_rules:
            for k in self.authorize_security_policy_rules:
                if k:
                    k.validate()
        if self.client_types:
            for k in self.client_types:
                if k:
                    k.validate()
        if self.domain_resolve_rule:
            for k in self.domain_resolve_rule:
                if k:
                    k.validate()
        if self.net_redirect_rule:
            for k in self.net_redirect_rule:
                if k:
                    k.validate()
        if self.usb_supply_redirect_rule:
            for k in self.usb_supply_redirect_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBodyDescribePolicyGroups, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_content_protection is not None:
            result['AppContentProtection'] = self.app_content_protection
        result['AuthorizeAccessPolicyRules'] = []
        if self.authorize_access_policy_rules is not None:
            for k in self.authorize_access_policy_rules:
                result['AuthorizeAccessPolicyRules'].append(k.to_map() if k else None)
        result['AuthorizeSecurityPolicyRules'] = []
        if self.authorize_security_policy_rules is not None:
            for k in self.authorize_security_policy_rules:
                result['AuthorizeSecurityPolicyRules'].append(k.to_map() if k else None)
        if self.camera_redirect is not None:
            result['CameraRedirect'] = self.camera_redirect
        result['ClientTypes'] = []
        if self.client_types is not None:
            for k in self.client_types:
                result['ClientTypes'].append(k.to_map() if k else None)
        if self.clipboard is not None:
            result['Clipboard'] = self.clipboard
        if self.domain_list is not None:
            result['DomainList'] = self.domain_list
        result['DomainResolveRule'] = []
        if self.domain_resolve_rule is not None:
            for k in self.domain_resolve_rule:
                result['DomainResolveRule'].append(k.to_map() if k else None)
        if self.domain_resolve_rule_type is not None:
            result['DomainResolveRuleType'] = self.domain_resolve_rule_type
        if self.eds_count is not None:
            result['EdsCount'] = self.eds_count
        if self.end_user_apply_admin_coordinate is not None:
            result['EndUserApplyAdminCoordinate'] = self.end_user_apply_admin_coordinate
        if self.end_user_group_coordinate is not None:
            result['EndUserGroupCoordinate'] = self.end_user_group_coordinate
        if self.gpu_acceleration is not None:
            result['GpuAcceleration'] = self.gpu_acceleration
        if self.html_5access is not None:
            result['Html5Access'] = self.html_5access
        if self.html_5file_transfer is not None:
            result['Html5FileTransfer'] = self.html_5file_transfer
        if self.internet_communication_protocol is not None:
            result['InternetCommunicationProtocol'] = self.internet_communication_protocol
        if self.local_drive is not None:
            result['LocalDrive'] = self.local_drive
        if self.name is not None:
            result['Name'] = self.name
        if self.net_redirect is not None:
            result['NetRedirect'] = self.net_redirect
        result['NetRedirectRule'] = []
        if self.net_redirect_rule is not None:
            for k in self.net_redirect_rule:
                result['NetRedirectRule'].append(k.to_map() if k else None)
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_type is not None:
            result['PolicyGroupType'] = self.policy_group_type
        if self.policy_status is not None:
            result['PolicyStatus'] = self.policy_status
        if self.preempt_login is not None:
            result['PreemptLogin'] = self.preempt_login
        if self.preempt_login_users is not None:
            result['PreemptLoginUsers'] = self.preempt_login_users
        if self.printer_redirection is not None:
            result['PrinterRedirection'] = self.printer_redirection
        if self.record_content is not None:
            result['RecordContent'] = self.record_content
        if self.record_content_expires is not None:
            result['RecordContentExpires'] = self.record_content_expires
        if self.recording is not None:
            result['Recording'] = self.recording
        if self.recording_audio is not None:
            result['RecordingAudio'] = self.recording_audio
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.recording_end_time is not None:
            result['RecordingEndTime'] = self.recording_end_time
        if self.recording_expires is not None:
            result['RecordingExpires'] = self.recording_expires
        if self.recording_fps is not None:
            result['RecordingFps'] = self.recording_fps
        if self.recording_start_time is not None:
            result['RecordingStartTime'] = self.recording_start_time
        if self.remote_coordinate is not None:
            result['RemoteCoordinate'] = self.remote_coordinate
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        if self.usb_redirect is not None:
            result['UsbRedirect'] = self.usb_redirect
        result['UsbSupplyRedirectRule'] = []
        if self.usb_supply_redirect_rule is not None:
            for k in self.usb_supply_redirect_rule:
                result['UsbSupplyRedirectRule'].append(k.to_map() if k else None)
        if self.video_redirect is not None:
            result['VideoRedirect'] = self.video_redirect
        if self.visual_quality is not None:
            result['VisualQuality'] = self.visual_quality
        if self.watermark is not None:
            result['Watermark'] = self.watermark
        if self.watermark_color is not None:
            result['WatermarkColor'] = self.watermark_color
        if self.watermark_custom_text is not None:
            result['WatermarkCustomText'] = self.watermark_custom_text
        if self.watermark_degree is not None:
            result['WatermarkDegree'] = self.watermark_degree
        if self.watermark_font_size is not None:
            result['WatermarkFontSize'] = self.watermark_font_size
        if self.watermark_font_style is not None:
            result['WatermarkFontStyle'] = self.watermark_font_style
        if self.watermark_row_amount is not None:
            result['WatermarkRowAmount'] = self.watermark_row_amount
        if self.watermark_transparency is not None:
            result['WatermarkTransparency'] = self.watermark_transparency
        if self.watermark_transparency_value is not None:
            result['WatermarkTransparencyValue'] = self.watermark_transparency_value
        if self.watermark_type is not None:
            result['WatermarkType'] = self.watermark_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppContentProtection') is not None:
            self.app_content_protection = m.get('AppContentProtection')
        self.authorize_access_policy_rules = []
        if m.get('AuthorizeAccessPolicyRules') is not None:
            for k in m.get('AuthorizeAccessPolicyRules'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeAccessPolicyRules()
                self.authorize_access_policy_rules.append(temp_model.from_map(k))
        self.authorize_security_policy_rules = []
        if m.get('AuthorizeSecurityPolicyRules') is not None:
            for k in m.get('AuthorizeSecurityPolicyRules'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsAuthorizeSecurityPolicyRules()
                self.authorize_security_policy_rules.append(temp_model.from_map(k))
        if m.get('CameraRedirect') is not None:
            self.camera_redirect = m.get('CameraRedirect')
        self.client_types = []
        if m.get('ClientTypes') is not None:
            for k in m.get('ClientTypes'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsClientTypes()
                self.client_types.append(temp_model.from_map(k))
        if m.get('Clipboard') is not None:
            self.clipboard = m.get('Clipboard')
        if m.get('DomainList') is not None:
            self.domain_list = m.get('DomainList')
        self.domain_resolve_rule = []
        if m.get('DomainResolveRule') is not None:
            for k in m.get('DomainResolveRule'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsDomainResolveRule()
                self.domain_resolve_rule.append(temp_model.from_map(k))
        if m.get('DomainResolveRuleType') is not None:
            self.domain_resolve_rule_type = m.get('DomainResolveRuleType')
        if m.get('EdsCount') is not None:
            self.eds_count = m.get('EdsCount')
        if m.get('EndUserApplyAdminCoordinate') is not None:
            self.end_user_apply_admin_coordinate = m.get('EndUserApplyAdminCoordinate')
        if m.get('EndUserGroupCoordinate') is not None:
            self.end_user_group_coordinate = m.get('EndUserGroupCoordinate')
        if m.get('GpuAcceleration') is not None:
            self.gpu_acceleration = m.get('GpuAcceleration')
        if m.get('Html5Access') is not None:
            self.html_5access = m.get('Html5Access')
        if m.get('Html5FileTransfer') is not None:
            self.html_5file_transfer = m.get('Html5FileTransfer')
        if m.get('InternetCommunicationProtocol') is not None:
            self.internet_communication_protocol = m.get('InternetCommunicationProtocol')
        if m.get('LocalDrive') is not None:
            self.local_drive = m.get('LocalDrive')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetRedirect') is not None:
            self.net_redirect = m.get('NetRedirect')
        self.net_redirect_rule = []
        if m.get('NetRedirectRule') is not None:
            for k in m.get('NetRedirectRule'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsNetRedirectRule()
                self.net_redirect_rule.append(temp_model.from_map(k))
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupType') is not None:
            self.policy_group_type = m.get('PolicyGroupType')
        if m.get('PolicyStatus') is not None:
            self.policy_status = m.get('PolicyStatus')
        if m.get('PreemptLogin') is not None:
            self.preempt_login = m.get('PreemptLogin')
        if m.get('PreemptLoginUsers') is not None:
            self.preempt_login_users = m.get('PreemptLoginUsers')
        if m.get('PrinterRedirection') is not None:
            self.printer_redirection = m.get('PrinterRedirection')
        if m.get('RecordContent') is not None:
            self.record_content = m.get('RecordContent')
        if m.get('RecordContentExpires') is not None:
            self.record_content_expires = m.get('RecordContentExpires')
        if m.get('Recording') is not None:
            self.recording = m.get('Recording')
        if m.get('RecordingAudio') is not None:
            self.recording_audio = m.get('RecordingAudio')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('RecordingEndTime') is not None:
            self.recording_end_time = m.get('RecordingEndTime')
        if m.get('RecordingExpires') is not None:
            self.recording_expires = m.get('RecordingExpires')
        if m.get('RecordingFps') is not None:
            self.recording_fps = m.get('RecordingFps')
        if m.get('RecordingStartTime') is not None:
            self.recording_start_time = m.get('RecordingStartTime')
        if m.get('RemoteCoordinate') is not None:
            self.remote_coordinate = m.get('RemoteCoordinate')
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        if m.get('UsbRedirect') is not None:
            self.usb_redirect = m.get('UsbRedirect')
        self.usb_supply_redirect_rule = []
        if m.get('UsbSupplyRedirectRule') is not None:
            for k in m.get('UsbSupplyRedirectRule'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroupsUsbSupplyRedirectRule()
                self.usb_supply_redirect_rule.append(temp_model.from_map(k))
        if m.get('VideoRedirect') is not None:
            self.video_redirect = m.get('VideoRedirect')
        if m.get('VisualQuality') is not None:
            self.visual_quality = m.get('VisualQuality')
        if m.get('Watermark') is not None:
            self.watermark = m.get('Watermark')
        if m.get('WatermarkColor') is not None:
            self.watermark_color = m.get('WatermarkColor')
        if m.get('WatermarkCustomText') is not None:
            self.watermark_custom_text = m.get('WatermarkCustomText')
        if m.get('WatermarkDegree') is not None:
            self.watermark_degree = m.get('WatermarkDegree')
        if m.get('WatermarkFontSize') is not None:
            self.watermark_font_size = m.get('WatermarkFontSize')
        if m.get('WatermarkFontStyle') is not None:
            self.watermark_font_style = m.get('WatermarkFontStyle')
        if m.get('WatermarkRowAmount') is not None:
            self.watermark_row_amount = m.get('WatermarkRowAmount')
        if m.get('WatermarkTransparency') is not None:
            self.watermark_transparency = m.get('WatermarkTransparency')
        if m.get('WatermarkTransparencyValue') is not None:
            self.watermark_transparency_value = m.get('WatermarkTransparencyValue')
        if m.get('WatermarkType') is not None:
            self.watermark_type = m.get('WatermarkType')
        return self


class DescribePolicyGroupsResponseBody(TeaModel):
    def __init__(self, describe_policy_groups=None, next_token=None, request_id=None):
        self.describe_policy_groups = describe_policy_groups  # type: list[DescribePolicyGroupsResponseBodyDescribePolicyGroups]
        self.next_token = next_token  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        if self.describe_policy_groups:
            for k in self.describe_policy_groups:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribePolicyGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DescribePolicyGroups'] = []
        if self.describe_policy_groups is not None:
            for k in self.describe_policy_groups:
                result['DescribePolicyGroups'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.describe_policy_groups = []
        if m.get('DescribePolicyGroups') is not None:
            for k in m.get('DescribePolicyGroups'):
                temp_model = DescribePolicyGroupsResponseBodyDescribePolicyGroups()
                self.describe_policy_groups.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribePolicyGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribePolicyGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribePolicyGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribePolicyGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeRegionsRequest(TeaModel):
    def __init__(self, accept_language=None, region_id=None):
        # The language of the response. Valid values:
        # 
        # - zh: Chinese
        # - en: English
        self.accept_language = accept_language  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRegionsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.accept_language is not None:
            result['AcceptLanguage'] = self.accept_language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AcceptLanguage') is not None:
            self.accept_language = m.get('AcceptLanguage')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeRegionsResponseBodyRegions(TeaModel):
    def __init__(self, local_name=None, region_endpoint=None, region_id=None):
        # The name of the region.
        # 
        # > If the AcceptLanguage parameter is set to zh-CN, the Chinese name of the region is returned. If the AcceptLanguage parameter is set to zh-US or left empty, the English name of the region is returned.
        self.local_name = local_name  # type: str
        # The endpoint of the region.
        self.region_endpoint = region_endpoint  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeRegionsResponseBodyRegions, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.local_name is not None:
            result['LocalName'] = self.local_name
        if self.region_endpoint is not None:
            result['RegionEndpoint'] = self.region_endpoint
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('LocalName') is not None:
            self.local_name = m.get('LocalName')
        if m.get('RegionEndpoint') is not None:
            self.region_endpoint = m.get('RegionEndpoint')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeRegionsResponseBody(TeaModel):
    def __init__(self, regions=None, request_id=None):
        # The list of regions.
        self.regions = regions  # type: list[DescribeRegionsResponseBodyRegions]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.regions:
            for k in self.regions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeRegionsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Regions'] = []
        if self.regions is not None:
            for k in self.regions:
                result['Regions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.regions = []
        if m.get('Regions') is not None:
            for k in m.get('Regions'):
                temp_model = DescribeRegionsResponseBodyRegions()
                self.regions.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeRegionsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeRegionsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeRegionsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeRegionsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeScanTaskProgressRequest(TeaModel):
    def __init__(self, region_id=None, task_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the virus scan task. If this parameter is not specified, the status of the latest scan task is queried by default.
        # 
        # You can call the [StartVirusScanTask](~~217908~~) operation to query the ID of a virus scan task.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskProgressRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeScanTaskProgressResponseBody(TeaModel):
    def __init__(self, create_time=None, request_id=None, task_status=None):
        # The time when the task was created.
        self.create_time = create_time  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The status of the task. Valid values:
        # 
        # *   init: The task is being initialized.
        # *   Processing: The task is in progress.
        # *   Success: The task is completed.
        # *   Failed: The task failed.
        self.task_status = task_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeScanTaskProgressResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeScanTaskProgressResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeScanTaskProgressResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeScanTaskProgressResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeScanTaskProgressResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationStatusRequest(TeaModel):
    def __init__(self, region_id=None, security_event_id=None, task_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        self.security_event_id = security_event_id  # type: list[str]
        # The ID of the task to handle the alerts.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatuses(TeaModel):
    def __init__(self, error_code=None, security_event_id=None, status=None):
        # The code that indicates the processing result of the alert.
        self.error_code = error_code  # type: str
        # The ID of the alert.
        self.security_event_id = security_event_id  # type: long
        # The processing status of the alert. Valid values:
        # 
        # *   Processing: The alert is being processed.
        # *   Success: The alert is processed.
        # *   Failed: The alert failed to be processed.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatuses, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.error_code is not None:
            result['ErrorCode'] = self.error_code
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ErrorCode') is not None:
            self.error_code = m.get('ErrorCode')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSecurityEventOperationStatusResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_operation_statuses=None, task_status=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about the processing status of alerts.
        self.security_event_operation_statuses = security_event_operation_statuses  # type: list[DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatuses]
        # The status of the task that handles the alerts. Valid values:
        # 
        # *   Processing: The task is being executed.
        # *   Success: The task is executed.
        # *   Failure: The task failed.
        # *   Pending: The task is waiting to be executed.
        self.task_status = task_status  # type: str

    def validate(self):
        if self.security_event_operation_statuses:
            for k in self.security_event_operation_statuses:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperationStatuses'] = []
        if self.security_event_operation_statuses is not None:
            for k in self.security_event_operation_statuses:
                result['SecurityEventOperationStatuses'].append(k.to_map() if k else None)
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operation_statuses = []
        if m.get('SecurityEventOperationStatuses') is not None:
            for k in m.get('SecurityEventOperationStatuses'):
                temp_model = DescribeSecurityEventOperationStatusResponseBodySecurityEventOperationStatuses()
                self.security_event_operation_statuses.append(temp_model.from_map(k))
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        return self


class DescribeSecurityEventOperationStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityEventOperationStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSecurityEventOperationsRequest(TeaModel):
    def __init__(self, region_id=None, security_event_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the alert.
        self.security_event_id = security_event_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        return self


class DescribeSecurityEventOperationsResponseBodySecurityEventOperations(TeaModel):
    def __init__(self, operation_code=None, operation_params=None, user_can_operate=None):
        # The code of the operation performed on the alert. Valid values:
        # 
        # *   mark_mis_info: adds the alert to the whitelist without configuring rules. This operation is triggered by adding multiple alerts to the whitelist at a time.
        # *   advance_mark_mis_inf: adds the alert to the whitelist by configuring advanced rules.
        # *   defense_mark_mis_info: adds the alert to the whitelist by configuring precise defense rules.
        # *   rm_mark_mis_info: removes the alert from the whitelist.
        # *   rm_defense_mark_mis_info: removes the alert from the whitelist configured with precise defense rules.
        # *   manual_handled: manually handles the alert.
        # *   ignore: ignores the alert.
        # *   quara: quarantines the source file of the malicious process.
        # *   block_ip: blocks access from the source IP address.
        # *   kill_and_quara: terminates the malicious process and quarantines the source file.
        self.operation_code = operation_code  # type: str
        # The parameters of the operation.
        self.operation_params = operation_params  # type: str
        # Indicates whether the alert can be handled. Valid values:
        # 
        # *   true: The alert can be handled.
        # *   false: The alert cannot be handled.
        self.user_can_operate = user_can_operate  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBodySecurityEventOperations, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.user_can_operate is not None:
            result['UserCanOperate'] = self.user_can_operate
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('UserCanOperate') is not None:
            self.user_can_operate = m.get('UserCanOperate')
        return self


class DescribeSecurityEventOperationsResponseBody(TeaModel):
    def __init__(self, request_id=None, security_event_operations=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The operations performed on the alert.
        self.security_event_operations = security_event_operations  # type: list[DescribeSecurityEventOperationsResponseBodySecurityEventOperations]

    def validate(self):
        if self.security_event_operations:
            for k in self.security_event_operations:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SecurityEventOperations'] = []
        if self.security_event_operations is not None:
            for k in self.security_event_operations:
                result['SecurityEventOperations'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.security_event_operations = []
        if m.get('SecurityEventOperations') is not None:
            for k in m.get('SecurityEventOperations'):
                temp_model = DescribeSecurityEventOperationsResponseBodySecurityEventOperations()
                self.security_event_operations.append(temp_model.from_map(k))
        return self


class DescribeSecurityEventOperationsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSecurityEventOperationsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSecurityEventOperationsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSecurityEventOperationsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSnapshotsRequest(TeaModel):
    def __init__(self, creator=None, desktop_id=None, desktop_name=None, end_time=None, max_results=None,
                 next_token=None, region_id=None, snapshot_id=None, snapshot_name=None, snapshot_type=None,
                 source_disk_type=None, start_time=None):
        self.creator = creator  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The time when you want to stop creating the snapshot. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
        self.end_time = end_time  # type: str
        # The maximum number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 10
        self.max_results = max_results  # type: int
        # The token that determines the start point of the query. Set the value to the value of NextToken that is returned from the last call.
        self.next_token = next_token  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The name of the snapshot. The name must be 2 to 128 characters in length. It can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter and cannot start with `http://` or `https://`.
        # 
        # It cannot start with `auto` because snapshots whose names start with auto are recognized as automatic snapshots.
        self.snapshot_name = snapshot_name  # type: str
        # The type of the snapshot. Default value: all.
        # 
        # Valid values:
        # 
        # *   auto: auto snapshot
        # *   user: manual snapshot
        # *   all: all types of snapshots
        self.snapshot_type = snapshot_type  # type: str
        # The type of the source disk for which you want to create the snapshot. Valid values:
        # 
        # *   System: system disk
        # *   Data: data disk
        # 
        # > The value of this parameter is not case-sensitive.
        self.source_disk_type = source_disk_type  # type: str
        # The time when you want to create the snapshot. Specify the time in the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time must be in UTC.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.snapshot_type is not None:
            result['SnapshotType'] = self.snapshot_type
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SnapshotType') is not None:
            self.snapshot_type = m.get('SnapshotType')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class DescribeSnapshotsResponseBodySnapshots(TeaModel):
    def __init__(self, creation_time=None, creator=None, deletion_time=None, description=None, desktop_id=None,
                 desktop_name=None, desktop_status=None, progress=None, protocol_type=None, remain_time=None, snapshot_id=None,
                 snapshot_name=None, snapshot_type=None, source_disk_size=None, source_disk_type=None, status=None,
                 volume_encryption_enabled=None, volume_encryption_key=None):
        # The time when the snapshot was created. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The user that creates the snapshot.
        self.creator = creator  # type: str
        # The time when the snapshot was deleted. The time follows the [ISO 8601](~~25696~~) standard in the yyyy-mm-ddthh:mm:ssz format. The time is displayed in UTC.
        self.deletion_time = deletion_time  # type: str
        # The description of the snapshot.
        self.description = description  # type: str
        # The ID of the cloud desktop to which the snapshot belongs.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The state of the cloud desktop. Valid values:
        # 
        # *   Pending: The cloud desktop is pending.
        # *   Starting: The cloud desktop is being started.
        # *   Running: The cloud desktop is running.
        # *   Stopping: The cloud desktop is being stopped.
        # *   Rebuilding: The cloud desktop is being recreated.
        # *   Stopped: The cloud desktop is stopped.
        # *   Expired: The cloud desktop expired.
        # *   Deleted: The cloud desktop is deleted.
        self.desktop_status = desktop_status  # type: str
        # The progress of the snapshot creation. Unit: percentage (%).
        self.progress = progress  # type: str
        # The type of the protocol. Valid values:
        # 
        # *   ASP
        # *   HDX
        self.protocol_type = protocol_type  # type: str
        # The remaining time required to create the snapshot. Unit: seconds.
        # 
        # > If the value of the `Status` parameter is `PROGRESSING` and the value of the `RemainTime` parameter is `-1`, the system is calculating the remaining time required to create the snapshot.
        self.remain_time = remain_time  # type: int
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str
        # The name of the snapshot.
        self.snapshot_name = snapshot_name  # type: str
        # The type of snapshot. Valid values:
        # 
        # *   AUTO: auto snapshot
        # *   USER: manual snapshot
        self.snapshot_type = snapshot_type  # type: str
        # The size of the source disk. Unit: GiB.
        self.source_disk_size = source_disk_size  # type: str
        # The type of the source disk. Valid values:
        # 
        # *   SYSTEM: system disk
        # *   DATA: data disk
        self.source_disk_type = source_disk_type  # type: str
        # The state of the snapshot. Valid values:
        # 
        # *   PROGRESSING: The snapshot is being created.
        # *   FAILED: The snapshot failed to be created.
        # *   ACCOMPLISHED: The snapshot is created.
        self.status = status  # type: str
        # Indicates whether disk encryption is enabled.
        self.volume_encryption_enabled = volume_encryption_enabled  # type: bool
        # The ID of the Key Management Service (KMS) key that is used when disk encryption is enabled. You can call the [ListKeys](~~28951~~) operation to obtain a list of KMS keys.
        self.volume_encryption_key = volume_encryption_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBodySnapshots, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.deletion_time is not None:
            result['DeletionTime'] = self.deletion_time
        if self.description is not None:
            result['Description'] = self.description
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.progress is not None:
            result['Progress'] = self.progress
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.remain_time is not None:
            result['RemainTime'] = self.remain_time
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        if self.snapshot_name is not None:
            result['SnapshotName'] = self.snapshot_name
        if self.snapshot_type is not None:
            result['SnapshotType'] = self.snapshot_type
        if self.source_disk_size is not None:
            result['SourceDiskSize'] = self.source_disk_size
        if self.source_disk_type is not None:
            result['SourceDiskType'] = self.source_disk_type
        if self.status is not None:
            result['Status'] = self.status
        if self.volume_encryption_enabled is not None:
            result['VolumeEncryptionEnabled'] = self.volume_encryption_enabled
        if self.volume_encryption_key is not None:
            result['VolumeEncryptionKey'] = self.volume_encryption_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DeletionTime') is not None:
            self.deletion_time = m.get('DeletionTime')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('Progress') is not None:
            self.progress = m.get('Progress')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RemainTime') is not None:
            self.remain_time = m.get('RemainTime')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        if m.get('SnapshotName') is not None:
            self.snapshot_name = m.get('SnapshotName')
        if m.get('SnapshotType') is not None:
            self.snapshot_type = m.get('SnapshotType')
        if m.get('SourceDiskSize') is not None:
            self.source_disk_size = m.get('SourceDiskSize')
        if m.get('SourceDiskType') is not None:
            self.source_disk_type = m.get('SourceDiskType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VolumeEncryptionEnabled') is not None:
            self.volume_encryption_enabled = m.get('VolumeEncryptionEnabled')
        if m.get('VolumeEncryptionKey') is not None:
            self.volume_encryption_key = m.get('VolumeEncryptionKey')
        return self


class DescribeSnapshotsResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, snapshots=None):
        # The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details of the snapshots.
        self.snapshots = snapshots  # type: list[DescribeSnapshotsResponseBodySnapshots]

    def validate(self):
        if self.snapshots:
            for k in self.snapshots:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Snapshots'] = []
        if self.snapshots is not None:
            for k in self.snapshots:
                result['Snapshots'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.snapshots = []
        if m.get('Snapshots') is not None:
            for k in m.get('Snapshots'):
                temp_model = DescribeSnapshotsResponseBodySnapshots()
                self.snapshots.append(temp_model.from_map(k))
        return self


class DescribeSnapshotsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSnapshotsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSnapshotsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSnapshotsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventOverviewRequest(TeaModel):
    def __init__(self, region_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventOverviewRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeSuspEventOverviewResponseBody(TeaModel):
    def __init__(self, remind_count=None, request_id=None, serious_count=None, suspicious_count=None):
        # The total number of alerts at the remind level.
        self.remind_count = remind_count  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of alerts at the serious level.
        self.serious_count = serious_count  # type: int
        # The total number of alerts at the suspicious level.
        self.suspicious_count = suspicious_count  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventOverviewResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.remind_count is not None:
            result['RemindCount'] = self.remind_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.serious_count is not None:
            result['SeriousCount'] = self.serious_count
        if self.suspicious_count is not None:
            result['SuspiciousCount'] = self.suspicious_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RemindCount') is not None:
            self.remind_count = m.get('RemindCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SeriousCount') is not None:
            self.serious_count = m.get('SeriousCount')
        if m.get('SuspiciousCount') is not None:
            self.suspicious_count = m.get('SuspiciousCount')
        return self


class DescribeSuspEventOverviewResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventOverviewResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventOverviewResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventOverviewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventQuaraFilesRequest(TeaModel):
    def __init__(self, current_page=None, office_site_id=None, page_size=None, region_id=None, status=None):
        # The number of the page to return.
        # 
        # Pages start from page 1.
        # 
        # Default value: 1.
        self.current_page = current_page  # type: int
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The maximum number of entries to return on each page.
        # 
        # Default value: 20.
        self.page_size = page_size  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The status of the quarantined file. Valid values:
        # 
        # *   quaraFailed: The file failed to be quarantined.
        # *   quaraDone: The file is quarantined.
        # *   quaraing: The file is being quarantined.
        # *   rollbackFailed: Quarantine for the file failed to be canceled.
        # *   rollbackDone: Quarantine for the file is canceled.
        # *   rollbacking: Quarantine for the file is being canceled.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class DescribeSuspEventQuaraFilesResponseBodyQuaraFiles(TeaModel):
    def __init__(self, desktop_id=None, desktop_name=None, event_name=None, event_type=None, id=None, md_5=None,
                 modify_time=None, path=None, status=None, tag=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The name of the alert.
        self.event_name = event_name  # type: str
        # The type of the alert.
        self.event_type = event_type  # type: str
        # The ID of the quarantined file.
        self.id = id  # type: int
        # The message-digest algorithm 5 (MD5) value of the quarantined file.
        self.md_5 = md_5  # type: str
        # The time when the quarantined file was updated.
        self.modify_time = modify_time  # type: str
        # The path where the quarantined file is stored on the cloud desktop.
        self.path = path  # type: str
        # The status of the quarantined file. Valid values:
        # 
        # *   quaraFailed: The file failed to be quarantined.
        # *   quaraDone: The file is quarantined.
        # *   quaraing: The file is being quarantined.
        # *   rollbackFailed: Quarantine for the file failed to be canceled.
        # *   rollbackDone: Quarantine for the file is canceled.
        # *   rollbacking: Quarantine for the file is being canceled.
        self.status = status  # type: str
        # The tag of the alert.
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponseBodyQuaraFiles, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.event_name is not None:
            result['EventName'] = self.event_name
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.id is not None:
            result['Id'] = self.id
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.modify_time is not None:
            result['ModifyTime'] = self.modify_time
        if self.path is not None:
            result['Path'] = self.path
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('EventName') is not None:
            self.event_name = m.get('EventName')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('ModifyTime') is not None:
            self.modify_time = m.get('ModifyTime')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class DescribeSuspEventQuaraFilesResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, quara_files=None, request_id=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The maximum number of entries returned per page.
        self.page_size = page_size  # type: int
        # The quarantined files.
        self.quara_files = quara_files  # type: list[DescribeSuspEventQuaraFilesResponseBodyQuaraFiles]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of quarantined files.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.quara_files:
            for k in self.quara_files:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        result['QuaraFiles'] = []
        if self.quara_files is not None:
            for k in self.quara_files:
                result['QuaraFiles'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        self.quara_files = []
        if m.get('QuaraFiles') is not None:
            for k in m.get('QuaraFiles'):
                temp_model = DescribeSuspEventQuaraFilesResponseBodyQuaraFiles()
                self.quara_files.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventQuaraFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventQuaraFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventQuaraFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventQuaraFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeSuspEventsRequest(TeaModel):
    def __init__(self, alarm_unique_info=None, current_page=None, dealed=None, lang=None, levels=None,
                 office_site_id=None, page_size=None, parent_event_type=None, region_id=None):
        # The ID of the alert event to which the exception belongs.
        self.alarm_unique_info = alarm_unique_info  # type: str
        # The number of the page to return. Pages start from page 1. Default value: 1.
        self.current_page = current_page  # type: int
        # The processing status of the exception. Valid values:
        # 
        # *   N: not processed
        # *   Y: processed
        self.dealed = dealed  # type: str
        # The language of the content within the request and response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The severity of the exception. Valid values:
        # 
        # *   serious: The exception is urgent.
        # *   suspicious: The exception is a warning
        # *   remind: The exception is a suggestion.
        self.levels = levels  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The number of entries to return on each page. Default value: 20.
        self.page_size = page_size  # type: int
        # The type of the alert event to which the exception belongs.
        self.parent_event_type = parent_event_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.levels is not None:
            result['Levels'] = self.levels
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.parent_event_type is not None:
            result['ParentEventType'] = self.parent_event_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Levels') is not None:
            self.levels = m.get('Levels')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('ParentEventType') is not None:
            self.parent_event_type = m.get('ParentEventType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeSuspEventsResponseBodySuspEventsDetails(TeaModel):
    def __init__(self, name=None, name_display=None, type=None, value=None, value_display=None):
        # The original property name.
        self.name = name  # type: str
        # The property name that is displayed after the Name parameter was translated.
        self.name_display = name_display  # type: str
        # The format in which the property value is displayed. The property value can be a string or displayed in the HTML or Markdown format.
        self.type = type  # type: str
        # The property value.
        self.value = value  # type: str
        # The property value that is displayed after the Value parameter was translated.
        self.value_display = value_display  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEventsDetails, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.name is not None:
            result['Name'] = self.name
        if self.name_display is not None:
            result['NameDisplay'] = self.name_display
        if self.type is not None:
            result['Type'] = self.type
        if self.value is not None:
            result['Value'] = self.value
        if self.value_display is not None:
            result['ValueDisplay'] = self.value_display
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NameDisplay') is not None:
            self.name_display = m.get('NameDisplay')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        if m.get('ValueDisplay') is not None:
            self.value_display = m.get('ValueDisplay')
        return self


class DescribeSuspEventsResponseBodySuspEvents(TeaModel):
    def __init__(self, alarm_event_name=None, alarm_event_name_display=None, alarm_event_type=None,
                 alarm_event_type_display=None, alarm_unique_info=None, can_be_deal_on_line=None, can_cancel_fault=None, data_source=None,
                 desc=None, desktop_id=None, desktop_name=None, details=None, event_status=None, event_sub_type=None,
                 id=None, last_time=None, level=None, name=None, occurrence_time=None, operate_error_code=None,
                 operate_msg=None, unique_info=None):
        # The name of the alert event to which the exception belongs.
        self.alarm_event_name = alarm_event_name  # type: str
        # The description of the alert event with which the exception is associated.
        self.alarm_event_name_display = alarm_event_name_display  # type: str
        # The type of the alert event to which the exception belongs.
        self.alarm_event_type = alarm_event_type  # type: str
        # The description of the alert event to which the exception belongs.
        self.alarm_event_type_display = alarm_event_type_display  # type: str
        # The ID of the alert event to which the exception belongs.
        self.alarm_unique_info = alarm_unique_info  # type: str
        # Indicates whether the exception can be processed online. Valid values:
        # 
        # *   true: The exception can be processed online.
        # *   false: The exception cannot be processed online.
        self.can_be_deal_on_line = can_be_deal_on_line  # type: str
        # Indicates whether the exception can be ignored. Valid values:
        # 
        # *   true: The exception can be ignored.
        # *   false: The exception cannot be ignored.
        self.can_cancel_fault = can_cancel_fault  # type: bool
        # The source of data. This parameter can be ignored.
        self.data_source = data_source  # type: str
        # The impact of the exception.
        self.desc = desc  # type: str
        # The ID of the affected cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the affected cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # Details of the exceptions.
        self.details = details  # type: list[DescribeSuspEventsResponseBodySuspEventsDetails]
        # The state of the exception. Valid values:
        # 
        # *   1: PENDING
        # *   2: IGNORE
        # *   4: HANDLED
        # *   8: FAULT
        # *   16: DEALING
        # *   32: DONE
        # *   64: EXPIRE
        self.event_status = event_status  # type: int
        # The name of the exception.
        self.event_sub_type = event_sub_type  # type: str
        # The ID of the exception.
        self.id = id  # type: long
        # The time when the last exception occurred.
        self.last_time = last_time  # type: str
        # The severity of the exception. Valid values:
        # 
        # *   serious: The exception is urgent.
        # *   suspicious: The exception is a warning
        # *   remind: The exception is a suggestion.
        self.level = level  # type: str
        # The full name of the exception.
        self.name = name  # type: str
        # The time when the exception first occurred.
        self.occurrence_time = occurrence_time  # type: str
        # The handling result code of the exception.
        self.operate_error_code = operate_error_code  # type: str
        # The handling remarks on the exception.
        self.operate_msg = operate_msg  # type: str
        # The ID of the exception.
        self.unique_info = unique_info  # type: str

    def validate(self):
        if self.details:
            for k in self.details:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBodySuspEvents, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alarm_event_name is not None:
            result['AlarmEventName'] = self.alarm_event_name
        if self.alarm_event_name_display is not None:
            result['AlarmEventNameDisplay'] = self.alarm_event_name_display
        if self.alarm_event_type is not None:
            result['AlarmEventType'] = self.alarm_event_type
        if self.alarm_event_type_display is not None:
            result['AlarmEventTypeDisplay'] = self.alarm_event_type_display
        if self.alarm_unique_info is not None:
            result['AlarmUniqueInfo'] = self.alarm_unique_info
        if self.can_be_deal_on_line is not None:
            result['CanBeDealOnLine'] = self.can_be_deal_on_line
        if self.can_cancel_fault is not None:
            result['CanCancelFault'] = self.can_cancel_fault
        if self.data_source is not None:
            result['DataSource'] = self.data_source
        if self.desc is not None:
            result['Desc'] = self.desc
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        result['Details'] = []
        if self.details is not None:
            for k in self.details:
                result['Details'].append(k.to_map() if k else None)
        if self.event_status is not None:
            result['EventStatus'] = self.event_status
        if self.event_sub_type is not None:
            result['EventSubType'] = self.event_sub_type
        if self.id is not None:
            result['Id'] = self.id
        if self.last_time is not None:
            result['LastTime'] = self.last_time
        if self.level is not None:
            result['Level'] = self.level
        if self.name is not None:
            result['Name'] = self.name
        if self.occurrence_time is not None:
            result['OccurrenceTime'] = self.occurrence_time
        if self.operate_error_code is not None:
            result['OperateErrorCode'] = self.operate_error_code
        if self.operate_msg is not None:
            result['OperateMsg'] = self.operate_msg
        if self.unique_info is not None:
            result['UniqueInfo'] = self.unique_info
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AlarmEventName') is not None:
            self.alarm_event_name = m.get('AlarmEventName')
        if m.get('AlarmEventNameDisplay') is not None:
            self.alarm_event_name_display = m.get('AlarmEventNameDisplay')
        if m.get('AlarmEventType') is not None:
            self.alarm_event_type = m.get('AlarmEventType')
        if m.get('AlarmEventTypeDisplay') is not None:
            self.alarm_event_type_display = m.get('AlarmEventTypeDisplay')
        if m.get('AlarmUniqueInfo') is not None:
            self.alarm_unique_info = m.get('AlarmUniqueInfo')
        if m.get('CanBeDealOnLine') is not None:
            self.can_be_deal_on_line = m.get('CanBeDealOnLine')
        if m.get('CanCancelFault') is not None:
            self.can_cancel_fault = m.get('CanCancelFault')
        if m.get('DataSource') is not None:
            self.data_source = m.get('DataSource')
        if m.get('Desc') is not None:
            self.desc = m.get('Desc')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        self.details = []
        if m.get('Details') is not None:
            for k in m.get('Details'):
                temp_model = DescribeSuspEventsResponseBodySuspEventsDetails()
                self.details.append(temp_model.from_map(k))
        if m.get('EventStatus') is not None:
            self.event_status = m.get('EventStatus')
        if m.get('EventSubType') is not None:
            self.event_sub_type = m.get('EventSubType')
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('LastTime') is not None:
            self.last_time = m.get('LastTime')
        if m.get('Level') is not None:
            self.level = m.get('Level')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OccurrenceTime') is not None:
            self.occurrence_time = m.get('OccurrenceTime')
        if m.get('OperateErrorCode') is not None:
            self.operate_error_code = m.get('OperateErrorCode')
        if m.get('OperateMsg') is not None:
            self.operate_msg = m.get('OperateMsg')
        if m.get('UniqueInfo') is not None:
            self.unique_info = m.get('UniqueInfo')
        return self


class DescribeSuspEventsResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, request_id=None, susp_events=None, total_count=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details of the exceptions.
        self.susp_events = susp_events  # type: list[DescribeSuspEventsResponseBodySuspEvents]
        # The total number of exceptions returned.
        self.total_count = total_count  # type: int

    def validate(self):
        if self.susp_events:
            for k in self.susp_events:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['SuspEvents'] = []
        if self.susp_events is not None:
            for k in self.susp_events:
                result['SuspEvents'].append(k.to_map() if k else None)
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.susp_events = []
        if m.get('SuspEvents') is not None:
            for k in m.get('SuspEvents'):
                temp_model = DescribeSuspEventsResponseBodySuspEvents()
                self.susp_events.append(temp_model.from_map(k))
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        return self


class DescribeSuspEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeSuspEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeSuspEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeSuspEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserConnectionRecordsRequest(TeaModel):
    def __init__(self, connect_duration_from=None, connect_duration_to=None, connect_end_time_from=None,
                 connect_end_time_to=None, connect_start_time_from=None, connect_start_time_to=None, desktop_group_id=None,
                 desktop_id=None, end_user_id=None, end_user_type=None, max_results=None, next_token=None, region_id=None):
        # The duration when the cloud desktop is connected, which is the minimum value for condition filtering.
        self.connect_duration_from = connect_duration_from  # type: long
        # The duration when the cloud desktop is connected, which is the maximum value for condition filtering.
        self.connect_duration_to = connect_duration_to  # type: long
        # The time when the cloud desktop stops to be connected, which is the minimum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
        self.connect_end_time_from = connect_end_time_from  # type: long
        # The time when the cloud desktop stops to be connected, which is the maximum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
        self.connect_end_time_to = connect_end_time_to  # type: long
        # The time when the cloud desktop starts to be connected, which is the minimum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
        self.connect_start_time_from = connect_start_time_from  # type: long
        # The time when the cloud desktop starts to be connected, which is the maximum value for condition filtering. The value is a UNIX timestamp. Unit: milliseconds.
        self.connect_start_time_to = connect_start_time_to  # type: long
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The user that you want to authorize to use the desktop group.
        self.end_user_id = end_user_id  # type: str
        # The account type of the user. Valid values:
        # 
        # *   SIMPLE: the convenience account type
        # *   AD_CONNECTOR: the enterprise Active Directory (AD) account type
        self.end_user_type = end_user_type  # type: str
        # The number of entries to return on each page. Maximum value: 100. Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserConnectionRecordsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_duration_from is not None:
            result['ConnectDurationFrom'] = self.connect_duration_from
        if self.connect_duration_to is not None:
            result['ConnectDurationTo'] = self.connect_duration_to
        if self.connect_end_time_from is not None:
            result['ConnectEndTimeFrom'] = self.connect_end_time_from
        if self.connect_end_time_to is not None:
            result['ConnectEndTimeTo'] = self.connect_end_time_to
        if self.connect_start_time_from is not None:
            result['ConnectStartTimeFrom'] = self.connect_start_time_from
        if self.connect_start_time_to is not None:
            result['ConnectStartTimeTo'] = self.connect_start_time_to
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.end_user_type is not None:
            result['EndUserType'] = self.end_user_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectDurationFrom') is not None:
            self.connect_duration_from = m.get('ConnectDurationFrom')
        if m.get('ConnectDurationTo') is not None:
            self.connect_duration_to = m.get('ConnectDurationTo')
        if m.get('ConnectEndTimeFrom') is not None:
            self.connect_end_time_from = m.get('ConnectEndTimeFrom')
        if m.get('ConnectEndTimeTo') is not None:
            self.connect_end_time_to = m.get('ConnectEndTimeTo')
        if m.get('ConnectStartTimeFrom') is not None:
            self.connect_start_time_from = m.get('ConnectStartTimeFrom')
        if m.get('ConnectStartTimeTo') is not None:
            self.connect_start_time_to = m.get('ConnectStartTimeTo')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EndUserType') is not None:
            self.end_user_type = m.get('EndUserType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeUserConnectionRecordsResponseBodyConnectionRecords(TeaModel):
    def __init__(self, connect_duration=None, connect_end_time=None, connect_start_time=None,
                 connection_record_id=None, desktop_id=None, desktop_name=None):
        # The duration of the desktop connection. Unit: seconds.
        self.connect_duration = connect_duration  # type: str
        # The time when the cloud desktop was disconnected.
        self.connect_end_time = connect_end_time  # type: str
        # The time when the cloud desktop was connected.
        self.connect_start_time = connect_start_time  # type: str
        # The ID of the connection record.
        self.connection_record_id = connection_record_id  # type: str
        # The ID of the cloud desktop that is connected.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop that is connected.
        self.desktop_name = desktop_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserConnectionRecordsResponseBodyConnectionRecords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_duration is not None:
            result['ConnectDuration'] = self.connect_duration
        if self.connect_end_time is not None:
            result['ConnectEndTime'] = self.connect_end_time
        if self.connect_start_time is not None:
            result['ConnectStartTime'] = self.connect_start_time
        if self.connection_record_id is not None:
            result['ConnectionRecordId'] = self.connection_record_id
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectDuration') is not None:
            self.connect_duration = m.get('ConnectDuration')
        if m.get('ConnectEndTime') is not None:
            self.connect_end_time = m.get('ConnectEndTime')
        if m.get('ConnectStartTime') is not None:
            self.connect_start_time = m.get('ConnectStartTime')
        if m.get('ConnectionRecordId') is not None:
            self.connection_record_id = m.get('ConnectionRecordId')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        return self


class DescribeUserConnectionRecordsResponseBody(TeaModel):
    def __init__(self, connection_records=None, next_token=None, request_id=None):
        # Details about connection records.
        self.connection_records = connection_records  # type: list[DescribeUserConnectionRecordsResponseBodyConnectionRecords]
        # The token that is used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.connection_records:
            for k in self.connection_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUserConnectionRecordsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ConnectionRecords'] = []
        if self.connection_records is not None:
            for k in self.connection_records:
                result['ConnectionRecords'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.connection_records = []
        if m.get('ConnectionRecords') is not None:
            for k in m.get('ConnectionRecords'):
                temp_model = DescribeUserConnectionRecordsResponseBodyConnectionRecords()
                self.connection_records.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUserConnectionRecordsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserConnectionRecordsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserConnectionRecordsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserConnectionRecordsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUserProfilePathRulesRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None, rule_type=None):
        self.desktop_group_id = desktop_group_id  # type: str
        self.region_id = region_id  # type: str
        self.rule_type = rule_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.rule_type is not None:
            result['RuleType'] = self.rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RuleType') is not None:
            self.rule_type = m.get('RuleType')
        return self


class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath(TeaModel):
    def __init__(self, path=None, type=None):
        self.path = path  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths(TeaModel):
    def __init__(self, path=None, type=None):
        self.path = path  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules(TeaModel):
    def __init__(self, black_path=None, white_paths=None):
        self.black_path = black_path  # type: DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath
        self.white_paths = white_paths  # type: list[DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths]

    def validate(self):
        if self.black_path:
            self.black_path.validate()
        if self.white_paths:
            for k in self.white_paths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_path is not None:
            result['BlackPath'] = self.black_path.to_map()
        result['WhitePaths'] = []
        if self.white_paths is not None:
            for k in self.white_paths:
                result['WhitePaths'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlackPath') is not None:
            temp_model = DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesBlackPath()
            self.black_path = temp_model.from_map(m['BlackPath'])
        self.white_paths = []
        if m.get('WhitePaths') is not None:
            for k in m.get('WhitePaths'):
                temp_model = DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRulesWhitePaths()
                self.white_paths.append(temp_model.from_map(k))
        return self


class DescribeUserProfilePathRulesResponseBodyUserProfilePathRule(TeaModel):
    def __init__(self, desktop_group_id=None, rules=None, user_profile_rule_type=None):
        self.desktop_group_id = desktop_group_id  # type: str
        self.rules = rules  # type: list[DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules]
        self.user_profile_rule_type = user_profile_rule_type  # type: str

    def validate(self):
        if self.rules:
            for k in self.rules:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponseBodyUserProfilePathRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        result['Rules'] = []
        if self.rules is not None:
            for k in self.rules:
                result['Rules'].append(k.to_map() if k else None)
        if self.user_profile_rule_type is not None:
            result['UserProfileRuleType'] = self.user_profile_rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        self.rules = []
        if m.get('Rules') is not None:
            for k in m.get('Rules'):
                temp_model = DescribeUserProfilePathRulesResponseBodyUserProfilePathRuleRules()
                self.rules.append(temp_model.from_map(k))
        if m.get('UserProfileRuleType') is not None:
            self.user_profile_rule_type = m.get('UserProfileRuleType')
        return self


class DescribeUserProfilePathRulesResponseBody(TeaModel):
    def __init__(self, request_id=None, user_profile_path_rule=None):
        self.request_id = request_id  # type: str
        self.user_profile_path_rule = user_profile_path_rule  # type: DescribeUserProfilePathRulesResponseBodyUserProfilePathRule

    def validate(self):
        if self.user_profile_path_rule:
            self.user_profile_path_rule.validate()

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.user_profile_path_rule is not None:
            result['UserProfilePathRule'] = self.user_profile_path_rule.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UserProfilePathRule') is not None:
            temp_model = DescribeUserProfilePathRulesResponseBodyUserProfilePathRule()
            self.user_profile_path_rule = temp_model.from_map(m['UserProfilePathRule'])
        return self


class DescribeUserProfilePathRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUserProfilePathRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUserProfilePathRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUserProfilePathRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsersInGroupRequest(TeaModel):
    def __init__(self, connect_state=None, desktop_group_id=None, end_user_id=None, end_user_ids=None, filter=None,
                 max_results=None, next_token=None, org_id=None, query_user_detail=None, region_id=None):
        # The status of the desktop connection for the end user.
        self.connect_state = connect_state  # type: int
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the authorized user.
        self.end_user_id = end_user_id  # type: str
        # The IDs of the end users.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The query string for fuzzy match. If you specify this parameter, the system returns all results that contain the string.
        self.filter = filter  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the organization to which the end user belongs.
        self.org_id = org_id  # type: str
        # Specifies whether to query the details about the end user.
        self.query_user_detail = query_user_detail  # type: bool
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUsersInGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connect_state is not None:
            result['ConnectState'] = self.connect_state
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.org_id is not None:
            result['OrgId'] = self.org_id
        if self.query_user_detail is not None:
            result['QueryUserDetail'] = self.query_user_detail
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectState') is not None:
            self.connect_state = m.get('ConnectState')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrgId') is not None:
            self.org_id = m.get('OrgId')
        if m.get('QueryUserDetail') is not None:
            self.query_user_detail = m.get('QueryUserDetail')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeUsersInGroupResponseBodyEndUsersExternalInfo(TeaModel):
    def __init__(self, external_name=None, job_number=None):
        # The external name.
        self.external_name = external_name  # type: str
        # The employee ID.
        self.job_number = job_number  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUsersInGroupResponseBodyEndUsersExternalInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.external_name is not None:
            result['ExternalName'] = self.external_name
        if self.job_number is not None:
            result['JobNumber'] = self.job_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExternalName') is not None:
            self.external_name = m.get('ExternalName')
        if m.get('JobNumber') is not None:
            self.job_number = m.get('JobNumber')
        return self


class DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues(TeaModel):
    def __init__(self, property_value=None, property_value_id=None):
        # The property value.
        self.property_value = property_value  # type: str
        # The ID of the property value.
        self.property_value_id = property_value_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.property_value is not None:
            result['PropertyValue'] = self.property_value
        if self.property_value_id is not None:
            result['PropertyValueId'] = self.property_value_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PropertyValue') is not None:
            self.property_value = m.get('PropertyValue')
        if m.get('PropertyValueId') is not None:
            self.property_value_id = m.get('PropertyValueId')
        return self


class DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels(TeaModel):
    def __init__(self, property_id=None, property_key=None, property_type=None, property_values=None, user_id=None,
                 user_name=None):
        # The ID of the property.
        self.property_id = property_id  # type: long
        # The name of the property.
        self.property_key = property_key  # type: str
        # The type of the property.
        self.property_type = property_type  # type: int
        # Details about property values.
        self.property_values = property_values  # type: list[DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues]
        # The ID of the end user.
        self.user_id = user_id  # type: long
        # The name of the end user.
        self.user_name = user_name  # type: str

    def validate(self):
        if self.property_values:
            for k in self.property_values:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.property_id is not None:
            result['PropertyId'] = self.property_id
        if self.property_key is not None:
            result['PropertyKey'] = self.property_key
        if self.property_type is not None:
            result['PropertyType'] = self.property_type
        result['PropertyValues'] = []
        if self.property_values is not None:
            for k in self.property_values:
                result['PropertyValues'].append(k.to_map() if k else None)
        if self.user_id is not None:
            result['UserId'] = self.user_id
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('PropertyId') is not None:
            self.property_id = m.get('PropertyId')
        if m.get('PropertyKey') is not None:
            self.property_key = m.get('PropertyKey')
        if m.get('PropertyType') is not None:
            self.property_type = m.get('PropertyType')
        self.property_values = []
        if m.get('PropertyValues') is not None:
            for k in m.get('PropertyValues'):
                temp_model = DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModelsPropertyValues()
                self.property_values.append(temp_model.from_map(k))
        if m.get('UserId') is not None:
            self.user_id = m.get('UserId')
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class DescribeUsersInGroupResponseBodyEndUsers(TeaModel):
    def __init__(self, connection_status=None, desktop_id=None, desktop_name=None, display_name=None,
                 end_user_email=None, end_user_id=None, end_user_name=None, end_user_phone=None, end_user_remark=None,
                 end_user_type=None, external_info=None, user_desktop_id=None, user_set_properties_models=None):
        # The status of the desktop connection for the end user.
        self.connection_status = connection_status  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The display name of the enterprise AD account.
        self.display_name = display_name  # type: str
        # The email address of the end user.
        self.end_user_email = end_user_email  # type: str
        # The name of the end user.
        self.end_user_id = end_user_id  # type: str
        # The name of the end user.
        self.end_user_name = end_user_name  # type: str
        # The mobile number of the end user.
        self.end_user_phone = end_user_phone  # type: str
        # The remarks of the end user.
        self.end_user_remark = end_user_remark  # type: str
        # The account type of the end user.
        self.end_user_type = end_user_type  # type: str
        # The appended information.
        self.external_info = external_info  # type: DescribeUsersInGroupResponseBodyEndUsersExternalInfo
        # The ID of the desktop of the end user.
        self.user_desktop_id = user_desktop_id  # type: str
        # Details about the seats of end users.
        self.user_set_properties_models = user_set_properties_models  # type: list[DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels]

    def validate(self):
        if self.external_info:
            self.external_info.validate()
        if self.user_set_properties_models:
            for k in self.user_set_properties_models:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUsersInGroupResponseBodyEndUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.connection_status is not None:
            result['ConnectionStatus'] = self.connection_status
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.end_user_email is not None:
            result['EndUserEmail'] = self.end_user_email
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.end_user_name is not None:
            result['EndUserName'] = self.end_user_name
        if self.end_user_phone is not None:
            result['EndUserPhone'] = self.end_user_phone
        if self.end_user_remark is not None:
            result['EndUserRemark'] = self.end_user_remark
        if self.end_user_type is not None:
            result['EndUserType'] = self.end_user_type
        if self.external_info is not None:
            result['ExternalInfo'] = self.external_info.to_map()
        if self.user_desktop_id is not None:
            result['UserDesktopId'] = self.user_desktop_id
        result['UserSetPropertiesModels'] = []
        if self.user_set_properties_models is not None:
            for k in self.user_set_properties_models:
                result['UserSetPropertiesModels'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConnectionStatus') is not None:
            self.connection_status = m.get('ConnectionStatus')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('EndUserEmail') is not None:
            self.end_user_email = m.get('EndUserEmail')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EndUserName') is not None:
            self.end_user_name = m.get('EndUserName')
        if m.get('EndUserPhone') is not None:
            self.end_user_phone = m.get('EndUserPhone')
        if m.get('EndUserRemark') is not None:
            self.end_user_remark = m.get('EndUserRemark')
        if m.get('EndUserType') is not None:
            self.end_user_type = m.get('EndUserType')
        if m.get('ExternalInfo') is not None:
            temp_model = DescribeUsersInGroupResponseBodyEndUsersExternalInfo()
            self.external_info = temp_model.from_map(m['ExternalInfo'])
        if m.get('UserDesktopId') is not None:
            self.user_desktop_id = m.get('UserDesktopId')
        self.user_set_properties_models = []
        if m.get('UserSetPropertiesModels') is not None:
            for k in m.get('UserSetPropertiesModels'):
                temp_model = DescribeUsersInGroupResponseBodyEndUsersUserSetPropertiesModels()
                self.user_set_properties_models.append(temp_model.from_map(k))
        return self


class DescribeUsersInGroupResponseBody(TeaModel):
    def __init__(self, end_users=None, next_token=None, online_users_count=None, request_id=None, users_count=None):
        # Details about the end users.
        self.end_users = end_users  # type: list[DescribeUsersInGroupResponseBodyEndUsers]
        # The token that is used to start the next query.
        self.next_token = next_token  # type: str
        # The number of authorized users that are connecting to cloud desktops.
        self.online_users_count = online_users_count  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of authorized users of the desktop group.
        self.users_count = users_count  # type: int

    def validate(self):
        if self.end_users:
            for k in self.end_users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUsersInGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['EndUsers'] = []
        if self.end_users is not None:
            for k in self.end_users:
                result['EndUsers'].append(k.to_map() if k else None)
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.online_users_count is not None:
            result['OnlineUsersCount'] = self.online_users_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.users_count is not None:
            result['UsersCount'] = self.users_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.end_users = []
        if m.get('EndUsers') is not None:
            for k in m.get('EndUsers'):
                temp_model = DescribeUsersInGroupResponseBodyEndUsers()
                self.end_users.append(temp_model.from_map(k))
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OnlineUsersCount') is not None:
            self.online_users_count = m.get('OnlineUsersCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('UsersCount') is not None:
            self.users_count = m.get('UsersCount')
        return self


class DescribeUsersInGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUsersInGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUsersInGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsersInGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeUsersPasswordRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUsersPasswordRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeUsersPasswordResponseBodyDesktopUsers(TeaModel):
    def __init__(self, display_name=None, end_user_id=None, password=None):
        # The display name of the user.
        self.display_name = display_name  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The password of the user.
        self.password = password  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeUsersPasswordResponseBodyDesktopUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.password is not None:
            result['Password'] = self.password
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        return self


class DescribeUsersPasswordResponseBody(TeaModel):
    def __init__(self, desktop_users=None, request_id=None):
        # The users that are associated with cloud desktop.
        self.desktop_users = desktop_users  # type: list[DescribeUsersPasswordResponseBodyDesktopUsers]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktop_users:
            for k in self.desktop_users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeUsersPasswordResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['DesktopUsers'] = []
        if self.desktop_users is not None:
            for k in self.desktop_users:
                result['DesktopUsers'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.desktop_users = []
        if m.get('DesktopUsers') is not None:
            for k in m.get('DesktopUsers'):
                temp_model = DescribeUsersPasswordResponseBodyDesktopUsers()
                self.desktop_users.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeUsersPasswordResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeUsersPasswordResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeUsersPasswordResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeUsersPasswordResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVirtualMFADevicesRequest(TeaModel):
    def __init__(self, end_user_id=None, max_results=None, next_token=None, office_site_id=None, region_id=None):
        # The list of the AD users.
        self.end_user_id = end_user_id  # type: list[str]
        # The maximum number of results to return. Valid values: 1 to 500. Default value: 100.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the query. Set the value to the NextToken value returned in the last call.
        self.next_token = next_token  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualMFADevicesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeVirtualMFADevicesResponseBodyVirtualMFADevices(TeaModel):
    def __init__(self, consecutive_fails=None, directory_id=None, end_user_id=None, gmt_enabled=None,
                 gmt_unlock=None, office_site_id=None, serial_number=None, status=None):
        # The number of consecutive failures to bind the virtual MFA device, or the number of MFA failures based on the virtual MFA device.
        self.consecutive_fails = consecutive_fails  # type: int
        # >  This parameter is in invitational preview and unavailable for public use.
        self.directory_id = directory_id  # type: str
        # The name of the AD user who uses the virtual MFA device.
        self.end_user_id = end_user_id  # type: str
        # The time when the virtual MFA device is enabled. The time follows the [ISO 8601 standard](~~25696~~) in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.gmt_enabled = gmt_enabled  # type: str
        # The time when the virtual MFA device is automatically unlocked after being locked. The time follows the [ISO 8601 standard](~~25696~~) in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
        self.gmt_unlock = gmt_unlock  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The serial number of the virtual MFA device, which is a unique identifier.
        self.serial_number = serial_number  # type: str
        # The status of the virtual MFA device. The valid values include:
        # 
        # *   UNBOUND: The virtual MFA device is not bound.
        # *   NORMAL: The virtual MFA device is normal.
        # *   LOCKED: The virtual MFA device is locked.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVirtualMFADevicesResponseBodyVirtualMFADevices, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.consecutive_fails is not None:
            result['ConsecutiveFails'] = self.consecutive_fails
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.gmt_enabled is not None:
            result['GmtEnabled'] = self.gmt_enabled
        if self.gmt_unlock is not None:
            result['GmtUnlock'] = self.gmt_unlock
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        if self.status is not None:
            result['status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ConsecutiveFails') is not None:
            self.consecutive_fails = m.get('ConsecutiveFails')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('GmtEnabled') is not None:
            self.gmt_enabled = m.get('GmtEnabled')
        if m.get('GmtUnlock') is not None:
            self.gmt_unlock = m.get('GmtUnlock')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        if m.get('status') is not None:
            self.status = m.get('status')
        return self


class DescribeVirtualMFADevicesResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, virtual_mfadevices=None):
        # The token that determines the start point of the next query. This parameter is empty if no additional results exist.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details of the virtual MFA devices.
        self.virtual_mfadevices = virtual_mfadevices  # type: list[DescribeVirtualMFADevicesResponseBodyVirtualMFADevices]

    def validate(self):
        if self.virtual_mfadevices:
            for k in self.virtual_mfadevices:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVirtualMFADevicesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['VirtualMFADevices'] = []
        if self.virtual_mfadevices is not None:
            for k in self.virtual_mfadevices:
                result['VirtualMFADevices'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.virtual_mfadevices = []
        if m.get('VirtualMFADevices') is not None:
            for k in m.get('VirtualMFADevices'):
                temp_model = DescribeVirtualMFADevicesResponseBodyVirtualMFADevices()
                self.virtual_mfadevices.append(temp_model.from_map(k))
        return self


class DescribeVirtualMFADevicesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVirtualMFADevicesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVirtualMFADevicesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVirtualMFADevicesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulDetailsRequest(TeaModel):
    def __init__(self, alias_name=None, lang=None, name=None, region_id=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The natural language of the request and response. Valid values:
        # 
        # *   zh: Chinese
        # *   en: English
        self.lang = lang  # type: str
        # The name of the Redhat Package Manager (RPM) package.
        # 
        # You can call the [DescribeVulList](~~223907~~) operation to obtain the names of RPM packages.
        self.name = name  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: Linux software vulnerability
        # *   sys: Windows system vulnerability
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulDetailsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulDetailsResponseBodyCves(TeaModel):
    def __init__(self, cve_id=None, cvss_score=None, summary=None, title=None):
        # The ID of the vulnerability.
        self.cve_id = cve_id  # type: str
        # The Common Vulnerability Scoring System (CVSS) score of the vulnerability, which indicates the severity of the vulnerability. A larger value indicates a higher severity. Valid values: 0 to 10.
        self.cvss_score = cvss_score  # type: str
        # The description of the vulnerability.
        self.summary = summary  # type: str
        # The name of the vulnerability.
        self.title = title  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulDetailsResponseBodyCves, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cve_id is not None:
            result['CveId'] = self.cve_id
        if self.cvss_score is not None:
            result['CvssScore'] = self.cvss_score
        if self.summary is not None:
            result['Summary'] = self.summary
        if self.title is not None:
            result['Title'] = self.title
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CveId') is not None:
            self.cve_id = m.get('CveId')
        if m.get('CvssScore') is not None:
            self.cvss_score = m.get('CvssScore')
        if m.get('Summary') is not None:
            self.summary = m.get('Summary')
        if m.get('Title') is not None:
            self.title = m.get('Title')
        return self


class DescribeVulDetailsResponseBody(TeaModel):
    def __init__(self, cves=None, request_id=None):
        # Details about the vulnerability.
        self.cves = cves  # type: list[DescribeVulDetailsResponseBodyCves]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.cves:
            for k in self.cves:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulDetailsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Cves'] = []
        if self.cves is not None:
            for k in self.cves:
                result['Cves'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.cves = []
        if m.get('Cves') is not None:
            for k in m.get('Cves'):
                temp_model = DescribeVulDetailsResponseBodyCves()
                self.cves.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulDetailsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulDetailsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulDetailsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulDetailsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulListRequest(TeaModel):
    def __init__(self, alias_name=None, current_page=None, dealed=None, lang=None, name=None, necessity=None,
                 office_site_id=None, page_size=None, region_id=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The number of the page to return.
        # 
        # *   Pages start from page 1.
        # *   Default value: 1.
        self.current_page = current_page  # type: int
        # The processing status of the vulnerability.
        self.dealed = dealed  # type: str
        # The language of the content within the request and response.
        self.lang = lang  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the detected vulnerability or the risk level of the vulnerability.
        self.necessity = necessity  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The number of entries to return on each page.\
        # Default value: 20.
        self.page_size = page_size  # type: int
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of the detected vulnerability.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.dealed is not None:
            result['Dealed'] = self.dealed
        if self.lang is not None:
            result['Lang'] = self.lang
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('Dealed') is not None:
            self.dealed = m.get('Dealed')
        if m.get('Lang') is not None:
            self.lang = m.get('Lang')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList(TeaModel):
    def __init__(self, full_version=None, match_detail=None, name=None, path=None, update_cmd=None):
        # The complete version number.
        self.full_version = full_version  # type: str
        # The reason why the vulnerability is detected.
        self.match_detail = match_detail  # type: str
        # The name of the RPM package.
        self.name = name  # type: str
        # The path of the software that has the vulnerability.
        self.path = path  # type: str
        # The command that is used to fix the vulnerability.
        self.update_cmd = update_cmd  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.full_version is not None:
            result['FullVersion'] = self.full_version
        if self.match_detail is not None:
            result['MatchDetail'] = self.match_detail
        if self.name is not None:
            result['Name'] = self.name
        if self.path is not None:
            result['Path'] = self.path
        if self.update_cmd is not None:
            result['UpdateCmd'] = self.update_cmd
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FullVersion') is not None:
            self.full_version = m.get('FullVersion')
        if m.get('MatchDetail') is not None:
            self.match_detail = m.get('MatchDetail')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('UpdateCmd') is not None:
            self.update_cmd = m.get('UpdateCmd')
        return self


class DescribeVulListResponseBodyVulRecordsExtendContentJson(TeaModel):
    def __init__(self, rpm_entity_list=None):
        # The RPM Package Manager (RPM) packages.
        self.rpm_entity_list = rpm_entity_list  # type: list[DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList]

    def validate(self):
        if self.rpm_entity_list:
            for k in self.rpm_entity_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecordsExtendContentJson, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RpmEntityList'] = []
        if self.rpm_entity_list is not None:
            for k in self.rpm_entity_list:
                result['RpmEntityList'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rpm_entity_list = []
        if m.get('RpmEntityList') is not None:
            for k in m.get('RpmEntityList'):
                temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJsonRpmEntityList()
                self.rpm_entity_list.append(temp_model.from_map(k))
        return self


class DescribeVulListResponseBodyVulRecords(TeaModel):
    def __init__(self, alias_name=None, desktop_id=None, desktop_name=None, extend_content_json=None, first_ts=None,
                 last_ts=None, modify_ts=None, name=None, necessity=None, online=None, os_version=None, related=None,
                 repair_ts=None, result_code=None, result_message=None, status=None, tag=None, type=None):
        # The alias of the vulnerability.
        self.alias_name = alias_name  # type: str
        # The ID of the affected cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the affected cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The extended information about the vulnerability.
        self.extend_content_json = extend_content_json  # type: DescribeVulListResponseBodyVulRecordsExtendContentJson
        # The UNIX timestamp when the vulnerability was first detected. Unit: milliseconds.
        self.first_ts = first_ts  # type: long
        # The UNIX timestamp when the vulnerability was last detected. Unit: milliseconds.
        self.last_ts = last_ts  # type: long
        # The timestamp when the vulnerability status was changed. Unit: milliseconds.
        self.modify_ts = modify_ts  # type: long
        # The name of the vulnerability.
        self.name = name  # type: str
        # The priority to fix the vulnerability or the risk level of the vulnerability.
        self.necessity = necessity  # type: str
        # Indicates whether the Security Center agent on the cloud desktop is online.
        self.online = online  # type: bool
        # The version of the OS of the cloud desktop.
        self.os_version = os_version  # type: str
        # The IDs of the common vulnerabilities and exposures (CVEs) that are related to the vulnerability.
        self.related = related  # type: str
        # The UNIX timestamp when the vulnerability was fixed. Unit: milliseconds.
        self.repair_ts = repair_ts  # type: long
        # The code returned after the vulnerability is fixed.
        self.result_code = result_code  # type: str
        # The message returned after the vulnerability is fixed.
        self.result_message = result_message  # type: str
        # The status of the vulnerability.
        self.status = status  # type: int
        # The tag that is added to the vulnerability.
        self.tag = tag  # type: str
        # The type of the vulnerability.
        self.type = type  # type: str

    def validate(self):
        if self.extend_content_json:
            self.extend_content_json.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBodyVulRecords, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.alias_name is not None:
            result['AliasName'] = self.alias_name
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.extend_content_json is not None:
            result['ExtendContentJson'] = self.extend_content_json.to_map()
        if self.first_ts is not None:
            result['FirstTs'] = self.first_ts
        if self.last_ts is not None:
            result['LastTs'] = self.last_ts
        if self.modify_ts is not None:
            result['ModifyTs'] = self.modify_ts
        if self.name is not None:
            result['Name'] = self.name
        if self.necessity is not None:
            result['Necessity'] = self.necessity
        if self.online is not None:
            result['Online'] = self.online
        if self.os_version is not None:
            result['OsVersion'] = self.os_version
        if self.related is not None:
            result['Related'] = self.related
        if self.repair_ts is not None:
            result['RepairTs'] = self.repair_ts
        if self.result_code is not None:
            result['ResultCode'] = self.result_code
        if self.result_message is not None:
            result['ResultMessage'] = self.result_message
        if self.status is not None:
            result['Status'] = self.status
        if self.tag is not None:
            result['Tag'] = self.tag
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AliasName') is not None:
            self.alias_name = m.get('AliasName')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('ExtendContentJson') is not None:
            temp_model = DescribeVulListResponseBodyVulRecordsExtendContentJson()
            self.extend_content_json = temp_model.from_map(m['ExtendContentJson'])
        if m.get('FirstTs') is not None:
            self.first_ts = m.get('FirstTs')
        if m.get('LastTs') is not None:
            self.last_ts = m.get('LastTs')
        if m.get('ModifyTs') is not None:
            self.modify_ts = m.get('ModifyTs')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Necessity') is not None:
            self.necessity = m.get('Necessity')
        if m.get('Online') is not None:
            self.online = m.get('Online')
        if m.get('OsVersion') is not None:
            self.os_version = m.get('OsVersion')
        if m.get('Related') is not None:
            self.related = m.get('Related')
        if m.get('RepairTs') is not None:
            self.repair_ts = m.get('RepairTs')
        if m.get('ResultCode') is not None:
            self.result_code = m.get('ResultCode')
        if m.get('ResultMessage') is not None:
            self.result_message = m.get('ResultMessage')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class DescribeVulListResponseBody(TeaModel):
    def __init__(self, current_page=None, page_size=None, request_id=None, total_count=None, vul_records=None):
        # The page number of the returned page.
        self.current_page = current_page  # type: int
        # The number of entries returned per page.
        self.page_size = page_size  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The total number of returned entries.
        self.total_count = total_count  # type: int
        # The vulnerabilities.
        self.vul_records = vul_records  # type: list[DescribeVulListResponseBodyVulRecords]

    def validate(self):
        if self.vul_records:
            for k in self.vul_records:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeVulListResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.current_page is not None:
            result['CurrentPage'] = self.current_page
        if self.page_size is not None:
            result['PageSize'] = self.page_size
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.total_count is not None:
            result['TotalCount'] = self.total_count
        result['VulRecords'] = []
        if self.vul_records is not None:
            for k in self.vul_records:
                result['VulRecords'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CurrentPage') is not None:
            self.current_page = m.get('CurrentPage')
        if m.get('PageSize') is not None:
            self.page_size = m.get('PageSize')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TotalCount') is not None:
            self.total_count = m.get('TotalCount')
        self.vul_records = []
        if m.get('VulRecords') is not None:
            for k in m.get('VulRecords'):
                temp_model = DescribeVulListResponseBodyVulRecords()
                self.vul_records.append(temp_model.from_map(k))
        return self


class DescribeVulListResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulListResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulListResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulListResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeVulOverviewRequest(TeaModel):
    def __init__(self, region_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulOverviewRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DescribeVulOverviewResponseBody(TeaModel):
    def __init__(self, asap_count=None, later_count=None, nntf_count=None, request_id=None):
        # The number of high-risk vulnerabilities.
        self.asap_count = asap_count  # type: int
        # The number of medium-risk vulnerabilities.
        self.later_count = later_count  # type: int
        # The number of low-risk vulnerabilities.
        self.nntf_count = nntf_count  # type: int
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeVulOverviewResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.asap_count is not None:
            result['AsapCount'] = self.asap_count
        if self.later_count is not None:
            result['LaterCount'] = self.later_count
        if self.nntf_count is not None:
            result['NntfCount'] = self.nntf_count
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsapCount') is not None:
            self.asap_count = m.get('AsapCount')
        if m.get('LaterCount') is not None:
            self.later_count = m.get('LaterCount')
        if m.get('NntfCount') is not None:
            self.nntf_count = m.get('NntfCount')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DescribeVulOverviewResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeVulOverviewResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeVulOverviewResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeVulOverviewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DescribeZonesRequest(TeaModel):
    def __init__(self, region_id=None, zone_type=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the zone. Default value: **AvailabilityZone**. This value indicates Alibaba Cloud zones.
        self.zone_type = zone_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.zone_type is not None:
            result['ZoneType'] = self.zone_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ZoneType') is not None:
            self.zone_type = m.get('ZoneType')
        return self


class DescribeZonesResponseBodyZones(TeaModel):
    def __init__(self, zone_id=None):
        # The ID of the zone.
        self.zone_id = zone_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DescribeZonesResponseBodyZones, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.zone_id is not None:
            result['ZoneId'] = self.zone_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ZoneId') is not None:
            self.zone_id = m.get('ZoneId')
        return self


class DescribeZonesResponseBody(TeaModel):
    def __init__(self, request_id=None, zones=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Details about zones.
        self.zones = zones  # type: list[DescribeZonesResponseBodyZones]

    def validate(self):
        if self.zones:
            for k in self.zones:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(DescribeZonesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Zones'] = []
        if self.zones is not None:
            for k in self.zones:
                result['Zones'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.zones = []
        if m.get('Zones') is not None:
            for k in m.get('Zones'):
                temp_model = DescribeZonesResponseBodyZones()
                self.zones.append(temp_model.from_map(k))
        return self


class DescribeZonesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DescribeZonesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DescribeZonesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DescribeZonesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachCenRequest(TeaModel):
    def __init__(self, office_site_id=None, region_id=None):
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachCenRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DetachCenResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachCenResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachCenResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachCenResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachCenResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachCenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DetachEndUserRequest(TeaModel):
    def __init__(self, ad_domain=None, client_type=None, device_id=None, directory_id=None, end_user_id=None,
                 region=None):
        # The address of the Active Directory (AD) workspace.
        self.ad_domain = ad_domain  # type: str
        # The type of the Alibaba Cloud Workspace client. 1: the hardware client 2: the software client
        self.client_type = client_type  # type: str
        # The ID of the device.
        self.device_id = device_id  # type: str
        # The ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The ID of the user that is bound to the client.
        self.end_user_id = end_user_id  # type: str
        # The ID of the region.
        self.region = region  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachEndUserRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_domain is not None:
            result['AdDomain'] = self.ad_domain
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.device_id is not None:
            result['DeviceId'] = self.device_id
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region is not None:
            result['Region'] = self.region
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdDomain') is not None:
            self.ad_domain = m.get('AdDomain')
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('DeviceId') is not None:
            self.device_id = m.get('DeviceId')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('Region') is not None:
            self.region = m.get('Region')
        return self


class DetachEndUserResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DetachEndUserResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DetachEndUserResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DetachEndUserResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DetachEndUserResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DetachEndUserResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DisableDesktopsInGroupRequest(TeaModel):
    def __init__(self, desktop_group_id=None, desktop_ids=None, region_id=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the cloud desktops.
        self.desktop_ids = desktop_ids  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableDesktopsInGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_ids is not None:
            result['DesktopIds'] = self.desktop_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopIds') is not None:
            self.desktop_ids = m.get('DesktopIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DisableDesktopsInGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DisableDesktopsInGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DisableDesktopsInGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DisableDesktopsInGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DisableDesktopsInGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DisableDesktopsInGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class DissociateNetworkPackageRequest(TeaModel):
    def __init__(self, network_package_id=None, region_id=None):
        # The ID of the Internet access package. You can call the [DescribeNetworkPackages](~~216079~~) operation to query the ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DissociateNetworkPackageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class DissociateNetworkPackageResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(DissociateNetworkPackageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class DissociateNetworkPackageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: DissociateNetworkPackageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(DissociateNetworkPackageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = DissociateNetworkPackageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportClientEventsRequest(TeaModel):
    def __init__(self, desktop_id=None, desktop_name=None, end_time=None, end_user_id=None, event_type=None,
                 event_types=None, lang_type=None, max_results=None, office_site_id=None, office_site_name=None, region_id=None,
                 start_time=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The end of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.\
        # If you leave this parameter empty, the current time is used.
        self.end_time = end_time  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The type of the event that you want to query. If you specify a value for the EventTypes parameter, the combination of event types that you want to query is considered the filter condition for the query. If you do not specify a value for the EventTypes parameter and the EventType parameter is left empty, all events are queried.
        self.event_type = event_type  # type: str
        # The combination of event types that you want to query. You can combine multiple event types. The query result contains all the combined events.
        self.event_types = event_types  # type: list[str]
        self.lang_type = lang_type  # type: str
        # The number of records that you want to export. Maximum Value: 5000 Default value: 5000
        self.max_results = max_results  # type: int
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The beginning of the time range to query. Specify the time in the [ISO 8601](~~25696~~) standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.\
        # If you leave this parameter empty, all events that occurred before the point in time that you specify for `EndTime` are queried.
        self.start_time = start_time  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportClientEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.end_time is not None:
            result['EndTime'] = self.end_time
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.event_type is not None:
            result['EventType'] = self.event_type
        if self.event_types is not None:
            result['EventTypes'] = self.event_types
        if self.lang_type is not None:
            result['LangType'] = self.lang_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.start_time is not None:
            result['StartTime'] = self.start_time
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('EndTime') is not None:
            self.end_time = m.get('EndTime')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('EventType') is not None:
            self.event_type = m.get('EventType')
        if m.get('EventTypes') is not None:
            self.event_types = m.get('EventTypes')
        if m.get('LangType') is not None:
            self.lang_type = m.get('LangType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StartTime') is not None:
            self.start_time = m.get('StartTime')
        return self


class ExportClientEventsResponseBody(TeaModel):
    def __init__(self, request_id=None, url=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The URL from which you export events.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportClientEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ExportClientEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportClientEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportClientEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportClientEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportDesktopGroupInfoRequest(TeaModel):
    def __init__(self, charge_type=None, desktop_group_id=None, desktop_group_name=None, end_user_id=None,
                 expired_time=None, lang_type=None, max_results=None, next_token=None, office_site_id=None, policy_group_id=None,
                 region_id=None):
        # The billing method of cloud desktops in a desktop group.
        self.charge_type = charge_type  # type: str
        # The IDs of the desktop groups. You can specify 1 to 100 desktop groups.
        self.desktop_group_id = desktop_group_id  # type: list[str]
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # The IDs of the users authorized to use the desktop group. You can specify 1 to 100 users.
        self.end_user_id = end_user_id  # type: list[str]
        # The time when the subscription cloud desktop expires.
        self.expired_time = expired_time  # type: str
        # The language that you want to use.
        self.lang_type = lang_type  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the workspace to which the desktop group belongs.
        self.office_site_id = office_site_id  # type: str
        # The ID of policy with which the desktop group is associated.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportDesktopGroupInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.lang_type is not None:
            result['LangType'] = self.lang_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('LangType') is not None:
            self.lang_type = m.get('LangType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ExportDesktopGroupInfoResponseBody(TeaModel):
    def __init__(self, request_id=None, url=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The download address from which you can export desktop groups.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportDesktopGroupInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ExportDesktopGroupInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportDesktopGroupInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportDesktopGroupInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportDesktopGroupInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ExportDesktopListInfoRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of the tag. If you specify the `Tag` parameter, you must also specify the `Key` parameter. The tag key can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `aliyun` or `acs:`. You cannot specify an empty string as a tag key.
        self.key = key  # type: str
        # The value of the tag. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `aliyun` or `acs:`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportDesktopListInfoRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ExportDesktopListInfoRequest(TeaModel):
    def __init__(self, charge_type=None, desktop_id=None, desktop_name=None, desktop_status=None, end_user_id=None,
                 expired_time=None, group_id=None, lang_type=None, max_results=None, next_token=None, office_site_id=None,
                 policy_group_id=None, region_id=None, tag=None, user_name=None):
        # The billing method of the cloud desktop. Valid values:
        # 
        # *   PostPaid: pay-as-you-go
        # *   PrePaid: subscription
        # 
        # Default value: PostPaid.
        self.charge_type = charge_type  # type: str
        # The ID of cloud desktop N. Valid values of N: 1 to 100.
        self.desktop_id = desktop_id  # type: list[str]
        # The name of the cloud desktop.
        self.desktop_name = desktop_name  # type: str
        # The status of the cloud desktop. Valid values:
        # 
        # *   Pending: The cloud desktop is pending.
        # *   Starting: The cloud desktop is being started.
        # *   Running: The cloud desktop is running.
        # *   Stopping: The cloud desktop is being stopped.
        # *   Rebuilding: The cloud desktop is being rebuilt.
        # *   Stopped: The cloud desktop is stopped.
        # *   Expired: The cloud desktop expired.
        # *   Deleted: The cloud desktop is deleted.
        self.desktop_status = desktop_status  # type: str
        # The ID of end user N that is assigned the cloud desktop. Valid values of N: 1 to 100.
        # 
        # > Only one end user can use the cloud desktop at a time.
        self.end_user_id = end_user_id  # type: list[str]
        # The time when the subscription cloud desktop expires.
        self.expired_time = expired_time  # type: str
        # The ID of the desktop group.
        self.group_id = group_id  # type: str
        # The language in which the cloud desktop is displayed in the console UI. You can export the list of cloud desktops in the specified language. Valid values:
        # 
        # *   `zh-CN`: Simplified Chinese
        # *   `en-GB`: English (United Kingdom)
        # 
        # Default value: `zh-CN`.
        self.lang_type = lang_type  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100.
        # 
        # Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the policy that is associated with the cloud desktop.
        self.policy_group_id = policy_group_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The tags. A tag is a key-value pair that consists of a tag key and a tag value. Tags are used to identify resources. You can use tags to manage cloud desktops by group for easy searching and batch operations. For more information, see [Use tags to manage cloud desktops](~~203781~~).
        self.tag = tag  # type: list[ExportDesktopListInfoRequestTag]
        # The username of the end user that is using the cloud desktop.
        self.user_name = user_name  # type: str

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ExportDesktopListInfoRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_name is not None:
            result['DesktopName'] = self.desktop_name
        if self.desktop_status is not None:
            result['DesktopStatus'] = self.desktop_status
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.lang_type is not None:
            result['LangType'] = self.lang_type
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        if self.user_name is not None:
            result['UserName'] = self.user_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopName') is not None:
            self.desktop_name = m.get('DesktopName')
        if m.get('DesktopStatus') is not None:
            self.desktop_status = m.get('DesktopStatus')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('LangType') is not None:
            self.lang_type = m.get('LangType')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ExportDesktopListInfoRequestTag()
                self.tag.append(temp_model.from_map(k))
        if m.get('UserName') is not None:
            self.user_name = m.get('UserName')
        return self


class ExportDesktopListInfoResponseBody(TeaModel):
    def __init__(self, request_id=None, url=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The URL from which you can download the file that contains information about exported cloud desktops.
        self.url = url  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ExportDesktopListInfoResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.url is not None:
            result['Url'] = self.url
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Url') is not None:
            self.url = m.get('Url')
        return self


class ExportDesktopListInfoResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ExportDesktopListInfoResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ExportDesktopListInfoResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ExportDesktopListInfoResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetConnectionTicketRequest(TeaModel):
    def __init__(self, command_content=None, desktop_id=None, end_user_id=None, owner_id=None, password=None,
                 region_id=None, resource_owner_account=None, resource_owner_id=None, task_id=None, uuid=None):
        # The command that you want to run to configure a custom application in user mode. After you obtain the credentials, the application automatically starts.
        # 
        # *   appPath: the path of the application startup file. Example: C:\\\Program Files (x86)\\\000\\\000.exe. Use double slashes as delimiters.
        # *   appParameter: the startup parameters of the application. The value must be of the String type. Separate multiple parameters with spaces. Example: meetingid 000 meetingname aaa.
        self.command_content = command_content  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        self.owner_id = owner_id  # type: long
        # The password for the username.
        self.password = password  # type: str
        # The region ID of the cloud desktop.
        self.region_id = region_id  # type: str
        self.resource_owner_account = resource_owner_account  # type: str
        self.resource_owner_id = resource_owner_id  # type: long
        # The ID of the desktop connection task.
        self.task_id = task_id  # type: str
        # The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetConnectionTicketRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.owner_id is not None:
            result['OwnerId'] = self.owner_id
        if self.password is not None:
            result['Password'] = self.password
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_owner_account is not None:
            result['ResourceOwnerAccount'] = self.resource_owner_account
        if self.resource_owner_id is not None:
            result['ResourceOwnerId'] = self.resource_owner_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('OwnerId') is not None:
            self.owner_id = m.get('OwnerId')
        if m.get('Password') is not None:
            self.password = m.get('Password')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceOwnerAccount') is not None:
            self.resource_owner_account = m.get('ResourceOwnerAccount')
        if m.get('ResourceOwnerId') is not None:
            self.resource_owner_id = m.get('ResourceOwnerId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class GetConnectionTicketResponseBody(TeaModel):
    def __init__(self, request_id=None, task_id=None, task_status=None, ticket=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the desktop connection task.
        self.task_id = task_id  # type: str
        # The status of the task.
        # 
        # Valid values:
        # 
        # *   FAILED
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Failed to obtain the token
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   RUNNING
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The token is being obtained
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   FINISHED
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The token-based logon is successful
        # 
        #     <!-- -->
        # 
        #     .
        self.task_status = task_status  # type: str
        # The credentials that are used to connect to the cloud desktop. To use the credentials, you must decode the credentials in Base64, save the credentials as a xxx.ica file, and then open the file. Sample Python code:
        # 
        #     import base64
        #     response = {
        #         "Ticket": "XXXX",
        #         "RequestId": "XXX-XXX",
        #     }
        #     f = open (\"xxx.ica\", \"w\")
        #     out = base64.b64decode(response[\"Ticket\"])
        #     f.write(out)
        #     f.close()
        self.ticket = ticket  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetConnectionTicketResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        if self.task_status is not None:
            result['TaskStatus'] = self.task_status
        if self.ticket is not None:
            result['Ticket'] = self.ticket
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        if m.get('TaskStatus') is not None:
            self.task_status = m.get('TaskStatus')
        if m.get('Ticket') is not None:
            self.ticket = m.get('Ticket')
        return self


class GetConnectionTicketResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetConnectionTicketResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetConnectionTicketResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetConnectionTicketResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetDesktopGroupDetailRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The region ID of the desktop group.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDesktopGroupDetailRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos(TeaModel):
    def __init__(self, buy_res_amount=None, cron=None, keep_duration=None, load_policy=None, max_res_amount=None,
                 min_res_amount=None, ratio_threshold=None, type=None):
        # The number of purchased cloud desktops during the scaling event. Valid values: 0 to 200.
        self.buy_res_amount = buy_res_amount  # type: int
        # The type of the CRON expression that is specified for the scheduled task.
        self.cron = cron  # type: str
        # The retention period of a cloud desktop in the desktop group after the cloud desktop is disconnected. Unit: milliseconds.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy for the multi-session desktop group.
        self.load_policy = load_policy  # type: int
        # The maximum number of cloud desktops that the system can scale. Valid values: 0 to 200.
        self.max_res_amount = max_res_amount  # type: int
        # The minimum number of cloud desktops that the system must scale. Valid values: 0 to 200.
        self.min_res_amount = min_res_amount  # type: int
        # The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops × Maximum number of sessions allowed for each cloud desktop) × 100%`. If the specified threshold is reached, new cloud desktops are automatically created. If the specified threshold is not reached, idle cloud desktops are released.
        self.ratio_threshold = ratio_threshold  # type: float
        # The type of the scheduled task.
        # 
        # Valid values:
        # 
        # *   drop
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     decline policy
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   normal
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     normal policy
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   peak
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     peak hour policy
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   rise
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     rise policy
        # 
        #     <!-- -->
        # 
        #     .
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buy_res_amount is not None:
            result['BuyResAmount'] = self.buy_res_amount
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_res_amount is not None:
            result['MaxResAmount'] = self.max_res_amount
        if self.min_res_amount is not None:
            result['MinResAmount'] = self.min_res_amount
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuyResAmount') is not None:
            self.buy_res_amount = m.get('BuyResAmount')
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxResAmount') is not None:
            self.max_res_amount = m.get('MaxResAmount')
        if m.get('MinResAmount') is not None:
            self.min_res_amount = m.get('MinResAmount')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class GetDesktopGroupDetailResponseBodyDesktopsTimerInfos(TeaModel):
    def __init__(self, cron_expression=None, forced=None, status=None, timer_type=None):
        # The CRON expression of the scheduled task.
        self.cron_expression = cron_expression  # type: str
        # Indicates whether the scheduled task is forcibly executed.
        self.forced = forced  # type: bool
        # The status of the scheduled task.
        # 
        # Valid values:
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The scheduled task is enabled
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The scheduled task is disabled
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   3
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The scheduled task is deleted
        # 
        #     <!-- -->
        # 
        #     .
        self.status = status  # type: int
        # The type of the scheduled task.
        # 
        # Valid values:
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     scheduled reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     scheduled startup
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   3
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     scheduled stop
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   4
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     scheduled restart
        # 
        #     <!-- -->
        # 
        #     .
        self.timer_type = timer_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetDesktopGroupDetailResponseBodyDesktopsTimerInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_expression is not None:
            result['CronExpression'] = self.cron_expression
        if self.forced is not None:
            result['Forced'] = self.forced
        if self.status is not None:
            result['Status'] = self.status
        if self.timer_type is not None:
            result['TimerType'] = self.timer_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronExpression') is not None:
            self.cron_expression = m.get('CronExpression')
        if m.get('Forced') is not None:
            self.forced = m.get('Forced')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimerType') is not None:
            self.timer_type = m.get('TimerType')
        return self


class GetDesktopGroupDetailResponseBodyDesktops(TeaModel):
    def __init__(self, allow_auto_setup=None, allow_buffer_count=None, bind_amount=None, buy_desktops_count=None,
                 comments=None, connect_duration=None, cpu=None, creation_time=None, creator=None, data_disk_category=None,
                 data_disk_size=None, desktop_group_id=None, desktop_group_name=None, directory_id=None, directory_type=None,
                 expired_time=None, gpu_count=None, gpu_spec=None, idle_disconnect_duration=None, image_id=None,
                 keep_duration=None, load_policy=None, max_desktops_count=None, memory=None, min_desktops_count=None,
                 nas_file_system_id=None, nas_file_system_name=None, office_site_id=None, office_site_name=None,
                 office_site_type=None, own_bundle_id=None, own_bundle_name=None, own_type=None, pay_type=None, policy_group_id=None,
                 policy_group_ids=None, policy_group_name=None, policy_group_names=None, profile_follow_switch=None,
                 ratio_threshold=None, res_type=None, reset_type=None, scale_timer_infos=None, status=None, stop_duration=None,
                 system_disk_category=None, system_disk_size=None, timer_infos=None, timing_strategy_info=None, version=None):
        # Indicates whether the auto scale-out feature is enabled for the desktop group.
        self.allow_auto_setup = allow_auto_setup  # type: int
        # The number of reserved cloud desktops in the desktop group.
        self.allow_buffer_count = allow_buffer_count  # type: int
        # The number of sessions that are allowed for each cloud desktop in the multi-session desktop group.
        self.bind_amount = bind_amount  # type: int
        # The number of purchased cloud desktops. Valid values: 0 to 200.
        self.buy_desktops_count = buy_desktops_count  # type: int
        # The remarks on the desktop group.
        self.comments = comments  # type: str
        # The maximum period of time for which a session is effective. Unit: milliseconds.
        self.connect_duration = connect_duration  # type: long
        # The number of vCPUs.
        self.cpu = cpu  # type: int
        # The time when the desktop group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
        self.creation_time = creation_time  # type: str
        # The user who creates the desktop group.
        self.creator = creator  # type: str
        # The category of the data disk.
        self.data_disk_category = data_disk_category  # type: str
        # The size of the data disk.
        self.data_disk_size = data_disk_size  # type: str
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # The ID of the directory, which is the same as the ID of the workspace.
        self.directory_id = directory_id  # type: str
        # The type of the directory.
        self.directory_type = directory_type  # type: str
        # The time when the desktop group expires.
        self.expired_time = expired_time  # type: str
        # The number of vGPUs.
        self.gpu_count = gpu_count  # type: float
        # The GPU specifications.
        self.gpu_spec = gpu_spec  # type: str
        # The maximum period of time for which a session remains idle. Unit: milliseconds.
        self.idle_disconnect_duration = idle_disconnect_duration  # type: long
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The retention period of a cloud desktop in the desktop group after the cloud desktop is disconnected. Unit: milliseconds.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy for the multi-session desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     depth first
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     breadth first
        # 
        #     <!-- -->
        # 
        #     .
        self.load_policy = load_policy  # type: int
        # The maximum number of cloud desktops that the desktop group can contain.
        self.max_desktops_count = max_desktops_count  # type: int
        # The memory size.
        self.memory = memory  # type: long
        # The minimum number of cloud desktops that the desktop group must retain.
        self.min_desktops_count = min_desktops_count  # type: int
        # The ID of the Apsara File Storage NAS (NAS) file system.
        self.nas_file_system_id = nas_file_system_id  # type: str
        # The name of the NAS file system.
        self.nas_file_system_name = nas_file_system_name  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The type of the workspace.
        self.office_site_type = office_site_type  # type: str
        # The ID of the desktop template.
        self.own_bundle_id = own_bundle_id  # type: str
        # The name of the desktop template.
        self.own_bundle_name = own_bundle_name  # type: str
        # The type of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     personal desktop group
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     shared desktop group (multi-session)
        # 
        #     <!-- -->
        # 
        #     .
        self.own_type = own_type  # type: int
        # The billing method.
        # 
        # Valid values:
        # 
        # *   PostPaid
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     pay-as-you-go
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   PrePaid
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     subscription
        # 
        #     <!-- -->
        # 
        #     .
        self.pay_type = pay_type  # type: str
        # The ID of the security policy group.
        self.policy_group_id = policy_group_id  # type: str
        # The IDs of the policies with which the desktop group is associated.
        self.policy_group_ids = policy_group_ids  # type: list[str]
        # The name of the security policy group.
        self.policy_group_name = policy_group_name  # type: str
        # The names of the policies.
        self.policy_group_names = policy_group_names  # type: list[str]
        # Indicates whether data roaming is enabled.
        self.profile_follow_switch = profile_follow_switch  # type: bool
        # The session usage threshold for the multi-session desktop group that has an auto scaling policy in effect.
        self.ratio_threshold = ratio_threshold  # type: float
        # The type of the resource. Only Elastic Compute Service (ECS) instances are supported.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     ECS
        # 
        #     <!-- -->
        # 
        #     .
        self.res_type = res_type  # type: int
        # Indicates which type of disk is reset for cloud desktops in the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     No disks are reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Only the system disk is reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Only the data disk is reset
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   3
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     Both the system disk and data disk are reset
        # 
        #     <!-- -->
        # 
        #     .
        self.reset_type = reset_type  # type: int
        # Details of the scheduled tasks.
        self.scale_timer_infos = scale_timer_infos  # type: list[GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos]
        # The status of the desktop group.
        # 
        # Valid values:
        # 
        # *   0
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is unpaid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   1
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group is paid
        # 
        #     <!-- -->
        # 
        #     .
        # 
        # *   2
        # 
        #     <!-- -->
        # 
        #     :
        # 
        #     <!-- -->
        # 
        #     The desktop group has an overdue payment or expired
        # 
        #     <!-- -->
        # 
        #     .
        self.status = status  # type: int
        # The period of time before an idle cloud desktop enters the Stopped state. When the specified period of time is reached, the idle cloud desktop automatically stops. If an end user connects to a stopped cloud desktop, the cloud desktop automatically starts. Unit: milliseconds.
        self.stop_duration = stop_duration  # type: long
        # The category of the system disk.
        self.system_disk_category = system_disk_category  # type: str
        # The size of the system disk.
        self.system_disk_size = system_disk_size  # type: int
        # The list of scheduled points in time for desktop group tasks.
        self.timer_infos = timer_infos  # type: list[GetDesktopGroupDetailResponseBodyDesktopsTimerInfos]
        # The information about the scheduling policy.
        self.timing_strategy_info = timing_strategy_info  # type: str
        # The version number of the desktop group.
        self.version = version  # type: long

    def validate(self):
        if self.scale_timer_infos:
            for k in self.scale_timer_infos:
                if k:
                    k.validate()
        if self.timer_infos:
            for k in self.timer_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(GetDesktopGroupDetailResponseBodyDesktops, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_auto_setup is not None:
            result['AllowAutoSetup'] = self.allow_auto_setup
        if self.allow_buffer_count is not None:
            result['AllowBufferCount'] = self.allow_buffer_count
        if self.bind_amount is not None:
            result['BindAmount'] = self.bind_amount
        if self.buy_desktops_count is not None:
            result['BuyDesktopsCount'] = self.buy_desktops_count
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.connect_duration is not None:
            result['ConnectDuration'] = self.connect_duration
        if self.cpu is not None:
            result['Cpu'] = self.cpu
        if self.creation_time is not None:
            result['CreationTime'] = self.creation_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.data_disk_category is not None:
            result['DataDiskCategory'] = self.data_disk_category
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_type is not None:
            result['DirectoryType'] = self.directory_type
        if self.expired_time is not None:
            result['ExpiredTime'] = self.expired_time
        if self.gpu_count is not None:
            result['GpuCount'] = self.gpu_count
        if self.gpu_spec is not None:
            result['GpuSpec'] = self.gpu_spec
        if self.idle_disconnect_duration is not None:
            result['IdleDisconnectDuration'] = self.idle_disconnect_duration
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_desktops_count is not None:
            result['MaxDesktopsCount'] = self.max_desktops_count
        if self.memory is not None:
            result['Memory'] = self.memory
        if self.min_desktops_count is not None:
            result['MinDesktopsCount'] = self.min_desktops_count
        if self.nas_file_system_id is not None:
            result['NasFileSystemID'] = self.nas_file_system_id
        if self.nas_file_system_name is not None:
            result['NasFileSystemName'] = self.nas_file_system_name
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_type is not None:
            result['OfficeSiteType'] = self.office_site_type
        if self.own_bundle_id is not None:
            result['OwnBundleId'] = self.own_bundle_id
        if self.own_bundle_name is not None:
            result['OwnBundleName'] = self.own_bundle_name
        if self.own_type is not None:
            result['OwnType'] = self.own_type
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_ids is not None:
            result['PolicyGroupIds'] = self.policy_group_ids
        if self.policy_group_name is not None:
            result['PolicyGroupName'] = self.policy_group_name
        if self.policy_group_names is not None:
            result['PolicyGroupNames'] = self.policy_group_names
        if self.profile_follow_switch is not None:
            result['ProfileFollowSwitch'] = self.profile_follow_switch
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.res_type is not None:
            result['ResType'] = self.res_type
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        result['ScaleTimerInfos'] = []
        if self.scale_timer_infos is not None:
            for k in self.scale_timer_infos:
                result['ScaleTimerInfos'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        if self.stop_duration is not None:
            result['StopDuration'] = self.stop_duration
        if self.system_disk_category is not None:
            result['SystemDiskCategory'] = self.system_disk_category
        if self.system_disk_size is not None:
            result['SystemDiskSize'] = self.system_disk_size
        result['TimerInfos'] = []
        if self.timer_infos is not None:
            for k in self.timer_infos:
                result['TimerInfos'].append(k.to_map() if k else None)
        if self.timing_strategy_info is not None:
            result['TimingStrategyInfo'] = self.timing_strategy_info
        if self.version is not None:
            result['Version'] = self.version
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowAutoSetup') is not None:
            self.allow_auto_setup = m.get('AllowAutoSetup')
        if m.get('AllowBufferCount') is not None:
            self.allow_buffer_count = m.get('AllowBufferCount')
        if m.get('BindAmount') is not None:
            self.bind_amount = m.get('BindAmount')
        if m.get('BuyDesktopsCount') is not None:
            self.buy_desktops_count = m.get('BuyDesktopsCount')
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('ConnectDuration') is not None:
            self.connect_duration = m.get('ConnectDuration')
        if m.get('Cpu') is not None:
            self.cpu = m.get('Cpu')
        if m.get('CreationTime') is not None:
            self.creation_time = m.get('CreationTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('DataDiskCategory') is not None:
            self.data_disk_category = m.get('DataDiskCategory')
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryType') is not None:
            self.directory_type = m.get('DirectoryType')
        if m.get('ExpiredTime') is not None:
            self.expired_time = m.get('ExpiredTime')
        if m.get('GpuCount') is not None:
            self.gpu_count = m.get('GpuCount')
        if m.get('GpuSpec') is not None:
            self.gpu_spec = m.get('GpuSpec')
        if m.get('IdleDisconnectDuration') is not None:
            self.idle_disconnect_duration = m.get('IdleDisconnectDuration')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxDesktopsCount') is not None:
            self.max_desktops_count = m.get('MaxDesktopsCount')
        if m.get('Memory') is not None:
            self.memory = m.get('Memory')
        if m.get('MinDesktopsCount') is not None:
            self.min_desktops_count = m.get('MinDesktopsCount')
        if m.get('NasFileSystemID') is not None:
            self.nas_file_system_id = m.get('NasFileSystemID')
        if m.get('NasFileSystemName') is not None:
            self.nas_file_system_name = m.get('NasFileSystemName')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteType') is not None:
            self.office_site_type = m.get('OfficeSiteType')
        if m.get('OwnBundleId') is not None:
            self.own_bundle_id = m.get('OwnBundleId')
        if m.get('OwnBundleName') is not None:
            self.own_bundle_name = m.get('OwnBundleName')
        if m.get('OwnType') is not None:
            self.own_type = m.get('OwnType')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupIds') is not None:
            self.policy_group_ids = m.get('PolicyGroupIds')
        if m.get('PolicyGroupName') is not None:
            self.policy_group_name = m.get('PolicyGroupName')
        if m.get('PolicyGroupNames') is not None:
            self.policy_group_names = m.get('PolicyGroupNames')
        if m.get('ProfileFollowSwitch') is not None:
            self.profile_follow_switch = m.get('ProfileFollowSwitch')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('ResType') is not None:
            self.res_type = m.get('ResType')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        self.scale_timer_infos = []
        if m.get('ScaleTimerInfos') is not None:
            for k in m.get('ScaleTimerInfos'):
                temp_model = GetDesktopGroupDetailResponseBodyDesktopsScaleTimerInfos()
                self.scale_timer_infos.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('StopDuration') is not None:
            self.stop_duration = m.get('StopDuration')
        if m.get('SystemDiskCategory') is not None:
            self.system_disk_category = m.get('SystemDiskCategory')
        if m.get('SystemDiskSize') is not None:
            self.system_disk_size = m.get('SystemDiskSize')
        self.timer_infos = []
        if m.get('TimerInfos') is not None:
            for k in m.get('TimerInfos'):
                temp_model = GetDesktopGroupDetailResponseBodyDesktopsTimerInfos()
                self.timer_infos.append(temp_model.from_map(k))
        if m.get('TimingStrategyInfo') is not None:
            self.timing_strategy_info = m.get('TimingStrategyInfo')
        if m.get('Version') is not None:
            self.version = m.get('Version')
        return self


class GetDesktopGroupDetailResponseBody(TeaModel):
    def __init__(self, desktops=None, request_id=None):
        # Details of the desktop group.
        self.desktops = desktops  # type: GetDesktopGroupDetailResponseBodyDesktops
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.desktops:
            self.desktops.validate()

    def to_map(self):
        _map = super(GetDesktopGroupDetailResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktops is not None:
            result['Desktops'] = self.desktops.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Desktops') is not None:
            temp_model = GetDesktopGroupDetailResponseBodyDesktops()
            self.desktops = temp_model.from_map(m['Desktops'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class GetDesktopGroupDetailResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetDesktopGroupDetailResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetDesktopGroupDetailResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetDesktopGroupDetailResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetOfficeSiteSsoStatusRequest(TeaModel):
    def __init__(self, office_site_id=None, region_id=None):
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOfficeSiteSsoStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetOfficeSiteSsoStatusResponseBody(TeaModel):
    def __init__(self, request_id=None, sso_status=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # Indicates whether SSO is enabled.
        self.sso_status = sso_status  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetOfficeSiteSsoStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sso_status is not None:
            result['SsoStatus'] = self.sso_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SsoStatus') is not None:
            self.sso_status = m.get('SsoStatus')
        return self


class GetOfficeSiteSsoStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetOfficeSiteSsoStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetOfficeSiteSsoStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetOfficeSiteSsoStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class GetSpMetadataRequest(TeaModel):
    def __init__(self, directory_id=None, office_site_id=None, region_id=None):
        # The ID of the workspace. The parameter is the same as the `OfficeSiteId` parameter. We recommend that you use `OfficeSiteId` instead of `DirectoryId`. You can specify a value for either the `DirectoryId` parameter or the `OfficeSiteId` parameter, but not both.
        self.directory_id = directory_id  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSpMetadataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class GetSpMetadataResponseBody(TeaModel):
    def __init__(self, request_id=None, sp_metadata=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The metadata of the SP.
        self.sp_metadata = sp_metadata  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(GetSpMetadataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.sp_metadata is not None:
            result['SpMetadata'] = self.sp_metadata
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('SpMetadata') is not None:
            self.sp_metadata = m.get('SpMetadata')
        return self


class GetSpMetadataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: GetSpMetadataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(GetSpMetadataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = GetSpMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class HandleSecurityEventsRequestSecurityEvent(TeaModel):
    def __init__(self, desktop_id=None, security_event_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the alert.
        self.security_event_id = security_event_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSecurityEventsRequestSecurityEvent, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.security_event_id is not None:
            result['SecurityEventId'] = self.security_event_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('SecurityEventId') is not None:
            self.security_event_id = m.get('SecurityEventId')
        return self


class HandleSecurityEventsRequest(TeaModel):
    def __init__(self, operation_code=None, operation_params=None, region_id=None, security_event=None):
        # The operation to handle multiple alerts of the same type at a time.
        self.operation_code = operation_code  # type: str
        # The return value from the operation to handle multiple alerts of the same type at a time.\
        # This parameter is required only if you set the OperationCode parameter to `kill_and_quara` or `block_ip`. This parameter is not required if you set the OperationCode parameter to other values.
        self.operation_params = operation_params  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The alerts.
        self.security_event = security_event  # type: list[HandleSecurityEventsRequestSecurityEvent]

    def validate(self):
        if self.security_event:
            for k in self.security_event:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(HandleSecurityEventsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operation_code is not None:
            result['OperationCode'] = self.operation_code
        if self.operation_params is not None:
            result['OperationParams'] = self.operation_params
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['SecurityEvent'] = []
        if self.security_event is not None:
            for k in self.security_event:
                result['SecurityEvent'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperationCode') is not None:
            self.operation_code = m.get('OperationCode')
        if m.get('OperationParams') is not None:
            self.operation_params = m.get('OperationParams')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.security_event = []
        if m.get('SecurityEvent') is not None:
            for k in m.get('SecurityEvent'):
                temp_model = HandleSecurityEventsRequestSecurityEvent()
                self.security_event.append(temp_model.from_map(k))
        return self


class HandleSecurityEventsResponseBody(TeaModel):
    def __init__(self, request_id=None, task_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the task to handle alerts.
        self.task_id = task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(HandleSecurityEventsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.task_id is not None:
            result['TaskId'] = self.task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('TaskId') is not None:
            self.task_id = m.get('TaskId')
        return self


class HandleSecurityEventsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: HandleSecurityEventsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(HandleSecurityEventsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = HandleSecurityEventsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListCdsFilesRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_ids=None, max_results=None, next_token=None,
                 order_type=None, parent_file_id=None, region_id=None, status=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_ids = file_ids  # type: list[str]
        self.max_results = max_results  # type: int
        self.next_token = next_token  # type: str
        self.order_type = order_type  # type: str
        self.parent_file_id = parent_file_id  # type: str
        self.region_id = region_id  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCdsFilesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_ids is not None:
            result['FileIds'] = self.file_ids
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.parent_file_id is not None:
            result['ParentFileId'] = self.parent_file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileIds') is not None:
            self.file_ids = m.get('FileIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ParentFileId') is not None:
            self.parent_file_id = m.get('ParentFileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCdsFilesShrinkRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_ids_shrink=None, max_results=None, next_token=None,
                 order_type=None, parent_file_id=None, region_id=None, status=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_ids_shrink = file_ids_shrink  # type: str
        self.max_results = max_results  # type: int
        self.next_token = next_token  # type: str
        self.order_type = order_type  # type: str
        self.parent_file_id = parent_file_id  # type: str
        self.region_id = region_id  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCdsFilesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_ids_shrink is not None:
            result['FileIds'] = self.file_ids_shrink
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.order_type is not None:
            result['OrderType'] = self.order_type
        if self.parent_file_id is not None:
            result['ParentFileId'] = self.parent_file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileIds') is not None:
            self.file_ids_shrink = m.get('FileIds')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OrderType') is not None:
            self.order_type = m.get('OrderType')
        if m.get('ParentFileId') is not None:
            self.parent_file_id = m.get('ParentFileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ListCdsFilesResponseBodyFileModels(TeaModel):
    def __init__(self, category=None, content_type=None, create_time=None, creator=None, description=None,
                 download_url=None, file_extension=None, file_id=None, file_path=None, file_type=None, md_5=None,
                 modified_time=None, modifier=None, name=None, open_time=None, open_time_stamp=None, parent_id=None,
                 region_id=None, sha_1=None, size=None, thumbnail=None):
        self.category = category  # type: str
        self.content_type = content_type  # type: str
        self.create_time = create_time  # type: str
        self.creator = creator  # type: str
        self.description = description  # type: str
        self.download_url = download_url  # type: str
        self.file_extension = file_extension  # type: str
        self.file_id = file_id  # type: str
        self.file_path = file_path  # type: str
        self.file_type = file_type  # type: str
        self.md_5 = md_5  # type: str
        self.modified_time = modified_time  # type: str
        self.modifier = modifier  # type: str
        self.name = name  # type: str
        self.open_time = open_time  # type: str
        self.open_time_stamp = open_time_stamp  # type: long
        self.parent_id = parent_id  # type: str
        self.region_id = region_id  # type: str
        self.sha_1 = sha_1  # type: str
        self.size = size  # type: long
        self.thumbnail = thumbnail  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListCdsFilesResponseBodyFileModels, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.category is not None:
            result['Category'] = self.category
        if self.content_type is not None:
            result['ContentType'] = self.content_type
        if self.create_time is not None:
            result['CreateTime'] = self.create_time
        if self.creator is not None:
            result['Creator'] = self.creator
        if self.description is not None:
            result['Description'] = self.description
        if self.download_url is not None:
            result['DownloadUrl'] = self.download_url
        if self.file_extension is not None:
            result['FileExtension'] = self.file_extension
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_path is not None:
            result['FilePath'] = self.file_path
        if self.file_type is not None:
            result['FileType'] = self.file_type
        if self.md_5 is not None:
            result['Md5'] = self.md_5
        if self.modified_time is not None:
            result['ModifiedTime'] = self.modified_time
        if self.modifier is not None:
            result['Modifier'] = self.modifier
        if self.name is not None:
            result['Name'] = self.name
        if self.open_time is not None:
            result['OpenTime'] = self.open_time
        if self.open_time_stamp is not None:
            result['OpenTimeStamp'] = self.open_time_stamp
        if self.parent_id is not None:
            result['ParentId'] = self.parent_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sha_1 is not None:
            result['Sha1'] = self.sha_1
        if self.size is not None:
            result['Size'] = self.size
        if self.thumbnail is not None:
            result['Thumbnail'] = self.thumbnail
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Category') is not None:
            self.category = m.get('Category')
        if m.get('ContentType') is not None:
            self.content_type = m.get('ContentType')
        if m.get('CreateTime') is not None:
            self.create_time = m.get('CreateTime')
        if m.get('Creator') is not None:
            self.creator = m.get('Creator')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DownloadUrl') is not None:
            self.download_url = m.get('DownloadUrl')
        if m.get('FileExtension') is not None:
            self.file_extension = m.get('FileExtension')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FilePath') is not None:
            self.file_path = m.get('FilePath')
        if m.get('FileType') is not None:
            self.file_type = m.get('FileType')
        if m.get('Md5') is not None:
            self.md_5 = m.get('Md5')
        if m.get('ModifiedTime') is not None:
            self.modified_time = m.get('ModifiedTime')
        if m.get('Modifier') is not None:
            self.modifier = m.get('Modifier')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('OpenTime') is not None:
            self.open_time = m.get('OpenTime')
        if m.get('OpenTimeStamp') is not None:
            self.open_time_stamp = m.get('OpenTimeStamp')
        if m.get('ParentId') is not None:
            self.parent_id = m.get('ParentId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Sha1') is not None:
            self.sha_1 = m.get('Sha1')
        if m.get('Size') is not None:
            self.size = m.get('Size')
        if m.get('Thumbnail') is not None:
            self.thumbnail = m.get('Thumbnail')
        return self


class ListCdsFilesResponseBody(TeaModel):
    def __init__(self, code=None, count=None, file_models=None, message=None, next_token=None, request_id=None,
                 success=None):
        self.code = code  # type: str
        self.count = count  # type: str
        self.file_models = file_models  # type: list[ListCdsFilesResponseBodyFileModels]
        self.message = message  # type: str
        self.next_token = next_token  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.file_models:
            for k in self.file_models:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListCdsFilesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.count is not None:
            result['Count'] = self.count
        result['FileModels'] = []
        if self.file_models is not None:
            for k in self.file_models:
                result['FileModels'].append(k.to_map() if k else None)
        if self.message is not None:
            result['Message'] = self.message
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Count') is not None:
            self.count = m.get('Count')
        self.file_models = []
        if m.get('FileModels') is not None:
            for k in m.get('FileModels'):
                temp_model = ListCdsFilesResponseBodyFileModels()
                self.file_models.append(temp_model.from_map(k))
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ListCdsFilesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListCdsFilesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListCdsFilesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListCdsFilesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListDirectoryUsersRequest(TeaModel):
    def __init__(self, directory_id=None, filter=None, max_results=None, next_token=None, oupath=None,
                 region_id=None):
        # The ID of the AD directory.
        self.directory_id = directory_id  # type: str
        # The query string for fuzzy query. If you specify this parameter, the system returns all results that contain the string.
        self.filter = filter  # type: str
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100
        # *   Default value: 10
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this parameter is left empty, all results are returned.
        self.next_token = next_token  # type: str
        # The organizational unit (OU) of the AD domain to which users belong. You can call the [ListUserAdOrganizationUnits](~~311259~~) operation to obtain the OU.
        self.oupath = oupath  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDirectoryUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.oupath is not None:
            result['OUPath'] = self.oupath
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OUPath') is not None:
            self.oupath = m.get('OUPath')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListDirectoryUsersResponseBodyUsers(TeaModel):
    def __init__(self, display_name=None, end_user=None):
        # The display name of the user.
        self.display_name = display_name  # type: str
        # The name of the user.
        self.end_user = end_user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListDirectoryUsersResponseBodyUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.end_user is not None:
            result['EndUser'] = self.end_user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('EndUser') is not None:
            self.end_user = m.get('EndUser')
        return self


class ListDirectoryUsersResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, users=None):
        # The token that is used to start the next query. If the value of this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The names of users corresponding to the AD directory. If the AD directory corresponds only to Administrator and Guest users, the returned value of the Users parameter is empty.
        self.users = users  # type: list[ListDirectoryUsersResponseBodyUsers]

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListDirectoryUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ListDirectoryUsersResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ListDirectoryUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListDirectoryUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListDirectoryUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListDirectoryUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListFilePermissionRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListFilePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListFilePermissionResponseBody(TeaModel):
    def __init__(self, file_permissions=None, request_id=None):
        self.file_permissions = file_permissions  # type: list[FilePermissionMember]
        self.request_id = request_id  # type: str

    def validate(self):
        if self.file_permissions:
            for k in self.file_permissions:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListFilePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['FilePermissions'] = []
        if self.file_permissions is not None:
            for k in self.file_permissions:
                result['FilePermissions'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.file_permissions = []
        if m.get('FilePermissions') is not None:
            for k in m.get('FilePermissions'):
                temp_model = FilePermissionMember()
                self.file_permissions.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListFilePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListFilePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListFilePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListFilePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOfficeSiteOverviewRequest(TeaModel):
    def __init__(self, force_refresh=None, max_results=None, next_token=None, office_site_id=None, query_range=None,
                 region_id=None):
        # Specifies whether to refresh the cache.
        self.force_refresh = force_refresh  # type: bool
        # The number of entries to return on each page.
        # 
        # *   Maximum value: 100.
        # *   Default value: 10.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the next query. If this is your first query or no next query is to be sent, skip this parameter. If a next query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
        self.next_token = next_token  # type: str
        # Details about the IDs of the workspaces. You can specify 1 to 100 workspace IDs.
        self.office_site_id = office_site_id  # type: list[str]
        # The beginning of the time range that you want to query.
        self.query_range = query_range  # type: int
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOfficeSiteOverviewRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.force_refresh is not None:
            result['ForceRefresh'] = self.force_refresh
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.query_range is not None:
            result['QueryRange'] = self.query_range
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ForceRefresh') is not None:
            self.force_refresh = m.get('ForceRefresh')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('QueryRange') is not None:
            self.query_range = m.get('QueryRange')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults(TeaModel):
    def __init__(self, has_expired_eds_count=None, has_expired_eds_count_for_group=None, office_site_id=None,
                 office_site_name=None, office_site_status=None, region_id=None, running_eds_count=None,
                 running_eds_count_for_group=None, total_eds_count=None, total_eds_count_for_group=None, vpc_type=None,
                 will_expired_eds_count=None, will_expired_eds_count_for_group=None):
        # The number of expired cloud desktops in the workspace.
        self.has_expired_eds_count = has_expired_eds_count  # type: int
        # The number of expired cloud desktops in the desktop group.
        self.has_expired_eds_count_for_group = has_expired_eds_count_for_group  # type: int
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace.
        self.office_site_name = office_site_name  # type: str
        # The status of the workspace.
        self.office_site_status = office_site_status  # type: str
        # The region ID of the workspace.
        self.region_id = region_id  # type: str
        # The number of running cloud desktops in the workspace.
        self.running_eds_count = running_eds_count  # type: int
        # The number of running cloud desktops in the desktop group.
        self.running_eds_count_for_group = running_eds_count_for_group  # type: int
        # The total number of cloud desktops in the workspace.
        self.total_eds_count = total_eds_count  # type: int
        # The total number of cloud desktops in the desktop group.
        self.total_eds_count_for_group = total_eds_count_for_group  # type: int
        # The virtual private cloud (VPC) type of the workspace.
        self.vpc_type = vpc_type  # type: str
        # The number of cloud desktops that are about to expire in the workspace.
        self.will_expired_eds_count = will_expired_eds_count  # type: int
        # The number of cloud desktops that are about to expire in the desktop group.
        self.will_expired_eds_count_for_group = will_expired_eds_count_for_group  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.has_expired_eds_count is not None:
            result['HasExpiredEdsCount'] = self.has_expired_eds_count
        if self.has_expired_eds_count_for_group is not None:
            result['HasExpiredEdsCountForGroup'] = self.has_expired_eds_count_for_group
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.office_site_status is not None:
            result['OfficeSiteStatus'] = self.office_site_status
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.running_eds_count is not None:
            result['RunningEdsCount'] = self.running_eds_count
        if self.running_eds_count_for_group is not None:
            result['RunningEdsCountForGroup'] = self.running_eds_count_for_group
        if self.total_eds_count is not None:
            result['TotalEdsCount'] = self.total_eds_count
        if self.total_eds_count_for_group is not None:
            result['TotalEdsCountForGroup'] = self.total_eds_count_for_group
        if self.vpc_type is not None:
            result['VpcType'] = self.vpc_type
        if self.will_expired_eds_count is not None:
            result['WillExpiredEdsCount'] = self.will_expired_eds_count
        if self.will_expired_eds_count_for_group is not None:
            result['WillExpiredEdsCountForGroup'] = self.will_expired_eds_count_for_group
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('HasExpiredEdsCount') is not None:
            self.has_expired_eds_count = m.get('HasExpiredEdsCount')
        if m.get('HasExpiredEdsCountForGroup') is not None:
            self.has_expired_eds_count_for_group = m.get('HasExpiredEdsCountForGroup')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('OfficeSiteStatus') is not None:
            self.office_site_status = m.get('OfficeSiteStatus')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RunningEdsCount') is not None:
            self.running_eds_count = m.get('RunningEdsCount')
        if m.get('RunningEdsCountForGroup') is not None:
            self.running_eds_count_for_group = m.get('RunningEdsCountForGroup')
        if m.get('TotalEdsCount') is not None:
            self.total_eds_count = m.get('TotalEdsCount')
        if m.get('TotalEdsCountForGroup') is not None:
            self.total_eds_count_for_group = m.get('TotalEdsCountForGroup')
        if m.get('VpcType') is not None:
            self.vpc_type = m.get('VpcType')
        if m.get('WillExpiredEdsCount') is not None:
            self.will_expired_eds_count = m.get('WillExpiredEdsCount')
        if m.get('WillExpiredEdsCountForGroup') is not None:
            self.will_expired_eds_count_for_group = m.get('WillExpiredEdsCountForGroup')
        return self


class ListOfficeSiteOverviewResponseBody(TeaModel):
    def __init__(self, next_token=None, office_site_overview_results=None, request_id=None):
        # The token that is used to start the next query. If this parameter is empty, all results are returned.
        self.next_token = next_token  # type: str
        # Details of the workspaces.
        self.office_site_overview_results = office_site_overview_results  # type: list[ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.office_site_overview_results:
            for k in self.office_site_overview_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListOfficeSiteOverviewResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['OfficeSiteOverviewResults'] = []
        if self.office_site_overview_results is not None:
            for k in self.office_site_overview_results:
                result['OfficeSiteOverviewResults'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.office_site_overview_results = []
        if m.get('OfficeSiteOverviewResults') is not None:
            for k in m.get('OfficeSiteOverviewResults'):
                temp_model = ListOfficeSiteOverviewResponseBodyOfficeSiteOverviewResults()
                self.office_site_overview_results.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListOfficeSiteOverviewResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListOfficeSiteOverviewResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListOfficeSiteOverviewResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOfficeSiteOverviewResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListOfficeSiteUsersRequest(TeaModel):
    def __init__(self, filter=None, max_results=None, next_token=None, oupath=None, office_site_id=None,
                 region_id=None):
        # The character string for fuzzy search.
        self.filter = filter  # type: str
        # The number of entries to return on each page.
        # 
        # Maximum value: 100
        # 
        # Default value: 10
        self.max_results = max_results  # type: int
        # The token that specifies the start point of the next query.
        self.next_token = next_token  # type: str
        # The organizational unit (OU) in the specified AD domain.
        self.oupath = oupath  # type: str
        # The ID of the workspace. Only workspaces of the enterprise AD account type are supported.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOfficeSiteUsersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.oupath is not None:
            result['OUPath'] = self.oupath
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OUPath') is not None:
            self.oupath = m.get('OUPath')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListOfficeSiteUsersResponseBodyUsers(TeaModel):
    def __init__(self, display_name=None, end_user=None):
        # The display name of the AD user.
        self.display_name = display_name  # type: str
        # The username of the AD user.
        self.end_user = end_user  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListOfficeSiteUsersResponseBodyUsers, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_name is not None:
            result['DisplayName'] = self.display_name
        if self.end_user is not None:
            result['EndUser'] = self.end_user
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayName') is not None:
            self.display_name = m.get('DisplayName')
        if m.get('EndUser') is not None:
            self.end_user = m.get('EndUser')
        return self


class ListOfficeSiteUsersResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, users=None):
        # The ID of the request.
        self.next_token = next_token  # type: str
        # The usernames of AD users.
        # 
        # This parameter is empty if the AD users include only Administrator and Guest.
        self.request_id = request_id  # type: str
        # The usernames of AD users.
        self.users = users  # type: list[ListOfficeSiteUsersResponseBodyUsers]

    def validate(self):
        if self.users:
            for k in self.users:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListOfficeSiteUsersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['Users'] = []
        if self.users is not None:
            for k in self.users:
                result['Users'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.users = []
        if m.get('Users') is not None:
            for k in m.get('Users'):
                temp_model = ListOfficeSiteUsersResponseBodyUsers()
                self.users.append(temp_model.from_map(k))
        return self


class ListOfficeSiteUsersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListOfficeSiteUsersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListOfficeSiteUsersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListOfficeSiteUsersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListTagResourcesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag N. Valid values of N: 1 to 20.
        self.key = key  # type: str
        # The value of tag N. Valid values of N: 1 to 20.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTagResourcesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class ListTagResourcesRequest(TeaModel):
    def __init__(self, max_results=None, next_token=None, region_id=None, resource_id=None, resource_type=None,
                 tag=None):
        # The number of entries to return on each page.
        self.max_results = max_results  # type: int
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The region ID of the resource.
        self.region_id = region_id  # type: str
        # The ID of the resource, which is the ID of the cloud desktop. Valid values of N: 1 to 50.
        self.resource_id = resource_id  # type: list[str]
        # The type of the resource. Set the value to ALIYUN::GWS::INSTANCE.
        self.resource_type = resource_type  # type: str
        # The list of the resource.
        self.tag = tag  # type: list[ListTagResourcesRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = ListTagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponseBodyTagResources(TeaModel):
    def __init__(self, resource_id=None, resource_type=None, tag_key=None, tag_value=None):
        # The ID of the resource, which is the ID of the cloud desktop.
        self.resource_id = resource_id  # type: str
        # The type of the resource. Valid value: ALIYUN::GWS::INSTANCE.
        self.resource_type = resource_type  # type: str
        # The tag key of the resource.
        self.tag_key = tag_key  # type: str
        # The tag value of the resource.
        self.tag_value = tag_value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListTagResourcesResponseBodyTagResources, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        if self.tag_value is not None:
            result['TagValue'] = self.tag_value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        if m.get('TagValue') is not None:
            self.tag_value = m.get('TagValue')
        return self


class ListTagResourcesResponseBody(TeaModel):
    def __init__(self, next_token=None, request_id=None, tag_resources=None):
        # The token used to start the next query.
        self.next_token = next_token  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The resources and their tags.
        self.tag_resources = tag_resources  # type: list[ListTagResourcesResponseBodyTagResources]

    def validate(self):
        if self.tag_resources:
            for k in self.tag_resources:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListTagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['TagResources'] = []
        if self.tag_resources is not None:
            for k in self.tag_resources:
                result['TagResources'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.tag_resources = []
        if m.get('TagResources') is not None:
            for k in m.get('TagResources'):
                temp_model = ListTagResourcesResponseBodyTagResources()
                self.tag_resources.append(temp_model.from_map(k))
        return self


class ListTagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListTagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListTagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListTagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ListUserAdOrganizationUnitsRequest(TeaModel):
    def __init__(self, filter=None, max_results=None, next_token=None, office_site_id=None, region_id=None):
        # The string that you enter for fuzzy search.
        self.filter = filter  # type: str
        # The maximum number of entries to return on each page. Valid values: 1 to 500. Default value: 500.
        self.max_results = max_results  # type: int
        # The token that determines the start point of the query. Set the value to the NextToken value that is returned from the last call.
        self.next_token = next_token  # type: str
        # The ID of the AD workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserAdOrganizationUnitsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.filter is not None:
            result['Filter'] = self.filter
        if self.max_results is not None:
            result['MaxResults'] = self.max_results
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Filter') is not None:
            self.filter = m.get('Filter')
        if m.get('MaxResults') is not None:
            self.max_results = m.get('MaxResults')
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ListUserAdOrganizationUnitsResponseBodyOUNames(TeaModel):
    def __init__(self, display_ouname=None, ouname=None, office_site_id=None):
        # The display name of the OU.
        self.display_ouname = display_ouname  # type: str
        # The name of the OU of the AD domain controller.
        self.ouname = ouname  # type: str
        # The ID of the AD workspace.
        self.office_site_id = office_site_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ListUserAdOrganizationUnitsResponseBodyOUNames, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_ouname is not None:
            result['DisplayOUName'] = self.display_ouname
        if self.ouname is not None:
            result['OUName'] = self.ouname
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayOUName') is not None:
            self.display_ouname = m.get('DisplayOUName')
        if m.get('OUName') is not None:
            self.ouname = m.get('OUName')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        return self


class ListUserAdOrganizationUnitsResponseBody(TeaModel):
    def __init__(self, next_token=None, ounames=None, request_id=None):
        # The token that is used to start the next query.
        self.next_token = next_token  # type: str
        # The names of the OUs in the AD domain.
        self.ounames = ounames  # type: list[ListUserAdOrganizationUnitsResponseBodyOUNames]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.ounames:
            for k in self.ounames:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ListUserAdOrganizationUnitsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.next_token is not None:
            result['NextToken'] = self.next_token
        result['OUNames'] = []
        if self.ounames is not None:
            for k in self.ounames:
                result['OUNames'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('NextToken') is not None:
            self.next_token = m.get('NextToken')
        self.ounames = []
        if m.get('OUNames') is not None:
            for k in m.get('OUNames'):
                temp_model = ListUserAdOrganizationUnitsResponseBodyOUNames()
                self.ounames.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ListUserAdOrganizationUnitsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ListUserAdOrganizationUnitsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ListUserAdOrganizationUnitsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ListUserAdOrganizationUnitsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class LockVirtualMFADeviceRequest(TeaModel):
    def __init__(self, region_id=None, serial_number=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The serial number of the virtual MFA device, which is a unique identifier.
        # 
        # You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound by AD users.
        self.serial_number = serial_number  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(LockVirtualMFADeviceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        return self


class LockVirtualMFADeviceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(LockVirtualMFADeviceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class LockVirtualMFADeviceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: LockVirtualMFADeviceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(LockVirtualMFADeviceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = LockVirtualMFADeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MigrateDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None, target_office_site_id=None):
        self.desktop_id = desktop_id  # type: list[str]
        self.region_id = region_id  # type: str
        self.target_office_site_id = target_office_site_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrateDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.target_office_site_id is not None:
            result['TargetOfficeSiteId'] = self.target_office_site_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TargetOfficeSiteId') is not None:
            self.target_office_site_id = m.get('TargetOfficeSiteId')
        return self


class MigrateDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MigrateDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class MigrateDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: MigrateDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(MigrateDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MigrateDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyADConnectorDirectoryRequest(TeaModel):
    def __init__(self, ad_hostname=None, directory_id=None, directory_name=None, dns_address=None, domain_name=None,
                 domain_password=None, domain_user_name=None, mfa_enabled=None, ouname=None, region_id=None,
                 sub_domain_dns_address=None, sub_domain_name=None):
        # The hostname of the domain controller. The hostname must comply with the naming conventions for hostnames in Windows.
        self.ad_hostname = ad_hostname  # type: str
        # The ID of the directory.
        self.directory_id = directory_id  # type: str
        # The name of the AD directory.
        self.directory_name = directory_name  # type: str
        # Details of the DNS addresses that correspond to the enterprise AD system. You can specify only one IP address. Make sure that the specified IP address can be accessed over the network that the selected vSwitch uses.
        self.dns_address = dns_address  # type: list[str]
        # The domain name. The domain name must be 2 to 255 characters in length and consist of two parts. Example: example.com. You can register each domain name only once.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator. The username can be up to 64 characters in length.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator. The username can be up to 64 characters in length.
        self.domain_user_name = domain_user_name  # type: str
        # Specifies whether to enable multi-factor authentication (MFA). Default value: false.\
        # If you enable MFA, all AD users in the AD directory must enter the password and the dynamic verification code generated by the MFA device when they connect to a cloud desktop.
        # 
        # > The first time you log on to the Alibaba Cloud Workspace client as an end user, you must bind an MFA device.
        self.mfa_enabled = mfa_enabled  # type: bool
        # The name of the organizational unit (OU) in the AD domain. You can call the [ListUserAdOrganizationUnits](~~311259~~) operation to obtain the name of the OU.
        self.ouname = ouname  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The DNS addresses of the enterprise AD subdomain. If you specify SubDomainName but not this parameter, the DNS address of the subdomain is considered to be the same as that of the parent domain.
        self.sub_domain_dns_address = sub_domain_dns_address  # type: list[str]
        # The domain name of the enterprise AD subdomain.
        self.sub_domain_name = sub_domain_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyADConnectorDirectoryRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.directory_name is not None:
            result['DirectoryName'] = self.directory_name
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.ouname is not None:
            result['OUName'] = self.ouname
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sub_domain_dns_address is not None:
            result['SubDomainDnsAddress'] = self.sub_domain_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('DirectoryName') is not None:
            self.directory_name = m.get('DirectoryName')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('OUName') is not None:
            self.ouname = m.get('OUName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubDomainDnsAddress') is not None:
            self.sub_domain_dns_address = m.get('SubDomainDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        return self


class ModifyADConnectorDirectoryResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyADConnectorDirectoryResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyADConnectorDirectoryResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyADConnectorDirectoryResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyADConnectorDirectoryResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyADConnectorDirectoryResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyADConnectorOfficeSiteRequest(TeaModel):
    def __init__(self, ad_hostname=None, dns_address=None, domain_name=None, domain_password=None,
                 domain_user_name=None, mfa_enabled=None, ouname=None, office_site_id=None, office_site_name=None, region_id=None,
                 sub_domain_dns_address=None, sub_domain_name=None):
        # The hostname of the domain controller. The hostname must comply with the naming conventions for hostnames in Windows.
        self.ad_hostname = ad_hostname  # type: str
        # Details of the IP addresses of the Domain Name System (DNS) servers that correspond to the enterprise AD system. You can specify only one IP address.
        self.dns_address = dns_address  # type: list[str]
        # The domain name of the enterprise AD system. You can register each domain name only once.
        self.domain_name = domain_name  # type: str
        # The password of the domain administrator. The username can be up to 64 characters in length.
        self.domain_password = domain_password  # type: str
        # The username of the domain administrator. The username can be up to 64 characters in length.
        # 
        # > Specify the value of the sAMAccountName parameter instead of the value of the userPrincipalName parameter as the username.
        self.domain_user_name = domain_user_name  # type: str
        # Specifies whether to enable multi-factor authentication (MFA).\
        # Default value: false.
        self.mfa_enabled = mfa_enabled  # type: bool
        # The name of the organizational unit (OU) in the AD domain. You can call the [ListUserAdOrganizationUnits](~~311259~~) operation to obtain the name of the OU.
        self.ouname = ouname  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace. The name must be 2 to 255 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
        self.office_site_name = office_site_name  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The DNS address of the enterprise AD subdomain. You can specify only one IP address. If you specify a value for the `SubDomainName` parameter but you do not specify a value for this parameter, the DNS address of the subdomain is the same as the DNS address of the parent domain.
        self.sub_domain_dns_address = sub_domain_dns_address  # type: list[str]
        # The domain name of the enterprise AD subdomain.
        self.sub_domain_name = sub_domain_name  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyADConnectorOfficeSiteRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.ad_hostname is not None:
            result['AdHostname'] = self.ad_hostname
        if self.dns_address is not None:
            result['DnsAddress'] = self.dns_address
        if self.domain_name is not None:
            result['DomainName'] = self.domain_name
        if self.domain_password is not None:
            result['DomainPassword'] = self.domain_password
        if self.domain_user_name is not None:
            result['DomainUserName'] = self.domain_user_name
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.ouname is not None:
            result['OUName'] = self.ouname
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.sub_domain_dns_address is not None:
            result['SubDomainDnsAddress'] = self.sub_domain_dns_address
        if self.sub_domain_name is not None:
            result['SubDomainName'] = self.sub_domain_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AdHostname') is not None:
            self.ad_hostname = m.get('AdHostname')
        if m.get('DnsAddress') is not None:
            self.dns_address = m.get('DnsAddress')
        if m.get('DomainName') is not None:
            self.domain_name = m.get('DomainName')
        if m.get('DomainPassword') is not None:
            self.domain_password = m.get('DomainPassword')
        if m.get('DomainUserName') is not None:
            self.domain_user_name = m.get('DomainUserName')
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('OUName') is not None:
            self.ouname = m.get('OUName')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SubDomainDnsAddress') is not None:
            self.sub_domain_dns_address = m.get('SubDomainDnsAddress')
        if m.get('SubDomainName') is not None:
            self.sub_domain_name = m.get('SubDomainName')
        return self


class ModifyADConnectorOfficeSiteResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyADConnectorOfficeSiteResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyADConnectorOfficeSiteResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyADConnectorOfficeSiteResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyADConnectorOfficeSiteResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyADConnectorOfficeSiteResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyAutoSnapshotPolicyRequest(TeaModel):
    def __init__(self, cron_expression=None, policy_id=None, policy_name=None, region_id=None, retention_days=None):
        # The CRON expression.
        self.cron_expression = cron_expression  # type: str
        # The ID of the automatic snapshot policy.
        self.policy_id = policy_id  # type: str
        # The name of the automatic snapshot policy. The name must be 2 to 128 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with [http:// or https://. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). Default value: null.](http://https://。、（:）、（\_）（-）。：。)
        self.policy_name = policy_name  # type: str
        # The ID of the region where the automatic snapshot policy is created.
        self.region_id = region_id  # type: str
        # The retention period of automatic snapshots. Unit: days. Valid values:
        # 
        # *   1 (default): The automatic snapshots are permanently retained.
        # *   1 to 65536: The automatic snapshots are retained for the specified number of days.
        self.retention_days = retention_days  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_expression is not None:
            result['CronExpression'] = self.cron_expression
        if self.policy_id is not None:
            result['PolicyId'] = self.policy_id
        if self.policy_name is not None:
            result['PolicyName'] = self.policy_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.retention_days is not None:
            result['RetentionDays'] = self.retention_days
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronExpression') is not None:
            self.cron_expression = m.get('CronExpression')
        if m.get('PolicyId') is not None:
            self.policy_id = m.get('PolicyId')
        if m.get('PolicyName') is not None:
            self.policy_name = m.get('PolicyName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RetentionDays') is not None:
            self.retention_days = m.get('RetentionDays')
        return self


class ModifyAutoSnapshotPolicyResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The request ID.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyAutoSnapshotPolicyResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyAutoSnapshotPolicyResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyAutoSnapshotPolicyResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyAutoSnapshotPolicyResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyBundleRequest(TeaModel):
    def __init__(self, bundle_id=None, bundle_name=None, description=None, image_id=None, language=None,
                 region_id=None):
        # The ID of the desktop template.
        self.bundle_id = bundle_id  # type: str
        # The name of the new desktop template.
        self.bundle_name = bundle_name  # type: str
        # The description of the new desktop template.
        self.description = description  # type: str
        # The ID of the new image. The new image must meet the following requirements:
        # 
        # *   The new image must be in the Available state.
        # *   The operating system of the new image must be the same as that of the original image.
        # *   The required disk size for the new image cannot be greater than that for the original image.
        # *   The GPU type of the new image must be the same as that of the original image.
        self.image_id = image_id  # type: str
        # The language of the operating system. This parameter is available only for system images. Valid values:
        # 
        # *   zh-CN: Simplified Chinese
        # *   zh-HK: Traditional Chinese (Hong Kong)
        # *   en-US: English
        self.language = language  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBundleRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.bundle_id is not None:
            result['BundleId'] = self.bundle_id
        if self.bundle_name is not None:
            result['BundleName'] = self.bundle_name
        if self.description is not None:
            result['Description'] = self.description
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.language is not None:
            result['Language'] = self.language
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BundleId') is not None:
            self.bundle_id = m.get('BundleId')
        if m.get('BundleName') is not None:
            self.bundle_name = m.get('BundleName')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('Language') is not None:
            self.language = m.get('Language')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyBundleResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyBundleResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyBundleResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyBundleResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyBundleResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyBundleResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCdsFileRequest(TeaModel):
    def __init__(self, cds_id=None, conflict_policy=None, end_user_id=None, file_id=None, file_name=None,
                 region_id=None):
        self.cds_id = cds_id  # type: str
        self.conflict_policy = conflict_policy  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.file_name = file_name  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.conflict_policy is not None:
            result['ConflictPolicy'] = self.conflict_policy
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.file_name is not None:
            result['FileName'] = self.file_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('ConflictPolicy') is not None:
            self.conflict_policy = m.get('ConflictPolicy')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('FileName') is not None:
            self.file_name = m.get('FileName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyCdsFileResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: str
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCdsFileShareLinkRequest(TeaModel):
    def __init__(self, cds_id=None, description=None, disable_download=None, disable_preview=None,
                 disable_save=None, download_count=None, download_limit=None, expiration=None, preview_count=None,
                 preview_limit=None, report_count=None, save_count=None, save_limit=None, share_id=None, share_name=None,
                 share_pwd=None, status=None, video_preview_count=None):
        self.cds_id = cds_id  # type: str
        self.description = description  # type: str
        self.disable_download = disable_download  # type: bool
        self.disable_preview = disable_preview  # type: bool
        self.disable_save = disable_save  # type: bool
        self.download_count = download_count  # type: long
        self.download_limit = download_limit  # type: long
        self.expiration = expiration  # type: str
        self.preview_count = preview_count  # type: long
        self.preview_limit = preview_limit  # type: long
        self.report_count = report_count  # type: long
        self.save_count = save_count  # type: long
        self.save_limit = save_limit  # type: long
        self.share_id = share_id  # type: str
        self.share_name = share_name  # type: str
        self.share_pwd = share_pwd  # type: str
        self.status = status  # type: str
        self.video_preview_count = video_preview_count  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCdsFileShareLinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.description is not None:
            result['Description'] = self.description
        if self.disable_download is not None:
            result['DisableDownload'] = self.disable_download
        if self.disable_preview is not None:
            result['DisablePreview'] = self.disable_preview
        if self.disable_save is not None:
            result['DisableSave'] = self.disable_save
        if self.download_count is not None:
            result['DownloadCount'] = self.download_count
        if self.download_limit is not None:
            result['DownloadLimit'] = self.download_limit
        if self.expiration is not None:
            result['Expiration'] = self.expiration
        if self.preview_count is not None:
            result['PreviewCount'] = self.preview_count
        if self.preview_limit is not None:
            result['PreviewLimit'] = self.preview_limit
        if self.report_count is not None:
            result['ReportCount'] = self.report_count
        if self.save_count is not None:
            result['SaveCount'] = self.save_count
        if self.save_limit is not None:
            result['SaveLimit'] = self.save_limit
        if self.share_id is not None:
            result['ShareId'] = self.share_id
        if self.share_name is not None:
            result['ShareName'] = self.share_name
        if self.share_pwd is not None:
            result['SharePwd'] = self.share_pwd
        if self.status is not None:
            result['Status'] = self.status
        if self.video_preview_count is not None:
            result['VideoPreviewCount'] = self.video_preview_count
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DisableDownload') is not None:
            self.disable_download = m.get('DisableDownload')
        if m.get('DisablePreview') is not None:
            self.disable_preview = m.get('DisablePreview')
        if m.get('DisableSave') is not None:
            self.disable_save = m.get('DisableSave')
        if m.get('DownloadCount') is not None:
            self.download_count = m.get('DownloadCount')
        if m.get('DownloadLimit') is not None:
            self.download_limit = m.get('DownloadLimit')
        if m.get('Expiration') is not None:
            self.expiration = m.get('Expiration')
        if m.get('PreviewCount') is not None:
            self.preview_count = m.get('PreviewCount')
        if m.get('PreviewLimit') is not None:
            self.preview_limit = m.get('PreviewLimit')
        if m.get('ReportCount') is not None:
            self.report_count = m.get('ReportCount')
        if m.get('SaveCount') is not None:
            self.save_count = m.get('SaveCount')
        if m.get('SaveLimit') is not None:
            self.save_limit = m.get('SaveLimit')
        if m.get('ShareId') is not None:
            self.share_id = m.get('ShareId')
        if m.get('ShareName') is not None:
            self.share_name = m.get('ShareName')
        if m.get('SharePwd') is not None:
            self.share_pwd = m.get('SharePwd')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('VideoPreviewCount') is not None:
            self.video_preview_count = m.get('VideoPreviewCount')
        return self


class ModifyCdsFileShareLinkResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        self.code = code  # type: str
        self.data = data  # type: CdsFileShareLinkModel
        self.message = message  # type: str
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.data:
            self.data.validate()

    def to_map(self):
        _map = super(ModifyCdsFileShareLinkResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data.to_map()
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            temp_model = CdsFileShareLinkModel()
            self.data = temp_model.from_map(m['Data'])
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyCdsFileShareLinkResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCdsFileShareLinkResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCdsFileShareLinkResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCdsFileShareLinkResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCloudDriveGroupsRequest(TeaModel):
    def __init__(self, cds_id=None, group_id=None, region_id=None, status=None, total_size=None):
        # The ID of the cloud disk in Cloud Drive Service.
        self.cds_id = cds_id  # type: str
        # The IDs of the teams.
        self.group_id = group_id  # type: list[str]
        # The region ID.
        self.region_id = region_id  # type: str
        # The status of the team space. Valid values:
        # 
        # *   enabled
        # *   disabled
        # 
        # Default value: enabled.
        self.status = status  # type: str
        # The total capacity of the team space.
        self.total_size = total_size  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCloudDriveGroupsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.group_id is not None:
            result['GroupId'] = self.group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.total_size is not None:
            result['TotalSize'] = self.total_size
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('GroupId') is not None:
            self.group_id = m.get('GroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TotalSize') is not None:
            self.total_size = m.get('TotalSize')
        return self


class ModifyCloudDriveGroupsResponseBody(TeaModel):
    def __init__(self, code=None, data=None, message=None, request_id=None, success=None):
        # The returned results. A value of success indicates that the operation is successful. If the operation failed, an error message is returned.
        self.code = code  # type: str
        # The data information.
        self.data = data  # type: str
        # The message returned.
        self.message = message  # type: str
        # The request ID.
        self.request_id = request_id  # type: str
        # Indicates whether the request was successful. Valid values: true and false.
        self.success = success  # type: bool

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCloudDriveGroupsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.data is not None:
            result['Data'] = self.data
        if self.message is not None:
            result['Message'] = self.message
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Data') is not None:
            self.data = m.get('Data')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class ModifyCloudDriveGroupsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCloudDriveGroupsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCloudDriveGroupsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCloudDriveGroupsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCloudDrivePermissionRequest(TeaModel):
    def __init__(self, cds_id=None, download_end_user_ids=None, download_upload_end_user_ids=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.download_end_user_ids = download_end_user_ids  # type: list[str]
        self.download_upload_end_user_ids = download_upload_end_user_ids  # type: list[str]
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCloudDrivePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.download_end_user_ids is not None:
            result['DownloadEndUserIds'] = self.download_end_user_ids
        if self.download_upload_end_user_ids is not None:
            result['DownloadUploadEndUserIds'] = self.download_upload_end_user_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('DownloadEndUserIds') is not None:
            self.download_end_user_ids = m.get('DownloadEndUserIds')
        if m.get('DownloadUploadEndUserIds') is not None:
            self.download_upload_end_user_ids = m.get('DownloadUploadEndUserIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyCloudDrivePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCloudDrivePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCloudDrivePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCloudDrivePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCloudDrivePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCloudDrivePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyCustomizedListHeadersRequestHeaders(TeaModel):
    def __init__(self, display_type=None, header_key=None):
        # The display type of the header.
        self.display_type = display_type  # type: str
        # The key of the header.
        self.header_key = header_key  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCustomizedListHeadersRequestHeaders, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.display_type is not None:
            result['DisplayType'] = self.display_type
        if self.header_key is not None:
            result['HeaderKey'] = self.header_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DisplayType') is not None:
            self.display_type = m.get('DisplayType')
        if m.get('HeaderKey') is not None:
            self.header_key = m.get('HeaderKey')
        return self


class ModifyCustomizedListHeadersRequest(TeaModel):
    def __init__(self, headers=None, list_type=None, region_id=None):
        # The list of headers.
        self.headers = headers  # type: list[ModifyCustomizedListHeadersRequestHeaders]
        # The type of the list.
        self.list_type = list_type  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        if self.headers:
            for k in self.headers:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyCustomizedListHeadersRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['Headers'] = []
        if self.headers is not None:
            for k in self.headers:
                result['Headers'].append(k.to_map() if k else None)
        if self.list_type is not None:
            result['ListType'] = self.list_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.headers = []
        if m.get('Headers') is not None:
            for k in m.get('Headers'):
                temp_model = ModifyCustomizedListHeadersRequestHeaders()
                self.headers.append(temp_model.from_map(k))
        if m.get('ListType') is not None:
            self.list_type = m.get('ListType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyCustomizedListHeadersResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyCustomizedListHeadersResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyCustomizedListHeadersResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyCustomizedListHeadersResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyCustomizedListHeadersResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyCustomizedListHeadersResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopChargeTypeRequest(TeaModel):
    def __init__(self, auto_pay=None, charge_type=None, desktop_id=None, period=None, period_unit=None,
                 promotion_id=None, region_id=None):
        # Specifies whether to enable automatic payment if you specify subscription as the new billing method for the cloud desktop.
        self.auto_pay = auto_pay  # type: bool
        # The new billing method that you want to use for the desktop group.
        self.charge_type = charge_type  # type: str
        # The IDs of the cloud desktops. You can specify 1 to 20 IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The subscription duration if you specify subscription as the new billing method for the cloud desktop. The unit of the value is specified by the `PeriodUnit` parameter. This parameter takes effect only when the `ChargeType` parameter is set to `PrePaid`.
        # 
        # *   If the `PeriodUnit` parameter is set to `Week`, the valid value of the Period parameter is 1.
        # *   If the `PeriodUnit` parameter is set to `Month`, the valid values of the Period parameter are 1, 2, 3, and 6.
        # *   If the `PeriodUnit` parameter is set to `Year`, the valid values of the Period parameter are 1, 2, 3, 4, and 5.
        self.period = period  # type: int
        # The unit of the subscription duration if you specify subscription as the new billing method for the cloud desktop.
        self.period_unit = period_unit  # type: str
        # The ID of the sales promotion.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopChargeTypeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.charge_type is not None:
            result['ChargeType'] = self.charge_type
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('ChargeType') is not None:
            self.charge_type = m.get('ChargeType')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyDesktopChargeTypeResponseBody(TeaModel):
    def __init__(self, desktop_id=None, order_id=None, request_id=None):
        # The IDs of the desktop groups. If multiple cloud desktops are created at a time, multiple cloud desktop IDs are returned.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopChargeTypeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopChargeTypeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopChargeTypeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopChargeTypeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopChargeTypeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopGroupRequest(TeaModel):
    def __init__(self, allow_auto_setup=None, allow_buffer_count=None, bind_amount=None, buy_desktops_count=None,
                 classify=None, comments=None, connect_duration=None, desktop_group_id=None, desktop_group_name=None,
                 disable_session_config=None, file_system_id=None, idle_disconnect_duration=None, image_id=None, keep_duration=None,
                 load_policy=None, max_desktops_count=None, min_desktops_count=None, own_bundle_id=None, policy_group_id=None,
                 policy_group_ids=None, profile_follow_switch=None, ratio_threshold=None, region_id=None, reset_type=None,
                 scale_strategy_id=None, stop_duration=None):
        # Specifies whether to automatically create cloud desktops in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values:
        # 
        # *   0: does not create cloud desktops in the desktop group.
        # *   1: creates cloud desktops in the desktop group.
        self.allow_auto_setup = allow_auto_setup  # type: int
        # Specifies whether to reserve cloud desktops if you set the billing method to pay-as-you-go. If you set the ChargeType parameter to PostPaid, this parameter is required. Valid values: 0: does not reserve cloud desktops. N: reserves N cloud desktops. Valid values of N: 1 to the value of the MaxDesktopsCount parameter.
        self.allow_buffer_count = allow_buffer_count  # type: int
        # The maximum number of sessions per cloud desktop in the multi-session desktop group.
        self.bind_amount = bind_amount  # type: long
        # The number of cloud desktops to purchase. Valid values: 0 to 200.
        self.buy_desktops_count = buy_desktops_count  # type: int
        # The classification of the cloud desktop pool.
        self.classify = classify  # type: str
        # The remarks on the desktop group.
        self.comments = comments  # type: str
        # The maximum duration of the session. Unit: milliseconds.
        self.connect_duration = connect_duration  # type: long
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The name of the desktop group.
        self.desktop_group_name = desktop_group_name  # type: str
        # Specifies whether to disable session management.
        self.disable_session_config = disable_session_config  # type: bool
        # The ID of the Apsara File Storage NAS (NAS) file system.
        self.file_system_id = file_system_id  # type: str
        # The maximum duration of the idle session. Unit: milliseconds.
        self.idle_disconnect_duration = idle_disconnect_duration  # type: long
        # The IDs of the images.
        self.image_id = image_id  # type: str
        # The retention period of cloud desktops in the desktop group after end users disconnect from the desktops. Unit: ms.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy of the multi-session desktop group.
        self.load_policy = load_policy  # type: long
        # The maximum number of cloud desktops that the desktop group can contain. Valid values: 0 to 200.
        self.max_desktops_count = max_desktops_count  # type: int
        # The minimum number of cloud desktops that must be contained in the desktop group if you set the billing method to subscription. If you set the ChargeType parameter to PrePaid, this parameter is required. Valid values: 0 to the value of MaxDesktopsCount. Default value: 1.
        self.min_desktops_count = min_desktops_count  # type: int
        # The ID of the cloud desktop template.
        self.own_bundle_id = own_bundle_id  # type: str
        # The ID of the security policy.
        self.policy_group_id = policy_group_id  # type: str
        # The IDs of policy groups.
        self.policy_group_ids = policy_group_ids  # type: list[str]
        # Specifies whether to enable data roaming.
        self.profile_follow_switch = profile_follow_switch  # type: bool
        # The session usage threshold for the multi-session desktop group that has an auto scaling policy in effect.
        self.ratio_threshold = ratio_threshold  # type: float
        # The region ID of the desktop group.
        self.region_id = region_id  # type: str
        # Specifies which type of disk to reset for cloud desktops in the desktop group.
        self.reset_type = reset_type  # type: long
        # The ID of the scaling policy group.
        # 
        # >  This parameter is unavailable.
        self.scale_strategy_id = scale_strategy_id  # type: str
        # The duration before an idle cloud desktop is stopped. Unit: milliseconds.
        self.stop_duration = stop_duration  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.allow_auto_setup is not None:
            result['AllowAutoSetup'] = self.allow_auto_setup
        if self.allow_buffer_count is not None:
            result['AllowBufferCount'] = self.allow_buffer_count
        if self.bind_amount is not None:
            result['BindAmount'] = self.bind_amount
        if self.buy_desktops_count is not None:
            result['BuyDesktopsCount'] = self.buy_desktops_count
        if self.classify is not None:
            result['Classify'] = self.classify
        if self.comments is not None:
            result['Comments'] = self.comments
        if self.connect_duration is not None:
            result['ConnectDuration'] = self.connect_duration
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_name is not None:
            result['DesktopGroupName'] = self.desktop_group_name
        if self.disable_session_config is not None:
            result['DisableSessionConfig'] = self.disable_session_config
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.idle_disconnect_duration is not None:
            result['IdleDisconnectDuration'] = self.idle_disconnect_duration
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_desktops_count is not None:
            result['MaxDesktopsCount'] = self.max_desktops_count
        if self.min_desktops_count is not None:
            result['MinDesktopsCount'] = self.min_desktops_count
        if self.own_bundle_id is not None:
            result['OwnBundleId'] = self.own_bundle_id
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_ids is not None:
            result['PolicyGroupIds'] = self.policy_group_ids
        if self.profile_follow_switch is not None:
            result['ProfileFollowSwitch'] = self.profile_follow_switch
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        if self.scale_strategy_id is not None:
            result['ScaleStrategyId'] = self.scale_strategy_id
        if self.stop_duration is not None:
            result['StopDuration'] = self.stop_duration
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AllowAutoSetup') is not None:
            self.allow_auto_setup = m.get('AllowAutoSetup')
        if m.get('AllowBufferCount') is not None:
            self.allow_buffer_count = m.get('AllowBufferCount')
        if m.get('BindAmount') is not None:
            self.bind_amount = m.get('BindAmount')
        if m.get('BuyDesktopsCount') is not None:
            self.buy_desktops_count = m.get('BuyDesktopsCount')
        if m.get('Classify') is not None:
            self.classify = m.get('Classify')
        if m.get('Comments') is not None:
            self.comments = m.get('Comments')
        if m.get('ConnectDuration') is not None:
            self.connect_duration = m.get('ConnectDuration')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupName') is not None:
            self.desktop_group_name = m.get('DesktopGroupName')
        if m.get('DisableSessionConfig') is not None:
            self.disable_session_config = m.get('DisableSessionConfig')
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('IdleDisconnectDuration') is not None:
            self.idle_disconnect_duration = m.get('IdleDisconnectDuration')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxDesktopsCount') is not None:
            self.max_desktops_count = m.get('MaxDesktopsCount')
        if m.get('MinDesktopsCount') is not None:
            self.min_desktops_count = m.get('MinDesktopsCount')
        if m.get('OwnBundleId') is not None:
            self.own_bundle_id = m.get('OwnBundleId')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupIds') is not None:
            self.policy_group_ids = m.get('PolicyGroupIds')
        if m.get('ProfileFollowSwitch') is not None:
            self.profile_follow_switch = m.get('ProfileFollowSwitch')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        if m.get('ScaleStrategyId') is not None:
            self.scale_strategy_id = m.get('ScaleStrategyId')
        if m.get('StopDuration') is not None:
            self.stop_duration = m.get('StopDuration')
        return self


class ModifyDesktopGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopHostNameRequest(TeaModel):
    def __init__(self, desktop_id=None, new_host_name=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The new hostname of the cloud desktop. The hostname must meet the following requirements:
        # 
        # *   Must be 2 to 15 characters in length.
        # *   Contain letters, digits, and hyphens (-). It cannot start or end with a hyphen (-), contain consecutive hyphens (-), or contain only digits.
        self.new_host_name = new_host_name  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopHostNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.new_host_name is not None:
            result['NewHostName'] = self.new_host_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('NewHostName') is not None:
            self.new_host_name = m.get('NewHostName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyDesktopHostNameResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopHostNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopHostNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopHostNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopHostNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopHostNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopNameRequest(TeaModel):
    def __init__(self, desktop_id=None, new_desktop_name=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The new name of the cloud desktop. The name of the cloud desktop must meet the following requirements:
        # 
        # *   The name must be 1 to 64 characters in length.
        # *   The name must start with a letter and cannot start with `http://` or `https://`.
        # *   The name can contain letters, digits, colons (:), underscores (\_), periods (.), and hyphens (-).
        self.new_desktop_name = new_desktop_name  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopNameRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.new_desktop_name is not None:
            result['NewDesktopName'] = self.new_desktop_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('NewDesktopName') is not None:
            self.new_desktop_name = m.get('NewDesktopName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyDesktopNameResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopNameResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopNameResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopNameResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopNameResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopNameResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopSpecRequest(TeaModel):
    def __init__(self, auto_pay=None, desktop_id=None, desktop_type=None, promotion_id=None, region_id=None,
                 root_disk_size_gib=None, user_disk_performance_level=None, user_disk_size_gib=None):
        # Specifies whether to automatically complete the payment. Valid values:
        # 
        # *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
        # *   `false`: does not automatically complete the payment. In this case, an order is generated, but no payment is made. You can log on to the EDS console and complete the payment based on the order ID on the **Orders** page.
        # 
        # Default value: `true`.
        self.auto_pay = auto_pay  # type: bool
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The new cloud desktop type. You can call the [DescribeDesktopTypes](~~188882~~) operation to query the IDs of supported cloud desktop types.
        self.desktop_type = desktop_type  # type: str
        # The ID of the sales promotion.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The size of the new system disk. Unit: GiB. Valid values: 80 to 500 GiB. The value must be a multiple of 10.
        self.root_disk_size_gib = root_disk_size_gib  # type: int
        # The performance level (PL) of the data disk. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        # 
        # Default value: PL0.
        self.user_disk_performance_level = user_disk_performance_level  # type: str
        # The size of the new data disk. Unit: GiB.
        # 
        # *   The data disk size of a non-Graphics cloud desktop can be within the range of 20 to 1,020 GiB. The value must be a multiple of 10.
        # *   The data disk size of the Graphics cloud desktop can be within the range of 40 to 1,020 GiB. The value must be a multiple of 10.
        self.user_disk_size_gib = user_disk_size_gib  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.desktop_type is not None:
            result['DesktopType'] = self.desktop_type
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.root_disk_size_gib is not None:
            result['RootDiskSizeGib'] = self.root_disk_size_gib
        if self.user_disk_performance_level is not None:
            result['UserDiskPerformanceLevel'] = self.user_disk_performance_level
        if self.user_disk_size_gib is not None:
            result['UserDiskSizeGib'] = self.user_disk_size_gib
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('DesktopType') is not None:
            self.desktop_type = m.get('DesktopType')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RootDiskSizeGib') is not None:
            self.root_disk_size_gib = m.get('RootDiskSizeGib')
        if m.get('UserDiskPerformanceLevel') is not None:
            self.user_disk_performance_level = m.get('UserDiskPerformanceLevel')
        if m.get('UserDiskSizeGib') is not None:
            self.user_disk_size_gib = m.get('UserDiskSizeGib')
        return self


class ModifyDesktopSpecResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDesktopsPolicyGroupRequest(TeaModel):
    def __init__(self, desktop_id=None, policy_group_id=None, policy_group_ids=None, region_id=None):
        # The IDs of the cloud desktops. You can specify one or more cloud desktops. The value is a JSON array.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the policy.
        self.policy_group_id = policy_group_id  # type: str
        # The IDs of the policies.
        self.policy_group_ids = policy_group_ids  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopsPolicyGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.policy_group_ids is not None:
            result['PolicyGroupIds'] = self.policy_group_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PolicyGroupIds') is not None:
            self.policy_group_ids = m.get('PolicyGroupIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyDesktopsPolicyGroupResponseBodyModifyResults(TeaModel):
    def __init__(self, code=None, desktop_id=None, message=None):
        # The result of the modification. A value of success indicates that the policy is modified. If the policy failed to be modified, an error message is returned.
        self.code = code  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The error message. This parameter is not returned if the value of Code is `success`.
        self.message = message  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDesktopsPolicyGroupResponseBodyModifyResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class ModifyDesktopsPolicyGroupResponseBody(TeaModel):
    def __init__(self, modify_results=None, request_id=None):
        # The modification results.
        self.modify_results = modify_results  # type: list[ModifyDesktopsPolicyGroupResponseBodyModifyResults]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.modify_results:
            for k in self.modify_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyDesktopsPolicyGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['ModifyResults'] = []
        if self.modify_results is not None:
            for k in self.modify_results:
                result['ModifyResults'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.modify_results = []
        if m.get('ModifyResults') is not None:
            for k in m.get('ModifyResults'):
                temp_model = ModifyDesktopsPolicyGroupResponseBodyModifyResults()
                self.modify_results.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDesktopsPolicyGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDesktopsPolicyGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDesktopsPolicyGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDesktopsPolicyGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyDiskSpecRequest(TeaModel):
    def __init__(self, auto_pay=None, desktop_id=None, promotion_id=None, region_id=None,
                 root_disk_performance_level=None, user_disk_performance_level=None):
        # Specifies whether to automatically complete the payment. Valid values:
        # 
        # *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
        # *   `false`: does not complete the payment. In this case, an order is generated, but no payment is made. You can log on to the Elastic Desktop Service (EDS) console and complete the payment based on the order ID on the **Orders** page.
        # 
        # Default value: `true`.
        self.auto_pay = auto_pay  # type: bool
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the sales promotion activity. You can call the DescribePrice operation to obtain the IDs of matching sales promotion activities.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The performance level (PL) of the system disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the system disk. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        self.root_disk_performance_level = root_disk_performance_level  # type: str
        # The PL of the data disk. If the cloud desktop type is Graphics or High Frequency, you can set the PL of the data disk. Valid values:
        # 
        # *   PL0
        # *   PL1
        # *   PL2
        # *   PL3
        self.user_disk_performance_level = user_disk_performance_level  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskSpecRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.root_disk_performance_level is not None:
            result['RootDiskPerformanceLevel'] = self.root_disk_performance_level
        if self.user_disk_performance_level is not None:
            result['UserDiskPerformanceLevel'] = self.user_disk_performance_level
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RootDiskPerformanceLevel') is not None:
            self.root_disk_performance_level = m.get('RootDiskPerformanceLevel')
        if m.get('UserDiskPerformanceLevel') is not None:
            self.user_disk_performance_level = m.get('UserDiskPerformanceLevel')
        return self


class ModifyDiskSpecResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order. You can obtain the order ID on the [Orders](https://usercenter2-intl.aliyun.com/order/list?pageIndex=1\&pageSize=20\&spm=5176.12818093.top-nav.ditem-ord.36f016d0OQFmJa) page in Alibaba Cloud User Center.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyDiskSpecResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyDiskSpecResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyDiskSpecResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyDiskSpecResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyDiskSpecResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyEntitlementRequest(TeaModel):
    def __init__(self, desktop_id=None, end_user_id=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The usernames of users. You can specify up to 100 usernames.
        self.end_user_id = end_user_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEntitlementRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyEntitlementResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyEntitlementResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyEntitlementResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyEntitlementResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyEntitlementResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyEntitlementResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImageAttributeRequest(TeaModel):
    def __init__(self, description=None, image_id=None, name=None, region_id=None):
        # The description of the image.
        self.description = description  # type: str
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The name of the image.
        self.name = name  # type: str
        # The region ID of the image.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.name is not None:
            result['Name'] = self.name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyImageAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImageAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImageAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyImageAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyImageAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImageAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyImagePermissionRequest(TeaModel):
    def __init__(self, add_account=None, image_id=None, region_id=None, remove_account=None):
        # The IDs of the recipient Alibaba Cloud accounts. You can share an image with up to 50 Alibaba Cloud accounts.
        self.add_account = add_account  # type: list[long]
        # The ID of the image that you want to share.
        self.image_id = image_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The IDs of the recipient Alibaba Cloud accounts from which you want to unshare the image. You can unshare an image from up to 50 Alibaba Cloud accounts.
        self.remove_account = remove_account  # type: list[long]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImagePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.add_account is not None:
            result['AddAccount'] = self.add_account
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remove_account is not None:
            result['RemoveAccount'] = self.remove_account
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AddAccount') is not None:
            self.add_account = m.get('AddAccount')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoveAccount') is not None:
            self.remove_account = m.get('RemoveAccount')
        return self


class ModifyImagePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyImagePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyImagePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyImagePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyImagePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyImagePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNASDefaultMountTargetRequest(TeaModel):
    def __init__(self, file_system_id=None, mount_target_domain=None, region_id=None):
        # The ID of the NAS file system.
        self.file_system_id = file_system_id  # type: str
        # The domain name of the mount target.
        self.mount_target_domain = mount_target_domain  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNASDefaultMountTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.mount_target_domain is not None:
            result['MountTargetDomain'] = self.mount_target_domain
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('MountTargetDomain') is not None:
            self.mount_target_domain = m.get('MountTargetDomain')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyNASDefaultMountTargetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNASDefaultMountTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNASDefaultMountTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyNASDefaultMountTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyNASDefaultMountTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNASDefaultMountTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNetworkPackageBandwidthRequest(TeaModel):
    def __init__(self, auto_pay=None, bandwidth=None, network_package_id=None, promotion_id=None, region_id=None):
        # Specifies whether to enable automatic payment. Valid values:
        # 
        # *   `true`: enables automatic payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
        # *   `false`: disables automatic payment. In this case, an order is generated, but no payment is complete. You can log on to the Elastic Desktop Service (EDS) console and complete the payment based on the order ID on the **Orders** page.
        # 
        # Default value: `true`.
        self.auto_pay = auto_pay  # type: bool
        # The bandwidth of the Internet access package. Unit: Mbit/s. Valid values: 10 to 1000.
        self.bandwidth = bandwidth  # type: int
        # The ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the promotion. You can call the `GetResourcePrice` operation to obtain the ID of the promotion.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkPackageBandwidthRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.bandwidth is not None:
            result['Bandwidth'] = self.bandwidth
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('Bandwidth') is not None:
            self.bandwidth = m.get('Bandwidth')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyNetworkPackageBandwidthResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkPackageBandwidthResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNetworkPackageBandwidthResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyNetworkPackageBandwidthResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyNetworkPackageBandwidthResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNetworkPackageBandwidthResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyNetworkPackageEnabledRequest(TeaModel):
    def __init__(self, enabled=None, network_package_id=None, region_id=None):
        # Specifies whether to restore or disable Internet access for the cloud desktop.
        # 
        # *   true: restores Internet access.
        # *   false: disables Internet access.
        self.enabled = enabled  # type: bool
        # The ID of the Internet access package.
        self.network_package_id = network_package_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkPackageEnabledRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enabled is not None:
            result['Enabled'] = self.enabled
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Enabled') is not None:
            self.enabled = m.get('Enabled')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyNetworkPackageEnabledResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyNetworkPackageEnabledResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyNetworkPackageEnabledResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyNetworkPackageEnabledResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyNetworkPackageEnabledResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyNetworkPackageEnabledResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOfficeSiteAttributeRequest(TeaModel):
    def __init__(self, desktop_access_type=None, enable_admin_access=None, need_verify_login_risk=None,
                 need_verify_zero_device=None, office_site_id=None, office_site_name=None, region_id=None):
        # The method that you want to use to connect the Alibaba Cloud Workspace client to cloud desktops. Valid values:
        # 
        # *   INTERNET: connects the client to cloud desktops only over the Internet.
        # *   VPC: connects the client to cloud desktops only over a VPC.
        # *   Any: connects clients to cloud desktops over the Internet or a VPC. You can select a connection method based on your business requirements when you connect to a cloud desktop from the client.
        # 
        # Default value: INTERNET.
        # 
        # > VPC connections are established by using Alibaba Cloud PrivateLink. You can use PrivateLink for free. When you set this parameter to VPC or Any, PrivateLink is automatically activated.
        self.desktop_access_type = desktop_access_type  # type: str
        self.enable_admin_access = enable_admin_access  # type: bool
        # This parameter is only applicable to a workspace of the convenience account type, which indicates whether to require two-factor verification when you log on to the client. If two-factor verification is enabled, the system checks whether security risks exist within the logon account when a convenience user logs on to the client. If risks are detected, the system sends a verification code to the email address that is associated with the account. Then, the convenience user can log on to the client only after the verification code is correctly entered.
        self.need_verify_login_risk = need_verify_login_risk  # type: bool
        # This parameter is only applicable to a workspace of the convenience account type, which indicates whether to require device verification when you log on to the client. For a workspace of the enterprise Active Directory (AD) account type, the value of this parameter is empty.
        self.need_verify_zero_device = need_verify_zero_device  # type: bool
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The name of the workspace. We recommend that you specify a name that is easy to identify. The name must be 2 to 255 characters in length. The name can contain letters, digits, colons (:), underscores (\_), and hyphens (-). It must start with a letter but cannot start with http:// or https://.
        self.office_site_name = office_site_name  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteAttributeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_access_type is not None:
            result['DesktopAccessType'] = self.desktop_access_type
        if self.enable_admin_access is not None:
            result['EnableAdminAccess'] = self.enable_admin_access
        if self.need_verify_login_risk is not None:
            result['NeedVerifyLoginRisk'] = self.need_verify_login_risk
        if self.need_verify_zero_device is not None:
            result['NeedVerifyZeroDevice'] = self.need_verify_zero_device
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.office_site_name is not None:
            result['OfficeSiteName'] = self.office_site_name
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopAccessType') is not None:
            self.desktop_access_type = m.get('DesktopAccessType')
        if m.get('EnableAdminAccess') is not None:
            self.enable_admin_access = m.get('EnableAdminAccess')
        if m.get('NeedVerifyLoginRisk') is not None:
            self.need_verify_login_risk = m.get('NeedVerifyLoginRisk')
        if m.get('NeedVerifyZeroDevice') is not None:
            self.need_verify_zero_device = m.get('NeedVerifyZeroDevice')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('OfficeSiteName') is not None:
            self.office_site_name = m.get('OfficeSiteName')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyOfficeSiteAttributeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteAttributeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOfficeSiteAttributeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOfficeSiteAttributeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOfficeSiteAttributeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOfficeSiteAttributeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOfficeSiteCrossDesktopAccessRequest(TeaModel):
    def __init__(self, enable_cross_desktop_access=None, office_site_id=None, region_id=None):
        # Specifies whether to enable cross-desktop access for a workspace.
        # 
        # *   true: enables cross-desktop access.
        # *   false: disables cross-desktop access.
        self.enable_cross_desktop_access = enable_cross_desktop_access  # type: bool
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteCrossDesktopAccessRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_cross_desktop_access is not None:
            result['EnableCrossDesktopAccess'] = self.enable_cross_desktop_access
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableCrossDesktopAccess') is not None:
            self.enable_cross_desktop_access = m.get('EnableCrossDesktopAccess')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyOfficeSiteCrossDesktopAccessResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteCrossDesktopAccessResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOfficeSiteCrossDesktopAccessResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOfficeSiteCrossDesktopAccessResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOfficeSiteCrossDesktopAccessResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOfficeSiteCrossDesktopAccessResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOfficeSiteMfaEnabledRequest(TeaModel):
    def __init__(self, mfa_enabled=None, office_site_id=None, region_id=None):
        # Specifies whether to enable MFA. Valid values:
        # 
        # *   true: enables MFA
        # *   false: disables MFA
        self.mfa_enabled = mfa_enabled  # type: bool
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteMfaEnabledRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.mfa_enabled is not None:
            result['MfaEnabled'] = self.mfa_enabled
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('MfaEnabled') is not None:
            self.mfa_enabled = m.get('MfaEnabled')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyOfficeSiteMfaEnabledResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOfficeSiteMfaEnabledResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOfficeSiteMfaEnabledResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOfficeSiteMfaEnabledResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOfficeSiteMfaEnabledResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOfficeSiteMfaEnabledResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyOperateVulRequestVulInfo(TeaModel):
    def __init__(self, desktop_id=None, name=None, tag=None):
        # The ID of cloud desktop in which the vulnerability is detected.
        self.desktop_id = desktop_id  # type: str
        # The name of the vulnerability.
        self.name = name  # type: str
        # The tag that you want to add to the vulnerability.
        self.tag = tag  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOperateVulRequestVulInfo, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.name is not None:
            result['Name'] = self.name
        if self.tag is not None:
            result['Tag'] = self.tag
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('Tag') is not None:
            self.tag = m.get('Tag')
        return self


class ModifyOperateVulRequest(TeaModel):
    def __init__(self, operate_type=None, reason=None, region_id=None, type=None, vul_info=None):
        # The action that you want to perform on the vulnerability. Valid values:
        # 
        # *   vul_fix: fixes the vulnerability. The system fixes the vulnerability.
        # *   vul_verify: verifies whether the vulnerability is fixed. You must perform this action after the vulnerability is fixed, and the cloud desktop is restarted.
        # *   vul_ignore: ignores the vulnerability. After the vulnerability is ignored, the system provides no more prompts about the vulnerability.
        # *   vul_undo_ignore: cancels the ignore action on the vulnerability. After you cancel the ignore action on the vulnerability, the system provides prompts about the vulnerability again.
        self.operate_type = operate_type  # type: str
        # The reason why the vulnerability is ignored.\
        # This parameter is required only when `OperateType` is set to `vul_ignore`.
        self.reason = reason  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the vulnerability. Valid values:
        # 
        # *   cve: the Linux software vulnerability
        # *   sys: the Windows system vulnerability
        self.type = type  # type: str
        # Details of the vulnerabilities.
        self.vul_info = vul_info  # type: list[ModifyOperateVulRequestVulInfo]

    def validate(self):
        if self.vul_info:
            for k in self.vul_info:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyOperateVulRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        result['VulInfo'] = []
        if self.vul_info is not None:
            for k in self.vul_info:
                result['VulInfo'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        self.vul_info = []
        if m.get('VulInfo') is not None:
            for k in m.get('VulInfo'):
                temp_model = ModifyOperateVulRequestVulInfo()
                self.vul_info.append(temp_model.from_map(k))
        return self


class ModifyOperateVulResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyOperateVulResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyOperateVulResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyOperateVulResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyOperateVulResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyOperateVulResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyPolicyGroupRequestAuthorizeAccessPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestAuthorizeAccessPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None, ip_protocol=None, policy=None, port_range=None, priority=None,
                 type=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.policy = policy  # type: str
        self.port_range = port_range  # type: str
        self.priority = priority  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyPolicyGroupRequestClientType(TeaModel):
    def __init__(self, client_type=None, status=None):
        self.client_type = client_type  # type: str
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestClientType, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.client_type is not None:
            result['ClientType'] = self.client_type
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ClientType') is not None:
            self.client_type = m.get('ClientType')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class ModifyPolicyGroupRequestRevokeAccessPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestRevokeAccessPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        return self


class ModifyPolicyGroupRequestRevokeSecurityPolicyRule(TeaModel):
    def __init__(self, cidr_ip=None, description=None, ip_protocol=None, policy=None, port_range=None, priority=None,
                 type=None):
        self.cidr_ip = cidr_ip  # type: str
        self.description = description  # type: str
        self.ip_protocol = ip_protocol  # type: str
        self.policy = policy  # type: str
        self.port_range = port_range  # type: str
        self.priority = priority  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestRevokeSecurityPolicyRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_ip is not None:
            result['CidrIp'] = self.cidr_ip
        if self.description is not None:
            result['Description'] = self.description
        if self.ip_protocol is not None:
            result['IpProtocol'] = self.ip_protocol
        if self.policy is not None:
            result['Policy'] = self.policy
        if self.port_range is not None:
            result['PortRange'] = self.port_range
        if self.priority is not None:
            result['Priority'] = self.priority
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrIp') is not None:
            self.cidr_ip = m.get('CidrIp')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('IpProtocol') is not None:
            self.ip_protocol = m.get('IpProtocol')
        if m.get('Policy') is not None:
            self.policy = m.get('Policy')
        if m.get('PortRange') is not None:
            self.port_range = m.get('PortRange')
        if m.get('Priority') is not None:
            self.priority = m.get('Priority')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class ModifyPolicyGroupRequestUsbSupplyRedirectRule(TeaModel):
    def __init__(self, description=None, device_class=None, device_subclass=None, product_id=None,
                 usb_redirect_type=None, usb_rule_type=None, vendor_id=None):
        self.description = description  # type: str
        self.device_class = device_class  # type: str
        self.device_subclass = device_subclass  # type: str
        self.product_id = product_id  # type: str
        self.usb_redirect_type = usb_redirect_type  # type: long
        self.usb_rule_type = usb_rule_type  # type: long
        self.vendor_id = vendor_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupRequestUsbSupplyRedirectRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.description is not None:
            result['Description'] = self.description
        if self.device_class is not None:
            result['DeviceClass'] = self.device_class
        if self.device_subclass is not None:
            result['DeviceSubclass'] = self.device_subclass
        if self.product_id is not None:
            result['ProductId'] = self.product_id
        if self.usb_redirect_type is not None:
            result['UsbRedirectType'] = self.usb_redirect_type
        if self.usb_rule_type is not None:
            result['UsbRuleType'] = self.usb_rule_type
        if self.vendor_id is not None:
            result['VendorId'] = self.vendor_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('DeviceClass') is not None:
            self.device_class = m.get('DeviceClass')
        if m.get('DeviceSubclass') is not None:
            self.device_subclass = m.get('DeviceSubclass')
        if m.get('ProductId') is not None:
            self.product_id = m.get('ProductId')
        if m.get('UsbRedirectType') is not None:
            self.usb_redirect_type = m.get('UsbRedirectType')
        if m.get('UsbRuleType') is not None:
            self.usb_rule_type = m.get('UsbRuleType')
        if m.get('VendorId') is not None:
            self.vendor_id = m.get('VendorId')
        return self


class ModifyPolicyGroupRequest(TeaModel):
    def __init__(self, app_content_protection=None, authorize_access_policy_rule=None,
                 authorize_security_policy_rule=None, camera_redirect=None, client_type=None, clipboard=None, domain_list=None,
                 end_user_apply_admin_coordinate=None, end_user_group_coordinate=None, gpu_acceleration=None, html_5access=None,
                 html_5file_transfer=None, internet_communication_protocol=None, local_drive=None, name=None, net_redirect=None,
                 policy_group_id=None, preempt_login=None, preempt_login_user=None, printer_redirection=None, record_content=None,
                 record_content_expires=None, recording=None, recording_audio=None, recording_duration=None, recording_end_time=None,
                 recording_expires=None, recording_fps=None, recording_start_time=None, region_id=None, remote_coordinate=None,
                 revoke_access_policy_rule=None, revoke_security_policy_rule=None, scope=None, scope_value=None, usb_redirect=None,
                 usb_supply_redirect_rule=None, video_redirect=None, visual_quality=None, watermark=None, watermark_color=None,
                 watermark_degree=None, watermark_font_size=None, watermark_font_style=None, watermark_row_amount=None,
                 watermark_transparency=None, watermark_transparency_value=None, watermark_type=None):
        self.app_content_protection = app_content_protection  # type: str
        self.authorize_access_policy_rule = authorize_access_policy_rule  # type: list[ModifyPolicyGroupRequestAuthorizeAccessPolicyRule]
        self.authorize_security_policy_rule = authorize_security_policy_rule  # type: list[ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule]
        self.camera_redirect = camera_redirect  # type: str
        self.client_type = client_type  # type: list[ModifyPolicyGroupRequestClientType]
        self.clipboard = clipboard  # type: str
        self.domain_list = domain_list  # type: str
        self.end_user_apply_admin_coordinate = end_user_apply_admin_coordinate  # type: str
        self.end_user_group_coordinate = end_user_group_coordinate  # type: str
        self.gpu_acceleration = gpu_acceleration  # type: str
        self.html_5access = html_5access  # type: str
        self.html_5file_transfer = html_5file_transfer  # type: str
        self.internet_communication_protocol = internet_communication_protocol  # type: str
        self.local_drive = local_drive  # type: str
        self.name = name  # type: str
        self.net_redirect = net_redirect  # type: str
        self.policy_group_id = policy_group_id  # type: str
        self.preempt_login = preempt_login  # type: str
        self.preempt_login_user = preempt_login_user  # type: list[str]
        self.printer_redirection = printer_redirection  # type: str
        self.record_content = record_content  # type: str
        self.record_content_expires = record_content_expires  # type: long
        self.recording = recording  # type: str
        self.recording_audio = recording_audio  # type: str
        self.recording_duration = recording_duration  # type: int
        self.recording_end_time = recording_end_time  # type: str
        self.recording_expires = recording_expires  # type: long
        self.recording_fps = recording_fps  # type: long
        self.recording_start_time = recording_start_time  # type: str
        self.region_id = region_id  # type: str
        self.remote_coordinate = remote_coordinate  # type: str
        self.revoke_access_policy_rule = revoke_access_policy_rule  # type: list[ModifyPolicyGroupRequestRevokeAccessPolicyRule]
        self.revoke_security_policy_rule = revoke_security_policy_rule  # type: list[ModifyPolicyGroupRequestRevokeSecurityPolicyRule]
        self.scope = scope  # type: str
        self.scope_value = scope_value  # type: list[str]
        self.usb_redirect = usb_redirect  # type: str
        self.usb_supply_redirect_rule = usb_supply_redirect_rule  # type: list[ModifyPolicyGroupRequestUsbSupplyRedirectRule]
        self.video_redirect = video_redirect  # type: str
        self.visual_quality = visual_quality  # type: str
        self.watermark = watermark  # type: str
        self.watermark_color = watermark_color  # type: int
        self.watermark_degree = watermark_degree  # type: float
        self.watermark_font_size = watermark_font_size  # type: int
        self.watermark_font_style = watermark_font_style  # type: str
        self.watermark_row_amount = watermark_row_amount  # type: int
        self.watermark_transparency = watermark_transparency  # type: str
        self.watermark_transparency_value = watermark_transparency_value  # type: int
        self.watermark_type = watermark_type  # type: str

    def validate(self):
        if self.authorize_access_policy_rule:
            for k in self.authorize_access_policy_rule:
                if k:
                    k.validate()
        if self.authorize_security_policy_rule:
            for k in self.authorize_security_policy_rule:
                if k:
                    k.validate()
        if self.client_type:
            for k in self.client_type:
                if k:
                    k.validate()
        if self.revoke_access_policy_rule:
            for k in self.revoke_access_policy_rule:
                if k:
                    k.validate()
        if self.revoke_security_policy_rule:
            for k in self.revoke_security_policy_rule:
                if k:
                    k.validate()
        if self.usb_supply_redirect_rule:
            for k in self.usb_supply_redirect_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(ModifyPolicyGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.app_content_protection is not None:
            result['AppContentProtection'] = self.app_content_protection
        result['AuthorizeAccessPolicyRule'] = []
        if self.authorize_access_policy_rule is not None:
            for k in self.authorize_access_policy_rule:
                result['AuthorizeAccessPolicyRule'].append(k.to_map() if k else None)
        result['AuthorizeSecurityPolicyRule'] = []
        if self.authorize_security_policy_rule is not None:
            for k in self.authorize_security_policy_rule:
                result['AuthorizeSecurityPolicyRule'].append(k.to_map() if k else None)
        if self.camera_redirect is not None:
            result['CameraRedirect'] = self.camera_redirect
        result['ClientType'] = []
        if self.client_type is not None:
            for k in self.client_type:
                result['ClientType'].append(k.to_map() if k else None)
        if self.clipboard is not None:
            result['Clipboard'] = self.clipboard
        if self.domain_list is not None:
            result['DomainList'] = self.domain_list
        if self.end_user_apply_admin_coordinate is not None:
            result['EndUserApplyAdminCoordinate'] = self.end_user_apply_admin_coordinate
        if self.end_user_group_coordinate is not None:
            result['EndUserGroupCoordinate'] = self.end_user_group_coordinate
        if self.gpu_acceleration is not None:
            result['GpuAcceleration'] = self.gpu_acceleration
        if self.html_5access is not None:
            result['Html5Access'] = self.html_5access
        if self.html_5file_transfer is not None:
            result['Html5FileTransfer'] = self.html_5file_transfer
        if self.internet_communication_protocol is not None:
            result['InternetCommunicationProtocol'] = self.internet_communication_protocol
        if self.local_drive is not None:
            result['LocalDrive'] = self.local_drive
        if self.name is not None:
            result['Name'] = self.name
        if self.net_redirect is not None:
            result['NetRedirect'] = self.net_redirect
        if self.policy_group_id is not None:
            result['PolicyGroupId'] = self.policy_group_id
        if self.preempt_login is not None:
            result['PreemptLogin'] = self.preempt_login
        if self.preempt_login_user is not None:
            result['PreemptLoginUser'] = self.preempt_login_user
        if self.printer_redirection is not None:
            result['PrinterRedirection'] = self.printer_redirection
        if self.record_content is not None:
            result['RecordContent'] = self.record_content
        if self.record_content_expires is not None:
            result['RecordContentExpires'] = self.record_content_expires
        if self.recording is not None:
            result['Recording'] = self.recording
        if self.recording_audio is not None:
            result['RecordingAudio'] = self.recording_audio
        if self.recording_duration is not None:
            result['RecordingDuration'] = self.recording_duration
        if self.recording_end_time is not None:
            result['RecordingEndTime'] = self.recording_end_time
        if self.recording_expires is not None:
            result['RecordingExpires'] = self.recording_expires
        if self.recording_fps is not None:
            result['RecordingFps'] = self.recording_fps
        if self.recording_start_time is not None:
            result['RecordingStartTime'] = self.recording_start_time
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.remote_coordinate is not None:
            result['RemoteCoordinate'] = self.remote_coordinate
        result['RevokeAccessPolicyRule'] = []
        if self.revoke_access_policy_rule is not None:
            for k in self.revoke_access_policy_rule:
                result['RevokeAccessPolicyRule'].append(k.to_map() if k else None)
        result['RevokeSecurityPolicyRule'] = []
        if self.revoke_security_policy_rule is not None:
            for k in self.revoke_security_policy_rule:
                result['RevokeSecurityPolicyRule'].append(k.to_map() if k else None)
        if self.scope is not None:
            result['Scope'] = self.scope
        if self.scope_value is not None:
            result['ScopeValue'] = self.scope_value
        if self.usb_redirect is not None:
            result['UsbRedirect'] = self.usb_redirect
        result['UsbSupplyRedirectRule'] = []
        if self.usb_supply_redirect_rule is not None:
            for k in self.usb_supply_redirect_rule:
                result['UsbSupplyRedirectRule'].append(k.to_map() if k else None)
        if self.video_redirect is not None:
            result['VideoRedirect'] = self.video_redirect
        if self.visual_quality is not None:
            result['VisualQuality'] = self.visual_quality
        if self.watermark is not None:
            result['Watermark'] = self.watermark
        if self.watermark_color is not None:
            result['WatermarkColor'] = self.watermark_color
        if self.watermark_degree is not None:
            result['WatermarkDegree'] = self.watermark_degree
        if self.watermark_font_size is not None:
            result['WatermarkFontSize'] = self.watermark_font_size
        if self.watermark_font_style is not None:
            result['WatermarkFontStyle'] = self.watermark_font_style
        if self.watermark_row_amount is not None:
            result['WatermarkRowAmount'] = self.watermark_row_amount
        if self.watermark_transparency is not None:
            result['WatermarkTransparency'] = self.watermark_transparency
        if self.watermark_transparency_value is not None:
            result['WatermarkTransparencyValue'] = self.watermark_transparency_value
        if self.watermark_type is not None:
            result['WatermarkType'] = self.watermark_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AppContentProtection') is not None:
            self.app_content_protection = m.get('AppContentProtection')
        self.authorize_access_policy_rule = []
        if m.get('AuthorizeAccessPolicyRule') is not None:
            for k in m.get('AuthorizeAccessPolicyRule'):
                temp_model = ModifyPolicyGroupRequestAuthorizeAccessPolicyRule()
                self.authorize_access_policy_rule.append(temp_model.from_map(k))
        self.authorize_security_policy_rule = []
        if m.get('AuthorizeSecurityPolicyRule') is not None:
            for k in m.get('AuthorizeSecurityPolicyRule'):
                temp_model = ModifyPolicyGroupRequestAuthorizeSecurityPolicyRule()
                self.authorize_security_policy_rule.append(temp_model.from_map(k))
        if m.get('CameraRedirect') is not None:
            self.camera_redirect = m.get('CameraRedirect')
        self.client_type = []
        if m.get('ClientType') is not None:
            for k in m.get('ClientType'):
                temp_model = ModifyPolicyGroupRequestClientType()
                self.client_type.append(temp_model.from_map(k))
        if m.get('Clipboard') is not None:
            self.clipboard = m.get('Clipboard')
        if m.get('DomainList') is not None:
            self.domain_list = m.get('DomainList')
        if m.get('EndUserApplyAdminCoordinate') is not None:
            self.end_user_apply_admin_coordinate = m.get('EndUserApplyAdminCoordinate')
        if m.get('EndUserGroupCoordinate') is not None:
            self.end_user_group_coordinate = m.get('EndUserGroupCoordinate')
        if m.get('GpuAcceleration') is not None:
            self.gpu_acceleration = m.get('GpuAcceleration')
        if m.get('Html5Access') is not None:
            self.html_5access = m.get('Html5Access')
        if m.get('Html5FileTransfer') is not None:
            self.html_5file_transfer = m.get('Html5FileTransfer')
        if m.get('InternetCommunicationProtocol') is not None:
            self.internet_communication_protocol = m.get('InternetCommunicationProtocol')
        if m.get('LocalDrive') is not None:
            self.local_drive = m.get('LocalDrive')
        if m.get('Name') is not None:
            self.name = m.get('Name')
        if m.get('NetRedirect') is not None:
            self.net_redirect = m.get('NetRedirect')
        if m.get('PolicyGroupId') is not None:
            self.policy_group_id = m.get('PolicyGroupId')
        if m.get('PreemptLogin') is not None:
            self.preempt_login = m.get('PreemptLogin')
        if m.get('PreemptLoginUser') is not None:
            self.preempt_login_user = m.get('PreemptLoginUser')
        if m.get('PrinterRedirection') is not None:
            self.printer_redirection = m.get('PrinterRedirection')
        if m.get('RecordContent') is not None:
            self.record_content = m.get('RecordContent')
        if m.get('RecordContentExpires') is not None:
            self.record_content_expires = m.get('RecordContentExpires')
        if m.get('Recording') is not None:
            self.recording = m.get('Recording')
        if m.get('RecordingAudio') is not None:
            self.recording_audio = m.get('RecordingAudio')
        if m.get('RecordingDuration') is not None:
            self.recording_duration = m.get('RecordingDuration')
        if m.get('RecordingEndTime') is not None:
            self.recording_end_time = m.get('RecordingEndTime')
        if m.get('RecordingExpires') is not None:
            self.recording_expires = m.get('RecordingExpires')
        if m.get('RecordingFps') is not None:
            self.recording_fps = m.get('RecordingFps')
        if m.get('RecordingStartTime') is not None:
            self.recording_start_time = m.get('RecordingStartTime')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RemoteCoordinate') is not None:
            self.remote_coordinate = m.get('RemoteCoordinate')
        self.revoke_access_policy_rule = []
        if m.get('RevokeAccessPolicyRule') is not None:
            for k in m.get('RevokeAccessPolicyRule'):
                temp_model = ModifyPolicyGroupRequestRevokeAccessPolicyRule()
                self.revoke_access_policy_rule.append(temp_model.from_map(k))
        self.revoke_security_policy_rule = []
        if m.get('RevokeSecurityPolicyRule') is not None:
            for k in m.get('RevokeSecurityPolicyRule'):
                temp_model = ModifyPolicyGroupRequestRevokeSecurityPolicyRule()
                self.revoke_security_policy_rule.append(temp_model.from_map(k))
        if m.get('Scope') is not None:
            self.scope = m.get('Scope')
        if m.get('ScopeValue') is not None:
            self.scope_value = m.get('ScopeValue')
        if m.get('UsbRedirect') is not None:
            self.usb_redirect = m.get('UsbRedirect')
        self.usb_supply_redirect_rule = []
        if m.get('UsbSupplyRedirectRule') is not None:
            for k in m.get('UsbSupplyRedirectRule'):
                temp_model = ModifyPolicyGroupRequestUsbSupplyRedirectRule()
                self.usb_supply_redirect_rule.append(temp_model.from_map(k))
        if m.get('VideoRedirect') is not None:
            self.video_redirect = m.get('VideoRedirect')
        if m.get('VisualQuality') is not None:
            self.visual_quality = m.get('VisualQuality')
        if m.get('Watermark') is not None:
            self.watermark = m.get('Watermark')
        if m.get('WatermarkColor') is not None:
            self.watermark_color = m.get('WatermarkColor')
        if m.get('WatermarkDegree') is not None:
            self.watermark_degree = m.get('WatermarkDegree')
        if m.get('WatermarkFontSize') is not None:
            self.watermark_font_size = m.get('WatermarkFontSize')
        if m.get('WatermarkFontStyle') is not None:
            self.watermark_font_style = m.get('WatermarkFontStyle')
        if m.get('WatermarkRowAmount') is not None:
            self.watermark_row_amount = m.get('WatermarkRowAmount')
        if m.get('WatermarkTransparency') is not None:
            self.watermark_transparency = m.get('WatermarkTransparency')
        if m.get('WatermarkTransparencyValue') is not None:
            self.watermark_transparency_value = m.get('WatermarkTransparencyValue')
        if m.get('WatermarkType') is not None:
            self.watermark_type = m.get('WatermarkType')
        return self


class ModifyPolicyGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyPolicyGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyPolicyGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyPolicyGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyPolicyGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyPolicyGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUserEntitlementRequest(TeaModel):
    def __init__(self, authorize_desktop_id=None, end_user_id=None, region_id=None, revoke_desktop_id=None):
        # The IDs of cloud desktops which you want to grant permissions to regular users.
        self.authorize_desktop_id = authorize_desktop_id  # type: list[str]
        # The IDs of regular users.
        self.end_user_id = end_user_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The IDs of cloud desktops which you want to revoke permissions from regular users.
        self.revoke_desktop_id = revoke_desktop_id  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserEntitlementRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.authorize_desktop_id is not None:
            result['AuthorizeDesktopId'] = self.authorize_desktop_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.revoke_desktop_id is not None:
            result['RevokeDesktopId'] = self.revoke_desktop_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AuthorizeDesktopId') is not None:
            self.authorize_desktop_id = m.get('AuthorizeDesktopId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('RevokeDesktopId') is not None:
            self.revoke_desktop_id = m.get('RevokeDesktopId')
        return self


class ModifyUserEntitlementResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserEntitlementResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUserEntitlementResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyUserEntitlementResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyUserEntitlementResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUserEntitlementResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ModifyUserToDesktopGroupRequest(TeaModel):
    def __init__(self, desktop_group_id=None, new_end_user_ids=None, old_end_user_ids=None, region_id=None):
        # The ID of the desktop group that you want to assign to users.
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the regular users to whom you want to grant the permissions on the cloud desktop.
        self.new_end_user_ids = new_end_user_ids  # type: list[str]
        # The IDs of the original regular users who have the permissions on the cloud desktop.
        self.old_end_user_ids = old_end_user_ids  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserToDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.new_end_user_ids is not None:
            result['NewEndUserIds'] = self.new_end_user_ids
        if self.old_end_user_ids is not None:
            result['OldEndUserIds'] = self.old_end_user_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('NewEndUserIds') is not None:
            self.new_end_user_ids = m.get('NewEndUserIds')
        if m.get('OldEndUserIds') is not None:
            self.old_end_user_ids = m.get('OldEndUserIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ModifyUserToDesktopGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ModifyUserToDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ModifyUserToDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ModifyUserToDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ModifyUserToDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ModifyUserToDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class MoveCdsFileRequest(TeaModel):
    def __init__(self, cds_id=None, conflict_policy=None, end_user_id=None, file_id=None, parent_folder_id=None,
                 region_id=None):
        self.cds_id = cds_id  # type: str
        self.conflict_policy = conflict_policy  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.parent_folder_id = parent_folder_id  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MoveCdsFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.conflict_policy is not None:
            result['ConflictPolicy'] = self.conflict_policy
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.parent_folder_id is not None:
            result['ParentFolderId'] = self.parent_folder_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('ConflictPolicy') is not None:
            self.conflict_policy = m.get('ConflictPolicy')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('ParentFolderId') is not None:
            self.parent_folder_id = m.get('ParentFolderId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class MoveCdsFileResponseBodyMoveCdsFileModel(TeaModel):
    def __init__(self, async_task_id=None, exist=None, file_id=None):
        self.async_task_id = async_task_id  # type: str
        self.exist = exist  # type: bool
        self.file_id = file_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(MoveCdsFileResponseBodyMoveCdsFileModel, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.async_task_id is not None:
            result['AsyncTaskId'] = self.async_task_id
        if self.exist is not None:
            result['Exist'] = self.exist
        if self.file_id is not None:
            result['FileId'] = self.file_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AsyncTaskId') is not None:
            self.async_task_id = m.get('AsyncTaskId')
        if m.get('Exist') is not None:
            self.exist = m.get('Exist')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        return self


class MoveCdsFileResponseBody(TeaModel):
    def __init__(self, code=None, message=None, move_cds_file_model=None, request_id=None, success=None):
        self.code = code  # type: str
        self.message = message  # type: str
        self.move_cds_file_model = move_cds_file_model  # type: MoveCdsFileResponseBodyMoveCdsFileModel
        self.request_id = request_id  # type: str
        self.success = success  # type: bool

    def validate(self):
        if self.move_cds_file_model:
            self.move_cds_file_model.validate()

    def to_map(self):
        _map = super(MoveCdsFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.message is not None:
            result['Message'] = self.message
        if self.move_cds_file_model is not None:
            result['MoveCdsFileModel'] = self.move_cds_file_model.to_map()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.success is not None:
            result['Success'] = self.success
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        if m.get('MoveCdsFileModel') is not None:
            temp_model = MoveCdsFileResponseBodyMoveCdsFileModel()
            self.move_cds_file_model = temp_model.from_map(m['MoveCdsFileModel'])
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('Success') is not None:
            self.success = m.get('Success')
        return self


class MoveCdsFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: MoveCdsFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(MoveCdsFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = MoveCdsFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class OperateVulsRequest(TeaModel):
    def __init__(self, desktop_id=None, operate_type=None, precondition=None, reason=None, region_id=None, type=None,
                 vul_name=None):
        # The IDs of the cloud desktops.
        self.desktop_id = desktop_id  # type: list[str]
        # The action that you want to perform on the vulnerability. Valid values:
        # 
        # *   vul_fix: fixes the vulnerability.
        # *   vul_verify: verifies whether the vulnerability is fixed. You must perform this action after the vulnerability is fixed and the cloud desktop is restarted.
        # *   vul_ignore: ignores the vulnerability. After the vulnerability is ignored, the system provides no more prompts about the vulnerability.
        # *   vul_undo_ignore: cancels the ignore action on the vulnerability. After you cancel the ignore action on the vulnerability, the system provides prompts about the vulnerability again.
        self.operate_type = operate_type  # type: str
        # Specifies whether to record the previous state of the vulnerability. Valid values:
        # 
        # *   0: records the previous state of the vulnerability.
        # *   1: does not record the previous state of the vulnerability.
        self.precondition = precondition  # type: int
        # The reason why the vulnerability is ignored.\
        # This parameter is required only when `OperateType` is set to `vul_ignore`.
        self.reason = reason  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the detected vulnerability. Valid values:
        # 
        # *   cve: the Linux software vulnerability
        # *   sys: the Windows system vulnerability
        self.type = type  # type: str
        # The names of the vulnerabilities.
        self.vul_name = vul_name  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVulsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.operate_type is not None:
            result['OperateType'] = self.operate_type
        if self.precondition is not None:
            result['Precondition'] = self.precondition
        if self.reason is not None:
            result['Reason'] = self.reason
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.type is not None:
            result['Type'] = self.type
        if self.vul_name is not None:
            result['VulName'] = self.vul_name
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('OperateType') is not None:
            self.operate_type = m.get('OperateType')
        if m.get('Precondition') is not None:
            self.precondition = m.get('Precondition')
        if m.get('Reason') is not None:
            self.reason = m.get('Reason')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        if m.get('VulName') is not None:
            self.vul_name = m.get('VulName')
        return self


class OperateVulsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(OperateVulsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class OperateVulsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: OperateVulsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(OperateVulsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = OperateVulsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebootDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None):
        # The IDs of the cloud desktops. You can specify 1 to 100 cloud desktop IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RebootDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebootDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebootDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RebootDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RebootDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebootDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RebuildDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, image_id=None, region_id=None):
        # The IDs of the cloud desktops. You can specify 1 to 20 cloud desktop IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the new image.
        self.image_id = image_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebuildDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RebuildDesktopsResponseBodyRebuildResults(TeaModel):
    def __init__(self, code=None, desktop_id=None, message=None):
        # The recreation result of the cloud desktop by changing the image. A value of success indicates that the image of the cloud desktop is changed. If the image of the cloud desktop failed to be changed, an error message is returned.
        self.code = code  # type: str
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The error message. This parameter is not returned if the value of Code is success.
        self.message = message  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RebuildDesktopsResponseBodyRebuildResults, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.code is not None:
            result['Code'] = self.code
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.message is not None:
            result['Message'] = self.message
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Code') is not None:
            self.code = m.get('Code')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Message') is not None:
            self.message = m.get('Message')
        return self


class RebuildDesktopsResponseBody(TeaModel):
    def __init__(self, rebuild_results=None, request_id=None):
        # The recreation results of cloud desktops by changing images.
        self.rebuild_results = rebuild_results  # type: list[RebuildDesktopsResponseBodyRebuildResults]
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        if self.rebuild_results:
            for k in self.rebuild_results:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RebuildDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        result['RebuildResults'] = []
        if self.rebuild_results is not None:
            for k in self.rebuild_results:
                result['RebuildResults'].append(k.to_map() if k else None)
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        self.rebuild_results = []
        if m.get('RebuildResults') is not None:
            for k in m.get('RebuildResults'):
                temp_model = RebuildDesktopsResponseBodyRebuildResults()
                self.rebuild_results.append(temp_model.from_map(k))
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RebuildDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RebuildDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RebuildDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RebuildDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveFilePermissionRequestMemberListCdsIdentity(TeaModel):
    def __init__(self, id=None, type=None):
        self.id = id  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveFilePermissionRequestMemberListCdsIdentity, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.id is not None:
            result['Id'] = self.id
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Id') is not None:
            self.id = m.get('Id')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RemoveFilePermissionRequestMemberList(TeaModel):
    def __init__(self, cds_identity=None, role_id=None):
        self.cds_identity = cds_identity  # type: RemoveFilePermissionRequestMemberListCdsIdentity
        self.role_id = role_id  # type: str

    def validate(self):
        if self.cds_identity:
            self.cds_identity.validate()

    def to_map(self):
        _map = super(RemoveFilePermissionRequestMemberList, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_identity is not None:
            result['CdsIdentity'] = self.cds_identity.to_map()
        if self.role_id is not None:
            result['RoleId'] = self.role_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsIdentity') is not None:
            temp_model = RemoveFilePermissionRequestMemberListCdsIdentity()
            self.cds_identity = temp_model.from_map(m['CdsIdentity'])
        if m.get('RoleId') is not None:
            self.role_id = m.get('RoleId')
        return self


class RemoveFilePermissionRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, member_list=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.member_list = member_list  # type: list[RemoveFilePermissionRequestMemberList]
        self.region_id = region_id  # type: str

    def validate(self):
        if self.member_list:
            for k in self.member_list:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(RemoveFilePermissionRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        result['MemberList'] = []
        if self.member_list is not None:
            for k in self.member_list:
                result['MemberList'].append(k.to_map() if k else None)
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        self.member_list = []
        if m.get('MemberList') is not None:
            for k in m.get('MemberList'):
                temp_model = RemoveFilePermissionRequestMemberList()
                self.member_list.append(temp_model.from_map(k))
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RemoveFilePermissionShrinkRequest(TeaModel):
    def __init__(self, cds_id=None, end_user_id=None, file_id=None, member_list_shrink=None, region_id=None):
        self.cds_id = cds_id  # type: str
        self.end_user_id = end_user_id  # type: str
        self.file_id = file_id  # type: str
        self.member_list_shrink = member_list_shrink  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveFilePermissionShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cds_id is not None:
            result['CdsId'] = self.cds_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.file_id is not None:
            result['FileId'] = self.file_id
        if self.member_list_shrink is not None:
            result['MemberList'] = self.member_list_shrink
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CdsId') is not None:
            self.cds_id = m.get('CdsId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('FileId') is not None:
            self.file_id = m.get('FileId')
        if m.get('MemberList') is not None:
            self.member_list_shrink = m.get('MemberList')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RemoveFilePermissionResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveFilePermissionResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveFilePermissionResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveFilePermissionResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveFilePermissionResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveFilePermissionResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RemoveUserFromDesktopGroupRequest(TeaModel):
    def __init__(self, desktop_group_id=None, desktop_group_ids=None, end_user_ids=None, region_id=None):
        # The ID of the desktop group on which the permissions you want to revoke from the authorized user.
        self.desktop_group_id = desktop_group_id  # type: str
        # Details about the IDs of the desktop groups.
        self.desktop_group_ids = desktop_group_ids  # type: list[str]
        # Details about the authorized users from which you want to revoke permissions on the desktop group.
        self.end_user_ids = end_user_ids  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveUserFromDesktopGroupRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_group_ids is not None:
            result['DesktopGroupIds'] = self.desktop_group_ids
        if self.end_user_ids is not None:
            result['EndUserIds'] = self.end_user_ids
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopGroupIds') is not None:
            self.desktop_group_ids = m.get('DesktopGroupIds')
        if m.get('EndUserIds') is not None:
            self.end_user_ids = m.get('EndUserIds')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RemoveUserFromDesktopGroupResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RemoveUserFromDesktopGroupResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RemoveUserFromDesktopGroupResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RemoveUserFromDesktopGroupResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RemoveUserFromDesktopGroupResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RemoveUserFromDesktopGroupResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewDesktopsRequest(TeaModel):
    def __init__(self, auto_pay=None, desktop_id=None, period=None, period_unit=None, promotion_id=None,
                 region_id=None):
        # Specifies whether to enable automatic payment. Valid values:
        # 
        # *   true: enables automatic payment. Make sure that you have sufficient balance in your account. Otherwise, abnormal orders are generated.
        # *   false: generates the order with no payment made. You can log on to the EDS console and complete the payment based on the order number.
        # 
        # Default value: true.
        self.auto_pay = auto_pay  # type: bool
        # The IDs of cloud desktops.
        # 
        # Only subscription cloud desktops can be renewed by calling this operation.
        self.desktop_id = desktop_id  # type: list[str]
        # The renewal duration. The valid values of this parameter are determined by the PeriodUnit value.
        # 
        # *   If PeriodUnit is set to Month, the valid values of the Period parameter are 1, 2, 3, and 6.
        # *   If PeriodUnit is set to Year, the valid values of the Period parameter are 1, 2, 3, 4, and 5.
        # 
        # Default value: 1.
        self.period = period  # type: int
        # The unit of the renewal duration specified by the Period parameter. Valid values:
        # 
        # *   Month
        # *   Year
        # 
        # Default value: Month.
        self.period_unit = period_unit  # type: str
        # The ID of the sales promotion.
        self.promotion_id = promotion_id  # type: str
        # The region ID of the cloud desktop.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RenewDesktopsResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RenewDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RenewDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RenewNetworkPackagesRequest(TeaModel):
    def __init__(self, auto_pay=None, network_package_id=None, period=None, period_unit=None, promotion_id=None,
                 region_id=None):
        # Specifies whether to automatically complete the payment. Valid values:
        # 
        # *   `true`: automatically completes the payment. Make sure that your Alibaba Cloud account has sufficient balance. If your Alibaba Cloud account does not have sufficient balance, abnormal orders are generated.
        # *   `false`: does not complete the payment. In this case, an order is generated, but no payment is made. You can log on to the Elastic Desktop Service (EDS) console and complete the payment based on the order ID on the **Orders** page.
        # 
        # Default value: `true`.
        self.auto_pay = auto_pay  # type: bool
        # The ID of the Internet access package. You can specify 1 to 100 IDs of Internet access packages.
        self.network_package_id = network_package_id  # type: list[str]
        # The renewal period. Valid values of this parameter are determined by the value of the `PeriodUnit` parameter.
        # 
        # *   Valid value when the `PeriodUnit` parameter is set to `Week`: 1
        # *   Valid values when the `PeriodUnit` parameter is set to `Month`: 1, 2, 3, and 6
        # *   Valid values when the `PeriodUnit` parameter is set to `Year`: 1, 2, and 3
        # 
        # Default value: 1.
        self.period = period  # type: int
        # The unit of the renewal period. Default value: Month.
        self.period_unit = period_unit  # type: str
        # The ID of the promotion. You can call the `GetResourcePrice` operation to query the promotion ID.
        self.promotion_id = promotion_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewNetworkPackagesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.auto_pay is not None:
            result['AutoPay'] = self.auto_pay
        if self.network_package_id is not None:
            result['NetworkPackageId'] = self.network_package_id
        if self.period is not None:
            result['Period'] = self.period
        if self.period_unit is not None:
            result['PeriodUnit'] = self.period_unit
        if self.promotion_id is not None:
            result['PromotionId'] = self.promotion_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('AutoPay') is not None:
            self.auto_pay = m.get('AutoPay')
        if m.get('NetworkPackageId') is not None:
            self.network_package_id = m.get('NetworkPackageId')
        if m.get('Period') is not None:
            self.period = m.get('Period')
        if m.get('PeriodUnit') is not None:
            self.period_unit = m.get('PeriodUnit')
        if m.get('PromotionId') is not None:
            self.promotion_id = m.get('PromotionId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RenewNetworkPackagesResponseBody(TeaModel):
    def __init__(self, order_id=None, request_id=None):
        # The ID of the order.
        self.order_id = order_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RenewNetworkPackagesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.order_id is not None:
            result['OrderId'] = self.order_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('OrderId') is not None:
            self.order_id = m.get('OrderId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RenewNetworkPackagesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RenewNetworkPackagesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RenewNetworkPackagesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RenewNetworkPackagesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetDesktopsRequest(TeaModel):
    def __init__(self, desktop_group_id=None, desktop_id=None, image_id=None, pay_type=None, region_id=None,
                 reset_type=None):
        # The ID of the desktop group. If you specify the `DesktopId` parameter, ignore the `DesktopGroupId` parameter. If you do not specify the `DesktopId` parameter, specify the `DesktopGroupId` parameter in the call to request all IDs of the cloud desktops in the specified desktop group.``
        self.desktop_group_id = desktop_group_id  # type: str
        # The IDs of the cloud desktops. You can specify 1 to 100 cloud desktop IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the image.
        self.image_id = image_id  # type: str
        # The billing method.
        # 
        # > This parameter is available only when you reset desktop groups. If you leave this parameter empty, all cloud desktops in the specified desktop group are reset, regardless of how the cloud desktops are billed.
        self.pay_type = pay_type  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~436773~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of the disk that you want to reset.
        self.reset_type = reset_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.pay_type is not None:
            result['PayType'] = self.pay_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('PayType') is not None:
            self.pay_type = m.get('PayType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        return self


class ResetDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetNASDefaultMountTargetRequest(TeaModel):
    def __init__(self, file_system_id=None, region_id=None):
        # The ID of the NAS file system.
        self.file_system_id = file_system_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetNASDefaultMountTargetRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.file_system_id is not None:
            result['FileSystemId'] = self.file_system_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('FileSystemId') is not None:
            self.file_system_id = m.get('FileSystemId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class ResetNASDefaultMountTargetResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetNASDefaultMountTargetResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetNASDefaultMountTargetResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetNASDefaultMountTargetResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetNASDefaultMountTargetResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetNASDefaultMountTargetResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class ResetSnapshotRequest(TeaModel):
    def __init__(self, region_id=None, snapshot_id=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The ID of the snapshot.
        self.snapshot_id = snapshot_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetSnapshotRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.snapshot_id is not None:
            result['SnapshotId'] = self.snapshot_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SnapshotId') is not None:
            self.snapshot_id = m.get('SnapshotId')
        return self


class ResetSnapshotResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(ResetSnapshotResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class ResetSnapshotResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: ResetSnapshotResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(ResetSnapshotResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = ResetSnapshotResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RevokeCoordinatePrivilegeRequest(TeaModel):
    def __init__(self, co_id=None, end_user_id=None, region_id=None, user_type=None, uuid=None):
        # The ID of the stream coordination task.
        self.co_id = co_id  # type: str
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The type of user who requires the coordinate permissions.
        # 
        # Set the value to TENANT_ADMIN. Only tenant administrators can be granted with the coordinate permissions.
        self.user_type = user_type  # type: str
        # The unique identifier of the client. If you use an Alibaba Cloud Workspace client, click **About** on the client logon page to view the identifier of the client.
        self.uuid = uuid  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeCoordinatePrivilegeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.co_id is not None:
            result['CoId'] = self.co_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_type is not None:
            result['UserType'] = self.user_type
        if self.uuid is not None:
            result['Uuid'] = self.uuid
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CoId') is not None:
            self.co_id = m.get('CoId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserType') is not None:
            self.user_type = m.get('UserType')
        if m.get('Uuid') is not None:
            self.uuid = m.get('Uuid')
        return self


class RevokeCoordinatePrivilegeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RevokeCoordinatePrivilegeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RevokeCoordinatePrivilegeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RevokeCoordinatePrivilegeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RevokeCoordinatePrivilegeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RevokeCoordinatePrivilegeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RollbackSuspEventQuaraFileRequest(TeaModel):
    def __init__(self, desktop_id=None, quara_field_id=None, region_id=None):
        # The ID of the cloud desktop.
        self.desktop_id = desktop_id  # type: str
        # The ID of the quarantined file.
        # 
        # You can call the [DescribeSuspEventQuaraFiles](~~217947~~) operation to obtain the ID of the quarantined file.
        self.quara_field_id = quara_field_id  # type: int
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.quara_field_id is not None:
            result['QuaraFieldId'] = self.quara_field_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('QuaraFieldId') is not None:
            self.quara_field_id = m.get('QuaraFieldId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class RollbackSuspEventQuaraFileResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RollbackSuspEventQuaraFileResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RollbackSuspEventQuaraFileResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RollbackSuspEventQuaraFileResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RollbackSuspEventQuaraFileResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class RunCommandRequest(TeaModel):
    def __init__(self, command_content=None, content_encoding=None, desktop_id=None, end_user_id=None,
                 region_id=None, timeout=None, type=None):
        # The content of the command. The command content can be plaintext or Base64-encoded.\
        # The Base64-encoded command content cannot exceed 16 KB in size.
        # 
        # > If the command content is Base64-encoded, you must set the ContentEncoding parameter to Base64.
        self.command_content = command_content  # type: str
        # The encoding mode of the command content. Valid values:
        # 
        # *   PlainText: The command content is not encoded.
        # *   Base64: The command content is Base64-encoded.
        # 
        # Default value: PlainText. If the specified value of this parameter is invalid, PlainText is used by default.
        self.content_encoding = content_encoding  # type: str
        # The ID of cloud desktop N. Valid values of N: 1 to 50.\
        # If multiple cloud desktops are specified and the command execution succeeds on at least one of the cloud desktops, the operation is considered successful. If multiple cloud desktops are specified and the command execution fails on all the cloud desktops, verify the value of the parameter and try again.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the end user.
        self.end_user_id = end_user_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The timeout period for the command to run. Unit: seconds. Default value: 60.\
        # A timeout error occurs if the command cannot be run because the process slows down or because a specific module or the Cloud Assistant client does not exist. When a timeout error occurs, the command process is forcibly terminated.
        self.timeout = timeout  # type: long
        # The language of the O\&M command. Valid values:
        # 
        # *   RunBatScript
        # *   RunPowerShellScript
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunCommandRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.command_content is not None:
            result['CommandContent'] = self.command_content
        if self.content_encoding is not None:
            result['ContentEncoding'] = self.content_encoding
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.end_user_id is not None:
            result['EndUserId'] = self.end_user_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.timeout is not None:
            result['Timeout'] = self.timeout
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CommandContent') is not None:
            self.command_content = m.get('CommandContent')
        if m.get('ContentEncoding') is not None:
            self.content_encoding = m.get('ContentEncoding')
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('EndUserId') is not None:
            self.end_user_id = m.get('EndUserId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Timeout') is not None:
            self.timeout = m.get('Timeout')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class RunCommandResponseBody(TeaModel):
    def __init__(self, invoke_id=None, request_id=None):
        # The ID of the command execution.
        self.invoke_id = invoke_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(RunCommandResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class RunCommandResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: RunCommandResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(RunCommandResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = RunCommandResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SendVerifyCodeRequest(TeaModel):
    def __init__(self, extra_info=None, region_id=None, verify_code_action=None):
        # The information in JSON format that is required for sending the verification code. To verify the security of CEN, you must provide the ID of the CEN instance and the ID of the Alibaba Cloud account to which the instance belongs.
        # 
        # *   CenId: the ID of the CEN instance
        # *   CenOwnerId: the ID of the Alibaba Cloud account to which the CEN instance belongs.
        # 
        # Note: If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to the Alibaba Cloud account, skip this parameter. If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account. Example: {"cenOwnerId": 1234567890\*\*\*\*\*\*,"cenId": "cen-3weq30r6t0s7t4\*\*\*\*"}.
        self.extra_info = extra_info  # type: str
        # The region ID.
        self.region_id = region_id  # type: str
        # The action that indicates what the verification code is used for. The parameter is only used to verify the security of CEN. Valid value: eds_cenID_securityverification.
        self.verify_code_action = verify_code_action  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendVerifyCodeRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.extra_info is not None:
            result['ExtraInfo'] = self.extra_info
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.verify_code_action is not None:
            result['VerifyCodeAction'] = self.verify_code_action
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ExtraInfo') is not None:
            self.extra_info = m.get('ExtraInfo')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VerifyCodeAction') is not None:
            self.verify_code_action = m.get('VerifyCodeAction')
        return self


class SendVerifyCodeResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SendVerifyCodeResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SendVerifyCodeResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SendVerifyCodeResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SendVerifyCodeResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SendVerifyCodeResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDesktopGroupScaleTimerRequestScaleTimerInfos(TeaModel):
    def __init__(self, buy_res_amount=None, cron=None, keep_duration=None, load_policy=None, max_res_amount=None,
                 min_res_amount=None, ratio_threshold=None, type=None):
        # The number of cloud desktops that you want to create in the desktop group. Valid values: 0 to 200. You must configure this parameter for the scaling policy.
        self.buy_res_amount = buy_res_amount  # type: int
        # The CRON expression that is used when an auto scaling task is triggered.
        self.cron = cron  # type: str
        # The keep-alive duration after the cloud desktop is disconnected. Unit: milliseconds.
        self.keep_duration = keep_duration  # type: long
        # The load balancing policy of the multi-session desktop group.
        self.load_policy = load_policy  # type: int
        # The maximum number of cloud desktops in the workspace after scaling. Valid values: 0 to 200. You must configure this parameter for the scaling policy.
        self.max_res_amount = max_res_amount  # type: int
        # The minimum number of cloud desktops that can be connected. Valid values: 0 to 200.
        self.min_res_amount = min_res_amount  # type: int
        # The threshold for the ratio of connected sessions. This parameter is the condition that triggers auto scaling in a multi-session desktop group. `Ratio of connected sessions = Number of connected sessions/(Total number of cloud desktops × Maximum number of sessions supported by each cloud desktop) × 100%`. When the ratio of connected sessions is greater than the specified threshold, desktop scale-out is automatically triggered. When the ratio of connected sessions is smaller than the specified threshold, desktop scale-in is automatically triggered under a specific condition.
        self.ratio_threshold = ratio_threshold  # type: float
        # The type of the policy.
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupScaleTimerRequestScaleTimerInfos, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.buy_res_amount is not None:
            result['BuyResAmount'] = self.buy_res_amount
        if self.cron is not None:
            result['Cron'] = self.cron
        if self.keep_duration is not None:
            result['KeepDuration'] = self.keep_duration
        if self.load_policy is not None:
            result['LoadPolicy'] = self.load_policy
        if self.max_res_amount is not None:
            result['MaxResAmount'] = self.max_res_amount
        if self.min_res_amount is not None:
            result['MinResAmount'] = self.min_res_amount
        if self.ratio_threshold is not None:
            result['RatioThreshold'] = self.ratio_threshold
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BuyResAmount') is not None:
            self.buy_res_amount = m.get('BuyResAmount')
        if m.get('Cron') is not None:
            self.cron = m.get('Cron')
        if m.get('KeepDuration') is not None:
            self.keep_duration = m.get('KeepDuration')
        if m.get('LoadPolicy') is not None:
            self.load_policy = m.get('LoadPolicy')
        if m.get('MaxResAmount') is not None:
            self.max_res_amount = m.get('MaxResAmount')
        if m.get('MinResAmount') is not None:
            self.min_res_amount = m.get('MinResAmount')
        if m.get('RatioThreshold') is not None:
            self.ratio_threshold = m.get('RatioThreshold')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SetDesktopGroupScaleTimerRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None, scale_timer_infos=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The information about the scheduled auto scaling tasks.
        self.scale_timer_infos = scale_timer_infos  # type: list[SetDesktopGroupScaleTimerRequestScaleTimerInfos]

    def validate(self):
        if self.scale_timer_infos:
            for k in self.scale_timer_infos:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SetDesktopGroupScaleTimerRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['ScaleTimerInfos'] = []
        if self.scale_timer_infos is not None:
            for k in self.scale_timer_infos:
                result['ScaleTimerInfos'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.scale_timer_infos = []
        if m.get('ScaleTimerInfos') is not None:
            for k in m.get('ScaleTimerInfos'):
                temp_model = SetDesktopGroupScaleTimerRequestScaleTimerInfos()
                self.scale_timer_infos.append(temp_model.from_map(k))
        return self


class SetDesktopGroupScaleTimerResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupScaleTimerResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDesktopGroupScaleTimerResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDesktopGroupScaleTimerResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDesktopGroupScaleTimerResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDesktopGroupScaleTimerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDesktopGroupTimerRequest(TeaModel):
    def __init__(self, cron_expression=None, desktop_group_id=None, force=None, region_id=None, reset_type=None,
                 timer_type=None):
        # The CRON expression for the scheduled task.
        self.cron_expression = cron_expression  # type: str
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # Specifies whether to forcefully execute the scheduled task.
        self.force = force  # type: bool
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The type of the disk that you want to reset.
        self.reset_type = reset_type  # type: int
        # The type of the scheduled task. Valid values:
        self.timer_type = timer_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupTimerRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cron_expression is not None:
            result['CronExpression'] = self.cron_expression
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.force is not None:
            result['Force'] = self.force
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.reset_type is not None:
            result['ResetType'] = self.reset_type
        if self.timer_type is not None:
            result['TimerType'] = self.timer_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CronExpression') is not None:
            self.cron_expression = m.get('CronExpression')
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('Force') is not None:
            self.force = m.get('Force')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResetType') is not None:
            self.reset_type = m.get('ResetType')
        if m.get('TimerType') is not None:
            self.timer_type = m.get('TimerType')
        return self


class SetDesktopGroupTimerResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupTimerResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDesktopGroupTimerResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDesktopGroupTimerResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDesktopGroupTimerResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDesktopGroupTimerResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDesktopGroupTimerStatusRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None, status=None, timer_type=None):
        # The ID of the desktop group.
        self.desktop_group_id = desktop_group_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The status of the scheduled task.
        self.status = status  # type: int
        # The type of the scheduled task.
        self.timer_type = timer_type  # type: int

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupTimerStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        if self.timer_type is not None:
            result['TimerType'] = self.timer_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        if m.get('TimerType') is not None:
            self.timer_type = m.get('TimerType')
        return self


class SetDesktopGroupTimerStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDesktopGroupTimerStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDesktopGroupTimerStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDesktopGroupTimerStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDesktopGroupTimerStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDesktopGroupTimerStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetDirectorySsoStatusRequest(TeaModel):
    def __init__(self, directory_id=None, enable_sso=None, region_id=None):
        self.directory_id = directory_id  # type: str
        self.enable_sso = enable_sso  # type: bool
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDirectorySsoStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.enable_sso is not None:
            result['EnableSso'] = self.enable_sso
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('EnableSso') is not None:
            self.enable_sso = m.get('EnableSso')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetDirectorySsoStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetDirectorySsoStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetDirectorySsoStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetDirectorySsoStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetDirectorySsoStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetDirectorySsoStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetIdpMetadataRequest(TeaModel):
    def __init__(self, directory_id=None, idp_metadata=None, office_site_id=None, region_id=None):
        # The ID of the directory.
        self.directory_id = directory_id  # type: str
        # The metadata of the IdP.
        self.idp_metadata = idp_metadata  # type: str
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetIdpMetadataRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.directory_id is not None:
            result['DirectoryId'] = self.directory_id
        if self.idp_metadata is not None:
            result['IdpMetadata'] = self.idp_metadata
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DirectoryId') is not None:
            self.directory_id = m.get('DirectoryId')
        if m.get('IdpMetadata') is not None:
            self.idp_metadata = m.get('IdpMetadata')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetIdpMetadataResponseBody(TeaModel):
    def __init__(self, idp_entity_id=None, request_id=None):
        # The entityID value obtained after the IdP metadata file is parsed.
        self.idp_entity_id = idp_entity_id  # type: str
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetIdpMetadataResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.idp_entity_id is not None:
            result['IdpEntityId'] = self.idp_entity_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('IdpEntityId') is not None:
            self.idp_entity_id = m.get('IdpEntityId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetIdpMetadataResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetIdpMetadataResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetIdpMetadataResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetIdpMetadataResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetOfficeSiteSsoStatusRequest(TeaModel):
    def __init__(self, enable_sso=None, office_site_id=None, region_id=None):
        # Specifies whether to enable SSO. Valid values:
        # 
        # *   true: enables SSO
        # *   false: disables SSO
        self.enable_sso = enable_sso  # type: bool
        # The ID of the workspace.
        self.office_site_id = office_site_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetOfficeSiteSsoStatusRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.enable_sso is not None:
            result['EnableSso'] = self.enable_sso
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('EnableSso') is not None:
            self.enable_sso = m.get('EnableSso')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class SetOfficeSiteSsoStatusResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetOfficeSiteSsoStatusResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetOfficeSiteSsoStatusResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetOfficeSiteSsoStatusResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetOfficeSiteSsoStatusResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetOfficeSiteSsoStatusResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath(TeaModel):
    def __init__(self, path=None, type=None):
        self.path = path  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths(TeaModel):
    def __init__(self, path=None, type=None):
        self.path = path  # type: str
        self.type = type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.path is not None:
            result['Path'] = self.path
        if self.type is not None:
            result['Type'] = self.type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Path') is not None:
            self.path = m.get('Path')
        if m.get('Type') is not None:
            self.type = m.get('Type')
        return self


class SetUserProfilePathRulesRequestUserProfilePathRule(TeaModel):
    def __init__(self, black_path=None, white_paths=None):
        self.black_path = black_path  # type: SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath
        self.white_paths = white_paths  # type: list[SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths]

    def validate(self):
        if self.black_path:
            self.black_path.validate()
        if self.white_paths:
            for k in self.white_paths:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SetUserProfilePathRulesRequestUserProfilePathRule, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.black_path is not None:
            result['BlackPath'] = self.black_path.to_map()
        result['WhitePaths'] = []
        if self.white_paths is not None:
            for k in self.white_paths:
                result['WhitePaths'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('BlackPath') is not None:
            temp_model = SetUserProfilePathRulesRequestUserProfilePathRuleBlackPath()
            self.black_path = temp_model.from_map(m['BlackPath'])
        self.white_paths = []
        if m.get('WhitePaths') is not None:
            for k in m.get('WhitePaths'):
                temp_model = SetUserProfilePathRulesRequestUserProfilePathRuleWhitePaths()
                self.white_paths.append(temp_model.from_map(k))
        return self


class SetUserProfilePathRulesRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None, user_profile_path_rule=None,
                 user_profile_rule_type=None):
        self.desktop_group_id = desktop_group_id  # type: str
        self.region_id = region_id  # type: str
        self.user_profile_path_rule = user_profile_path_rule  # type: list[SetUserProfilePathRulesRequestUserProfilePathRule]
        self.user_profile_rule_type = user_profile_rule_type  # type: str

    def validate(self):
        if self.user_profile_path_rule:
            for k in self.user_profile_path_rule:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(SetUserProfilePathRulesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        result['UserProfilePathRule'] = []
        if self.user_profile_path_rule is not None:
            for k in self.user_profile_path_rule:
                result['UserProfilePathRule'].append(k.to_map() if k else None)
        if self.user_profile_rule_type is not None:
            result['UserProfileRuleType'] = self.user_profile_rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        self.user_profile_path_rule = []
        if m.get('UserProfilePathRule') is not None:
            for k in m.get('UserProfilePathRule'):
                temp_model = SetUserProfilePathRulesRequestUserProfilePathRule()
                self.user_profile_path_rule.append(temp_model.from_map(k))
        if m.get('UserProfileRuleType') is not None:
            self.user_profile_rule_type = m.get('UserProfileRuleType')
        return self


class SetUserProfilePathRulesShrinkRequest(TeaModel):
    def __init__(self, desktop_group_id=None, region_id=None, user_profile_path_rule_shrink=None,
                 user_profile_rule_type=None):
        self.desktop_group_id = desktop_group_id  # type: str
        self.region_id = region_id  # type: str
        self.user_profile_path_rule_shrink = user_profile_path_rule_shrink  # type: str
        self.user_profile_rule_type = user_profile_rule_type  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetUserProfilePathRulesShrinkRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_group_id is not None:
            result['DesktopGroupId'] = self.desktop_group_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.user_profile_path_rule_shrink is not None:
            result['UserProfilePathRule'] = self.user_profile_path_rule_shrink
        if self.user_profile_rule_type is not None:
            result['UserProfileRuleType'] = self.user_profile_rule_type
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopGroupId') is not None:
            self.desktop_group_id = m.get('DesktopGroupId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('UserProfilePathRule') is not None:
            self.user_profile_path_rule_shrink = m.get('UserProfilePathRule')
        if m.get('UserProfileRuleType') is not None:
            self.user_profile_rule_type = m.get('UserProfileRuleType')
        return self


class SetUserProfilePathRulesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(SetUserProfilePathRulesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class SetUserProfilePathRulesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: SetUserProfilePathRulesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(SetUserProfilePathRulesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = SetUserProfilePathRulesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None):
        # The IDs of the cloud desktops. You can specify up to 100 IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StartDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StartVirusScanTaskRequest(TeaModel):
    def __init__(self, desktop_id=None, office_site_id=None, region_id=None):
        # The IDs of the cloud desktops.
        self.desktop_id = desktop_id  # type: list[str]
        # The IDs of the workspaces.
        self.office_site_id = office_site_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartVirusScanTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.office_site_id is not None:
            result['OfficeSiteId'] = self.office_site_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('OfficeSiteId') is not None:
            self.office_site_id = m.get('OfficeSiteId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StartVirusScanTaskResponseBody(TeaModel):
    def __init__(self, request_id=None, scan_task_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The ID of the virus scan task.
        self.scan_task_id = scan_task_id  # type: long

    def validate(self):
        pass

    def to_map(self):
        _map = super(StartVirusScanTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        if self.scan_task_id is not None:
            result['ScanTaskId'] = self.scan_task_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        if m.get('ScanTaskId') is not None:
            self.scan_task_id = m.get('ScanTaskId')
        return self


class StartVirusScanTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StartVirusScanTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StartVirusScanTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StartVirusScanTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopDesktopsRequest(TeaModel):
    def __init__(self, desktop_id=None, region_id=None, stopped_mode=None):
        # The IDs of cloud desktops. You can specify up to 20 cloud desktop IDs.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The billing mode after you stop the cloud desktop.
        # 
        # *   StopCharging: Computing resources are not billed after you stop the cloud desktop. After the cloud desktop is stopped, the system automatically reclaims computing resources. From this point on, you are no longer charged for computing resources. However, you are still charged for storage resources.
        # *   KeepCharging: The billing continues after you stop the cloud desktop. After the cloud desktop is stopped, the system does not reclaim resources to avoid startup failures due to insufficient resources. You are still charged for the resources.
        # 
        # Default value: StopCharging
        self.stopped_mode = stopped_mode  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopDesktopsRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.stopped_mode is not None:
            result['StoppedMode'] = self.stopped_mode
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('StoppedMode') is not None:
            self.stopped_mode = m.get('StoppedMode')
        return self


class StopDesktopsResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopDesktopsResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopDesktopsResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopDesktopsResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopDesktopsResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopDesktopsResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class StopInvocationRequest(TeaModel):
    def __init__(self, desktop_id=None, invoke_id=None, region_id=None):
        # The ID of cloud desktop. Valid values of N: 1 to 50.
        self.desktop_id = desktop_id  # type: list[str]
        # The ID of the execution.
        self.invoke_id = invoke_id  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInvocationRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.desktop_id is not None:
            result['DesktopId'] = self.desktop_id
        if self.invoke_id is not None:
            result['InvokeId'] = self.invoke_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DesktopId') is not None:
            self.desktop_id = m.get('DesktopId')
        if m.get('InvokeId') is not None:
            self.invoke_id = m.get('InvokeId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class StopInvocationResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(StopInvocationResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class StopInvocationResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: StopInvocationResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(StopInvocationResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = StopInvocationResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class TagResourcesRequestTag(TeaModel):
    def __init__(self, key=None, value=None):
        # The key of tag.
        # Valid values of N: 1 to 20.
        # The tag key cannot be an empty string. It can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
        self.key = key  # type: str
        # The value of tag.
        # Valid values of N: 1 to 20.
        # The tag value can be an empty string. It can be up to 128 characters in length. It cannot start with `acs:` or contain `http://` or `https://`.
        self.value = value  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TagResourcesRequestTag, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.key is not None:
            result['Key'] = self.key
        if self.value is not None:
            result['Value'] = self.value
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('Key') is not None:
            self.key = m.get('Key')
        if m.get('Value') is not None:
            self.value = m.get('Value')
        return self


class TagResourcesRequest(TeaModel):
    def __init__(self, region_id=None, resource_id=None, resource_type=None, tag=None):
        # The region ID of the resource.
        self.region_id = region_id  # type: str
        # The ID of the resource, which is the ID of the cloud desktop. Valid values of N: 1 to 50.
        self.resource_id = resource_id  # type: list[str]
        # The type of the resource. Set the value to ALIYUN::GWS::INSTANCE.
        self.resource_type = resource_type  # type: str
        # The list of the resource.
        self.tag = tag  # type: list[TagResourcesRequestTag]

    def validate(self):
        if self.tag:
            for k in self.tag:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(TagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        result['Tag'] = []
        if self.tag is not None:
            for k in self.tag:
                result['Tag'].append(k.to_map() if k else None)
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        self.tag = []
        if m.get('Tag') is not None:
            for k in m.get('Tag'):
                temp_model = TagResourcesRequestTag()
                self.tag.append(temp_model.from_map(k))
        return self


class TagResourcesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(TagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class TagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: TagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(TagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = TagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UnlockVirtualMFADeviceRequest(TeaModel):
    def __init__(self, region_id=None, serial_number=None):
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The serial number of the virtual MFA device, which is a unique identifier.
        # 
        # You can call the [DescribeVirtualMFADevices](~~206210~~) operation to query the serial number of the virtual MFA device bound to AD users.
        self.serial_number = serial_number  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnlockVirtualMFADeviceRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.serial_number is not None:
            result['SerialNumber'] = self.serial_number
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('SerialNumber') is not None:
            self.serial_number = m.get('SerialNumber')
        return self


class UnlockVirtualMFADeviceResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UnlockVirtualMFADeviceResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UnlockVirtualMFADeviceResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UnlockVirtualMFADeviceResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UnlockVirtualMFADeviceResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UnlockVirtualMFADeviceResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UntagResourcesRequest(TeaModel):
    def __init__(self, all=None, region_id=None, resource_id=None, resource_type=None, tag_key=None):
        # Specifies whether to unbind all tags from the resource. This parameter takes effect only when the TagKey.N parameter is not specified. Default value: false.
        self.all = all  # type: bool
        # The region ID of the resource.
        self.region_id = region_id  # type: str
        # The ID of the resource, which is the ID of the cloud desktop. Valid values of N: 1 to 50.
        self.resource_id = resource_id  # type: list[str]
        # The type of the resource. Set the value to ALIYUN::GWS::INSTANCE.
        self.resource_type = resource_type  # type: str
        # The key of tag N. Valid values of N: 1 to 20.
        self.tag_key = tag_key  # type: list[str]

    def validate(self):
        pass

    def to_map(self):
        _map = super(UntagResourcesRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.all is not None:
            result['All'] = self.all
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.resource_id is not None:
            result['ResourceId'] = self.resource_id
        if self.resource_type is not None:
            result['ResourceType'] = self.resource_type
        if self.tag_key is not None:
            result['TagKey'] = self.tag_key
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('All') is not None:
            self.all = m.get('All')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('ResourceId') is not None:
            self.resource_id = m.get('ResourceId')
        if m.get('ResourceType') is not None:
            self.resource_type = m.get('ResourceType')
        if m.get('TagKey') is not None:
            self.tag_key = m.get('TagKey')
        return self


class UntagResourcesResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UntagResourcesResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UntagResourcesResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UntagResourcesResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UntagResourcesResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UntagResourcesResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UpdateFotaTaskRequest(TeaModel):
    def __init__(self, region_id=None, task_uid=None, user_status=None):
        # The ID of the region. You can call the [DescribeRegions](~~196646~~) operation to query the most recent region list.
        self.region_id = region_id  # type: str
        # The ID of the image update task. You can call the DescribeFotaTasks operation to obtain the value of this parameter.
        self.task_uid = task_uid  # type: str
        # Specifies whether to automatically push the image update task.
        self.user_status = user_status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateFotaTaskRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.task_uid is not None:
            result['TaskUid'] = self.task_uid
        if self.user_status is not None:
            result['UserStatus'] = self.user_status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('TaskUid') is not None:
            self.task_uid = m.get('TaskUid')
        if m.get('UserStatus') is not None:
            self.user_status = m.get('UserStatus')
        return self


class UpdateFotaTaskResponseBody(TeaModel):
    def __init__(self, request_id=None):
        # The ID of the request.
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UpdateFotaTaskResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UpdateFotaTaskResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UpdateFotaTaskResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UpdateFotaTaskResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UpdateFotaTaskResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class UploadImageRequest(TeaModel):
    def __init__(self, data_disk_size=None, description=None, enable_security_check=None, gpu_category=None,
                 gpu_driver_type=None, image_name=None, license_type=None, os_type=None, oss_object_path=None, protocol_type=None,
                 region_id=None):
        self.data_disk_size = data_disk_size  # type: int
        self.description = description  # type: str
        self.enable_security_check = enable_security_check  # type: bool
        self.gpu_category = gpu_category  # type: bool
        self.gpu_driver_type = gpu_driver_type  # type: str
        self.image_name = image_name  # type: str
        self.license_type = license_type  # type: str
        self.os_type = os_type  # type: str
        self.oss_object_path = oss_object_path  # type: str
        self.protocol_type = protocol_type  # type: str
        self.region_id = region_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadImageRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.data_disk_size is not None:
            result['DataDiskSize'] = self.data_disk_size
        if self.description is not None:
            result['Description'] = self.description
        if self.enable_security_check is not None:
            result['EnableSecurityCheck'] = self.enable_security_check
        if self.gpu_category is not None:
            result['GpuCategory'] = self.gpu_category
        if self.gpu_driver_type is not None:
            result['GpuDriverType'] = self.gpu_driver_type
        if self.image_name is not None:
            result['ImageName'] = self.image_name
        if self.license_type is not None:
            result['LicenseType'] = self.license_type
        if self.os_type is not None:
            result['OsType'] = self.os_type
        if self.oss_object_path is not None:
            result['OssObjectPath'] = self.oss_object_path
        if self.protocol_type is not None:
            result['ProtocolType'] = self.protocol_type
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DataDiskSize') is not None:
            self.data_disk_size = m.get('DataDiskSize')
        if m.get('Description') is not None:
            self.description = m.get('Description')
        if m.get('EnableSecurityCheck') is not None:
            self.enable_security_check = m.get('EnableSecurityCheck')
        if m.get('GpuCategory') is not None:
            self.gpu_category = m.get('GpuCategory')
        if m.get('GpuDriverType') is not None:
            self.gpu_driver_type = m.get('GpuDriverType')
        if m.get('ImageName') is not None:
            self.image_name = m.get('ImageName')
        if m.get('LicenseType') is not None:
            self.license_type = m.get('LicenseType')
        if m.get('OsType') is not None:
            self.os_type = m.get('OsType')
        if m.get('OssObjectPath') is not None:
            self.oss_object_path = m.get('OssObjectPath')
        if m.get('ProtocolType') is not None:
            self.protocol_type = m.get('ProtocolType')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        return self


class UploadImageResponseBody(TeaModel):
    def __init__(self, image_id=None, request_id=None):
        self.image_id = image_id  # type: str
        self.request_id = request_id  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(UploadImageResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.image_id is not None:
            result['ImageId'] = self.image_id
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('ImageId') is not None:
            self.image_id = m.get('ImageId')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        return self


class UploadImageResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: UploadImageResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(UploadImageResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = UploadImageResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


class VerifyCenRequest(TeaModel):
    def __init__(self, cen_id=None, cen_owner_id=None, cidr_block=None, region_id=None, verify_code=None):
        # The ID of the CEN instance.
        self.cen_id = cen_id  # type: str
        # The ID of the Alibaba Cloud account to which the CEN instance belongs.
        # 
        # *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to the current Alibaba Cloud account, skip this parameter.
        # *   If you specify the CenId parameter and the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, enter the ID of the exact Alibaba Cloud account.
        self.cen_owner_id = cen_owner_id  # type: long
        # The IPv4 CIDR block of the workspace.
        self.cidr_block = cidr_block  # type: str
        # The ID of the region.
        self.region_id = region_id  # type: str
        # The verification code. If the CEN instance that you specify for the CenId parameter belongs to another Alibaba Cloud account, you must call the SendVerifyCode operation to obtain the verification code.
        self.verify_code = verify_code  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCenRequest, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cen_id is not None:
            result['CenId'] = self.cen_id
        if self.cen_owner_id is not None:
            result['CenOwnerId'] = self.cen_owner_id
        if self.cidr_block is not None:
            result['CidrBlock'] = self.cidr_block
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.verify_code is not None:
            result['VerifyCode'] = self.verify_code
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CenId') is not None:
            self.cen_id = m.get('CenId')
        if m.get('CenOwnerId') is not None:
            self.cen_owner_id = m.get('CenOwnerId')
        if m.get('CidrBlock') is not None:
            self.cidr_block = m.get('CidrBlock')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('VerifyCode') is not None:
            self.verify_code = m.get('VerifyCode')
        return self


class VerifyCenResponseBodyRouteEntries(TeaModel):
    def __init__(self, destination_cidr_block=None, next_hop_instance_id=None, region_id=None, status=None):
        # The CIDR block of the route.
        self.destination_cidr_block = destination_cidr_block  # type: str
        # The ID of the network instance that is attached to the route.
        self.next_hop_instance_id = next_hop_instance_id  # type: str
        # The ID of the region where the route resides.
        self.region_id = region_id  # type: str
        # The verification result for a route. Valid values:
        # 
        # *   Access: The route verification succeeds.
        # *   Conflict: A CIDR block conflict exists.
        self.status = status  # type: str

    def validate(self):
        pass

    def to_map(self):
        _map = super(VerifyCenResponseBodyRouteEntries, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.destination_cidr_block is not None:
            result['DestinationCidrBlock'] = self.destination_cidr_block
        if self.next_hop_instance_id is not None:
            result['NextHopInstanceId'] = self.next_hop_instance_id
        if self.region_id is not None:
            result['RegionId'] = self.region_id
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('DestinationCidrBlock') is not None:
            self.destination_cidr_block = m.get('DestinationCidrBlock')
        if m.get('NextHopInstanceId') is not None:
            self.next_hop_instance_id = m.get('NextHopInstanceId')
        if m.get('RegionId') is not None:
            self.region_id = m.get('RegionId')
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class VerifyCenResponseBody(TeaModel):
    def __init__(self, cidr_blocks=None, request_id=None, route_entries=None, status=None):
        # The three random IPv4 CIDR blocks that are recommended. If the returned value of the Status parameter is Conflict, this parameter is returned.
        self.cidr_blocks = cidr_blocks  # type: list[str]
        # The ID of the request.
        self.request_id = request_id  # type: str
        # The information about the routes of the CEN instance.
        self.route_entries = route_entries  # type: list[VerifyCenResponseBodyRouteEntries]
        # The verification result. Valid values:
        # 
        # *   Access: The route verification succeeds. If the verification result for all routes succeeds, Access is returned for this parameter.
        # *   Conflict: A CIDR block conflict exists. If the verification result of at least one route is Conflict, Conflict is returned for this parameter.
        # *   InvalidCen.ParameterCenInstanceId: The ID of the CEN instance and the ID of the Alibaba Cloud account are invalid. The CEN instance does not belong to the Alibaba Cloud account.
        # *   InvalidCen.CenUidInvalid: The ID of the Alibaba Cloud account is invalid or the Alibaba Cloud account is not granted the required permissions to access Elastic Desktop Service (EDS).
        # *   VerifyCode.InvalidTokenCode: The verification code is invalid.
        # *   VerifyCode.ReachTokenRetryTime: The retries of entering the verification code reaches the upper limit.
        self.status = status  # type: str

    def validate(self):
        if self.route_entries:
            for k in self.route_entries:
                if k:
                    k.validate()

    def to_map(self):
        _map = super(VerifyCenResponseBody, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.cidr_blocks is not None:
            result['CidrBlocks'] = self.cidr_blocks
        if self.request_id is not None:
            result['RequestId'] = self.request_id
        result['RouteEntries'] = []
        if self.route_entries is not None:
            for k in self.route_entries:
                result['RouteEntries'].append(k.to_map() if k else None)
        if self.status is not None:
            result['Status'] = self.status
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('CidrBlocks') is not None:
            self.cidr_blocks = m.get('CidrBlocks')
        if m.get('RequestId') is not None:
            self.request_id = m.get('RequestId')
        self.route_entries = []
        if m.get('RouteEntries') is not None:
            for k in m.get('RouteEntries'):
                temp_model = VerifyCenResponseBodyRouteEntries()
                self.route_entries.append(temp_model.from_map(k))
        if m.get('Status') is not None:
            self.status = m.get('Status')
        return self


class VerifyCenResponse(TeaModel):
    def __init__(self, headers=None, status_code=None, body=None):
        self.headers = headers  # type: dict[str, str]
        self.status_code = status_code  # type: int
        self.body = body  # type: VerifyCenResponseBody

    def validate(self):
        self.validate_required(self.headers, 'headers')
        self.validate_required(self.status_code, 'status_code')
        self.validate_required(self.body, 'body')
        if self.body:
            self.body.validate()

    def to_map(self):
        _map = super(VerifyCenResponse, self).to_map()
        if _map is not None:
            return _map

        result = dict()
        if self.headers is not None:
            result['headers'] = self.headers
        if self.status_code is not None:
            result['statusCode'] = self.status_code
        if self.body is not None:
            result['body'] = self.body.to_map()
        return result

    def from_map(self, m=None):
        m = m or dict()
        if m.get('headers') is not None:
            self.headers = m.get('headers')
        if m.get('statusCode') is not None:
            self.status_code = m.get('statusCode')
        if m.get('body') is not None:
            temp_model = VerifyCenResponseBody()
            self.body = temp_model.from_map(m['body'])
        return self


